
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model Tenant
 * 
 */
export type Tenant = $Result.DefaultSelection<Prisma.$TenantPayload>
/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model RefreshToken
 * 
 */
export type RefreshToken = $Result.DefaultSelection<Prisma.$RefreshTokenPayload>
/**
 * Model Santri
 * 
 */
export type Santri = $Result.DefaultSelection<Prisma.$SantriPayload>
/**
 * Model Wali
 * 
 */
export type Wali = $Result.DefaultSelection<Prisma.$WaliPayload>
/**
 * Model SantriWali
 * 
 */
export type SantriWali = $Result.DefaultSelection<Prisma.$SantriWaliPayload>
/**
 * Model Izin
 * 
 */
export type Izin = $Result.DefaultSelection<Prisma.$IzinPayload>
/**
 * Model CatatanHarian
 * 
 */
export type CatatanHarian = $Result.DefaultSelection<Prisma.$CatatanHarianPayload>
/**
 * Model Pengumuman
 * 
 */
export type Pengumuman = $Result.DefaultSelection<Prisma.$PengumumanPayload>
/**
 * Model Invoice
 * 
 */
export type Invoice = $Result.DefaultSelection<Prisma.$InvoicePayload>
/**
 * Model InvoiceLine
 * 
 */
export type InvoiceLine = $Result.DefaultSelection<Prisma.$InvoiceLinePayload>
/**
 * Model Payment
 * 
 */
export type Payment = $Result.DefaultSelection<Prisma.$PaymentPayload>
/**
 * Model Pelanggaran
 * 
 */
export type Pelanggaran = $Result.DefaultSelection<Prisma.$PelanggaranPayload>
/**
 * Model Pembinaan
 * 
 */
export type Pembinaan = $Result.DefaultSelection<Prisma.$PembinaanPayload>
/**
 * Model Kunjungan
 * 
 */
export type Kunjungan = $Result.DefaultSelection<Prisma.$KunjunganPayload>
/**
 * Model Tamu
 * 
 */
export type Tamu = $Result.DefaultSelection<Prisma.$TamuPayload>
/**
 * Model HealthRecord
 * 
 */
export type HealthRecord = $Result.DefaultSelection<Prisma.$HealthRecordPayload>
/**
 * Model Medication
 * 
 */
export type Medication = $Result.DefaultSelection<Prisma.$MedicationPayload>
/**
 * Model AuditLog
 * 
 */
export type AuditLog = $Result.DefaultSelection<Prisma.$AuditLogPayload>
/**
 * Model Notification
 * 
 */
export type Notification = $Result.DefaultSelection<Prisma.$NotificationPayload>
/**
 * Model WebhookEvent
 * 
 */
export type WebhookEvent = $Result.DefaultSelection<Prisma.$WebhookEventPayload>
/**
 * Model Tahfidz
 * 
 */
export type Tahfidz = $Result.DefaultSelection<Prisma.$TahfidzPayload>
/**
 * Model Mutabaah
 * 
 */
export type Mutabaah = $Result.DefaultSelection<Prisma.$MutabaahPayload>
/**
 * Model Wallet
 * 
 */
export type Wallet = $Result.DefaultSelection<Prisma.$WalletPayload>
/**
 * Model WalletTransaction
 * 
 */
export type WalletTransaction = $Result.DefaultSelection<Prisma.$WalletTransactionPayload>
/**
 * Model Employee
 * 
 */
export type Employee = $Result.DefaultSelection<Prisma.$EmployeePayload>
/**
 * Model Payroll
 * 
 */
export type Payroll = $Result.DefaultSelection<Prisma.$PayrollPayload>
/**
 * Model AcademicSchedule
 * 
 */
export type AcademicSchedule = $Result.DefaultSelection<Prisma.$AcademicSchedulePayload>
/**
 * Model Attendance
 * 
 */
export type Attendance = $Result.DefaultSelection<Prisma.$AttendancePayload>
/**
 * Model Grade
 * 
 */
export type Grade = $Result.DefaultSelection<Prisma.$GradePayload>
/**
 * Model PpdbRegistration
 * 
 */
export type PpdbRegistration = $Result.DefaultSelection<Prisma.$PpdbRegistrationPayload>
/**
 * Model PpdbDocument
 * 
 */
export type PpdbDocument = $Result.DefaultSelection<Prisma.$PpdbDocumentPayload>
/**
 * Model PpdbExam
 * 
 */
export type PpdbExam = $Result.DefaultSelection<Prisma.$PpdbExamPayload>
/**
 * Model Item
 * 
 */
export type Item = $Result.DefaultSelection<Prisma.$ItemPayload>
/**
 * Model InventoryTransaction
 * 
 */
export type InventoryTransaction = $Result.DefaultSelection<Prisma.$InventoryTransactionPayload>
/**
 * Model Supplier
 * 
 */
export type Supplier = $Result.DefaultSelection<Prisma.$SupplierPayload>
/**
 * Model PurchaseOrder
 * 
 */
export type PurchaseOrder = $Result.DefaultSelection<Prisma.$PurchaseOrderPayload>
/**
 * Model Building
 * 
 */
export type Building = $Result.DefaultSelection<Prisma.$BuildingPayload>
/**
 * Model Room
 * 
 */
export type Room = $Result.DefaultSelection<Prisma.$RoomPayload>
/**
 * Model RoomAssignment
 * 
 */
export type RoomAssignment = $Result.DefaultSelection<Prisma.$RoomAssignmentPayload>
/**
 * Model MaintenanceTicket
 * 
 */
export type MaintenanceTicket = $Result.DefaultSelection<Prisma.$MaintenanceTicketPayload>

/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Tenants
 * const tenants = await prisma.tenant.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Tenants
   * const tenants = await prisma.tenant.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb, ExtArgs>

      /**
   * `prisma.tenant`: Exposes CRUD operations for the **Tenant** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Tenants
    * const tenants = await prisma.tenant.findMany()
    * ```
    */
  get tenant(): Prisma.TenantDelegate<ExtArgs>;

  /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs>;

  /**
   * `prisma.refreshToken`: Exposes CRUD operations for the **RefreshToken** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RefreshTokens
    * const refreshTokens = await prisma.refreshToken.findMany()
    * ```
    */
  get refreshToken(): Prisma.RefreshTokenDelegate<ExtArgs>;

  /**
   * `prisma.santri`: Exposes CRUD operations for the **Santri** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Santris
    * const santris = await prisma.santri.findMany()
    * ```
    */
  get santri(): Prisma.SantriDelegate<ExtArgs>;

  /**
   * `prisma.wali`: Exposes CRUD operations for the **Wali** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Walis
    * const walis = await prisma.wali.findMany()
    * ```
    */
  get wali(): Prisma.WaliDelegate<ExtArgs>;

  /**
   * `prisma.santriWali`: Exposes CRUD operations for the **SantriWali** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SantriWalis
    * const santriWalis = await prisma.santriWali.findMany()
    * ```
    */
  get santriWali(): Prisma.SantriWaliDelegate<ExtArgs>;

  /**
   * `prisma.izin`: Exposes CRUD operations for the **Izin** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Izins
    * const izins = await prisma.izin.findMany()
    * ```
    */
  get izin(): Prisma.IzinDelegate<ExtArgs>;

  /**
   * `prisma.catatanHarian`: Exposes CRUD operations for the **CatatanHarian** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CatatanHarians
    * const catatanHarians = await prisma.catatanHarian.findMany()
    * ```
    */
  get catatanHarian(): Prisma.CatatanHarianDelegate<ExtArgs>;

  /**
   * `prisma.pengumuman`: Exposes CRUD operations for the **Pengumuman** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Pengumumen
    * const pengumumen = await prisma.pengumuman.findMany()
    * ```
    */
  get pengumuman(): Prisma.PengumumanDelegate<ExtArgs>;

  /**
   * `prisma.invoice`: Exposes CRUD operations for the **Invoice** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Invoices
    * const invoices = await prisma.invoice.findMany()
    * ```
    */
  get invoice(): Prisma.InvoiceDelegate<ExtArgs>;

  /**
   * `prisma.invoiceLine`: Exposes CRUD operations for the **InvoiceLine** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more InvoiceLines
    * const invoiceLines = await prisma.invoiceLine.findMany()
    * ```
    */
  get invoiceLine(): Prisma.InvoiceLineDelegate<ExtArgs>;

  /**
   * `prisma.payment`: Exposes CRUD operations for the **Payment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Payments
    * const payments = await prisma.payment.findMany()
    * ```
    */
  get payment(): Prisma.PaymentDelegate<ExtArgs>;

  /**
   * `prisma.pelanggaran`: Exposes CRUD operations for the **Pelanggaran** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Pelanggarans
    * const pelanggarans = await prisma.pelanggaran.findMany()
    * ```
    */
  get pelanggaran(): Prisma.PelanggaranDelegate<ExtArgs>;

  /**
   * `prisma.pembinaan`: Exposes CRUD operations for the **Pembinaan** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Pembinaans
    * const pembinaans = await prisma.pembinaan.findMany()
    * ```
    */
  get pembinaan(): Prisma.PembinaanDelegate<ExtArgs>;

  /**
   * `prisma.kunjungan`: Exposes CRUD operations for the **Kunjungan** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Kunjungans
    * const kunjungans = await prisma.kunjungan.findMany()
    * ```
    */
  get kunjungan(): Prisma.KunjunganDelegate<ExtArgs>;

  /**
   * `prisma.tamu`: Exposes CRUD operations for the **Tamu** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Tamus
    * const tamus = await prisma.tamu.findMany()
    * ```
    */
  get tamu(): Prisma.TamuDelegate<ExtArgs>;

  /**
   * `prisma.healthRecord`: Exposes CRUD operations for the **HealthRecord** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more HealthRecords
    * const healthRecords = await prisma.healthRecord.findMany()
    * ```
    */
  get healthRecord(): Prisma.HealthRecordDelegate<ExtArgs>;

  /**
   * `prisma.medication`: Exposes CRUD operations for the **Medication** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Medications
    * const medications = await prisma.medication.findMany()
    * ```
    */
  get medication(): Prisma.MedicationDelegate<ExtArgs>;

  /**
   * `prisma.auditLog`: Exposes CRUD operations for the **AuditLog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AuditLogs
    * const auditLogs = await prisma.auditLog.findMany()
    * ```
    */
  get auditLog(): Prisma.AuditLogDelegate<ExtArgs>;

  /**
   * `prisma.notification`: Exposes CRUD operations for the **Notification** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Notifications
    * const notifications = await prisma.notification.findMany()
    * ```
    */
  get notification(): Prisma.NotificationDelegate<ExtArgs>;

  /**
   * `prisma.webhookEvent`: Exposes CRUD operations for the **WebhookEvent** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more WebhookEvents
    * const webhookEvents = await prisma.webhookEvent.findMany()
    * ```
    */
  get webhookEvent(): Prisma.WebhookEventDelegate<ExtArgs>;

  /**
   * `prisma.tahfidz`: Exposes CRUD operations for the **Tahfidz** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Tahfidzs
    * const tahfidzs = await prisma.tahfidz.findMany()
    * ```
    */
  get tahfidz(): Prisma.TahfidzDelegate<ExtArgs>;

  /**
   * `prisma.mutabaah`: Exposes CRUD operations for the **Mutabaah** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Mutabaahs
    * const mutabaahs = await prisma.mutabaah.findMany()
    * ```
    */
  get mutabaah(): Prisma.MutabaahDelegate<ExtArgs>;

  /**
   * `prisma.wallet`: Exposes CRUD operations for the **Wallet** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Wallets
    * const wallets = await prisma.wallet.findMany()
    * ```
    */
  get wallet(): Prisma.WalletDelegate<ExtArgs>;

  /**
   * `prisma.walletTransaction`: Exposes CRUD operations for the **WalletTransaction** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more WalletTransactions
    * const walletTransactions = await prisma.walletTransaction.findMany()
    * ```
    */
  get walletTransaction(): Prisma.WalletTransactionDelegate<ExtArgs>;

  /**
   * `prisma.employee`: Exposes CRUD operations for the **Employee** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Employees
    * const employees = await prisma.employee.findMany()
    * ```
    */
  get employee(): Prisma.EmployeeDelegate<ExtArgs>;

  /**
   * `prisma.payroll`: Exposes CRUD operations for the **Payroll** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Payrolls
    * const payrolls = await prisma.payroll.findMany()
    * ```
    */
  get payroll(): Prisma.PayrollDelegate<ExtArgs>;

  /**
   * `prisma.academicSchedule`: Exposes CRUD operations for the **AcademicSchedule** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AcademicSchedules
    * const academicSchedules = await prisma.academicSchedule.findMany()
    * ```
    */
  get academicSchedule(): Prisma.AcademicScheduleDelegate<ExtArgs>;

  /**
   * `prisma.attendance`: Exposes CRUD operations for the **Attendance** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Attendances
    * const attendances = await prisma.attendance.findMany()
    * ```
    */
  get attendance(): Prisma.AttendanceDelegate<ExtArgs>;

  /**
   * `prisma.grade`: Exposes CRUD operations for the **Grade** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Grades
    * const grades = await prisma.grade.findMany()
    * ```
    */
  get grade(): Prisma.GradeDelegate<ExtArgs>;

  /**
   * `prisma.ppdbRegistration`: Exposes CRUD operations for the **PpdbRegistration** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PpdbRegistrations
    * const ppdbRegistrations = await prisma.ppdbRegistration.findMany()
    * ```
    */
  get ppdbRegistration(): Prisma.PpdbRegistrationDelegate<ExtArgs>;

  /**
   * `prisma.ppdbDocument`: Exposes CRUD operations for the **PpdbDocument** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PpdbDocuments
    * const ppdbDocuments = await prisma.ppdbDocument.findMany()
    * ```
    */
  get ppdbDocument(): Prisma.PpdbDocumentDelegate<ExtArgs>;

  /**
   * `prisma.ppdbExam`: Exposes CRUD operations for the **PpdbExam** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PpdbExams
    * const ppdbExams = await prisma.ppdbExam.findMany()
    * ```
    */
  get ppdbExam(): Prisma.PpdbExamDelegate<ExtArgs>;

  /**
   * `prisma.item`: Exposes CRUD operations for the **Item** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Items
    * const items = await prisma.item.findMany()
    * ```
    */
  get item(): Prisma.ItemDelegate<ExtArgs>;

  /**
   * `prisma.inventoryTransaction`: Exposes CRUD operations for the **InventoryTransaction** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more InventoryTransactions
    * const inventoryTransactions = await prisma.inventoryTransaction.findMany()
    * ```
    */
  get inventoryTransaction(): Prisma.InventoryTransactionDelegate<ExtArgs>;

  /**
   * `prisma.supplier`: Exposes CRUD operations for the **Supplier** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Suppliers
    * const suppliers = await prisma.supplier.findMany()
    * ```
    */
  get supplier(): Prisma.SupplierDelegate<ExtArgs>;

  /**
   * `prisma.purchaseOrder`: Exposes CRUD operations for the **PurchaseOrder** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PurchaseOrders
    * const purchaseOrders = await prisma.purchaseOrder.findMany()
    * ```
    */
  get purchaseOrder(): Prisma.PurchaseOrderDelegate<ExtArgs>;

  /**
   * `prisma.building`: Exposes CRUD operations for the **Building** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Buildings
    * const buildings = await prisma.building.findMany()
    * ```
    */
  get building(): Prisma.BuildingDelegate<ExtArgs>;

  /**
   * `prisma.room`: Exposes CRUD operations for the **Room** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Rooms
    * const rooms = await prisma.room.findMany()
    * ```
    */
  get room(): Prisma.RoomDelegate<ExtArgs>;

  /**
   * `prisma.roomAssignment`: Exposes CRUD operations for the **RoomAssignment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RoomAssignments
    * const roomAssignments = await prisma.roomAssignment.findMany()
    * ```
    */
  get roomAssignment(): Prisma.RoomAssignmentDelegate<ExtArgs>;

  /**
   * `prisma.maintenanceTicket`: Exposes CRUD operations for the **MaintenanceTicket** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MaintenanceTickets
    * const maintenanceTickets = await prisma.maintenanceTicket.findMany()
    * ```
    */
  get maintenanceTicket(): Prisma.MaintenanceTicketDelegate<ExtArgs>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 5.22.0
   * Query Engine version: 605197351a3c8bdd595af2d2a9bc3025bca48ea2
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    Tenant: 'Tenant',
    User: 'User',
    RefreshToken: 'RefreshToken',
    Santri: 'Santri',
    Wali: 'Wali',
    SantriWali: 'SantriWali',
    Izin: 'Izin',
    CatatanHarian: 'CatatanHarian',
    Pengumuman: 'Pengumuman',
    Invoice: 'Invoice',
    InvoiceLine: 'InvoiceLine',
    Payment: 'Payment',
    Pelanggaran: 'Pelanggaran',
    Pembinaan: 'Pembinaan',
    Kunjungan: 'Kunjungan',
    Tamu: 'Tamu',
    HealthRecord: 'HealthRecord',
    Medication: 'Medication',
    AuditLog: 'AuditLog',
    Notification: 'Notification',
    WebhookEvent: 'WebhookEvent',
    Tahfidz: 'Tahfidz',
    Mutabaah: 'Mutabaah',
    Wallet: 'Wallet',
    WalletTransaction: 'WalletTransaction',
    Employee: 'Employee',
    Payroll: 'Payroll',
    AcademicSchedule: 'AcademicSchedule',
    Attendance: 'Attendance',
    Grade: 'Grade',
    PpdbRegistration: 'PpdbRegistration',
    PpdbDocument: 'PpdbDocument',
    PpdbExam: 'PpdbExam',
    Item: 'Item',
    InventoryTransaction: 'InventoryTransaction',
    Supplier: 'Supplier',
    PurchaseOrder: 'PurchaseOrder',
    Building: 'Building',
    Room: 'Room',
    RoomAssignment: 'RoomAssignment',
    MaintenanceTicket: 'MaintenanceTicket'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb extends $Utils.Fn<{extArgs: $Extensions.InternalArgs, clientOptions: PrismaClientOptions }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], this['params']['clientOptions']>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> = {
    meta: {
      modelProps: "tenant" | "user" | "refreshToken" | "santri" | "wali" | "santriWali" | "izin" | "catatanHarian" | "pengumuman" | "invoice" | "invoiceLine" | "payment" | "pelanggaran" | "pembinaan" | "kunjungan" | "tamu" | "healthRecord" | "medication" | "auditLog" | "notification" | "webhookEvent" | "tahfidz" | "mutabaah" | "wallet" | "walletTransaction" | "employee" | "payroll" | "academicSchedule" | "attendance" | "grade" | "ppdbRegistration" | "ppdbDocument" | "ppdbExam" | "item" | "inventoryTransaction" | "supplier" | "purchaseOrder" | "building" | "room" | "roomAssignment" | "maintenanceTicket"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      Tenant: {
        payload: Prisma.$TenantPayload<ExtArgs>
        fields: Prisma.TenantFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TenantFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TenantFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantPayload>
          }
          findFirst: {
            args: Prisma.TenantFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TenantFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantPayload>
          }
          findMany: {
            args: Prisma.TenantFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantPayload>[]
          }
          create: {
            args: Prisma.TenantCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantPayload>
          }
          createMany: {
            args: Prisma.TenantCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TenantCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantPayload>[]
          }
          delete: {
            args: Prisma.TenantDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantPayload>
          }
          update: {
            args: Prisma.TenantUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantPayload>
          }
          deleteMany: {
            args: Prisma.TenantDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TenantUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.TenantUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantPayload>
          }
          aggregate: {
            args: Prisma.TenantAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTenant>
          }
          groupBy: {
            args: Prisma.TenantGroupByArgs<ExtArgs>
            result: $Utils.Optional<TenantGroupByOutputType>[]
          }
          count: {
            args: Prisma.TenantCountArgs<ExtArgs>
            result: $Utils.Optional<TenantCountAggregateOutputType> | number
          }
        }
      }
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      RefreshToken: {
        payload: Prisma.$RefreshTokenPayload<ExtArgs>
        fields: Prisma.RefreshTokenFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RefreshTokenFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefreshTokenPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RefreshTokenFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefreshTokenPayload>
          }
          findFirst: {
            args: Prisma.RefreshTokenFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefreshTokenPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RefreshTokenFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefreshTokenPayload>
          }
          findMany: {
            args: Prisma.RefreshTokenFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefreshTokenPayload>[]
          }
          create: {
            args: Prisma.RefreshTokenCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefreshTokenPayload>
          }
          createMany: {
            args: Prisma.RefreshTokenCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RefreshTokenCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefreshTokenPayload>[]
          }
          delete: {
            args: Prisma.RefreshTokenDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefreshTokenPayload>
          }
          update: {
            args: Prisma.RefreshTokenUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefreshTokenPayload>
          }
          deleteMany: {
            args: Prisma.RefreshTokenDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RefreshTokenUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.RefreshTokenUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefreshTokenPayload>
          }
          aggregate: {
            args: Prisma.RefreshTokenAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRefreshToken>
          }
          groupBy: {
            args: Prisma.RefreshTokenGroupByArgs<ExtArgs>
            result: $Utils.Optional<RefreshTokenGroupByOutputType>[]
          }
          count: {
            args: Prisma.RefreshTokenCountArgs<ExtArgs>
            result: $Utils.Optional<RefreshTokenCountAggregateOutputType> | number
          }
        }
      }
      Santri: {
        payload: Prisma.$SantriPayload<ExtArgs>
        fields: Prisma.SantriFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SantriFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SantriPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SantriFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SantriPayload>
          }
          findFirst: {
            args: Prisma.SantriFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SantriPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SantriFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SantriPayload>
          }
          findMany: {
            args: Prisma.SantriFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SantriPayload>[]
          }
          create: {
            args: Prisma.SantriCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SantriPayload>
          }
          createMany: {
            args: Prisma.SantriCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SantriCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SantriPayload>[]
          }
          delete: {
            args: Prisma.SantriDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SantriPayload>
          }
          update: {
            args: Prisma.SantriUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SantriPayload>
          }
          deleteMany: {
            args: Prisma.SantriDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SantriUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SantriUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SantriPayload>
          }
          aggregate: {
            args: Prisma.SantriAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSantri>
          }
          groupBy: {
            args: Prisma.SantriGroupByArgs<ExtArgs>
            result: $Utils.Optional<SantriGroupByOutputType>[]
          }
          count: {
            args: Prisma.SantriCountArgs<ExtArgs>
            result: $Utils.Optional<SantriCountAggregateOutputType> | number
          }
        }
      }
      Wali: {
        payload: Prisma.$WaliPayload<ExtArgs>
        fields: Prisma.WaliFieldRefs
        operations: {
          findUnique: {
            args: Prisma.WaliFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WaliPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.WaliFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WaliPayload>
          }
          findFirst: {
            args: Prisma.WaliFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WaliPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.WaliFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WaliPayload>
          }
          findMany: {
            args: Prisma.WaliFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WaliPayload>[]
          }
          create: {
            args: Prisma.WaliCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WaliPayload>
          }
          createMany: {
            args: Prisma.WaliCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.WaliCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WaliPayload>[]
          }
          delete: {
            args: Prisma.WaliDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WaliPayload>
          }
          update: {
            args: Prisma.WaliUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WaliPayload>
          }
          deleteMany: {
            args: Prisma.WaliDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.WaliUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.WaliUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WaliPayload>
          }
          aggregate: {
            args: Prisma.WaliAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateWali>
          }
          groupBy: {
            args: Prisma.WaliGroupByArgs<ExtArgs>
            result: $Utils.Optional<WaliGroupByOutputType>[]
          }
          count: {
            args: Prisma.WaliCountArgs<ExtArgs>
            result: $Utils.Optional<WaliCountAggregateOutputType> | number
          }
        }
      }
      SantriWali: {
        payload: Prisma.$SantriWaliPayload<ExtArgs>
        fields: Prisma.SantriWaliFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SantriWaliFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SantriWaliPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SantriWaliFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SantriWaliPayload>
          }
          findFirst: {
            args: Prisma.SantriWaliFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SantriWaliPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SantriWaliFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SantriWaliPayload>
          }
          findMany: {
            args: Prisma.SantriWaliFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SantriWaliPayload>[]
          }
          create: {
            args: Prisma.SantriWaliCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SantriWaliPayload>
          }
          createMany: {
            args: Prisma.SantriWaliCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SantriWaliCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SantriWaliPayload>[]
          }
          delete: {
            args: Prisma.SantriWaliDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SantriWaliPayload>
          }
          update: {
            args: Prisma.SantriWaliUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SantriWaliPayload>
          }
          deleteMany: {
            args: Prisma.SantriWaliDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SantriWaliUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SantriWaliUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SantriWaliPayload>
          }
          aggregate: {
            args: Prisma.SantriWaliAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSantriWali>
          }
          groupBy: {
            args: Prisma.SantriWaliGroupByArgs<ExtArgs>
            result: $Utils.Optional<SantriWaliGroupByOutputType>[]
          }
          count: {
            args: Prisma.SantriWaliCountArgs<ExtArgs>
            result: $Utils.Optional<SantriWaliCountAggregateOutputType> | number
          }
        }
      }
      Izin: {
        payload: Prisma.$IzinPayload<ExtArgs>
        fields: Prisma.IzinFieldRefs
        operations: {
          findUnique: {
            args: Prisma.IzinFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IzinPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.IzinFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IzinPayload>
          }
          findFirst: {
            args: Prisma.IzinFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IzinPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.IzinFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IzinPayload>
          }
          findMany: {
            args: Prisma.IzinFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IzinPayload>[]
          }
          create: {
            args: Prisma.IzinCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IzinPayload>
          }
          createMany: {
            args: Prisma.IzinCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.IzinCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IzinPayload>[]
          }
          delete: {
            args: Prisma.IzinDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IzinPayload>
          }
          update: {
            args: Prisma.IzinUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IzinPayload>
          }
          deleteMany: {
            args: Prisma.IzinDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.IzinUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.IzinUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IzinPayload>
          }
          aggregate: {
            args: Prisma.IzinAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateIzin>
          }
          groupBy: {
            args: Prisma.IzinGroupByArgs<ExtArgs>
            result: $Utils.Optional<IzinGroupByOutputType>[]
          }
          count: {
            args: Prisma.IzinCountArgs<ExtArgs>
            result: $Utils.Optional<IzinCountAggregateOutputType> | number
          }
        }
      }
      CatatanHarian: {
        payload: Prisma.$CatatanHarianPayload<ExtArgs>
        fields: Prisma.CatatanHarianFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CatatanHarianFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CatatanHarianPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CatatanHarianFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CatatanHarianPayload>
          }
          findFirst: {
            args: Prisma.CatatanHarianFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CatatanHarianPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CatatanHarianFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CatatanHarianPayload>
          }
          findMany: {
            args: Prisma.CatatanHarianFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CatatanHarianPayload>[]
          }
          create: {
            args: Prisma.CatatanHarianCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CatatanHarianPayload>
          }
          createMany: {
            args: Prisma.CatatanHarianCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CatatanHarianCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CatatanHarianPayload>[]
          }
          delete: {
            args: Prisma.CatatanHarianDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CatatanHarianPayload>
          }
          update: {
            args: Prisma.CatatanHarianUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CatatanHarianPayload>
          }
          deleteMany: {
            args: Prisma.CatatanHarianDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CatatanHarianUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CatatanHarianUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CatatanHarianPayload>
          }
          aggregate: {
            args: Prisma.CatatanHarianAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCatatanHarian>
          }
          groupBy: {
            args: Prisma.CatatanHarianGroupByArgs<ExtArgs>
            result: $Utils.Optional<CatatanHarianGroupByOutputType>[]
          }
          count: {
            args: Prisma.CatatanHarianCountArgs<ExtArgs>
            result: $Utils.Optional<CatatanHarianCountAggregateOutputType> | number
          }
        }
      }
      Pengumuman: {
        payload: Prisma.$PengumumanPayload<ExtArgs>
        fields: Prisma.PengumumanFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PengumumanFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PengumumanPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PengumumanFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PengumumanPayload>
          }
          findFirst: {
            args: Prisma.PengumumanFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PengumumanPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PengumumanFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PengumumanPayload>
          }
          findMany: {
            args: Prisma.PengumumanFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PengumumanPayload>[]
          }
          create: {
            args: Prisma.PengumumanCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PengumumanPayload>
          }
          createMany: {
            args: Prisma.PengumumanCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PengumumanCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PengumumanPayload>[]
          }
          delete: {
            args: Prisma.PengumumanDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PengumumanPayload>
          }
          update: {
            args: Prisma.PengumumanUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PengumumanPayload>
          }
          deleteMany: {
            args: Prisma.PengumumanDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PengumumanUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PengumumanUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PengumumanPayload>
          }
          aggregate: {
            args: Prisma.PengumumanAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePengumuman>
          }
          groupBy: {
            args: Prisma.PengumumanGroupByArgs<ExtArgs>
            result: $Utils.Optional<PengumumanGroupByOutputType>[]
          }
          count: {
            args: Prisma.PengumumanCountArgs<ExtArgs>
            result: $Utils.Optional<PengumumanCountAggregateOutputType> | number
          }
        }
      }
      Invoice: {
        payload: Prisma.$InvoicePayload<ExtArgs>
        fields: Prisma.InvoiceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.InvoiceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.InvoiceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>
          }
          findFirst: {
            args: Prisma.InvoiceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.InvoiceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>
          }
          findMany: {
            args: Prisma.InvoiceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>[]
          }
          create: {
            args: Prisma.InvoiceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>
          }
          createMany: {
            args: Prisma.InvoiceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.InvoiceCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>[]
          }
          delete: {
            args: Prisma.InvoiceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>
          }
          update: {
            args: Prisma.InvoiceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>
          }
          deleteMany: {
            args: Prisma.InvoiceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.InvoiceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.InvoiceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>
          }
          aggregate: {
            args: Prisma.InvoiceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateInvoice>
          }
          groupBy: {
            args: Prisma.InvoiceGroupByArgs<ExtArgs>
            result: $Utils.Optional<InvoiceGroupByOutputType>[]
          }
          count: {
            args: Prisma.InvoiceCountArgs<ExtArgs>
            result: $Utils.Optional<InvoiceCountAggregateOutputType> | number
          }
        }
      }
      InvoiceLine: {
        payload: Prisma.$InvoiceLinePayload<ExtArgs>
        fields: Prisma.InvoiceLineFieldRefs
        operations: {
          findUnique: {
            args: Prisma.InvoiceLineFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoiceLinePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.InvoiceLineFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoiceLinePayload>
          }
          findFirst: {
            args: Prisma.InvoiceLineFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoiceLinePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.InvoiceLineFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoiceLinePayload>
          }
          findMany: {
            args: Prisma.InvoiceLineFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoiceLinePayload>[]
          }
          create: {
            args: Prisma.InvoiceLineCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoiceLinePayload>
          }
          createMany: {
            args: Prisma.InvoiceLineCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.InvoiceLineCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoiceLinePayload>[]
          }
          delete: {
            args: Prisma.InvoiceLineDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoiceLinePayload>
          }
          update: {
            args: Prisma.InvoiceLineUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoiceLinePayload>
          }
          deleteMany: {
            args: Prisma.InvoiceLineDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.InvoiceLineUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.InvoiceLineUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoiceLinePayload>
          }
          aggregate: {
            args: Prisma.InvoiceLineAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateInvoiceLine>
          }
          groupBy: {
            args: Prisma.InvoiceLineGroupByArgs<ExtArgs>
            result: $Utils.Optional<InvoiceLineGroupByOutputType>[]
          }
          count: {
            args: Prisma.InvoiceLineCountArgs<ExtArgs>
            result: $Utils.Optional<InvoiceLineCountAggregateOutputType> | number
          }
        }
      }
      Payment: {
        payload: Prisma.$PaymentPayload<ExtArgs>
        fields: Prisma.PaymentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PaymentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PaymentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          findFirst: {
            args: Prisma.PaymentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PaymentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          findMany: {
            args: Prisma.PaymentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>[]
          }
          create: {
            args: Prisma.PaymentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          createMany: {
            args: Prisma.PaymentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PaymentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>[]
          }
          delete: {
            args: Prisma.PaymentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          update: {
            args: Prisma.PaymentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          deleteMany: {
            args: Prisma.PaymentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PaymentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PaymentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          aggregate: {
            args: Prisma.PaymentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePayment>
          }
          groupBy: {
            args: Prisma.PaymentGroupByArgs<ExtArgs>
            result: $Utils.Optional<PaymentGroupByOutputType>[]
          }
          count: {
            args: Prisma.PaymentCountArgs<ExtArgs>
            result: $Utils.Optional<PaymentCountAggregateOutputType> | number
          }
        }
      }
      Pelanggaran: {
        payload: Prisma.$PelanggaranPayload<ExtArgs>
        fields: Prisma.PelanggaranFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PelanggaranFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PelanggaranPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PelanggaranFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PelanggaranPayload>
          }
          findFirst: {
            args: Prisma.PelanggaranFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PelanggaranPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PelanggaranFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PelanggaranPayload>
          }
          findMany: {
            args: Prisma.PelanggaranFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PelanggaranPayload>[]
          }
          create: {
            args: Prisma.PelanggaranCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PelanggaranPayload>
          }
          createMany: {
            args: Prisma.PelanggaranCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PelanggaranCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PelanggaranPayload>[]
          }
          delete: {
            args: Prisma.PelanggaranDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PelanggaranPayload>
          }
          update: {
            args: Prisma.PelanggaranUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PelanggaranPayload>
          }
          deleteMany: {
            args: Prisma.PelanggaranDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PelanggaranUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PelanggaranUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PelanggaranPayload>
          }
          aggregate: {
            args: Prisma.PelanggaranAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePelanggaran>
          }
          groupBy: {
            args: Prisma.PelanggaranGroupByArgs<ExtArgs>
            result: $Utils.Optional<PelanggaranGroupByOutputType>[]
          }
          count: {
            args: Prisma.PelanggaranCountArgs<ExtArgs>
            result: $Utils.Optional<PelanggaranCountAggregateOutputType> | number
          }
        }
      }
      Pembinaan: {
        payload: Prisma.$PembinaanPayload<ExtArgs>
        fields: Prisma.PembinaanFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PembinaanFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PembinaanPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PembinaanFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PembinaanPayload>
          }
          findFirst: {
            args: Prisma.PembinaanFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PembinaanPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PembinaanFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PembinaanPayload>
          }
          findMany: {
            args: Prisma.PembinaanFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PembinaanPayload>[]
          }
          create: {
            args: Prisma.PembinaanCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PembinaanPayload>
          }
          createMany: {
            args: Prisma.PembinaanCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PembinaanCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PembinaanPayload>[]
          }
          delete: {
            args: Prisma.PembinaanDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PembinaanPayload>
          }
          update: {
            args: Prisma.PembinaanUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PembinaanPayload>
          }
          deleteMany: {
            args: Prisma.PembinaanDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PembinaanUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PembinaanUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PembinaanPayload>
          }
          aggregate: {
            args: Prisma.PembinaanAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePembinaan>
          }
          groupBy: {
            args: Prisma.PembinaanGroupByArgs<ExtArgs>
            result: $Utils.Optional<PembinaanGroupByOutputType>[]
          }
          count: {
            args: Prisma.PembinaanCountArgs<ExtArgs>
            result: $Utils.Optional<PembinaanCountAggregateOutputType> | number
          }
        }
      }
      Kunjungan: {
        payload: Prisma.$KunjunganPayload<ExtArgs>
        fields: Prisma.KunjunganFieldRefs
        operations: {
          findUnique: {
            args: Prisma.KunjunganFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KunjunganPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.KunjunganFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KunjunganPayload>
          }
          findFirst: {
            args: Prisma.KunjunganFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KunjunganPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.KunjunganFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KunjunganPayload>
          }
          findMany: {
            args: Prisma.KunjunganFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KunjunganPayload>[]
          }
          create: {
            args: Prisma.KunjunganCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KunjunganPayload>
          }
          createMany: {
            args: Prisma.KunjunganCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.KunjunganCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KunjunganPayload>[]
          }
          delete: {
            args: Prisma.KunjunganDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KunjunganPayload>
          }
          update: {
            args: Prisma.KunjunganUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KunjunganPayload>
          }
          deleteMany: {
            args: Prisma.KunjunganDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.KunjunganUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.KunjunganUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KunjunganPayload>
          }
          aggregate: {
            args: Prisma.KunjunganAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateKunjungan>
          }
          groupBy: {
            args: Prisma.KunjunganGroupByArgs<ExtArgs>
            result: $Utils.Optional<KunjunganGroupByOutputType>[]
          }
          count: {
            args: Prisma.KunjunganCountArgs<ExtArgs>
            result: $Utils.Optional<KunjunganCountAggregateOutputType> | number
          }
        }
      }
      Tamu: {
        payload: Prisma.$TamuPayload<ExtArgs>
        fields: Prisma.TamuFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TamuFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TamuPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TamuFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TamuPayload>
          }
          findFirst: {
            args: Prisma.TamuFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TamuPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TamuFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TamuPayload>
          }
          findMany: {
            args: Prisma.TamuFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TamuPayload>[]
          }
          create: {
            args: Prisma.TamuCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TamuPayload>
          }
          createMany: {
            args: Prisma.TamuCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TamuCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TamuPayload>[]
          }
          delete: {
            args: Prisma.TamuDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TamuPayload>
          }
          update: {
            args: Prisma.TamuUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TamuPayload>
          }
          deleteMany: {
            args: Prisma.TamuDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TamuUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.TamuUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TamuPayload>
          }
          aggregate: {
            args: Prisma.TamuAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTamu>
          }
          groupBy: {
            args: Prisma.TamuGroupByArgs<ExtArgs>
            result: $Utils.Optional<TamuGroupByOutputType>[]
          }
          count: {
            args: Prisma.TamuCountArgs<ExtArgs>
            result: $Utils.Optional<TamuCountAggregateOutputType> | number
          }
        }
      }
      HealthRecord: {
        payload: Prisma.$HealthRecordPayload<ExtArgs>
        fields: Prisma.HealthRecordFieldRefs
        operations: {
          findUnique: {
            args: Prisma.HealthRecordFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HealthRecordPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.HealthRecordFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HealthRecordPayload>
          }
          findFirst: {
            args: Prisma.HealthRecordFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HealthRecordPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.HealthRecordFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HealthRecordPayload>
          }
          findMany: {
            args: Prisma.HealthRecordFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HealthRecordPayload>[]
          }
          create: {
            args: Prisma.HealthRecordCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HealthRecordPayload>
          }
          createMany: {
            args: Prisma.HealthRecordCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.HealthRecordCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HealthRecordPayload>[]
          }
          delete: {
            args: Prisma.HealthRecordDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HealthRecordPayload>
          }
          update: {
            args: Prisma.HealthRecordUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HealthRecordPayload>
          }
          deleteMany: {
            args: Prisma.HealthRecordDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.HealthRecordUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.HealthRecordUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HealthRecordPayload>
          }
          aggregate: {
            args: Prisma.HealthRecordAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateHealthRecord>
          }
          groupBy: {
            args: Prisma.HealthRecordGroupByArgs<ExtArgs>
            result: $Utils.Optional<HealthRecordGroupByOutputType>[]
          }
          count: {
            args: Prisma.HealthRecordCountArgs<ExtArgs>
            result: $Utils.Optional<HealthRecordCountAggregateOutputType> | number
          }
        }
      }
      Medication: {
        payload: Prisma.$MedicationPayload<ExtArgs>
        fields: Prisma.MedicationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MedicationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MedicationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicationPayload>
          }
          findFirst: {
            args: Prisma.MedicationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MedicationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicationPayload>
          }
          findMany: {
            args: Prisma.MedicationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicationPayload>[]
          }
          create: {
            args: Prisma.MedicationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicationPayload>
          }
          createMany: {
            args: Prisma.MedicationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MedicationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicationPayload>[]
          }
          delete: {
            args: Prisma.MedicationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicationPayload>
          }
          update: {
            args: Prisma.MedicationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicationPayload>
          }
          deleteMany: {
            args: Prisma.MedicationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MedicationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.MedicationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicationPayload>
          }
          aggregate: {
            args: Prisma.MedicationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMedication>
          }
          groupBy: {
            args: Prisma.MedicationGroupByArgs<ExtArgs>
            result: $Utils.Optional<MedicationGroupByOutputType>[]
          }
          count: {
            args: Prisma.MedicationCountArgs<ExtArgs>
            result: $Utils.Optional<MedicationCountAggregateOutputType> | number
          }
        }
      }
      AuditLog: {
        payload: Prisma.$AuditLogPayload<ExtArgs>
        fields: Prisma.AuditLogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AuditLogFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AuditLogFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          findFirst: {
            args: Prisma.AuditLogFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AuditLogFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          findMany: {
            args: Prisma.AuditLogFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>[]
          }
          create: {
            args: Prisma.AuditLogCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          createMany: {
            args: Prisma.AuditLogCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AuditLogCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>[]
          }
          delete: {
            args: Prisma.AuditLogDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          update: {
            args: Prisma.AuditLogUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          deleteMany: {
            args: Prisma.AuditLogDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AuditLogUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AuditLogUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          aggregate: {
            args: Prisma.AuditLogAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAuditLog>
          }
          groupBy: {
            args: Prisma.AuditLogGroupByArgs<ExtArgs>
            result: $Utils.Optional<AuditLogGroupByOutputType>[]
          }
          count: {
            args: Prisma.AuditLogCountArgs<ExtArgs>
            result: $Utils.Optional<AuditLogCountAggregateOutputType> | number
          }
        }
      }
      Notification: {
        payload: Prisma.$NotificationPayload<ExtArgs>
        fields: Prisma.NotificationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.NotificationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.NotificationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          findFirst: {
            args: Prisma.NotificationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.NotificationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          findMany: {
            args: Prisma.NotificationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>[]
          }
          create: {
            args: Prisma.NotificationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          createMany: {
            args: Prisma.NotificationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.NotificationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>[]
          }
          delete: {
            args: Prisma.NotificationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          update: {
            args: Prisma.NotificationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          deleteMany: {
            args: Prisma.NotificationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.NotificationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.NotificationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          aggregate: {
            args: Prisma.NotificationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNotification>
          }
          groupBy: {
            args: Prisma.NotificationGroupByArgs<ExtArgs>
            result: $Utils.Optional<NotificationGroupByOutputType>[]
          }
          count: {
            args: Prisma.NotificationCountArgs<ExtArgs>
            result: $Utils.Optional<NotificationCountAggregateOutputType> | number
          }
        }
      }
      WebhookEvent: {
        payload: Prisma.$WebhookEventPayload<ExtArgs>
        fields: Prisma.WebhookEventFieldRefs
        operations: {
          findUnique: {
            args: Prisma.WebhookEventFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebhookEventPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.WebhookEventFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebhookEventPayload>
          }
          findFirst: {
            args: Prisma.WebhookEventFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebhookEventPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.WebhookEventFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebhookEventPayload>
          }
          findMany: {
            args: Prisma.WebhookEventFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebhookEventPayload>[]
          }
          create: {
            args: Prisma.WebhookEventCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebhookEventPayload>
          }
          createMany: {
            args: Prisma.WebhookEventCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.WebhookEventCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebhookEventPayload>[]
          }
          delete: {
            args: Prisma.WebhookEventDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebhookEventPayload>
          }
          update: {
            args: Prisma.WebhookEventUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebhookEventPayload>
          }
          deleteMany: {
            args: Prisma.WebhookEventDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.WebhookEventUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.WebhookEventUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebhookEventPayload>
          }
          aggregate: {
            args: Prisma.WebhookEventAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateWebhookEvent>
          }
          groupBy: {
            args: Prisma.WebhookEventGroupByArgs<ExtArgs>
            result: $Utils.Optional<WebhookEventGroupByOutputType>[]
          }
          count: {
            args: Prisma.WebhookEventCountArgs<ExtArgs>
            result: $Utils.Optional<WebhookEventCountAggregateOutputType> | number
          }
        }
      }
      Tahfidz: {
        payload: Prisma.$TahfidzPayload<ExtArgs>
        fields: Prisma.TahfidzFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TahfidzFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TahfidzPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TahfidzFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TahfidzPayload>
          }
          findFirst: {
            args: Prisma.TahfidzFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TahfidzPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TahfidzFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TahfidzPayload>
          }
          findMany: {
            args: Prisma.TahfidzFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TahfidzPayload>[]
          }
          create: {
            args: Prisma.TahfidzCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TahfidzPayload>
          }
          createMany: {
            args: Prisma.TahfidzCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TahfidzCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TahfidzPayload>[]
          }
          delete: {
            args: Prisma.TahfidzDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TahfidzPayload>
          }
          update: {
            args: Prisma.TahfidzUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TahfidzPayload>
          }
          deleteMany: {
            args: Prisma.TahfidzDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TahfidzUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.TahfidzUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TahfidzPayload>
          }
          aggregate: {
            args: Prisma.TahfidzAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTahfidz>
          }
          groupBy: {
            args: Prisma.TahfidzGroupByArgs<ExtArgs>
            result: $Utils.Optional<TahfidzGroupByOutputType>[]
          }
          count: {
            args: Prisma.TahfidzCountArgs<ExtArgs>
            result: $Utils.Optional<TahfidzCountAggregateOutputType> | number
          }
        }
      }
      Mutabaah: {
        payload: Prisma.$MutabaahPayload<ExtArgs>
        fields: Prisma.MutabaahFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MutabaahFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MutabaahPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MutabaahFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MutabaahPayload>
          }
          findFirst: {
            args: Prisma.MutabaahFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MutabaahPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MutabaahFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MutabaahPayload>
          }
          findMany: {
            args: Prisma.MutabaahFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MutabaahPayload>[]
          }
          create: {
            args: Prisma.MutabaahCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MutabaahPayload>
          }
          createMany: {
            args: Prisma.MutabaahCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MutabaahCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MutabaahPayload>[]
          }
          delete: {
            args: Prisma.MutabaahDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MutabaahPayload>
          }
          update: {
            args: Prisma.MutabaahUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MutabaahPayload>
          }
          deleteMany: {
            args: Prisma.MutabaahDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MutabaahUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.MutabaahUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MutabaahPayload>
          }
          aggregate: {
            args: Prisma.MutabaahAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMutabaah>
          }
          groupBy: {
            args: Prisma.MutabaahGroupByArgs<ExtArgs>
            result: $Utils.Optional<MutabaahGroupByOutputType>[]
          }
          count: {
            args: Prisma.MutabaahCountArgs<ExtArgs>
            result: $Utils.Optional<MutabaahCountAggregateOutputType> | number
          }
        }
      }
      Wallet: {
        payload: Prisma.$WalletPayload<ExtArgs>
        fields: Prisma.WalletFieldRefs
        operations: {
          findUnique: {
            args: Prisma.WalletFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WalletPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.WalletFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WalletPayload>
          }
          findFirst: {
            args: Prisma.WalletFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WalletPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.WalletFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WalletPayload>
          }
          findMany: {
            args: Prisma.WalletFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WalletPayload>[]
          }
          create: {
            args: Prisma.WalletCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WalletPayload>
          }
          createMany: {
            args: Prisma.WalletCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.WalletCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WalletPayload>[]
          }
          delete: {
            args: Prisma.WalletDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WalletPayload>
          }
          update: {
            args: Prisma.WalletUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WalletPayload>
          }
          deleteMany: {
            args: Prisma.WalletDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.WalletUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.WalletUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WalletPayload>
          }
          aggregate: {
            args: Prisma.WalletAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateWallet>
          }
          groupBy: {
            args: Prisma.WalletGroupByArgs<ExtArgs>
            result: $Utils.Optional<WalletGroupByOutputType>[]
          }
          count: {
            args: Prisma.WalletCountArgs<ExtArgs>
            result: $Utils.Optional<WalletCountAggregateOutputType> | number
          }
        }
      }
      WalletTransaction: {
        payload: Prisma.$WalletTransactionPayload<ExtArgs>
        fields: Prisma.WalletTransactionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.WalletTransactionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WalletTransactionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.WalletTransactionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WalletTransactionPayload>
          }
          findFirst: {
            args: Prisma.WalletTransactionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WalletTransactionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.WalletTransactionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WalletTransactionPayload>
          }
          findMany: {
            args: Prisma.WalletTransactionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WalletTransactionPayload>[]
          }
          create: {
            args: Prisma.WalletTransactionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WalletTransactionPayload>
          }
          createMany: {
            args: Prisma.WalletTransactionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.WalletTransactionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WalletTransactionPayload>[]
          }
          delete: {
            args: Prisma.WalletTransactionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WalletTransactionPayload>
          }
          update: {
            args: Prisma.WalletTransactionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WalletTransactionPayload>
          }
          deleteMany: {
            args: Prisma.WalletTransactionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.WalletTransactionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.WalletTransactionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WalletTransactionPayload>
          }
          aggregate: {
            args: Prisma.WalletTransactionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateWalletTransaction>
          }
          groupBy: {
            args: Prisma.WalletTransactionGroupByArgs<ExtArgs>
            result: $Utils.Optional<WalletTransactionGroupByOutputType>[]
          }
          count: {
            args: Prisma.WalletTransactionCountArgs<ExtArgs>
            result: $Utils.Optional<WalletTransactionCountAggregateOutputType> | number
          }
        }
      }
      Employee: {
        payload: Prisma.$EmployeePayload<ExtArgs>
        fields: Prisma.EmployeeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EmployeeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EmployeeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeePayload>
          }
          findFirst: {
            args: Prisma.EmployeeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EmployeeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeePayload>
          }
          findMany: {
            args: Prisma.EmployeeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeePayload>[]
          }
          create: {
            args: Prisma.EmployeeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeePayload>
          }
          createMany: {
            args: Prisma.EmployeeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.EmployeeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeePayload>[]
          }
          delete: {
            args: Prisma.EmployeeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeePayload>
          }
          update: {
            args: Prisma.EmployeeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeePayload>
          }
          deleteMany: {
            args: Prisma.EmployeeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EmployeeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.EmployeeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeePayload>
          }
          aggregate: {
            args: Prisma.EmployeeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEmployee>
          }
          groupBy: {
            args: Prisma.EmployeeGroupByArgs<ExtArgs>
            result: $Utils.Optional<EmployeeGroupByOutputType>[]
          }
          count: {
            args: Prisma.EmployeeCountArgs<ExtArgs>
            result: $Utils.Optional<EmployeeCountAggregateOutputType> | number
          }
        }
      }
      Payroll: {
        payload: Prisma.$PayrollPayload<ExtArgs>
        fields: Prisma.PayrollFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PayrollFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PayrollPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PayrollFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PayrollPayload>
          }
          findFirst: {
            args: Prisma.PayrollFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PayrollPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PayrollFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PayrollPayload>
          }
          findMany: {
            args: Prisma.PayrollFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PayrollPayload>[]
          }
          create: {
            args: Prisma.PayrollCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PayrollPayload>
          }
          createMany: {
            args: Prisma.PayrollCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PayrollCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PayrollPayload>[]
          }
          delete: {
            args: Prisma.PayrollDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PayrollPayload>
          }
          update: {
            args: Prisma.PayrollUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PayrollPayload>
          }
          deleteMany: {
            args: Prisma.PayrollDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PayrollUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PayrollUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PayrollPayload>
          }
          aggregate: {
            args: Prisma.PayrollAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePayroll>
          }
          groupBy: {
            args: Prisma.PayrollGroupByArgs<ExtArgs>
            result: $Utils.Optional<PayrollGroupByOutputType>[]
          }
          count: {
            args: Prisma.PayrollCountArgs<ExtArgs>
            result: $Utils.Optional<PayrollCountAggregateOutputType> | number
          }
        }
      }
      AcademicSchedule: {
        payload: Prisma.$AcademicSchedulePayload<ExtArgs>
        fields: Prisma.AcademicScheduleFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AcademicScheduleFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AcademicSchedulePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AcademicScheduleFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AcademicSchedulePayload>
          }
          findFirst: {
            args: Prisma.AcademicScheduleFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AcademicSchedulePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AcademicScheduleFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AcademicSchedulePayload>
          }
          findMany: {
            args: Prisma.AcademicScheduleFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AcademicSchedulePayload>[]
          }
          create: {
            args: Prisma.AcademicScheduleCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AcademicSchedulePayload>
          }
          createMany: {
            args: Prisma.AcademicScheduleCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AcademicScheduleCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AcademicSchedulePayload>[]
          }
          delete: {
            args: Prisma.AcademicScheduleDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AcademicSchedulePayload>
          }
          update: {
            args: Prisma.AcademicScheduleUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AcademicSchedulePayload>
          }
          deleteMany: {
            args: Prisma.AcademicScheduleDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AcademicScheduleUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AcademicScheduleUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AcademicSchedulePayload>
          }
          aggregate: {
            args: Prisma.AcademicScheduleAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAcademicSchedule>
          }
          groupBy: {
            args: Prisma.AcademicScheduleGroupByArgs<ExtArgs>
            result: $Utils.Optional<AcademicScheduleGroupByOutputType>[]
          }
          count: {
            args: Prisma.AcademicScheduleCountArgs<ExtArgs>
            result: $Utils.Optional<AcademicScheduleCountAggregateOutputType> | number
          }
        }
      }
      Attendance: {
        payload: Prisma.$AttendancePayload<ExtArgs>
        fields: Prisma.AttendanceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AttendanceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendancePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AttendanceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendancePayload>
          }
          findFirst: {
            args: Prisma.AttendanceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendancePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AttendanceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendancePayload>
          }
          findMany: {
            args: Prisma.AttendanceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendancePayload>[]
          }
          create: {
            args: Prisma.AttendanceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendancePayload>
          }
          createMany: {
            args: Prisma.AttendanceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AttendanceCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendancePayload>[]
          }
          delete: {
            args: Prisma.AttendanceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendancePayload>
          }
          update: {
            args: Prisma.AttendanceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendancePayload>
          }
          deleteMany: {
            args: Prisma.AttendanceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AttendanceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AttendanceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendancePayload>
          }
          aggregate: {
            args: Prisma.AttendanceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAttendance>
          }
          groupBy: {
            args: Prisma.AttendanceGroupByArgs<ExtArgs>
            result: $Utils.Optional<AttendanceGroupByOutputType>[]
          }
          count: {
            args: Prisma.AttendanceCountArgs<ExtArgs>
            result: $Utils.Optional<AttendanceCountAggregateOutputType> | number
          }
        }
      }
      Grade: {
        payload: Prisma.$GradePayload<ExtArgs>
        fields: Prisma.GradeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.GradeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GradePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.GradeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GradePayload>
          }
          findFirst: {
            args: Prisma.GradeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GradePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.GradeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GradePayload>
          }
          findMany: {
            args: Prisma.GradeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GradePayload>[]
          }
          create: {
            args: Prisma.GradeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GradePayload>
          }
          createMany: {
            args: Prisma.GradeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.GradeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GradePayload>[]
          }
          delete: {
            args: Prisma.GradeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GradePayload>
          }
          update: {
            args: Prisma.GradeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GradePayload>
          }
          deleteMany: {
            args: Prisma.GradeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.GradeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.GradeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GradePayload>
          }
          aggregate: {
            args: Prisma.GradeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateGrade>
          }
          groupBy: {
            args: Prisma.GradeGroupByArgs<ExtArgs>
            result: $Utils.Optional<GradeGroupByOutputType>[]
          }
          count: {
            args: Prisma.GradeCountArgs<ExtArgs>
            result: $Utils.Optional<GradeCountAggregateOutputType> | number
          }
        }
      }
      PpdbRegistration: {
        payload: Prisma.$PpdbRegistrationPayload<ExtArgs>
        fields: Prisma.PpdbRegistrationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PpdbRegistrationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PpdbRegistrationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PpdbRegistrationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PpdbRegistrationPayload>
          }
          findFirst: {
            args: Prisma.PpdbRegistrationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PpdbRegistrationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PpdbRegistrationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PpdbRegistrationPayload>
          }
          findMany: {
            args: Prisma.PpdbRegistrationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PpdbRegistrationPayload>[]
          }
          create: {
            args: Prisma.PpdbRegistrationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PpdbRegistrationPayload>
          }
          createMany: {
            args: Prisma.PpdbRegistrationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PpdbRegistrationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PpdbRegistrationPayload>[]
          }
          delete: {
            args: Prisma.PpdbRegistrationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PpdbRegistrationPayload>
          }
          update: {
            args: Prisma.PpdbRegistrationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PpdbRegistrationPayload>
          }
          deleteMany: {
            args: Prisma.PpdbRegistrationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PpdbRegistrationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PpdbRegistrationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PpdbRegistrationPayload>
          }
          aggregate: {
            args: Prisma.PpdbRegistrationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePpdbRegistration>
          }
          groupBy: {
            args: Prisma.PpdbRegistrationGroupByArgs<ExtArgs>
            result: $Utils.Optional<PpdbRegistrationGroupByOutputType>[]
          }
          count: {
            args: Prisma.PpdbRegistrationCountArgs<ExtArgs>
            result: $Utils.Optional<PpdbRegistrationCountAggregateOutputType> | number
          }
        }
      }
      PpdbDocument: {
        payload: Prisma.$PpdbDocumentPayload<ExtArgs>
        fields: Prisma.PpdbDocumentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PpdbDocumentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PpdbDocumentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PpdbDocumentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PpdbDocumentPayload>
          }
          findFirst: {
            args: Prisma.PpdbDocumentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PpdbDocumentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PpdbDocumentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PpdbDocumentPayload>
          }
          findMany: {
            args: Prisma.PpdbDocumentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PpdbDocumentPayload>[]
          }
          create: {
            args: Prisma.PpdbDocumentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PpdbDocumentPayload>
          }
          createMany: {
            args: Prisma.PpdbDocumentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PpdbDocumentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PpdbDocumentPayload>[]
          }
          delete: {
            args: Prisma.PpdbDocumentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PpdbDocumentPayload>
          }
          update: {
            args: Prisma.PpdbDocumentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PpdbDocumentPayload>
          }
          deleteMany: {
            args: Prisma.PpdbDocumentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PpdbDocumentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PpdbDocumentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PpdbDocumentPayload>
          }
          aggregate: {
            args: Prisma.PpdbDocumentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePpdbDocument>
          }
          groupBy: {
            args: Prisma.PpdbDocumentGroupByArgs<ExtArgs>
            result: $Utils.Optional<PpdbDocumentGroupByOutputType>[]
          }
          count: {
            args: Prisma.PpdbDocumentCountArgs<ExtArgs>
            result: $Utils.Optional<PpdbDocumentCountAggregateOutputType> | number
          }
        }
      }
      PpdbExam: {
        payload: Prisma.$PpdbExamPayload<ExtArgs>
        fields: Prisma.PpdbExamFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PpdbExamFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PpdbExamPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PpdbExamFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PpdbExamPayload>
          }
          findFirst: {
            args: Prisma.PpdbExamFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PpdbExamPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PpdbExamFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PpdbExamPayload>
          }
          findMany: {
            args: Prisma.PpdbExamFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PpdbExamPayload>[]
          }
          create: {
            args: Prisma.PpdbExamCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PpdbExamPayload>
          }
          createMany: {
            args: Prisma.PpdbExamCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PpdbExamCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PpdbExamPayload>[]
          }
          delete: {
            args: Prisma.PpdbExamDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PpdbExamPayload>
          }
          update: {
            args: Prisma.PpdbExamUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PpdbExamPayload>
          }
          deleteMany: {
            args: Prisma.PpdbExamDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PpdbExamUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PpdbExamUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PpdbExamPayload>
          }
          aggregate: {
            args: Prisma.PpdbExamAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePpdbExam>
          }
          groupBy: {
            args: Prisma.PpdbExamGroupByArgs<ExtArgs>
            result: $Utils.Optional<PpdbExamGroupByOutputType>[]
          }
          count: {
            args: Prisma.PpdbExamCountArgs<ExtArgs>
            result: $Utils.Optional<PpdbExamCountAggregateOutputType> | number
          }
        }
      }
      Item: {
        payload: Prisma.$ItemPayload<ExtArgs>
        fields: Prisma.ItemFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ItemFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ItemFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemPayload>
          }
          findFirst: {
            args: Prisma.ItemFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ItemFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemPayload>
          }
          findMany: {
            args: Prisma.ItemFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemPayload>[]
          }
          create: {
            args: Prisma.ItemCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemPayload>
          }
          createMany: {
            args: Prisma.ItemCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ItemCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemPayload>[]
          }
          delete: {
            args: Prisma.ItemDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemPayload>
          }
          update: {
            args: Prisma.ItemUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemPayload>
          }
          deleteMany: {
            args: Prisma.ItemDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ItemUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ItemUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ItemPayload>
          }
          aggregate: {
            args: Prisma.ItemAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateItem>
          }
          groupBy: {
            args: Prisma.ItemGroupByArgs<ExtArgs>
            result: $Utils.Optional<ItemGroupByOutputType>[]
          }
          count: {
            args: Prisma.ItemCountArgs<ExtArgs>
            result: $Utils.Optional<ItemCountAggregateOutputType> | number
          }
        }
      }
      InventoryTransaction: {
        payload: Prisma.$InventoryTransactionPayload<ExtArgs>
        fields: Prisma.InventoryTransactionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.InventoryTransactionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryTransactionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.InventoryTransactionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryTransactionPayload>
          }
          findFirst: {
            args: Prisma.InventoryTransactionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryTransactionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.InventoryTransactionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryTransactionPayload>
          }
          findMany: {
            args: Prisma.InventoryTransactionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryTransactionPayload>[]
          }
          create: {
            args: Prisma.InventoryTransactionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryTransactionPayload>
          }
          createMany: {
            args: Prisma.InventoryTransactionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.InventoryTransactionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryTransactionPayload>[]
          }
          delete: {
            args: Prisma.InventoryTransactionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryTransactionPayload>
          }
          update: {
            args: Prisma.InventoryTransactionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryTransactionPayload>
          }
          deleteMany: {
            args: Prisma.InventoryTransactionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.InventoryTransactionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.InventoryTransactionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryTransactionPayload>
          }
          aggregate: {
            args: Prisma.InventoryTransactionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateInventoryTransaction>
          }
          groupBy: {
            args: Prisma.InventoryTransactionGroupByArgs<ExtArgs>
            result: $Utils.Optional<InventoryTransactionGroupByOutputType>[]
          }
          count: {
            args: Prisma.InventoryTransactionCountArgs<ExtArgs>
            result: $Utils.Optional<InventoryTransactionCountAggregateOutputType> | number
          }
        }
      }
      Supplier: {
        payload: Prisma.$SupplierPayload<ExtArgs>
        fields: Prisma.SupplierFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SupplierFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupplierPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SupplierFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupplierPayload>
          }
          findFirst: {
            args: Prisma.SupplierFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupplierPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SupplierFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupplierPayload>
          }
          findMany: {
            args: Prisma.SupplierFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupplierPayload>[]
          }
          create: {
            args: Prisma.SupplierCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupplierPayload>
          }
          createMany: {
            args: Prisma.SupplierCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SupplierCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupplierPayload>[]
          }
          delete: {
            args: Prisma.SupplierDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupplierPayload>
          }
          update: {
            args: Prisma.SupplierUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupplierPayload>
          }
          deleteMany: {
            args: Prisma.SupplierDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SupplierUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SupplierUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupplierPayload>
          }
          aggregate: {
            args: Prisma.SupplierAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSupplier>
          }
          groupBy: {
            args: Prisma.SupplierGroupByArgs<ExtArgs>
            result: $Utils.Optional<SupplierGroupByOutputType>[]
          }
          count: {
            args: Prisma.SupplierCountArgs<ExtArgs>
            result: $Utils.Optional<SupplierCountAggregateOutputType> | number
          }
        }
      }
      PurchaseOrder: {
        payload: Prisma.$PurchaseOrderPayload<ExtArgs>
        fields: Prisma.PurchaseOrderFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PurchaseOrderFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseOrderPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PurchaseOrderFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseOrderPayload>
          }
          findFirst: {
            args: Prisma.PurchaseOrderFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseOrderPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PurchaseOrderFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseOrderPayload>
          }
          findMany: {
            args: Prisma.PurchaseOrderFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseOrderPayload>[]
          }
          create: {
            args: Prisma.PurchaseOrderCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseOrderPayload>
          }
          createMany: {
            args: Prisma.PurchaseOrderCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PurchaseOrderCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseOrderPayload>[]
          }
          delete: {
            args: Prisma.PurchaseOrderDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseOrderPayload>
          }
          update: {
            args: Prisma.PurchaseOrderUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseOrderPayload>
          }
          deleteMany: {
            args: Prisma.PurchaseOrderDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PurchaseOrderUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PurchaseOrderUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseOrderPayload>
          }
          aggregate: {
            args: Prisma.PurchaseOrderAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePurchaseOrder>
          }
          groupBy: {
            args: Prisma.PurchaseOrderGroupByArgs<ExtArgs>
            result: $Utils.Optional<PurchaseOrderGroupByOutputType>[]
          }
          count: {
            args: Prisma.PurchaseOrderCountArgs<ExtArgs>
            result: $Utils.Optional<PurchaseOrderCountAggregateOutputType> | number
          }
        }
      }
      Building: {
        payload: Prisma.$BuildingPayload<ExtArgs>
        fields: Prisma.BuildingFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BuildingFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BuildingPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BuildingFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BuildingPayload>
          }
          findFirst: {
            args: Prisma.BuildingFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BuildingPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BuildingFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BuildingPayload>
          }
          findMany: {
            args: Prisma.BuildingFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BuildingPayload>[]
          }
          create: {
            args: Prisma.BuildingCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BuildingPayload>
          }
          createMany: {
            args: Prisma.BuildingCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BuildingCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BuildingPayload>[]
          }
          delete: {
            args: Prisma.BuildingDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BuildingPayload>
          }
          update: {
            args: Prisma.BuildingUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BuildingPayload>
          }
          deleteMany: {
            args: Prisma.BuildingDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BuildingUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.BuildingUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BuildingPayload>
          }
          aggregate: {
            args: Prisma.BuildingAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBuilding>
          }
          groupBy: {
            args: Prisma.BuildingGroupByArgs<ExtArgs>
            result: $Utils.Optional<BuildingGroupByOutputType>[]
          }
          count: {
            args: Prisma.BuildingCountArgs<ExtArgs>
            result: $Utils.Optional<BuildingCountAggregateOutputType> | number
          }
        }
      }
      Room: {
        payload: Prisma.$RoomPayload<ExtArgs>
        fields: Prisma.RoomFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RoomFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoomPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RoomFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoomPayload>
          }
          findFirst: {
            args: Prisma.RoomFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoomPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RoomFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoomPayload>
          }
          findMany: {
            args: Prisma.RoomFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoomPayload>[]
          }
          create: {
            args: Prisma.RoomCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoomPayload>
          }
          createMany: {
            args: Prisma.RoomCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RoomCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoomPayload>[]
          }
          delete: {
            args: Prisma.RoomDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoomPayload>
          }
          update: {
            args: Prisma.RoomUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoomPayload>
          }
          deleteMany: {
            args: Prisma.RoomDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RoomUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.RoomUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoomPayload>
          }
          aggregate: {
            args: Prisma.RoomAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRoom>
          }
          groupBy: {
            args: Prisma.RoomGroupByArgs<ExtArgs>
            result: $Utils.Optional<RoomGroupByOutputType>[]
          }
          count: {
            args: Prisma.RoomCountArgs<ExtArgs>
            result: $Utils.Optional<RoomCountAggregateOutputType> | number
          }
        }
      }
      RoomAssignment: {
        payload: Prisma.$RoomAssignmentPayload<ExtArgs>
        fields: Prisma.RoomAssignmentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RoomAssignmentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoomAssignmentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RoomAssignmentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoomAssignmentPayload>
          }
          findFirst: {
            args: Prisma.RoomAssignmentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoomAssignmentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RoomAssignmentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoomAssignmentPayload>
          }
          findMany: {
            args: Prisma.RoomAssignmentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoomAssignmentPayload>[]
          }
          create: {
            args: Prisma.RoomAssignmentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoomAssignmentPayload>
          }
          createMany: {
            args: Prisma.RoomAssignmentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RoomAssignmentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoomAssignmentPayload>[]
          }
          delete: {
            args: Prisma.RoomAssignmentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoomAssignmentPayload>
          }
          update: {
            args: Prisma.RoomAssignmentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoomAssignmentPayload>
          }
          deleteMany: {
            args: Prisma.RoomAssignmentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RoomAssignmentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.RoomAssignmentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoomAssignmentPayload>
          }
          aggregate: {
            args: Prisma.RoomAssignmentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRoomAssignment>
          }
          groupBy: {
            args: Prisma.RoomAssignmentGroupByArgs<ExtArgs>
            result: $Utils.Optional<RoomAssignmentGroupByOutputType>[]
          }
          count: {
            args: Prisma.RoomAssignmentCountArgs<ExtArgs>
            result: $Utils.Optional<RoomAssignmentCountAggregateOutputType> | number
          }
        }
      }
      MaintenanceTicket: {
        payload: Prisma.$MaintenanceTicketPayload<ExtArgs>
        fields: Prisma.MaintenanceTicketFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MaintenanceTicketFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaintenanceTicketPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MaintenanceTicketFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaintenanceTicketPayload>
          }
          findFirst: {
            args: Prisma.MaintenanceTicketFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaintenanceTicketPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MaintenanceTicketFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaintenanceTicketPayload>
          }
          findMany: {
            args: Prisma.MaintenanceTicketFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaintenanceTicketPayload>[]
          }
          create: {
            args: Prisma.MaintenanceTicketCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaintenanceTicketPayload>
          }
          createMany: {
            args: Prisma.MaintenanceTicketCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MaintenanceTicketCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaintenanceTicketPayload>[]
          }
          delete: {
            args: Prisma.MaintenanceTicketDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaintenanceTicketPayload>
          }
          update: {
            args: Prisma.MaintenanceTicketUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaintenanceTicketPayload>
          }
          deleteMany: {
            args: Prisma.MaintenanceTicketDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MaintenanceTicketUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.MaintenanceTicketUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaintenanceTicketPayload>
          }
          aggregate: {
            args: Prisma.MaintenanceTicketAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMaintenanceTicket>
          }
          groupBy: {
            args: Prisma.MaintenanceTicketGroupByArgs<ExtArgs>
            result: $Utils.Optional<MaintenanceTicketGroupByOutputType>[]
          }
          count: {
            args: Prisma.MaintenanceTicketCountArgs<ExtArgs>
            result: $Utils.Optional<MaintenanceTicketCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
  }


  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type TenantCountOutputType
   */

  export type TenantCountOutputType = {
    users: number
    santri: number
    wali: number
    izin: number
    catatanHarian: number
    pengumuman: number
    invoices: number
    pelanggaran: number
    pembinaan: number
    kunjungan: number
    healthRecords: number
    auditLogs: number
    notifications: number
    webhookEvents: number
    tahfidz: number
    mutabaah: number
    wallets: number
    employees: number
    payrolls: number
    academicScheds: number
    attendances: number
    grades: number
    ppdbRegistrations: number
    ppdbDocuments: number
    ppdbExams: number
    inventoryItems: number
    inventoryTransactions: number
    suppliers: number
    purchaseOrders: number
    buildings: number
    rooms: number
    roomAssignments: number
    maintenanceTickets: number
  }

  export type TenantCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | TenantCountOutputTypeCountUsersArgs
    santri?: boolean | TenantCountOutputTypeCountSantriArgs
    wali?: boolean | TenantCountOutputTypeCountWaliArgs
    izin?: boolean | TenantCountOutputTypeCountIzinArgs
    catatanHarian?: boolean | TenantCountOutputTypeCountCatatanHarianArgs
    pengumuman?: boolean | TenantCountOutputTypeCountPengumumanArgs
    invoices?: boolean | TenantCountOutputTypeCountInvoicesArgs
    pelanggaran?: boolean | TenantCountOutputTypeCountPelanggaranArgs
    pembinaan?: boolean | TenantCountOutputTypeCountPembinaanArgs
    kunjungan?: boolean | TenantCountOutputTypeCountKunjunganArgs
    healthRecords?: boolean | TenantCountOutputTypeCountHealthRecordsArgs
    auditLogs?: boolean | TenantCountOutputTypeCountAuditLogsArgs
    notifications?: boolean | TenantCountOutputTypeCountNotificationsArgs
    webhookEvents?: boolean | TenantCountOutputTypeCountWebhookEventsArgs
    tahfidz?: boolean | TenantCountOutputTypeCountTahfidzArgs
    mutabaah?: boolean | TenantCountOutputTypeCountMutabaahArgs
    wallets?: boolean | TenantCountOutputTypeCountWalletsArgs
    employees?: boolean | TenantCountOutputTypeCountEmployeesArgs
    payrolls?: boolean | TenantCountOutputTypeCountPayrollsArgs
    academicScheds?: boolean | TenantCountOutputTypeCountAcademicSchedsArgs
    attendances?: boolean | TenantCountOutputTypeCountAttendancesArgs
    grades?: boolean | TenantCountOutputTypeCountGradesArgs
    ppdbRegistrations?: boolean | TenantCountOutputTypeCountPpdbRegistrationsArgs
    ppdbDocuments?: boolean | TenantCountOutputTypeCountPpdbDocumentsArgs
    ppdbExams?: boolean | TenantCountOutputTypeCountPpdbExamsArgs
    inventoryItems?: boolean | TenantCountOutputTypeCountInventoryItemsArgs
    inventoryTransactions?: boolean | TenantCountOutputTypeCountInventoryTransactionsArgs
    suppliers?: boolean | TenantCountOutputTypeCountSuppliersArgs
    purchaseOrders?: boolean | TenantCountOutputTypeCountPurchaseOrdersArgs
    buildings?: boolean | TenantCountOutputTypeCountBuildingsArgs
    rooms?: boolean | TenantCountOutputTypeCountRoomsArgs
    roomAssignments?: boolean | TenantCountOutputTypeCountRoomAssignmentsArgs
    maintenanceTickets?: boolean | TenantCountOutputTypeCountMaintenanceTicketsArgs
  }

  // Custom InputTypes
  /**
   * TenantCountOutputType without action
   */
  export type TenantCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TenantCountOutputType
     */
    select?: TenantCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TenantCountOutputType without action
   */
  export type TenantCountOutputTypeCountUsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
  }

  /**
   * TenantCountOutputType without action
   */
  export type TenantCountOutputTypeCountSantriArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SantriWhereInput
  }

  /**
   * TenantCountOutputType without action
   */
  export type TenantCountOutputTypeCountWaliArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WaliWhereInput
  }

  /**
   * TenantCountOutputType without action
   */
  export type TenantCountOutputTypeCountIzinArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: IzinWhereInput
  }

  /**
   * TenantCountOutputType without action
   */
  export type TenantCountOutputTypeCountCatatanHarianArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CatatanHarianWhereInput
  }

  /**
   * TenantCountOutputType without action
   */
  export type TenantCountOutputTypeCountPengumumanArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PengumumanWhereInput
  }

  /**
   * TenantCountOutputType without action
   */
  export type TenantCountOutputTypeCountInvoicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InvoiceWhereInput
  }

  /**
   * TenantCountOutputType without action
   */
  export type TenantCountOutputTypeCountPelanggaranArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PelanggaranWhereInput
  }

  /**
   * TenantCountOutputType without action
   */
  export type TenantCountOutputTypeCountPembinaanArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PembinaanWhereInput
  }

  /**
   * TenantCountOutputType without action
   */
  export type TenantCountOutputTypeCountKunjunganArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: KunjunganWhereInput
  }

  /**
   * TenantCountOutputType without action
   */
  export type TenantCountOutputTypeCountHealthRecordsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: HealthRecordWhereInput
  }

  /**
   * TenantCountOutputType without action
   */
  export type TenantCountOutputTypeCountAuditLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AuditLogWhereInput
  }

  /**
   * TenantCountOutputType without action
   */
  export type TenantCountOutputTypeCountNotificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationWhereInput
  }

  /**
   * TenantCountOutputType without action
   */
  export type TenantCountOutputTypeCountWebhookEventsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WebhookEventWhereInput
  }

  /**
   * TenantCountOutputType without action
   */
  export type TenantCountOutputTypeCountTahfidzArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TahfidzWhereInput
  }

  /**
   * TenantCountOutputType without action
   */
  export type TenantCountOutputTypeCountMutabaahArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MutabaahWhereInput
  }

  /**
   * TenantCountOutputType without action
   */
  export type TenantCountOutputTypeCountWalletsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WalletWhereInput
  }

  /**
   * TenantCountOutputType without action
   */
  export type TenantCountOutputTypeCountEmployeesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmployeeWhereInput
  }

  /**
   * TenantCountOutputType without action
   */
  export type TenantCountOutputTypeCountPayrollsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PayrollWhereInput
  }

  /**
   * TenantCountOutputType without action
   */
  export type TenantCountOutputTypeCountAcademicSchedsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AcademicScheduleWhereInput
  }

  /**
   * TenantCountOutputType without action
   */
  export type TenantCountOutputTypeCountAttendancesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AttendanceWhereInput
  }

  /**
   * TenantCountOutputType without action
   */
  export type TenantCountOutputTypeCountGradesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GradeWhereInput
  }

  /**
   * TenantCountOutputType without action
   */
  export type TenantCountOutputTypeCountPpdbRegistrationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PpdbRegistrationWhereInput
  }

  /**
   * TenantCountOutputType without action
   */
  export type TenantCountOutputTypeCountPpdbDocumentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PpdbDocumentWhereInput
  }

  /**
   * TenantCountOutputType without action
   */
  export type TenantCountOutputTypeCountPpdbExamsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PpdbExamWhereInput
  }

  /**
   * TenantCountOutputType without action
   */
  export type TenantCountOutputTypeCountInventoryItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ItemWhereInput
  }

  /**
   * TenantCountOutputType without action
   */
  export type TenantCountOutputTypeCountInventoryTransactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InventoryTransactionWhereInput
  }

  /**
   * TenantCountOutputType without action
   */
  export type TenantCountOutputTypeCountSuppliersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SupplierWhereInput
  }

  /**
   * TenantCountOutputType without action
   */
  export type TenantCountOutputTypeCountPurchaseOrdersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PurchaseOrderWhereInput
  }

  /**
   * TenantCountOutputType without action
   */
  export type TenantCountOutputTypeCountBuildingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BuildingWhereInput
  }

  /**
   * TenantCountOutputType without action
   */
  export type TenantCountOutputTypeCountRoomsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RoomWhereInput
  }

  /**
   * TenantCountOutputType without action
   */
  export type TenantCountOutputTypeCountRoomAssignmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RoomAssignmentWhereInput
  }

  /**
   * TenantCountOutputType without action
   */
  export type TenantCountOutputTypeCountMaintenanceTicketsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MaintenanceTicketWhereInput
  }


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    refreshTokens: number
    auditLogs: number
    notifications: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    refreshTokens?: boolean | UserCountOutputTypeCountRefreshTokensArgs
    auditLogs?: boolean | UserCountOutputTypeCountAuditLogsArgs
    notifications?: boolean | UserCountOutputTypeCountNotificationsArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountRefreshTokensArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RefreshTokenWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAuditLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AuditLogWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountNotificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationWhereInput
  }


  /**
   * Count Type SantriCountOutputType
   */

  export type SantriCountOutputType = {
    walis: number
    izin: number
    catatanHarian: number
    invoices: number
    pelanggaran: number
    pembinaan: number
    kunjungan: number
    healthRecords: number
    medications: number
    tahfidz: number
    mutabaah: number
    attendances: number
    grades: number
  }

  export type SantriCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    walis?: boolean | SantriCountOutputTypeCountWalisArgs
    izin?: boolean | SantriCountOutputTypeCountIzinArgs
    catatanHarian?: boolean | SantriCountOutputTypeCountCatatanHarianArgs
    invoices?: boolean | SantriCountOutputTypeCountInvoicesArgs
    pelanggaran?: boolean | SantriCountOutputTypeCountPelanggaranArgs
    pembinaan?: boolean | SantriCountOutputTypeCountPembinaanArgs
    kunjungan?: boolean | SantriCountOutputTypeCountKunjunganArgs
    healthRecords?: boolean | SantriCountOutputTypeCountHealthRecordsArgs
    medications?: boolean | SantriCountOutputTypeCountMedicationsArgs
    tahfidz?: boolean | SantriCountOutputTypeCountTahfidzArgs
    mutabaah?: boolean | SantriCountOutputTypeCountMutabaahArgs
    attendances?: boolean | SantriCountOutputTypeCountAttendancesArgs
    grades?: boolean | SantriCountOutputTypeCountGradesArgs
  }

  // Custom InputTypes
  /**
   * SantriCountOutputType without action
   */
  export type SantriCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SantriCountOutputType
     */
    select?: SantriCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * SantriCountOutputType without action
   */
  export type SantriCountOutputTypeCountWalisArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SantriWaliWhereInput
  }

  /**
   * SantriCountOutputType without action
   */
  export type SantriCountOutputTypeCountIzinArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: IzinWhereInput
  }

  /**
   * SantriCountOutputType without action
   */
  export type SantriCountOutputTypeCountCatatanHarianArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CatatanHarianWhereInput
  }

  /**
   * SantriCountOutputType without action
   */
  export type SantriCountOutputTypeCountInvoicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InvoiceWhereInput
  }

  /**
   * SantriCountOutputType without action
   */
  export type SantriCountOutputTypeCountPelanggaranArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PelanggaranWhereInput
  }

  /**
   * SantriCountOutputType without action
   */
  export type SantriCountOutputTypeCountPembinaanArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PembinaanWhereInput
  }

  /**
   * SantriCountOutputType without action
   */
  export type SantriCountOutputTypeCountKunjunganArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: KunjunganWhereInput
  }

  /**
   * SantriCountOutputType without action
   */
  export type SantriCountOutputTypeCountHealthRecordsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: HealthRecordWhereInput
  }

  /**
   * SantriCountOutputType without action
   */
  export type SantriCountOutputTypeCountMedicationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MedicationWhereInput
  }

  /**
   * SantriCountOutputType without action
   */
  export type SantriCountOutputTypeCountTahfidzArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TahfidzWhereInput
  }

  /**
   * SantriCountOutputType without action
   */
  export type SantriCountOutputTypeCountMutabaahArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MutabaahWhereInput
  }

  /**
   * SantriCountOutputType without action
   */
  export type SantriCountOutputTypeCountAttendancesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AttendanceWhereInput
  }

  /**
   * SantriCountOutputType without action
   */
  export type SantriCountOutputTypeCountGradesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GradeWhereInput
  }


  /**
   * Count Type WaliCountOutputType
   */

  export type WaliCountOutputType = {
    santris: number
  }

  export type WaliCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    santris?: boolean | WaliCountOutputTypeCountSantrisArgs
  }

  // Custom InputTypes
  /**
   * WaliCountOutputType without action
   */
  export type WaliCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WaliCountOutputType
     */
    select?: WaliCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * WaliCountOutputType without action
   */
  export type WaliCountOutputTypeCountSantrisArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SantriWaliWhereInput
  }


  /**
   * Count Type InvoiceCountOutputType
   */

  export type InvoiceCountOutputType = {
    lines: number
    payments: number
  }

  export type InvoiceCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    lines?: boolean | InvoiceCountOutputTypeCountLinesArgs
    payments?: boolean | InvoiceCountOutputTypeCountPaymentsArgs
  }

  // Custom InputTypes
  /**
   * InvoiceCountOutputType without action
   */
  export type InvoiceCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceCountOutputType
     */
    select?: InvoiceCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * InvoiceCountOutputType without action
   */
  export type InvoiceCountOutputTypeCountLinesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InvoiceLineWhereInput
  }

  /**
   * InvoiceCountOutputType without action
   */
  export type InvoiceCountOutputTypeCountPaymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PaymentWhereInput
  }


  /**
   * Count Type KunjunganCountOutputType
   */

  export type KunjunganCountOutputType = {
    tamu: number
  }

  export type KunjunganCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tamu?: boolean | KunjunganCountOutputTypeCountTamuArgs
  }

  // Custom InputTypes
  /**
   * KunjunganCountOutputType without action
   */
  export type KunjunganCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KunjunganCountOutputType
     */
    select?: KunjunganCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * KunjunganCountOutputType without action
   */
  export type KunjunganCountOutputTypeCountTamuArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TamuWhereInput
  }


  /**
   * Count Type WalletCountOutputType
   */

  export type WalletCountOutputType = {
    transactions: number
  }

  export type WalletCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    transactions?: boolean | WalletCountOutputTypeCountTransactionsArgs
  }

  // Custom InputTypes
  /**
   * WalletCountOutputType without action
   */
  export type WalletCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WalletCountOutputType
     */
    select?: WalletCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * WalletCountOutputType without action
   */
  export type WalletCountOutputTypeCountTransactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WalletTransactionWhereInput
  }


  /**
   * Count Type EmployeeCountOutputType
   */

  export type EmployeeCountOutputType = {
    payrolls: number
  }

  export type EmployeeCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    payrolls?: boolean | EmployeeCountOutputTypeCountPayrollsArgs
  }

  // Custom InputTypes
  /**
   * EmployeeCountOutputType without action
   */
  export type EmployeeCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeCountOutputType
     */
    select?: EmployeeCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * EmployeeCountOutputType without action
   */
  export type EmployeeCountOutputTypeCountPayrollsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PayrollWhereInput
  }


  /**
   * Count Type PpdbRegistrationCountOutputType
   */

  export type PpdbRegistrationCountOutputType = {
    documents: number
    exams: number
  }

  export type PpdbRegistrationCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    documents?: boolean | PpdbRegistrationCountOutputTypeCountDocumentsArgs
    exams?: boolean | PpdbRegistrationCountOutputTypeCountExamsArgs
  }

  // Custom InputTypes
  /**
   * PpdbRegistrationCountOutputType without action
   */
  export type PpdbRegistrationCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PpdbRegistrationCountOutputType
     */
    select?: PpdbRegistrationCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PpdbRegistrationCountOutputType without action
   */
  export type PpdbRegistrationCountOutputTypeCountDocumentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PpdbDocumentWhereInput
  }

  /**
   * PpdbRegistrationCountOutputType without action
   */
  export type PpdbRegistrationCountOutputTypeCountExamsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PpdbExamWhereInput
  }


  /**
   * Count Type ItemCountOutputType
   */

  export type ItemCountOutputType = {
    transactions: number
  }

  export type ItemCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    transactions?: boolean | ItemCountOutputTypeCountTransactionsArgs
  }

  // Custom InputTypes
  /**
   * ItemCountOutputType without action
   */
  export type ItemCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ItemCountOutputType
     */
    select?: ItemCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ItemCountOutputType without action
   */
  export type ItemCountOutputTypeCountTransactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InventoryTransactionWhereInput
  }


  /**
   * Count Type SupplierCountOutputType
   */

  export type SupplierCountOutputType = {
    purchaseOrders: number
  }

  export type SupplierCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    purchaseOrders?: boolean | SupplierCountOutputTypeCountPurchaseOrdersArgs
  }

  // Custom InputTypes
  /**
   * SupplierCountOutputType without action
   */
  export type SupplierCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupplierCountOutputType
     */
    select?: SupplierCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * SupplierCountOutputType without action
   */
  export type SupplierCountOutputTypeCountPurchaseOrdersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PurchaseOrderWhereInput
  }


  /**
   * Count Type BuildingCountOutputType
   */

  export type BuildingCountOutputType = {
    rooms: number
  }

  export type BuildingCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    rooms?: boolean | BuildingCountOutputTypeCountRoomsArgs
  }

  // Custom InputTypes
  /**
   * BuildingCountOutputType without action
   */
  export type BuildingCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BuildingCountOutputType
     */
    select?: BuildingCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * BuildingCountOutputType without action
   */
  export type BuildingCountOutputTypeCountRoomsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RoomWhereInput
  }


  /**
   * Count Type RoomCountOutputType
   */

  export type RoomCountOutputType = {
    assignments: number
    tickets: number
  }

  export type RoomCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    assignments?: boolean | RoomCountOutputTypeCountAssignmentsArgs
    tickets?: boolean | RoomCountOutputTypeCountTicketsArgs
  }

  // Custom InputTypes
  /**
   * RoomCountOutputType without action
   */
  export type RoomCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoomCountOutputType
     */
    select?: RoomCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * RoomCountOutputType without action
   */
  export type RoomCountOutputTypeCountAssignmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RoomAssignmentWhereInput
  }

  /**
   * RoomCountOutputType without action
   */
  export type RoomCountOutputTypeCountTicketsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MaintenanceTicketWhereInput
  }


  /**
   * Models
   */

  /**
   * Model Tenant
   */

  export type AggregateTenant = {
    _count: TenantCountAggregateOutputType | null
    _min: TenantMinAggregateOutputType | null
    _max: TenantMaxAggregateOutputType | null
  }

  export type TenantMinAggregateOutputType = {
    id: string | null
    name: string | null
    address: string | null
    phone: string | null
    adminUserId: string | null
    timezone: string | null
    plan: string | null
    billingContact: string | null
    status: string | null
    settings: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TenantMaxAggregateOutputType = {
    id: string | null
    name: string | null
    address: string | null
    phone: string | null
    adminUserId: string | null
    timezone: string | null
    plan: string | null
    billingContact: string | null
    status: string | null
    settings: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TenantCountAggregateOutputType = {
    id: number
    name: number
    address: number
    phone: number
    adminUserId: number
    timezone: number
    plan: number
    billingContact: number
    status: number
    settings: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type TenantMinAggregateInputType = {
    id?: true
    name?: true
    address?: true
    phone?: true
    adminUserId?: true
    timezone?: true
    plan?: true
    billingContact?: true
    status?: true
    settings?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TenantMaxAggregateInputType = {
    id?: true
    name?: true
    address?: true
    phone?: true
    adminUserId?: true
    timezone?: true
    plan?: true
    billingContact?: true
    status?: true
    settings?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TenantCountAggregateInputType = {
    id?: true
    name?: true
    address?: true
    phone?: true
    adminUserId?: true
    timezone?: true
    plan?: true
    billingContact?: true
    status?: true
    settings?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type TenantAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Tenant to aggregate.
     */
    where?: TenantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tenants to fetch.
     */
    orderBy?: TenantOrderByWithRelationInput | TenantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TenantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tenants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tenants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Tenants
    **/
    _count?: true | TenantCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TenantMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TenantMaxAggregateInputType
  }

  export type GetTenantAggregateType<T extends TenantAggregateArgs> = {
        [P in keyof T & keyof AggregateTenant]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTenant[P]>
      : GetScalarType<T[P], AggregateTenant[P]>
  }




  export type TenantGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TenantWhereInput
    orderBy?: TenantOrderByWithAggregationInput | TenantOrderByWithAggregationInput[]
    by: TenantScalarFieldEnum[] | TenantScalarFieldEnum
    having?: TenantScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TenantCountAggregateInputType | true
    _min?: TenantMinAggregateInputType
    _max?: TenantMaxAggregateInputType
  }

  export type TenantGroupByOutputType = {
    id: string
    name: string
    address: string | null
    phone: string | null
    adminUserId: string | null
    timezone: string
    plan: string
    billingContact: string | null
    status: string
    settings: string | null
    createdAt: Date
    updatedAt: Date
    _count: TenantCountAggregateOutputType | null
    _min: TenantMinAggregateOutputType | null
    _max: TenantMaxAggregateOutputType | null
  }

  type GetTenantGroupByPayload<T extends TenantGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TenantGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TenantGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TenantGroupByOutputType[P]>
            : GetScalarType<T[P], TenantGroupByOutputType[P]>
        }
      >
    >


  export type TenantSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    address?: boolean
    phone?: boolean
    adminUserId?: boolean
    timezone?: boolean
    plan?: boolean
    billingContact?: boolean
    status?: boolean
    settings?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    users?: boolean | Tenant$usersArgs<ExtArgs>
    santri?: boolean | Tenant$santriArgs<ExtArgs>
    wali?: boolean | Tenant$waliArgs<ExtArgs>
    izin?: boolean | Tenant$izinArgs<ExtArgs>
    catatanHarian?: boolean | Tenant$catatanHarianArgs<ExtArgs>
    pengumuman?: boolean | Tenant$pengumumanArgs<ExtArgs>
    invoices?: boolean | Tenant$invoicesArgs<ExtArgs>
    pelanggaran?: boolean | Tenant$pelanggaranArgs<ExtArgs>
    pembinaan?: boolean | Tenant$pembinaanArgs<ExtArgs>
    kunjungan?: boolean | Tenant$kunjunganArgs<ExtArgs>
    healthRecords?: boolean | Tenant$healthRecordsArgs<ExtArgs>
    auditLogs?: boolean | Tenant$auditLogsArgs<ExtArgs>
    notifications?: boolean | Tenant$notificationsArgs<ExtArgs>
    webhookEvents?: boolean | Tenant$webhookEventsArgs<ExtArgs>
    tahfidz?: boolean | Tenant$tahfidzArgs<ExtArgs>
    mutabaah?: boolean | Tenant$mutabaahArgs<ExtArgs>
    wallets?: boolean | Tenant$walletsArgs<ExtArgs>
    employees?: boolean | Tenant$employeesArgs<ExtArgs>
    payrolls?: boolean | Tenant$payrollsArgs<ExtArgs>
    academicScheds?: boolean | Tenant$academicSchedsArgs<ExtArgs>
    attendances?: boolean | Tenant$attendancesArgs<ExtArgs>
    grades?: boolean | Tenant$gradesArgs<ExtArgs>
    ppdbRegistrations?: boolean | Tenant$ppdbRegistrationsArgs<ExtArgs>
    ppdbDocuments?: boolean | Tenant$ppdbDocumentsArgs<ExtArgs>
    ppdbExams?: boolean | Tenant$ppdbExamsArgs<ExtArgs>
    inventoryItems?: boolean | Tenant$inventoryItemsArgs<ExtArgs>
    inventoryTransactions?: boolean | Tenant$inventoryTransactionsArgs<ExtArgs>
    suppliers?: boolean | Tenant$suppliersArgs<ExtArgs>
    purchaseOrders?: boolean | Tenant$purchaseOrdersArgs<ExtArgs>
    buildings?: boolean | Tenant$buildingsArgs<ExtArgs>
    rooms?: boolean | Tenant$roomsArgs<ExtArgs>
    roomAssignments?: boolean | Tenant$roomAssignmentsArgs<ExtArgs>
    maintenanceTickets?: boolean | Tenant$maintenanceTicketsArgs<ExtArgs>
    _count?: boolean | TenantCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tenant"]>

  export type TenantSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    address?: boolean
    phone?: boolean
    adminUserId?: boolean
    timezone?: boolean
    plan?: boolean
    billingContact?: boolean
    status?: boolean
    settings?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["tenant"]>

  export type TenantSelectScalar = {
    id?: boolean
    name?: boolean
    address?: boolean
    phone?: boolean
    adminUserId?: boolean
    timezone?: boolean
    plan?: boolean
    billingContact?: boolean
    status?: boolean
    settings?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type TenantInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | Tenant$usersArgs<ExtArgs>
    santri?: boolean | Tenant$santriArgs<ExtArgs>
    wali?: boolean | Tenant$waliArgs<ExtArgs>
    izin?: boolean | Tenant$izinArgs<ExtArgs>
    catatanHarian?: boolean | Tenant$catatanHarianArgs<ExtArgs>
    pengumuman?: boolean | Tenant$pengumumanArgs<ExtArgs>
    invoices?: boolean | Tenant$invoicesArgs<ExtArgs>
    pelanggaran?: boolean | Tenant$pelanggaranArgs<ExtArgs>
    pembinaan?: boolean | Tenant$pembinaanArgs<ExtArgs>
    kunjungan?: boolean | Tenant$kunjunganArgs<ExtArgs>
    healthRecords?: boolean | Tenant$healthRecordsArgs<ExtArgs>
    auditLogs?: boolean | Tenant$auditLogsArgs<ExtArgs>
    notifications?: boolean | Tenant$notificationsArgs<ExtArgs>
    webhookEvents?: boolean | Tenant$webhookEventsArgs<ExtArgs>
    tahfidz?: boolean | Tenant$tahfidzArgs<ExtArgs>
    mutabaah?: boolean | Tenant$mutabaahArgs<ExtArgs>
    wallets?: boolean | Tenant$walletsArgs<ExtArgs>
    employees?: boolean | Tenant$employeesArgs<ExtArgs>
    payrolls?: boolean | Tenant$payrollsArgs<ExtArgs>
    academicScheds?: boolean | Tenant$academicSchedsArgs<ExtArgs>
    attendances?: boolean | Tenant$attendancesArgs<ExtArgs>
    grades?: boolean | Tenant$gradesArgs<ExtArgs>
    ppdbRegistrations?: boolean | Tenant$ppdbRegistrationsArgs<ExtArgs>
    ppdbDocuments?: boolean | Tenant$ppdbDocumentsArgs<ExtArgs>
    ppdbExams?: boolean | Tenant$ppdbExamsArgs<ExtArgs>
    inventoryItems?: boolean | Tenant$inventoryItemsArgs<ExtArgs>
    inventoryTransactions?: boolean | Tenant$inventoryTransactionsArgs<ExtArgs>
    suppliers?: boolean | Tenant$suppliersArgs<ExtArgs>
    purchaseOrders?: boolean | Tenant$purchaseOrdersArgs<ExtArgs>
    buildings?: boolean | Tenant$buildingsArgs<ExtArgs>
    rooms?: boolean | Tenant$roomsArgs<ExtArgs>
    roomAssignments?: boolean | Tenant$roomAssignmentsArgs<ExtArgs>
    maintenanceTickets?: boolean | Tenant$maintenanceTicketsArgs<ExtArgs>
    _count?: boolean | TenantCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type TenantIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $TenantPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Tenant"
    objects: {
      users: Prisma.$UserPayload<ExtArgs>[]
      santri: Prisma.$SantriPayload<ExtArgs>[]
      wali: Prisma.$WaliPayload<ExtArgs>[]
      izin: Prisma.$IzinPayload<ExtArgs>[]
      catatanHarian: Prisma.$CatatanHarianPayload<ExtArgs>[]
      pengumuman: Prisma.$PengumumanPayload<ExtArgs>[]
      invoices: Prisma.$InvoicePayload<ExtArgs>[]
      pelanggaran: Prisma.$PelanggaranPayload<ExtArgs>[]
      pembinaan: Prisma.$PembinaanPayload<ExtArgs>[]
      kunjungan: Prisma.$KunjunganPayload<ExtArgs>[]
      healthRecords: Prisma.$HealthRecordPayload<ExtArgs>[]
      auditLogs: Prisma.$AuditLogPayload<ExtArgs>[]
      notifications: Prisma.$NotificationPayload<ExtArgs>[]
      webhookEvents: Prisma.$WebhookEventPayload<ExtArgs>[]
      tahfidz: Prisma.$TahfidzPayload<ExtArgs>[]
      mutabaah: Prisma.$MutabaahPayload<ExtArgs>[]
      wallets: Prisma.$WalletPayload<ExtArgs>[]
      employees: Prisma.$EmployeePayload<ExtArgs>[]
      payrolls: Prisma.$PayrollPayload<ExtArgs>[]
      academicScheds: Prisma.$AcademicSchedulePayload<ExtArgs>[]
      attendances: Prisma.$AttendancePayload<ExtArgs>[]
      grades: Prisma.$GradePayload<ExtArgs>[]
      ppdbRegistrations: Prisma.$PpdbRegistrationPayload<ExtArgs>[]
      ppdbDocuments: Prisma.$PpdbDocumentPayload<ExtArgs>[]
      ppdbExams: Prisma.$PpdbExamPayload<ExtArgs>[]
      inventoryItems: Prisma.$ItemPayload<ExtArgs>[]
      inventoryTransactions: Prisma.$InventoryTransactionPayload<ExtArgs>[]
      suppliers: Prisma.$SupplierPayload<ExtArgs>[]
      purchaseOrders: Prisma.$PurchaseOrderPayload<ExtArgs>[]
      buildings: Prisma.$BuildingPayload<ExtArgs>[]
      rooms: Prisma.$RoomPayload<ExtArgs>[]
      roomAssignments: Prisma.$RoomAssignmentPayload<ExtArgs>[]
      maintenanceTickets: Prisma.$MaintenanceTicketPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      address: string | null
      phone: string | null
      adminUserId: string | null
      timezone: string
      plan: string
      billingContact: string | null
      status: string
      settings: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["tenant"]>
    composites: {}
  }

  type TenantGetPayload<S extends boolean | null | undefined | TenantDefaultArgs> = $Result.GetResult<Prisma.$TenantPayload, S>

  type TenantCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<TenantFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: TenantCountAggregateInputType | true
    }

  export interface TenantDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Tenant'], meta: { name: 'Tenant' } }
    /**
     * Find zero or one Tenant that matches the filter.
     * @param {TenantFindUniqueArgs} args - Arguments to find a Tenant
     * @example
     * // Get one Tenant
     * const tenant = await prisma.tenant.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TenantFindUniqueArgs>(args: SelectSubset<T, TenantFindUniqueArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Tenant that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {TenantFindUniqueOrThrowArgs} args - Arguments to find a Tenant
     * @example
     * // Get one Tenant
     * const tenant = await prisma.tenant.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TenantFindUniqueOrThrowArgs>(args: SelectSubset<T, TenantFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Tenant that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenantFindFirstArgs} args - Arguments to find a Tenant
     * @example
     * // Get one Tenant
     * const tenant = await prisma.tenant.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TenantFindFirstArgs>(args?: SelectSubset<T, TenantFindFirstArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Tenant that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenantFindFirstOrThrowArgs} args - Arguments to find a Tenant
     * @example
     * // Get one Tenant
     * const tenant = await prisma.tenant.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TenantFindFirstOrThrowArgs>(args?: SelectSubset<T, TenantFindFirstOrThrowArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Tenants that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenantFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Tenants
     * const tenants = await prisma.tenant.findMany()
     * 
     * // Get first 10 Tenants
     * const tenants = await prisma.tenant.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const tenantWithIdOnly = await prisma.tenant.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TenantFindManyArgs>(args?: SelectSubset<T, TenantFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Tenant.
     * @param {TenantCreateArgs} args - Arguments to create a Tenant.
     * @example
     * // Create one Tenant
     * const Tenant = await prisma.tenant.create({
     *   data: {
     *     // ... data to create a Tenant
     *   }
     * })
     * 
     */
    create<T extends TenantCreateArgs>(args: SelectSubset<T, TenantCreateArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Tenants.
     * @param {TenantCreateManyArgs} args - Arguments to create many Tenants.
     * @example
     * // Create many Tenants
     * const tenant = await prisma.tenant.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TenantCreateManyArgs>(args?: SelectSubset<T, TenantCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Tenants and returns the data saved in the database.
     * @param {TenantCreateManyAndReturnArgs} args - Arguments to create many Tenants.
     * @example
     * // Create many Tenants
     * const tenant = await prisma.tenant.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Tenants and only return the `id`
     * const tenantWithIdOnly = await prisma.tenant.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TenantCreateManyAndReturnArgs>(args?: SelectSubset<T, TenantCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Tenant.
     * @param {TenantDeleteArgs} args - Arguments to delete one Tenant.
     * @example
     * // Delete one Tenant
     * const Tenant = await prisma.tenant.delete({
     *   where: {
     *     // ... filter to delete one Tenant
     *   }
     * })
     * 
     */
    delete<T extends TenantDeleteArgs>(args: SelectSubset<T, TenantDeleteArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Tenant.
     * @param {TenantUpdateArgs} args - Arguments to update one Tenant.
     * @example
     * // Update one Tenant
     * const tenant = await prisma.tenant.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TenantUpdateArgs>(args: SelectSubset<T, TenantUpdateArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Tenants.
     * @param {TenantDeleteManyArgs} args - Arguments to filter Tenants to delete.
     * @example
     * // Delete a few Tenants
     * const { count } = await prisma.tenant.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TenantDeleteManyArgs>(args?: SelectSubset<T, TenantDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tenants.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenantUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Tenants
     * const tenant = await prisma.tenant.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TenantUpdateManyArgs>(args: SelectSubset<T, TenantUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Tenant.
     * @param {TenantUpsertArgs} args - Arguments to update or create a Tenant.
     * @example
     * // Update or create a Tenant
     * const tenant = await prisma.tenant.upsert({
     *   create: {
     *     // ... data to create a Tenant
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Tenant we want to update
     *   }
     * })
     */
    upsert<T extends TenantUpsertArgs>(args: SelectSubset<T, TenantUpsertArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Tenants.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenantCountArgs} args - Arguments to filter Tenants to count.
     * @example
     * // Count the number of Tenants
     * const count = await prisma.tenant.count({
     *   where: {
     *     // ... the filter for the Tenants we want to count
     *   }
     * })
    **/
    count<T extends TenantCountArgs>(
      args?: Subset<T, TenantCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TenantCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Tenant.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenantAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TenantAggregateArgs>(args: Subset<T, TenantAggregateArgs>): Prisma.PrismaPromise<GetTenantAggregateType<T>>

    /**
     * Group by Tenant.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenantGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TenantGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TenantGroupByArgs['orderBy'] }
        : { orderBy?: TenantGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TenantGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTenantGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Tenant model
   */
  readonly fields: TenantFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Tenant.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TenantClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    users<T extends Tenant$usersArgs<ExtArgs> = {}>(args?: Subset<T, Tenant$usersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany"> | Null>
    santri<T extends Tenant$santriArgs<ExtArgs> = {}>(args?: Subset<T, Tenant$santriArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SantriPayload<ExtArgs>, T, "findMany"> | Null>
    wali<T extends Tenant$waliArgs<ExtArgs> = {}>(args?: Subset<T, Tenant$waliArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WaliPayload<ExtArgs>, T, "findMany"> | Null>
    izin<T extends Tenant$izinArgs<ExtArgs> = {}>(args?: Subset<T, Tenant$izinArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IzinPayload<ExtArgs>, T, "findMany"> | Null>
    catatanHarian<T extends Tenant$catatanHarianArgs<ExtArgs> = {}>(args?: Subset<T, Tenant$catatanHarianArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CatatanHarianPayload<ExtArgs>, T, "findMany"> | Null>
    pengumuman<T extends Tenant$pengumumanArgs<ExtArgs> = {}>(args?: Subset<T, Tenant$pengumumanArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PengumumanPayload<ExtArgs>, T, "findMany"> | Null>
    invoices<T extends Tenant$invoicesArgs<ExtArgs> = {}>(args?: Subset<T, Tenant$invoicesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findMany"> | Null>
    pelanggaran<T extends Tenant$pelanggaranArgs<ExtArgs> = {}>(args?: Subset<T, Tenant$pelanggaranArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PelanggaranPayload<ExtArgs>, T, "findMany"> | Null>
    pembinaan<T extends Tenant$pembinaanArgs<ExtArgs> = {}>(args?: Subset<T, Tenant$pembinaanArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PembinaanPayload<ExtArgs>, T, "findMany"> | Null>
    kunjungan<T extends Tenant$kunjunganArgs<ExtArgs> = {}>(args?: Subset<T, Tenant$kunjunganArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$KunjunganPayload<ExtArgs>, T, "findMany"> | Null>
    healthRecords<T extends Tenant$healthRecordsArgs<ExtArgs> = {}>(args?: Subset<T, Tenant$healthRecordsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HealthRecordPayload<ExtArgs>, T, "findMany"> | Null>
    auditLogs<T extends Tenant$auditLogsArgs<ExtArgs> = {}>(args?: Subset<T, Tenant$auditLogsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findMany"> | Null>
    notifications<T extends Tenant$notificationsArgs<ExtArgs> = {}>(args?: Subset<T, Tenant$notificationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findMany"> | Null>
    webhookEvents<T extends Tenant$webhookEventsArgs<ExtArgs> = {}>(args?: Subset<T, Tenant$webhookEventsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WebhookEventPayload<ExtArgs>, T, "findMany"> | Null>
    tahfidz<T extends Tenant$tahfidzArgs<ExtArgs> = {}>(args?: Subset<T, Tenant$tahfidzArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TahfidzPayload<ExtArgs>, T, "findMany"> | Null>
    mutabaah<T extends Tenant$mutabaahArgs<ExtArgs> = {}>(args?: Subset<T, Tenant$mutabaahArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MutabaahPayload<ExtArgs>, T, "findMany"> | Null>
    wallets<T extends Tenant$walletsArgs<ExtArgs> = {}>(args?: Subset<T, Tenant$walletsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WalletPayload<ExtArgs>, T, "findMany"> | Null>
    employees<T extends Tenant$employeesArgs<ExtArgs> = {}>(args?: Subset<T, Tenant$employeesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "findMany"> | Null>
    payrolls<T extends Tenant$payrollsArgs<ExtArgs> = {}>(args?: Subset<T, Tenant$payrollsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PayrollPayload<ExtArgs>, T, "findMany"> | Null>
    academicScheds<T extends Tenant$academicSchedsArgs<ExtArgs> = {}>(args?: Subset<T, Tenant$academicSchedsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AcademicSchedulePayload<ExtArgs>, T, "findMany"> | Null>
    attendances<T extends Tenant$attendancesArgs<ExtArgs> = {}>(args?: Subset<T, Tenant$attendancesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AttendancePayload<ExtArgs>, T, "findMany"> | Null>
    grades<T extends Tenant$gradesArgs<ExtArgs> = {}>(args?: Subset<T, Tenant$gradesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GradePayload<ExtArgs>, T, "findMany"> | Null>
    ppdbRegistrations<T extends Tenant$ppdbRegistrationsArgs<ExtArgs> = {}>(args?: Subset<T, Tenant$ppdbRegistrationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PpdbRegistrationPayload<ExtArgs>, T, "findMany"> | Null>
    ppdbDocuments<T extends Tenant$ppdbDocumentsArgs<ExtArgs> = {}>(args?: Subset<T, Tenant$ppdbDocumentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PpdbDocumentPayload<ExtArgs>, T, "findMany"> | Null>
    ppdbExams<T extends Tenant$ppdbExamsArgs<ExtArgs> = {}>(args?: Subset<T, Tenant$ppdbExamsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PpdbExamPayload<ExtArgs>, T, "findMany"> | Null>
    inventoryItems<T extends Tenant$inventoryItemsArgs<ExtArgs> = {}>(args?: Subset<T, Tenant$inventoryItemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ItemPayload<ExtArgs>, T, "findMany"> | Null>
    inventoryTransactions<T extends Tenant$inventoryTransactionsArgs<ExtArgs> = {}>(args?: Subset<T, Tenant$inventoryTransactionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InventoryTransactionPayload<ExtArgs>, T, "findMany"> | Null>
    suppliers<T extends Tenant$suppliersArgs<ExtArgs> = {}>(args?: Subset<T, Tenant$suppliersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SupplierPayload<ExtArgs>, T, "findMany"> | Null>
    purchaseOrders<T extends Tenant$purchaseOrdersArgs<ExtArgs> = {}>(args?: Subset<T, Tenant$purchaseOrdersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PurchaseOrderPayload<ExtArgs>, T, "findMany"> | Null>
    buildings<T extends Tenant$buildingsArgs<ExtArgs> = {}>(args?: Subset<T, Tenant$buildingsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BuildingPayload<ExtArgs>, T, "findMany"> | Null>
    rooms<T extends Tenant$roomsArgs<ExtArgs> = {}>(args?: Subset<T, Tenant$roomsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RoomPayload<ExtArgs>, T, "findMany"> | Null>
    roomAssignments<T extends Tenant$roomAssignmentsArgs<ExtArgs> = {}>(args?: Subset<T, Tenant$roomAssignmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RoomAssignmentPayload<ExtArgs>, T, "findMany"> | Null>
    maintenanceTickets<T extends Tenant$maintenanceTicketsArgs<ExtArgs> = {}>(args?: Subset<T, Tenant$maintenanceTicketsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MaintenanceTicketPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Tenant model
   */ 
  interface TenantFieldRefs {
    readonly id: FieldRef<"Tenant", 'String'>
    readonly name: FieldRef<"Tenant", 'String'>
    readonly address: FieldRef<"Tenant", 'String'>
    readonly phone: FieldRef<"Tenant", 'String'>
    readonly adminUserId: FieldRef<"Tenant", 'String'>
    readonly timezone: FieldRef<"Tenant", 'String'>
    readonly plan: FieldRef<"Tenant", 'String'>
    readonly billingContact: FieldRef<"Tenant", 'String'>
    readonly status: FieldRef<"Tenant", 'String'>
    readonly settings: FieldRef<"Tenant", 'String'>
    readonly createdAt: FieldRef<"Tenant", 'DateTime'>
    readonly updatedAt: FieldRef<"Tenant", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Tenant findUnique
   */
  export type TenantFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tenant
     */
    select?: TenantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantInclude<ExtArgs> | null
    /**
     * Filter, which Tenant to fetch.
     */
    where: TenantWhereUniqueInput
  }

  /**
   * Tenant findUniqueOrThrow
   */
  export type TenantFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tenant
     */
    select?: TenantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantInclude<ExtArgs> | null
    /**
     * Filter, which Tenant to fetch.
     */
    where: TenantWhereUniqueInput
  }

  /**
   * Tenant findFirst
   */
  export type TenantFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tenant
     */
    select?: TenantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantInclude<ExtArgs> | null
    /**
     * Filter, which Tenant to fetch.
     */
    where?: TenantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tenants to fetch.
     */
    orderBy?: TenantOrderByWithRelationInput | TenantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tenants.
     */
    cursor?: TenantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tenants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tenants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tenants.
     */
    distinct?: TenantScalarFieldEnum | TenantScalarFieldEnum[]
  }

  /**
   * Tenant findFirstOrThrow
   */
  export type TenantFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tenant
     */
    select?: TenantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantInclude<ExtArgs> | null
    /**
     * Filter, which Tenant to fetch.
     */
    where?: TenantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tenants to fetch.
     */
    orderBy?: TenantOrderByWithRelationInput | TenantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tenants.
     */
    cursor?: TenantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tenants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tenants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tenants.
     */
    distinct?: TenantScalarFieldEnum | TenantScalarFieldEnum[]
  }

  /**
   * Tenant findMany
   */
  export type TenantFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tenant
     */
    select?: TenantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantInclude<ExtArgs> | null
    /**
     * Filter, which Tenants to fetch.
     */
    where?: TenantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tenants to fetch.
     */
    orderBy?: TenantOrderByWithRelationInput | TenantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Tenants.
     */
    cursor?: TenantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tenants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tenants.
     */
    skip?: number
    distinct?: TenantScalarFieldEnum | TenantScalarFieldEnum[]
  }

  /**
   * Tenant create
   */
  export type TenantCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tenant
     */
    select?: TenantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantInclude<ExtArgs> | null
    /**
     * The data needed to create a Tenant.
     */
    data: XOR<TenantCreateInput, TenantUncheckedCreateInput>
  }

  /**
   * Tenant createMany
   */
  export type TenantCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Tenants.
     */
    data: TenantCreateManyInput | TenantCreateManyInput[]
  }

  /**
   * Tenant createManyAndReturn
   */
  export type TenantCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tenant
     */
    select?: TenantSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Tenants.
     */
    data: TenantCreateManyInput | TenantCreateManyInput[]
  }

  /**
   * Tenant update
   */
  export type TenantUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tenant
     */
    select?: TenantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantInclude<ExtArgs> | null
    /**
     * The data needed to update a Tenant.
     */
    data: XOR<TenantUpdateInput, TenantUncheckedUpdateInput>
    /**
     * Choose, which Tenant to update.
     */
    where: TenantWhereUniqueInput
  }

  /**
   * Tenant updateMany
   */
  export type TenantUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Tenants.
     */
    data: XOR<TenantUpdateManyMutationInput, TenantUncheckedUpdateManyInput>
    /**
     * Filter which Tenants to update
     */
    where?: TenantWhereInput
  }

  /**
   * Tenant upsert
   */
  export type TenantUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tenant
     */
    select?: TenantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantInclude<ExtArgs> | null
    /**
     * The filter to search for the Tenant to update in case it exists.
     */
    where: TenantWhereUniqueInput
    /**
     * In case the Tenant found by the `where` argument doesn't exist, create a new Tenant with this data.
     */
    create: XOR<TenantCreateInput, TenantUncheckedCreateInput>
    /**
     * In case the Tenant was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TenantUpdateInput, TenantUncheckedUpdateInput>
  }

  /**
   * Tenant delete
   */
  export type TenantDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tenant
     */
    select?: TenantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantInclude<ExtArgs> | null
    /**
     * Filter which Tenant to delete.
     */
    where: TenantWhereUniqueInput
  }

  /**
   * Tenant deleteMany
   */
  export type TenantDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Tenants to delete
     */
    where?: TenantWhereInput
  }

  /**
   * Tenant.users
   */
  export type Tenant$usersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    cursor?: UserWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * Tenant.santri
   */
  export type Tenant$santriArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Santri
     */
    select?: SantriSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SantriInclude<ExtArgs> | null
    where?: SantriWhereInput
    orderBy?: SantriOrderByWithRelationInput | SantriOrderByWithRelationInput[]
    cursor?: SantriWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SantriScalarFieldEnum | SantriScalarFieldEnum[]
  }

  /**
   * Tenant.wali
   */
  export type Tenant$waliArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Wali
     */
    select?: WaliSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WaliInclude<ExtArgs> | null
    where?: WaliWhereInput
    orderBy?: WaliOrderByWithRelationInput | WaliOrderByWithRelationInput[]
    cursor?: WaliWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WaliScalarFieldEnum | WaliScalarFieldEnum[]
  }

  /**
   * Tenant.izin
   */
  export type Tenant$izinArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Izin
     */
    select?: IzinSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IzinInclude<ExtArgs> | null
    where?: IzinWhereInput
    orderBy?: IzinOrderByWithRelationInput | IzinOrderByWithRelationInput[]
    cursor?: IzinWhereUniqueInput
    take?: number
    skip?: number
    distinct?: IzinScalarFieldEnum | IzinScalarFieldEnum[]
  }

  /**
   * Tenant.catatanHarian
   */
  export type Tenant$catatanHarianArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CatatanHarian
     */
    select?: CatatanHarianSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CatatanHarianInclude<ExtArgs> | null
    where?: CatatanHarianWhereInput
    orderBy?: CatatanHarianOrderByWithRelationInput | CatatanHarianOrderByWithRelationInput[]
    cursor?: CatatanHarianWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CatatanHarianScalarFieldEnum | CatatanHarianScalarFieldEnum[]
  }

  /**
   * Tenant.pengumuman
   */
  export type Tenant$pengumumanArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pengumuman
     */
    select?: PengumumanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PengumumanInclude<ExtArgs> | null
    where?: PengumumanWhereInput
    orderBy?: PengumumanOrderByWithRelationInput | PengumumanOrderByWithRelationInput[]
    cursor?: PengumumanWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PengumumanScalarFieldEnum | PengumumanScalarFieldEnum[]
  }

  /**
   * Tenant.invoices
   */
  export type Tenant$invoicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    where?: InvoiceWhereInput
    orderBy?: InvoiceOrderByWithRelationInput | InvoiceOrderByWithRelationInput[]
    cursor?: InvoiceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InvoiceScalarFieldEnum | InvoiceScalarFieldEnum[]
  }

  /**
   * Tenant.pelanggaran
   */
  export type Tenant$pelanggaranArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pelanggaran
     */
    select?: PelanggaranSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PelanggaranInclude<ExtArgs> | null
    where?: PelanggaranWhereInput
    orderBy?: PelanggaranOrderByWithRelationInput | PelanggaranOrderByWithRelationInput[]
    cursor?: PelanggaranWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PelanggaranScalarFieldEnum | PelanggaranScalarFieldEnum[]
  }

  /**
   * Tenant.pembinaan
   */
  export type Tenant$pembinaanArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pembinaan
     */
    select?: PembinaanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PembinaanInclude<ExtArgs> | null
    where?: PembinaanWhereInput
    orderBy?: PembinaanOrderByWithRelationInput | PembinaanOrderByWithRelationInput[]
    cursor?: PembinaanWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PembinaanScalarFieldEnum | PembinaanScalarFieldEnum[]
  }

  /**
   * Tenant.kunjungan
   */
  export type Tenant$kunjunganArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Kunjungan
     */
    select?: KunjunganSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KunjunganInclude<ExtArgs> | null
    where?: KunjunganWhereInput
    orderBy?: KunjunganOrderByWithRelationInput | KunjunganOrderByWithRelationInput[]
    cursor?: KunjunganWhereUniqueInput
    take?: number
    skip?: number
    distinct?: KunjunganScalarFieldEnum | KunjunganScalarFieldEnum[]
  }

  /**
   * Tenant.healthRecords
   */
  export type Tenant$healthRecordsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HealthRecord
     */
    select?: HealthRecordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HealthRecordInclude<ExtArgs> | null
    where?: HealthRecordWhereInput
    orderBy?: HealthRecordOrderByWithRelationInput | HealthRecordOrderByWithRelationInput[]
    cursor?: HealthRecordWhereUniqueInput
    take?: number
    skip?: number
    distinct?: HealthRecordScalarFieldEnum | HealthRecordScalarFieldEnum[]
  }

  /**
   * Tenant.auditLogs
   */
  export type Tenant$auditLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    where?: AuditLogWhereInput
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    cursor?: AuditLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * Tenant.notifications
   */
  export type Tenant$notificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    where?: NotificationWhereInput
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    cursor?: NotificationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Tenant.webhookEvents
   */
  export type Tenant$webhookEventsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WebhookEvent
     */
    select?: WebhookEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WebhookEventInclude<ExtArgs> | null
    where?: WebhookEventWhereInput
    orderBy?: WebhookEventOrderByWithRelationInput | WebhookEventOrderByWithRelationInput[]
    cursor?: WebhookEventWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WebhookEventScalarFieldEnum | WebhookEventScalarFieldEnum[]
  }

  /**
   * Tenant.tahfidz
   */
  export type Tenant$tahfidzArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tahfidz
     */
    select?: TahfidzSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TahfidzInclude<ExtArgs> | null
    where?: TahfidzWhereInput
    orderBy?: TahfidzOrderByWithRelationInput | TahfidzOrderByWithRelationInput[]
    cursor?: TahfidzWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TahfidzScalarFieldEnum | TahfidzScalarFieldEnum[]
  }

  /**
   * Tenant.mutabaah
   */
  export type Tenant$mutabaahArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Mutabaah
     */
    select?: MutabaahSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MutabaahInclude<ExtArgs> | null
    where?: MutabaahWhereInput
    orderBy?: MutabaahOrderByWithRelationInput | MutabaahOrderByWithRelationInput[]
    cursor?: MutabaahWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MutabaahScalarFieldEnum | MutabaahScalarFieldEnum[]
  }

  /**
   * Tenant.wallets
   */
  export type Tenant$walletsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Wallet
     */
    select?: WalletSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WalletInclude<ExtArgs> | null
    where?: WalletWhereInput
    orderBy?: WalletOrderByWithRelationInput | WalletOrderByWithRelationInput[]
    cursor?: WalletWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WalletScalarFieldEnum | WalletScalarFieldEnum[]
  }

  /**
   * Tenant.employees
   */
  export type Tenant$employeesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeInclude<ExtArgs> | null
    where?: EmployeeWhereInput
    orderBy?: EmployeeOrderByWithRelationInput | EmployeeOrderByWithRelationInput[]
    cursor?: EmployeeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EmployeeScalarFieldEnum | EmployeeScalarFieldEnum[]
  }

  /**
   * Tenant.payrolls
   */
  export type Tenant$payrollsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payroll
     */
    select?: PayrollSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PayrollInclude<ExtArgs> | null
    where?: PayrollWhereInput
    orderBy?: PayrollOrderByWithRelationInput | PayrollOrderByWithRelationInput[]
    cursor?: PayrollWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PayrollScalarFieldEnum | PayrollScalarFieldEnum[]
  }

  /**
   * Tenant.academicScheds
   */
  export type Tenant$academicSchedsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AcademicSchedule
     */
    select?: AcademicScheduleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AcademicScheduleInclude<ExtArgs> | null
    where?: AcademicScheduleWhereInput
    orderBy?: AcademicScheduleOrderByWithRelationInput | AcademicScheduleOrderByWithRelationInput[]
    cursor?: AcademicScheduleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AcademicScheduleScalarFieldEnum | AcademicScheduleScalarFieldEnum[]
  }

  /**
   * Tenant.attendances
   */
  export type Tenant$attendancesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attendance
     */
    select?: AttendanceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceInclude<ExtArgs> | null
    where?: AttendanceWhereInput
    orderBy?: AttendanceOrderByWithRelationInput | AttendanceOrderByWithRelationInput[]
    cursor?: AttendanceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AttendanceScalarFieldEnum | AttendanceScalarFieldEnum[]
  }

  /**
   * Tenant.grades
   */
  export type Tenant$gradesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Grade
     */
    select?: GradeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GradeInclude<ExtArgs> | null
    where?: GradeWhereInput
    orderBy?: GradeOrderByWithRelationInput | GradeOrderByWithRelationInput[]
    cursor?: GradeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: GradeScalarFieldEnum | GradeScalarFieldEnum[]
  }

  /**
   * Tenant.ppdbRegistrations
   */
  export type Tenant$ppdbRegistrationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PpdbRegistration
     */
    select?: PpdbRegistrationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PpdbRegistrationInclude<ExtArgs> | null
    where?: PpdbRegistrationWhereInput
    orderBy?: PpdbRegistrationOrderByWithRelationInput | PpdbRegistrationOrderByWithRelationInput[]
    cursor?: PpdbRegistrationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PpdbRegistrationScalarFieldEnum | PpdbRegistrationScalarFieldEnum[]
  }

  /**
   * Tenant.ppdbDocuments
   */
  export type Tenant$ppdbDocumentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PpdbDocument
     */
    select?: PpdbDocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PpdbDocumentInclude<ExtArgs> | null
    where?: PpdbDocumentWhereInput
    orderBy?: PpdbDocumentOrderByWithRelationInput | PpdbDocumentOrderByWithRelationInput[]
    cursor?: PpdbDocumentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PpdbDocumentScalarFieldEnum | PpdbDocumentScalarFieldEnum[]
  }

  /**
   * Tenant.ppdbExams
   */
  export type Tenant$ppdbExamsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PpdbExam
     */
    select?: PpdbExamSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PpdbExamInclude<ExtArgs> | null
    where?: PpdbExamWhereInput
    orderBy?: PpdbExamOrderByWithRelationInput | PpdbExamOrderByWithRelationInput[]
    cursor?: PpdbExamWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PpdbExamScalarFieldEnum | PpdbExamScalarFieldEnum[]
  }

  /**
   * Tenant.inventoryItems
   */
  export type Tenant$inventoryItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Item
     */
    select?: ItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemInclude<ExtArgs> | null
    where?: ItemWhereInput
    orderBy?: ItemOrderByWithRelationInput | ItemOrderByWithRelationInput[]
    cursor?: ItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ItemScalarFieldEnum | ItemScalarFieldEnum[]
  }

  /**
   * Tenant.inventoryTransactions
   */
  export type Tenant$inventoryTransactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryTransaction
     */
    select?: InventoryTransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryTransactionInclude<ExtArgs> | null
    where?: InventoryTransactionWhereInput
    orderBy?: InventoryTransactionOrderByWithRelationInput | InventoryTransactionOrderByWithRelationInput[]
    cursor?: InventoryTransactionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InventoryTransactionScalarFieldEnum | InventoryTransactionScalarFieldEnum[]
  }

  /**
   * Tenant.suppliers
   */
  export type Tenant$suppliersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Supplier
     */
    select?: SupplierSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierInclude<ExtArgs> | null
    where?: SupplierWhereInput
    orderBy?: SupplierOrderByWithRelationInput | SupplierOrderByWithRelationInput[]
    cursor?: SupplierWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SupplierScalarFieldEnum | SupplierScalarFieldEnum[]
  }

  /**
   * Tenant.purchaseOrders
   */
  export type Tenant$purchaseOrdersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseOrder
     */
    select?: PurchaseOrderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseOrderInclude<ExtArgs> | null
    where?: PurchaseOrderWhereInput
    orderBy?: PurchaseOrderOrderByWithRelationInput | PurchaseOrderOrderByWithRelationInput[]
    cursor?: PurchaseOrderWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PurchaseOrderScalarFieldEnum | PurchaseOrderScalarFieldEnum[]
  }

  /**
   * Tenant.buildings
   */
  export type Tenant$buildingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Building
     */
    select?: BuildingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BuildingInclude<ExtArgs> | null
    where?: BuildingWhereInput
    orderBy?: BuildingOrderByWithRelationInput | BuildingOrderByWithRelationInput[]
    cursor?: BuildingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BuildingScalarFieldEnum | BuildingScalarFieldEnum[]
  }

  /**
   * Tenant.rooms
   */
  export type Tenant$roomsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Room
     */
    select?: RoomSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoomInclude<ExtArgs> | null
    where?: RoomWhereInput
    orderBy?: RoomOrderByWithRelationInput | RoomOrderByWithRelationInput[]
    cursor?: RoomWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RoomScalarFieldEnum | RoomScalarFieldEnum[]
  }

  /**
   * Tenant.roomAssignments
   */
  export type Tenant$roomAssignmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoomAssignment
     */
    select?: RoomAssignmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoomAssignmentInclude<ExtArgs> | null
    where?: RoomAssignmentWhereInput
    orderBy?: RoomAssignmentOrderByWithRelationInput | RoomAssignmentOrderByWithRelationInput[]
    cursor?: RoomAssignmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RoomAssignmentScalarFieldEnum | RoomAssignmentScalarFieldEnum[]
  }

  /**
   * Tenant.maintenanceTickets
   */
  export type Tenant$maintenanceTicketsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaintenanceTicket
     */
    select?: MaintenanceTicketSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaintenanceTicketInclude<ExtArgs> | null
    where?: MaintenanceTicketWhereInput
    orderBy?: MaintenanceTicketOrderByWithRelationInput | MaintenanceTicketOrderByWithRelationInput[]
    cursor?: MaintenanceTicketWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MaintenanceTicketScalarFieldEnum | MaintenanceTicketScalarFieldEnum[]
  }

  /**
   * Tenant without action
   */
  export type TenantDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tenant
     */
    select?: TenantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantInclude<ExtArgs> | null
  }


  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    tenantId: string | null
    email: string | null
    passwordHash: string | null
    role: string | null
    name: string | null
    phone: string | null
    isActive: boolean | null
    lastLogin: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    tenantId: string | null
    email: string | null
    passwordHash: string | null
    role: string | null
    name: string | null
    phone: string | null
    isActive: boolean | null
    lastLogin: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    tenantId: number
    email: number
    passwordHash: number
    role: number
    name: number
    phone: number
    isActive: number
    lastLogin: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UserMinAggregateInputType = {
    id?: true
    tenantId?: true
    email?: true
    passwordHash?: true
    role?: true
    name?: true
    phone?: true
    isActive?: true
    lastLogin?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    tenantId?: true
    email?: true
    passwordHash?: true
    role?: true
    name?: true
    phone?: true
    isActive?: true
    lastLogin?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    tenantId?: true
    email?: true
    passwordHash?: true
    role?: true
    name?: true
    phone?: true
    isActive?: true
    lastLogin?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: string
    tenantId: string | null
    email: string
    passwordHash: string
    role: string
    name: string
    phone: string | null
    isActive: boolean
    lastLogin: Date | null
    createdAt: Date
    updatedAt: Date
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    email?: boolean
    passwordHash?: boolean
    role?: boolean
    name?: boolean
    phone?: boolean
    isActive?: boolean
    lastLogin?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | User$tenantArgs<ExtArgs>
    refreshTokens?: boolean | User$refreshTokensArgs<ExtArgs>
    auditLogs?: boolean | User$auditLogsArgs<ExtArgs>
    notifications?: boolean | User$notificationsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    email?: boolean
    passwordHash?: boolean
    role?: boolean
    name?: boolean
    phone?: boolean
    isActive?: boolean
    lastLogin?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | User$tenantArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    tenantId?: boolean
    email?: boolean
    passwordHash?: boolean
    role?: boolean
    name?: boolean
    phone?: boolean
    isActive?: boolean
    lastLogin?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | User$tenantArgs<ExtArgs>
    refreshTokens?: boolean | User$refreshTokensArgs<ExtArgs>
    auditLogs?: boolean | User$auditLogsArgs<ExtArgs>
    notifications?: boolean | User$notificationsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | User$tenantArgs<ExtArgs>
  }

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      tenant: Prisma.$TenantPayload<ExtArgs> | null
      refreshTokens: Prisma.$RefreshTokenPayload<ExtArgs>[]
      auditLogs: Prisma.$AuditLogPayload<ExtArgs>[]
      notifications: Prisma.$NotificationPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      tenantId: string | null
      email: string
      passwordHash: string
      role: string
      name: string
      phone: string | null
      isActive: boolean
      lastLogin: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    tenant<T extends User$tenantArgs<ExtArgs> = {}>(args?: Subset<T, User$tenantArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    refreshTokens<T extends User$refreshTokensArgs<ExtArgs> = {}>(args?: Subset<T, User$refreshTokensArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, "findMany"> | Null>
    auditLogs<T extends User$auditLogsArgs<ExtArgs> = {}>(args?: Subset<T, User$auditLogsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findMany"> | Null>
    notifications<T extends User$notificationsArgs<ExtArgs> = {}>(args?: Subset<T, User$notificationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */ 
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'String'>
    readonly tenantId: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly passwordHash: FieldRef<"User", 'String'>
    readonly role: FieldRef<"User", 'String'>
    readonly name: FieldRef<"User", 'String'>
    readonly phone: FieldRef<"User", 'String'>
    readonly isActive: FieldRef<"User", 'Boolean'>
    readonly lastLogin: FieldRef<"User", 'DateTime'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly updatedAt: FieldRef<"User", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
  }

  /**
   * User.tenant
   */
  export type User$tenantArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tenant
     */
    select?: TenantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantInclude<ExtArgs> | null
    where?: TenantWhereInput
  }

  /**
   * User.refreshTokens
   */
  export type User$refreshTokensArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenInclude<ExtArgs> | null
    where?: RefreshTokenWhereInput
    orderBy?: RefreshTokenOrderByWithRelationInput | RefreshTokenOrderByWithRelationInput[]
    cursor?: RefreshTokenWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RefreshTokenScalarFieldEnum | RefreshTokenScalarFieldEnum[]
  }

  /**
   * User.auditLogs
   */
  export type User$auditLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    where?: AuditLogWhereInput
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    cursor?: AuditLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * User.notifications
   */
  export type User$notificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    where?: NotificationWhereInput
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    cursor?: NotificationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model RefreshToken
   */

  export type AggregateRefreshToken = {
    _count: RefreshTokenCountAggregateOutputType | null
    _min: RefreshTokenMinAggregateOutputType | null
    _max: RefreshTokenMaxAggregateOutputType | null
  }

  export type RefreshTokenMinAggregateOutputType = {
    id: string | null
    userId: string | null
    token: string | null
    expiresAt: Date | null
    revoked: boolean | null
    createdAt: Date | null
  }

  export type RefreshTokenMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    token: string | null
    expiresAt: Date | null
    revoked: boolean | null
    createdAt: Date | null
  }

  export type RefreshTokenCountAggregateOutputType = {
    id: number
    userId: number
    token: number
    expiresAt: number
    revoked: number
    createdAt: number
    _all: number
  }


  export type RefreshTokenMinAggregateInputType = {
    id?: true
    userId?: true
    token?: true
    expiresAt?: true
    revoked?: true
    createdAt?: true
  }

  export type RefreshTokenMaxAggregateInputType = {
    id?: true
    userId?: true
    token?: true
    expiresAt?: true
    revoked?: true
    createdAt?: true
  }

  export type RefreshTokenCountAggregateInputType = {
    id?: true
    userId?: true
    token?: true
    expiresAt?: true
    revoked?: true
    createdAt?: true
    _all?: true
  }

  export type RefreshTokenAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RefreshToken to aggregate.
     */
    where?: RefreshTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RefreshTokens to fetch.
     */
    orderBy?: RefreshTokenOrderByWithRelationInput | RefreshTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RefreshTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RefreshTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RefreshTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RefreshTokens
    **/
    _count?: true | RefreshTokenCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RefreshTokenMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RefreshTokenMaxAggregateInputType
  }

  export type GetRefreshTokenAggregateType<T extends RefreshTokenAggregateArgs> = {
        [P in keyof T & keyof AggregateRefreshToken]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRefreshToken[P]>
      : GetScalarType<T[P], AggregateRefreshToken[P]>
  }




  export type RefreshTokenGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RefreshTokenWhereInput
    orderBy?: RefreshTokenOrderByWithAggregationInput | RefreshTokenOrderByWithAggregationInput[]
    by: RefreshTokenScalarFieldEnum[] | RefreshTokenScalarFieldEnum
    having?: RefreshTokenScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RefreshTokenCountAggregateInputType | true
    _min?: RefreshTokenMinAggregateInputType
    _max?: RefreshTokenMaxAggregateInputType
  }

  export type RefreshTokenGroupByOutputType = {
    id: string
    userId: string
    token: string
    expiresAt: Date
    revoked: boolean
    createdAt: Date
    _count: RefreshTokenCountAggregateOutputType | null
    _min: RefreshTokenMinAggregateOutputType | null
    _max: RefreshTokenMaxAggregateOutputType | null
  }

  type GetRefreshTokenGroupByPayload<T extends RefreshTokenGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RefreshTokenGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RefreshTokenGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RefreshTokenGroupByOutputType[P]>
            : GetScalarType<T[P], RefreshTokenGroupByOutputType[P]>
        }
      >
    >


  export type RefreshTokenSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    token?: boolean
    expiresAt?: boolean
    revoked?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["refreshToken"]>

  export type RefreshTokenSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    token?: boolean
    expiresAt?: boolean
    revoked?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["refreshToken"]>

  export type RefreshTokenSelectScalar = {
    id?: boolean
    userId?: boolean
    token?: boolean
    expiresAt?: boolean
    revoked?: boolean
    createdAt?: boolean
  }

  export type RefreshTokenInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type RefreshTokenIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $RefreshTokenPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "RefreshToken"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      token: string
      expiresAt: Date
      revoked: boolean
      createdAt: Date
    }, ExtArgs["result"]["refreshToken"]>
    composites: {}
  }

  type RefreshTokenGetPayload<S extends boolean | null | undefined | RefreshTokenDefaultArgs> = $Result.GetResult<Prisma.$RefreshTokenPayload, S>

  type RefreshTokenCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<RefreshTokenFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: RefreshTokenCountAggregateInputType | true
    }

  export interface RefreshTokenDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['RefreshToken'], meta: { name: 'RefreshToken' } }
    /**
     * Find zero or one RefreshToken that matches the filter.
     * @param {RefreshTokenFindUniqueArgs} args - Arguments to find a RefreshToken
     * @example
     * // Get one RefreshToken
     * const refreshToken = await prisma.refreshToken.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RefreshTokenFindUniqueArgs>(args: SelectSubset<T, RefreshTokenFindUniqueArgs<ExtArgs>>): Prisma__RefreshTokenClient<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one RefreshToken that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {RefreshTokenFindUniqueOrThrowArgs} args - Arguments to find a RefreshToken
     * @example
     * // Get one RefreshToken
     * const refreshToken = await prisma.refreshToken.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RefreshTokenFindUniqueOrThrowArgs>(args: SelectSubset<T, RefreshTokenFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RefreshTokenClient<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first RefreshToken that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RefreshTokenFindFirstArgs} args - Arguments to find a RefreshToken
     * @example
     * // Get one RefreshToken
     * const refreshToken = await prisma.refreshToken.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RefreshTokenFindFirstArgs>(args?: SelectSubset<T, RefreshTokenFindFirstArgs<ExtArgs>>): Prisma__RefreshTokenClient<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first RefreshToken that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RefreshTokenFindFirstOrThrowArgs} args - Arguments to find a RefreshToken
     * @example
     * // Get one RefreshToken
     * const refreshToken = await prisma.refreshToken.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RefreshTokenFindFirstOrThrowArgs>(args?: SelectSubset<T, RefreshTokenFindFirstOrThrowArgs<ExtArgs>>): Prisma__RefreshTokenClient<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more RefreshTokens that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RefreshTokenFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RefreshTokens
     * const refreshTokens = await prisma.refreshToken.findMany()
     * 
     * // Get first 10 RefreshTokens
     * const refreshTokens = await prisma.refreshToken.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const refreshTokenWithIdOnly = await prisma.refreshToken.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RefreshTokenFindManyArgs>(args?: SelectSubset<T, RefreshTokenFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a RefreshToken.
     * @param {RefreshTokenCreateArgs} args - Arguments to create a RefreshToken.
     * @example
     * // Create one RefreshToken
     * const RefreshToken = await prisma.refreshToken.create({
     *   data: {
     *     // ... data to create a RefreshToken
     *   }
     * })
     * 
     */
    create<T extends RefreshTokenCreateArgs>(args: SelectSubset<T, RefreshTokenCreateArgs<ExtArgs>>): Prisma__RefreshTokenClient<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many RefreshTokens.
     * @param {RefreshTokenCreateManyArgs} args - Arguments to create many RefreshTokens.
     * @example
     * // Create many RefreshTokens
     * const refreshToken = await prisma.refreshToken.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RefreshTokenCreateManyArgs>(args?: SelectSubset<T, RefreshTokenCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many RefreshTokens and returns the data saved in the database.
     * @param {RefreshTokenCreateManyAndReturnArgs} args - Arguments to create many RefreshTokens.
     * @example
     * // Create many RefreshTokens
     * const refreshToken = await prisma.refreshToken.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many RefreshTokens and only return the `id`
     * const refreshTokenWithIdOnly = await prisma.refreshToken.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RefreshTokenCreateManyAndReturnArgs>(args?: SelectSubset<T, RefreshTokenCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a RefreshToken.
     * @param {RefreshTokenDeleteArgs} args - Arguments to delete one RefreshToken.
     * @example
     * // Delete one RefreshToken
     * const RefreshToken = await prisma.refreshToken.delete({
     *   where: {
     *     // ... filter to delete one RefreshToken
     *   }
     * })
     * 
     */
    delete<T extends RefreshTokenDeleteArgs>(args: SelectSubset<T, RefreshTokenDeleteArgs<ExtArgs>>): Prisma__RefreshTokenClient<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one RefreshToken.
     * @param {RefreshTokenUpdateArgs} args - Arguments to update one RefreshToken.
     * @example
     * // Update one RefreshToken
     * const refreshToken = await prisma.refreshToken.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RefreshTokenUpdateArgs>(args: SelectSubset<T, RefreshTokenUpdateArgs<ExtArgs>>): Prisma__RefreshTokenClient<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more RefreshTokens.
     * @param {RefreshTokenDeleteManyArgs} args - Arguments to filter RefreshTokens to delete.
     * @example
     * // Delete a few RefreshTokens
     * const { count } = await prisma.refreshToken.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RefreshTokenDeleteManyArgs>(args?: SelectSubset<T, RefreshTokenDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RefreshTokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RefreshTokenUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RefreshTokens
     * const refreshToken = await prisma.refreshToken.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RefreshTokenUpdateManyArgs>(args: SelectSubset<T, RefreshTokenUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one RefreshToken.
     * @param {RefreshTokenUpsertArgs} args - Arguments to update or create a RefreshToken.
     * @example
     * // Update or create a RefreshToken
     * const refreshToken = await prisma.refreshToken.upsert({
     *   create: {
     *     // ... data to create a RefreshToken
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RefreshToken we want to update
     *   }
     * })
     */
    upsert<T extends RefreshTokenUpsertArgs>(args: SelectSubset<T, RefreshTokenUpsertArgs<ExtArgs>>): Prisma__RefreshTokenClient<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of RefreshTokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RefreshTokenCountArgs} args - Arguments to filter RefreshTokens to count.
     * @example
     * // Count the number of RefreshTokens
     * const count = await prisma.refreshToken.count({
     *   where: {
     *     // ... the filter for the RefreshTokens we want to count
     *   }
     * })
    **/
    count<T extends RefreshTokenCountArgs>(
      args?: Subset<T, RefreshTokenCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RefreshTokenCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RefreshToken.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RefreshTokenAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RefreshTokenAggregateArgs>(args: Subset<T, RefreshTokenAggregateArgs>): Prisma.PrismaPromise<GetRefreshTokenAggregateType<T>>

    /**
     * Group by RefreshToken.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RefreshTokenGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RefreshTokenGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RefreshTokenGroupByArgs['orderBy'] }
        : { orderBy?: RefreshTokenGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RefreshTokenGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRefreshTokenGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the RefreshToken model
   */
  readonly fields: RefreshTokenFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RefreshToken.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RefreshTokenClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the RefreshToken model
   */ 
  interface RefreshTokenFieldRefs {
    readonly id: FieldRef<"RefreshToken", 'String'>
    readonly userId: FieldRef<"RefreshToken", 'String'>
    readonly token: FieldRef<"RefreshToken", 'String'>
    readonly expiresAt: FieldRef<"RefreshToken", 'DateTime'>
    readonly revoked: FieldRef<"RefreshToken", 'Boolean'>
    readonly createdAt: FieldRef<"RefreshToken", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * RefreshToken findUnique
   */
  export type RefreshTokenFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenInclude<ExtArgs> | null
    /**
     * Filter, which RefreshToken to fetch.
     */
    where: RefreshTokenWhereUniqueInput
  }

  /**
   * RefreshToken findUniqueOrThrow
   */
  export type RefreshTokenFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenInclude<ExtArgs> | null
    /**
     * Filter, which RefreshToken to fetch.
     */
    where: RefreshTokenWhereUniqueInput
  }

  /**
   * RefreshToken findFirst
   */
  export type RefreshTokenFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenInclude<ExtArgs> | null
    /**
     * Filter, which RefreshToken to fetch.
     */
    where?: RefreshTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RefreshTokens to fetch.
     */
    orderBy?: RefreshTokenOrderByWithRelationInput | RefreshTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RefreshTokens.
     */
    cursor?: RefreshTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RefreshTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RefreshTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RefreshTokens.
     */
    distinct?: RefreshTokenScalarFieldEnum | RefreshTokenScalarFieldEnum[]
  }

  /**
   * RefreshToken findFirstOrThrow
   */
  export type RefreshTokenFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenInclude<ExtArgs> | null
    /**
     * Filter, which RefreshToken to fetch.
     */
    where?: RefreshTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RefreshTokens to fetch.
     */
    orderBy?: RefreshTokenOrderByWithRelationInput | RefreshTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RefreshTokens.
     */
    cursor?: RefreshTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RefreshTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RefreshTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RefreshTokens.
     */
    distinct?: RefreshTokenScalarFieldEnum | RefreshTokenScalarFieldEnum[]
  }

  /**
   * RefreshToken findMany
   */
  export type RefreshTokenFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenInclude<ExtArgs> | null
    /**
     * Filter, which RefreshTokens to fetch.
     */
    where?: RefreshTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RefreshTokens to fetch.
     */
    orderBy?: RefreshTokenOrderByWithRelationInput | RefreshTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RefreshTokens.
     */
    cursor?: RefreshTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RefreshTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RefreshTokens.
     */
    skip?: number
    distinct?: RefreshTokenScalarFieldEnum | RefreshTokenScalarFieldEnum[]
  }

  /**
   * RefreshToken create
   */
  export type RefreshTokenCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenInclude<ExtArgs> | null
    /**
     * The data needed to create a RefreshToken.
     */
    data: XOR<RefreshTokenCreateInput, RefreshTokenUncheckedCreateInput>
  }

  /**
   * RefreshToken createMany
   */
  export type RefreshTokenCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many RefreshTokens.
     */
    data: RefreshTokenCreateManyInput | RefreshTokenCreateManyInput[]
  }

  /**
   * RefreshToken createManyAndReturn
   */
  export type RefreshTokenCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many RefreshTokens.
     */
    data: RefreshTokenCreateManyInput | RefreshTokenCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * RefreshToken update
   */
  export type RefreshTokenUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenInclude<ExtArgs> | null
    /**
     * The data needed to update a RefreshToken.
     */
    data: XOR<RefreshTokenUpdateInput, RefreshTokenUncheckedUpdateInput>
    /**
     * Choose, which RefreshToken to update.
     */
    where: RefreshTokenWhereUniqueInput
  }

  /**
   * RefreshToken updateMany
   */
  export type RefreshTokenUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update RefreshTokens.
     */
    data: XOR<RefreshTokenUpdateManyMutationInput, RefreshTokenUncheckedUpdateManyInput>
    /**
     * Filter which RefreshTokens to update
     */
    where?: RefreshTokenWhereInput
  }

  /**
   * RefreshToken upsert
   */
  export type RefreshTokenUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenInclude<ExtArgs> | null
    /**
     * The filter to search for the RefreshToken to update in case it exists.
     */
    where: RefreshTokenWhereUniqueInput
    /**
     * In case the RefreshToken found by the `where` argument doesn't exist, create a new RefreshToken with this data.
     */
    create: XOR<RefreshTokenCreateInput, RefreshTokenUncheckedCreateInput>
    /**
     * In case the RefreshToken was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RefreshTokenUpdateInput, RefreshTokenUncheckedUpdateInput>
  }

  /**
   * RefreshToken delete
   */
  export type RefreshTokenDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenInclude<ExtArgs> | null
    /**
     * Filter which RefreshToken to delete.
     */
    where: RefreshTokenWhereUniqueInput
  }

  /**
   * RefreshToken deleteMany
   */
  export type RefreshTokenDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RefreshTokens to delete
     */
    where?: RefreshTokenWhereInput
  }

  /**
   * RefreshToken without action
   */
  export type RefreshTokenDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenInclude<ExtArgs> | null
  }


  /**
   * Model Santri
   */

  export type AggregateSantri = {
    _count: SantriCountAggregateOutputType | null
    _min: SantriMinAggregateOutputType | null
    _max: SantriMaxAggregateOutputType | null
  }

  export type SantriMinAggregateOutputType = {
    id: string | null
    tenantId: string | null
    nisn: string | null
    name: string | null
    gender: string | null
    dob: Date | null
    kelas: string | null
    room: string | null
    contact: string | null
    address: string | null
    photo: string | null
    status: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SantriMaxAggregateOutputType = {
    id: string | null
    tenantId: string | null
    nisn: string | null
    name: string | null
    gender: string | null
    dob: Date | null
    kelas: string | null
    room: string | null
    contact: string | null
    address: string | null
    photo: string | null
    status: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SantriCountAggregateOutputType = {
    id: number
    tenantId: number
    nisn: number
    name: number
    gender: number
    dob: number
    kelas: number
    room: number
    contact: number
    address: number
    photo: number
    status: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SantriMinAggregateInputType = {
    id?: true
    tenantId?: true
    nisn?: true
    name?: true
    gender?: true
    dob?: true
    kelas?: true
    room?: true
    contact?: true
    address?: true
    photo?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SantriMaxAggregateInputType = {
    id?: true
    tenantId?: true
    nisn?: true
    name?: true
    gender?: true
    dob?: true
    kelas?: true
    room?: true
    contact?: true
    address?: true
    photo?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SantriCountAggregateInputType = {
    id?: true
    tenantId?: true
    nisn?: true
    name?: true
    gender?: true
    dob?: true
    kelas?: true
    room?: true
    contact?: true
    address?: true
    photo?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SantriAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Santri to aggregate.
     */
    where?: SantriWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Santris to fetch.
     */
    orderBy?: SantriOrderByWithRelationInput | SantriOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SantriWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Santris from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Santris.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Santris
    **/
    _count?: true | SantriCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SantriMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SantriMaxAggregateInputType
  }

  export type GetSantriAggregateType<T extends SantriAggregateArgs> = {
        [P in keyof T & keyof AggregateSantri]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSantri[P]>
      : GetScalarType<T[P], AggregateSantri[P]>
  }




  export type SantriGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SantriWhereInput
    orderBy?: SantriOrderByWithAggregationInput | SantriOrderByWithAggregationInput[]
    by: SantriScalarFieldEnum[] | SantriScalarFieldEnum
    having?: SantriScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SantriCountAggregateInputType | true
    _min?: SantriMinAggregateInputType
    _max?: SantriMaxAggregateInputType
  }

  export type SantriGroupByOutputType = {
    id: string
    tenantId: string
    nisn: string | null
    name: string
    gender: string
    dob: Date | null
    kelas: string | null
    room: string | null
    contact: string | null
    address: string | null
    photo: string | null
    status: string
    createdAt: Date
    updatedAt: Date
    _count: SantriCountAggregateOutputType | null
    _min: SantriMinAggregateOutputType | null
    _max: SantriMaxAggregateOutputType | null
  }

  type GetSantriGroupByPayload<T extends SantriGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SantriGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SantriGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SantriGroupByOutputType[P]>
            : GetScalarType<T[P], SantriGroupByOutputType[P]>
        }
      >
    >


  export type SantriSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    nisn?: boolean
    name?: boolean
    gender?: boolean
    dob?: boolean
    kelas?: boolean
    room?: boolean
    contact?: boolean
    address?: boolean
    photo?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    walis?: boolean | Santri$walisArgs<ExtArgs>
    izin?: boolean | Santri$izinArgs<ExtArgs>
    catatanHarian?: boolean | Santri$catatanHarianArgs<ExtArgs>
    invoices?: boolean | Santri$invoicesArgs<ExtArgs>
    pelanggaran?: boolean | Santri$pelanggaranArgs<ExtArgs>
    pembinaan?: boolean | Santri$pembinaanArgs<ExtArgs>
    kunjungan?: boolean | Santri$kunjunganArgs<ExtArgs>
    healthRecords?: boolean | Santri$healthRecordsArgs<ExtArgs>
    medications?: boolean | Santri$medicationsArgs<ExtArgs>
    tahfidz?: boolean | Santri$tahfidzArgs<ExtArgs>
    mutabaah?: boolean | Santri$mutabaahArgs<ExtArgs>
    wallet?: boolean | Santri$walletArgs<ExtArgs>
    attendances?: boolean | Santri$attendancesArgs<ExtArgs>
    grades?: boolean | Santri$gradesArgs<ExtArgs>
    _count?: boolean | SantriCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["santri"]>

  export type SantriSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    nisn?: boolean
    name?: boolean
    gender?: boolean
    dob?: boolean
    kelas?: boolean
    room?: boolean
    contact?: boolean
    address?: boolean
    photo?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["santri"]>

  export type SantriSelectScalar = {
    id?: boolean
    tenantId?: boolean
    nisn?: boolean
    name?: boolean
    gender?: boolean
    dob?: boolean
    kelas?: boolean
    room?: boolean
    contact?: boolean
    address?: boolean
    photo?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type SantriInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    walis?: boolean | Santri$walisArgs<ExtArgs>
    izin?: boolean | Santri$izinArgs<ExtArgs>
    catatanHarian?: boolean | Santri$catatanHarianArgs<ExtArgs>
    invoices?: boolean | Santri$invoicesArgs<ExtArgs>
    pelanggaran?: boolean | Santri$pelanggaranArgs<ExtArgs>
    pembinaan?: boolean | Santri$pembinaanArgs<ExtArgs>
    kunjungan?: boolean | Santri$kunjunganArgs<ExtArgs>
    healthRecords?: boolean | Santri$healthRecordsArgs<ExtArgs>
    medications?: boolean | Santri$medicationsArgs<ExtArgs>
    tahfidz?: boolean | Santri$tahfidzArgs<ExtArgs>
    mutabaah?: boolean | Santri$mutabaahArgs<ExtArgs>
    wallet?: boolean | Santri$walletArgs<ExtArgs>
    attendances?: boolean | Santri$attendancesArgs<ExtArgs>
    grades?: boolean | Santri$gradesArgs<ExtArgs>
    _count?: boolean | SantriCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type SantriIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }

  export type $SantriPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Santri"
    objects: {
      tenant: Prisma.$TenantPayload<ExtArgs>
      walis: Prisma.$SantriWaliPayload<ExtArgs>[]
      izin: Prisma.$IzinPayload<ExtArgs>[]
      catatanHarian: Prisma.$CatatanHarianPayload<ExtArgs>[]
      invoices: Prisma.$InvoicePayload<ExtArgs>[]
      pelanggaran: Prisma.$PelanggaranPayload<ExtArgs>[]
      pembinaan: Prisma.$PembinaanPayload<ExtArgs>[]
      kunjungan: Prisma.$KunjunganPayload<ExtArgs>[]
      healthRecords: Prisma.$HealthRecordPayload<ExtArgs>[]
      medications: Prisma.$MedicationPayload<ExtArgs>[]
      tahfidz: Prisma.$TahfidzPayload<ExtArgs>[]
      mutabaah: Prisma.$MutabaahPayload<ExtArgs>[]
      wallet: Prisma.$WalletPayload<ExtArgs> | null
      attendances: Prisma.$AttendancePayload<ExtArgs>[]
      grades: Prisma.$GradePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      tenantId: string
      nisn: string | null
      name: string
      gender: string
      dob: Date | null
      kelas: string | null
      room: string | null
      contact: string | null
      address: string | null
      photo: string | null
      status: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["santri"]>
    composites: {}
  }

  type SantriGetPayload<S extends boolean | null | undefined | SantriDefaultArgs> = $Result.GetResult<Prisma.$SantriPayload, S>

  type SantriCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<SantriFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: SantriCountAggregateInputType | true
    }

  export interface SantriDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Santri'], meta: { name: 'Santri' } }
    /**
     * Find zero or one Santri that matches the filter.
     * @param {SantriFindUniqueArgs} args - Arguments to find a Santri
     * @example
     * // Get one Santri
     * const santri = await prisma.santri.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SantriFindUniqueArgs>(args: SelectSubset<T, SantriFindUniqueArgs<ExtArgs>>): Prisma__SantriClient<$Result.GetResult<Prisma.$SantriPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Santri that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {SantriFindUniqueOrThrowArgs} args - Arguments to find a Santri
     * @example
     * // Get one Santri
     * const santri = await prisma.santri.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SantriFindUniqueOrThrowArgs>(args: SelectSubset<T, SantriFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SantriClient<$Result.GetResult<Prisma.$SantriPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Santri that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SantriFindFirstArgs} args - Arguments to find a Santri
     * @example
     * // Get one Santri
     * const santri = await prisma.santri.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SantriFindFirstArgs>(args?: SelectSubset<T, SantriFindFirstArgs<ExtArgs>>): Prisma__SantriClient<$Result.GetResult<Prisma.$SantriPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Santri that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SantriFindFirstOrThrowArgs} args - Arguments to find a Santri
     * @example
     * // Get one Santri
     * const santri = await prisma.santri.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SantriFindFirstOrThrowArgs>(args?: SelectSubset<T, SantriFindFirstOrThrowArgs<ExtArgs>>): Prisma__SantriClient<$Result.GetResult<Prisma.$SantriPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Santris that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SantriFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Santris
     * const santris = await prisma.santri.findMany()
     * 
     * // Get first 10 Santris
     * const santris = await prisma.santri.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const santriWithIdOnly = await prisma.santri.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SantriFindManyArgs>(args?: SelectSubset<T, SantriFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SantriPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Santri.
     * @param {SantriCreateArgs} args - Arguments to create a Santri.
     * @example
     * // Create one Santri
     * const Santri = await prisma.santri.create({
     *   data: {
     *     // ... data to create a Santri
     *   }
     * })
     * 
     */
    create<T extends SantriCreateArgs>(args: SelectSubset<T, SantriCreateArgs<ExtArgs>>): Prisma__SantriClient<$Result.GetResult<Prisma.$SantriPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Santris.
     * @param {SantriCreateManyArgs} args - Arguments to create many Santris.
     * @example
     * // Create many Santris
     * const santri = await prisma.santri.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SantriCreateManyArgs>(args?: SelectSubset<T, SantriCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Santris and returns the data saved in the database.
     * @param {SantriCreateManyAndReturnArgs} args - Arguments to create many Santris.
     * @example
     * // Create many Santris
     * const santri = await prisma.santri.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Santris and only return the `id`
     * const santriWithIdOnly = await prisma.santri.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SantriCreateManyAndReturnArgs>(args?: SelectSubset<T, SantriCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SantriPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Santri.
     * @param {SantriDeleteArgs} args - Arguments to delete one Santri.
     * @example
     * // Delete one Santri
     * const Santri = await prisma.santri.delete({
     *   where: {
     *     // ... filter to delete one Santri
     *   }
     * })
     * 
     */
    delete<T extends SantriDeleteArgs>(args: SelectSubset<T, SantriDeleteArgs<ExtArgs>>): Prisma__SantriClient<$Result.GetResult<Prisma.$SantriPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Santri.
     * @param {SantriUpdateArgs} args - Arguments to update one Santri.
     * @example
     * // Update one Santri
     * const santri = await prisma.santri.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SantriUpdateArgs>(args: SelectSubset<T, SantriUpdateArgs<ExtArgs>>): Prisma__SantriClient<$Result.GetResult<Prisma.$SantriPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Santris.
     * @param {SantriDeleteManyArgs} args - Arguments to filter Santris to delete.
     * @example
     * // Delete a few Santris
     * const { count } = await prisma.santri.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SantriDeleteManyArgs>(args?: SelectSubset<T, SantriDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Santris.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SantriUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Santris
     * const santri = await prisma.santri.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SantriUpdateManyArgs>(args: SelectSubset<T, SantriUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Santri.
     * @param {SantriUpsertArgs} args - Arguments to update or create a Santri.
     * @example
     * // Update or create a Santri
     * const santri = await prisma.santri.upsert({
     *   create: {
     *     // ... data to create a Santri
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Santri we want to update
     *   }
     * })
     */
    upsert<T extends SantriUpsertArgs>(args: SelectSubset<T, SantriUpsertArgs<ExtArgs>>): Prisma__SantriClient<$Result.GetResult<Prisma.$SantriPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Santris.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SantriCountArgs} args - Arguments to filter Santris to count.
     * @example
     * // Count the number of Santris
     * const count = await prisma.santri.count({
     *   where: {
     *     // ... the filter for the Santris we want to count
     *   }
     * })
    **/
    count<T extends SantriCountArgs>(
      args?: Subset<T, SantriCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SantriCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Santri.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SantriAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SantriAggregateArgs>(args: Subset<T, SantriAggregateArgs>): Prisma.PrismaPromise<GetSantriAggregateType<T>>

    /**
     * Group by Santri.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SantriGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SantriGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SantriGroupByArgs['orderBy'] }
        : { orderBy?: SantriGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SantriGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSantriGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Santri model
   */
  readonly fields: SantriFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Santri.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SantriClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    tenant<T extends TenantDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TenantDefaultArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    walis<T extends Santri$walisArgs<ExtArgs> = {}>(args?: Subset<T, Santri$walisArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SantriWaliPayload<ExtArgs>, T, "findMany"> | Null>
    izin<T extends Santri$izinArgs<ExtArgs> = {}>(args?: Subset<T, Santri$izinArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IzinPayload<ExtArgs>, T, "findMany"> | Null>
    catatanHarian<T extends Santri$catatanHarianArgs<ExtArgs> = {}>(args?: Subset<T, Santri$catatanHarianArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CatatanHarianPayload<ExtArgs>, T, "findMany"> | Null>
    invoices<T extends Santri$invoicesArgs<ExtArgs> = {}>(args?: Subset<T, Santri$invoicesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findMany"> | Null>
    pelanggaran<T extends Santri$pelanggaranArgs<ExtArgs> = {}>(args?: Subset<T, Santri$pelanggaranArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PelanggaranPayload<ExtArgs>, T, "findMany"> | Null>
    pembinaan<T extends Santri$pembinaanArgs<ExtArgs> = {}>(args?: Subset<T, Santri$pembinaanArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PembinaanPayload<ExtArgs>, T, "findMany"> | Null>
    kunjungan<T extends Santri$kunjunganArgs<ExtArgs> = {}>(args?: Subset<T, Santri$kunjunganArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$KunjunganPayload<ExtArgs>, T, "findMany"> | Null>
    healthRecords<T extends Santri$healthRecordsArgs<ExtArgs> = {}>(args?: Subset<T, Santri$healthRecordsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HealthRecordPayload<ExtArgs>, T, "findMany"> | Null>
    medications<T extends Santri$medicationsArgs<ExtArgs> = {}>(args?: Subset<T, Santri$medicationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MedicationPayload<ExtArgs>, T, "findMany"> | Null>
    tahfidz<T extends Santri$tahfidzArgs<ExtArgs> = {}>(args?: Subset<T, Santri$tahfidzArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TahfidzPayload<ExtArgs>, T, "findMany"> | Null>
    mutabaah<T extends Santri$mutabaahArgs<ExtArgs> = {}>(args?: Subset<T, Santri$mutabaahArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MutabaahPayload<ExtArgs>, T, "findMany"> | Null>
    wallet<T extends Santri$walletArgs<ExtArgs> = {}>(args?: Subset<T, Santri$walletArgs<ExtArgs>>): Prisma__WalletClient<$Result.GetResult<Prisma.$WalletPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    attendances<T extends Santri$attendancesArgs<ExtArgs> = {}>(args?: Subset<T, Santri$attendancesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AttendancePayload<ExtArgs>, T, "findMany"> | Null>
    grades<T extends Santri$gradesArgs<ExtArgs> = {}>(args?: Subset<T, Santri$gradesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GradePayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Santri model
   */ 
  interface SantriFieldRefs {
    readonly id: FieldRef<"Santri", 'String'>
    readonly tenantId: FieldRef<"Santri", 'String'>
    readonly nisn: FieldRef<"Santri", 'String'>
    readonly name: FieldRef<"Santri", 'String'>
    readonly gender: FieldRef<"Santri", 'String'>
    readonly dob: FieldRef<"Santri", 'DateTime'>
    readonly kelas: FieldRef<"Santri", 'String'>
    readonly room: FieldRef<"Santri", 'String'>
    readonly contact: FieldRef<"Santri", 'String'>
    readonly address: FieldRef<"Santri", 'String'>
    readonly photo: FieldRef<"Santri", 'String'>
    readonly status: FieldRef<"Santri", 'String'>
    readonly createdAt: FieldRef<"Santri", 'DateTime'>
    readonly updatedAt: FieldRef<"Santri", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Santri findUnique
   */
  export type SantriFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Santri
     */
    select?: SantriSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SantriInclude<ExtArgs> | null
    /**
     * Filter, which Santri to fetch.
     */
    where: SantriWhereUniqueInput
  }

  /**
   * Santri findUniqueOrThrow
   */
  export type SantriFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Santri
     */
    select?: SantriSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SantriInclude<ExtArgs> | null
    /**
     * Filter, which Santri to fetch.
     */
    where: SantriWhereUniqueInput
  }

  /**
   * Santri findFirst
   */
  export type SantriFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Santri
     */
    select?: SantriSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SantriInclude<ExtArgs> | null
    /**
     * Filter, which Santri to fetch.
     */
    where?: SantriWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Santris to fetch.
     */
    orderBy?: SantriOrderByWithRelationInput | SantriOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Santris.
     */
    cursor?: SantriWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Santris from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Santris.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Santris.
     */
    distinct?: SantriScalarFieldEnum | SantriScalarFieldEnum[]
  }

  /**
   * Santri findFirstOrThrow
   */
  export type SantriFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Santri
     */
    select?: SantriSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SantriInclude<ExtArgs> | null
    /**
     * Filter, which Santri to fetch.
     */
    where?: SantriWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Santris to fetch.
     */
    orderBy?: SantriOrderByWithRelationInput | SantriOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Santris.
     */
    cursor?: SantriWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Santris from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Santris.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Santris.
     */
    distinct?: SantriScalarFieldEnum | SantriScalarFieldEnum[]
  }

  /**
   * Santri findMany
   */
  export type SantriFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Santri
     */
    select?: SantriSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SantriInclude<ExtArgs> | null
    /**
     * Filter, which Santris to fetch.
     */
    where?: SantriWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Santris to fetch.
     */
    orderBy?: SantriOrderByWithRelationInput | SantriOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Santris.
     */
    cursor?: SantriWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Santris from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Santris.
     */
    skip?: number
    distinct?: SantriScalarFieldEnum | SantriScalarFieldEnum[]
  }

  /**
   * Santri create
   */
  export type SantriCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Santri
     */
    select?: SantriSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SantriInclude<ExtArgs> | null
    /**
     * The data needed to create a Santri.
     */
    data: XOR<SantriCreateInput, SantriUncheckedCreateInput>
  }

  /**
   * Santri createMany
   */
  export type SantriCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Santris.
     */
    data: SantriCreateManyInput | SantriCreateManyInput[]
  }

  /**
   * Santri createManyAndReturn
   */
  export type SantriCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Santri
     */
    select?: SantriSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Santris.
     */
    data: SantriCreateManyInput | SantriCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SantriIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Santri update
   */
  export type SantriUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Santri
     */
    select?: SantriSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SantriInclude<ExtArgs> | null
    /**
     * The data needed to update a Santri.
     */
    data: XOR<SantriUpdateInput, SantriUncheckedUpdateInput>
    /**
     * Choose, which Santri to update.
     */
    where: SantriWhereUniqueInput
  }

  /**
   * Santri updateMany
   */
  export type SantriUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Santris.
     */
    data: XOR<SantriUpdateManyMutationInput, SantriUncheckedUpdateManyInput>
    /**
     * Filter which Santris to update
     */
    where?: SantriWhereInput
  }

  /**
   * Santri upsert
   */
  export type SantriUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Santri
     */
    select?: SantriSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SantriInclude<ExtArgs> | null
    /**
     * The filter to search for the Santri to update in case it exists.
     */
    where: SantriWhereUniqueInput
    /**
     * In case the Santri found by the `where` argument doesn't exist, create a new Santri with this data.
     */
    create: XOR<SantriCreateInput, SantriUncheckedCreateInput>
    /**
     * In case the Santri was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SantriUpdateInput, SantriUncheckedUpdateInput>
  }

  /**
   * Santri delete
   */
  export type SantriDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Santri
     */
    select?: SantriSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SantriInclude<ExtArgs> | null
    /**
     * Filter which Santri to delete.
     */
    where: SantriWhereUniqueInput
  }

  /**
   * Santri deleteMany
   */
  export type SantriDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Santris to delete
     */
    where?: SantriWhereInput
  }

  /**
   * Santri.walis
   */
  export type Santri$walisArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SantriWali
     */
    select?: SantriWaliSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SantriWaliInclude<ExtArgs> | null
    where?: SantriWaliWhereInput
    orderBy?: SantriWaliOrderByWithRelationInput | SantriWaliOrderByWithRelationInput[]
    cursor?: SantriWaliWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SantriWaliScalarFieldEnum | SantriWaliScalarFieldEnum[]
  }

  /**
   * Santri.izin
   */
  export type Santri$izinArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Izin
     */
    select?: IzinSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IzinInclude<ExtArgs> | null
    where?: IzinWhereInput
    orderBy?: IzinOrderByWithRelationInput | IzinOrderByWithRelationInput[]
    cursor?: IzinWhereUniqueInput
    take?: number
    skip?: number
    distinct?: IzinScalarFieldEnum | IzinScalarFieldEnum[]
  }

  /**
   * Santri.catatanHarian
   */
  export type Santri$catatanHarianArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CatatanHarian
     */
    select?: CatatanHarianSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CatatanHarianInclude<ExtArgs> | null
    where?: CatatanHarianWhereInput
    orderBy?: CatatanHarianOrderByWithRelationInput | CatatanHarianOrderByWithRelationInput[]
    cursor?: CatatanHarianWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CatatanHarianScalarFieldEnum | CatatanHarianScalarFieldEnum[]
  }

  /**
   * Santri.invoices
   */
  export type Santri$invoicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    where?: InvoiceWhereInput
    orderBy?: InvoiceOrderByWithRelationInput | InvoiceOrderByWithRelationInput[]
    cursor?: InvoiceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InvoiceScalarFieldEnum | InvoiceScalarFieldEnum[]
  }

  /**
   * Santri.pelanggaran
   */
  export type Santri$pelanggaranArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pelanggaran
     */
    select?: PelanggaranSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PelanggaranInclude<ExtArgs> | null
    where?: PelanggaranWhereInput
    orderBy?: PelanggaranOrderByWithRelationInput | PelanggaranOrderByWithRelationInput[]
    cursor?: PelanggaranWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PelanggaranScalarFieldEnum | PelanggaranScalarFieldEnum[]
  }

  /**
   * Santri.pembinaan
   */
  export type Santri$pembinaanArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pembinaan
     */
    select?: PembinaanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PembinaanInclude<ExtArgs> | null
    where?: PembinaanWhereInput
    orderBy?: PembinaanOrderByWithRelationInput | PembinaanOrderByWithRelationInput[]
    cursor?: PembinaanWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PembinaanScalarFieldEnum | PembinaanScalarFieldEnum[]
  }

  /**
   * Santri.kunjungan
   */
  export type Santri$kunjunganArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Kunjungan
     */
    select?: KunjunganSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KunjunganInclude<ExtArgs> | null
    where?: KunjunganWhereInput
    orderBy?: KunjunganOrderByWithRelationInput | KunjunganOrderByWithRelationInput[]
    cursor?: KunjunganWhereUniqueInput
    take?: number
    skip?: number
    distinct?: KunjunganScalarFieldEnum | KunjunganScalarFieldEnum[]
  }

  /**
   * Santri.healthRecords
   */
  export type Santri$healthRecordsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HealthRecord
     */
    select?: HealthRecordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HealthRecordInclude<ExtArgs> | null
    where?: HealthRecordWhereInput
    orderBy?: HealthRecordOrderByWithRelationInput | HealthRecordOrderByWithRelationInput[]
    cursor?: HealthRecordWhereUniqueInput
    take?: number
    skip?: number
    distinct?: HealthRecordScalarFieldEnum | HealthRecordScalarFieldEnum[]
  }

  /**
   * Santri.medications
   */
  export type Santri$medicationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Medication
     */
    select?: MedicationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicationInclude<ExtArgs> | null
    where?: MedicationWhereInput
    orderBy?: MedicationOrderByWithRelationInput | MedicationOrderByWithRelationInput[]
    cursor?: MedicationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MedicationScalarFieldEnum | MedicationScalarFieldEnum[]
  }

  /**
   * Santri.tahfidz
   */
  export type Santri$tahfidzArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tahfidz
     */
    select?: TahfidzSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TahfidzInclude<ExtArgs> | null
    where?: TahfidzWhereInput
    orderBy?: TahfidzOrderByWithRelationInput | TahfidzOrderByWithRelationInput[]
    cursor?: TahfidzWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TahfidzScalarFieldEnum | TahfidzScalarFieldEnum[]
  }

  /**
   * Santri.mutabaah
   */
  export type Santri$mutabaahArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Mutabaah
     */
    select?: MutabaahSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MutabaahInclude<ExtArgs> | null
    where?: MutabaahWhereInput
    orderBy?: MutabaahOrderByWithRelationInput | MutabaahOrderByWithRelationInput[]
    cursor?: MutabaahWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MutabaahScalarFieldEnum | MutabaahScalarFieldEnum[]
  }

  /**
   * Santri.wallet
   */
  export type Santri$walletArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Wallet
     */
    select?: WalletSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WalletInclude<ExtArgs> | null
    where?: WalletWhereInput
  }

  /**
   * Santri.attendances
   */
  export type Santri$attendancesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attendance
     */
    select?: AttendanceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceInclude<ExtArgs> | null
    where?: AttendanceWhereInput
    orderBy?: AttendanceOrderByWithRelationInput | AttendanceOrderByWithRelationInput[]
    cursor?: AttendanceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AttendanceScalarFieldEnum | AttendanceScalarFieldEnum[]
  }

  /**
   * Santri.grades
   */
  export type Santri$gradesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Grade
     */
    select?: GradeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GradeInclude<ExtArgs> | null
    where?: GradeWhereInput
    orderBy?: GradeOrderByWithRelationInput | GradeOrderByWithRelationInput[]
    cursor?: GradeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: GradeScalarFieldEnum | GradeScalarFieldEnum[]
  }

  /**
   * Santri without action
   */
  export type SantriDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Santri
     */
    select?: SantriSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SantriInclude<ExtArgs> | null
  }


  /**
   * Model Wali
   */

  export type AggregateWali = {
    _count: WaliCountAggregateOutputType | null
    _min: WaliMinAggregateOutputType | null
    _max: WaliMaxAggregateOutputType | null
  }

  export type WaliMinAggregateOutputType = {
    id: string | null
    tenantId: string | null
    name: string | null
    relation: string | null
    phone: string | null
    email: string | null
    address: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type WaliMaxAggregateOutputType = {
    id: string | null
    tenantId: string | null
    name: string | null
    relation: string | null
    phone: string | null
    email: string | null
    address: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type WaliCountAggregateOutputType = {
    id: number
    tenantId: number
    name: number
    relation: number
    phone: number
    email: number
    address: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type WaliMinAggregateInputType = {
    id?: true
    tenantId?: true
    name?: true
    relation?: true
    phone?: true
    email?: true
    address?: true
    createdAt?: true
    updatedAt?: true
  }

  export type WaliMaxAggregateInputType = {
    id?: true
    tenantId?: true
    name?: true
    relation?: true
    phone?: true
    email?: true
    address?: true
    createdAt?: true
    updatedAt?: true
  }

  export type WaliCountAggregateInputType = {
    id?: true
    tenantId?: true
    name?: true
    relation?: true
    phone?: true
    email?: true
    address?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type WaliAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Wali to aggregate.
     */
    where?: WaliWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Walis to fetch.
     */
    orderBy?: WaliOrderByWithRelationInput | WaliOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: WaliWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Walis from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Walis.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Walis
    **/
    _count?: true | WaliCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WaliMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WaliMaxAggregateInputType
  }

  export type GetWaliAggregateType<T extends WaliAggregateArgs> = {
        [P in keyof T & keyof AggregateWali]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWali[P]>
      : GetScalarType<T[P], AggregateWali[P]>
  }




  export type WaliGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WaliWhereInput
    orderBy?: WaliOrderByWithAggregationInput | WaliOrderByWithAggregationInput[]
    by: WaliScalarFieldEnum[] | WaliScalarFieldEnum
    having?: WaliScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WaliCountAggregateInputType | true
    _min?: WaliMinAggregateInputType
    _max?: WaliMaxAggregateInputType
  }

  export type WaliGroupByOutputType = {
    id: string
    tenantId: string
    name: string
    relation: string
    phone: string
    email: string | null
    address: string | null
    createdAt: Date
    updatedAt: Date
    _count: WaliCountAggregateOutputType | null
    _min: WaliMinAggregateOutputType | null
    _max: WaliMaxAggregateOutputType | null
  }

  type GetWaliGroupByPayload<T extends WaliGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<WaliGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WaliGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WaliGroupByOutputType[P]>
            : GetScalarType<T[P], WaliGroupByOutputType[P]>
        }
      >
    >


  export type WaliSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    name?: boolean
    relation?: boolean
    phone?: boolean
    email?: boolean
    address?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    santris?: boolean | Wali$santrisArgs<ExtArgs>
    _count?: boolean | WaliCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["wali"]>

  export type WaliSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    name?: boolean
    relation?: boolean
    phone?: boolean
    email?: boolean
    address?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["wali"]>

  export type WaliSelectScalar = {
    id?: boolean
    tenantId?: boolean
    name?: boolean
    relation?: boolean
    phone?: boolean
    email?: boolean
    address?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type WaliInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    santris?: boolean | Wali$santrisArgs<ExtArgs>
    _count?: boolean | WaliCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type WaliIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }

  export type $WaliPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Wali"
    objects: {
      tenant: Prisma.$TenantPayload<ExtArgs>
      santris: Prisma.$SantriWaliPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      tenantId: string
      name: string
      relation: string
      phone: string
      email: string | null
      address: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["wali"]>
    composites: {}
  }

  type WaliGetPayload<S extends boolean | null | undefined | WaliDefaultArgs> = $Result.GetResult<Prisma.$WaliPayload, S>

  type WaliCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<WaliFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: WaliCountAggregateInputType | true
    }

  export interface WaliDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Wali'], meta: { name: 'Wali' } }
    /**
     * Find zero or one Wali that matches the filter.
     * @param {WaliFindUniqueArgs} args - Arguments to find a Wali
     * @example
     * // Get one Wali
     * const wali = await prisma.wali.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends WaliFindUniqueArgs>(args: SelectSubset<T, WaliFindUniqueArgs<ExtArgs>>): Prisma__WaliClient<$Result.GetResult<Prisma.$WaliPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Wali that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {WaliFindUniqueOrThrowArgs} args - Arguments to find a Wali
     * @example
     * // Get one Wali
     * const wali = await prisma.wali.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends WaliFindUniqueOrThrowArgs>(args: SelectSubset<T, WaliFindUniqueOrThrowArgs<ExtArgs>>): Prisma__WaliClient<$Result.GetResult<Prisma.$WaliPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Wali that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WaliFindFirstArgs} args - Arguments to find a Wali
     * @example
     * // Get one Wali
     * const wali = await prisma.wali.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends WaliFindFirstArgs>(args?: SelectSubset<T, WaliFindFirstArgs<ExtArgs>>): Prisma__WaliClient<$Result.GetResult<Prisma.$WaliPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Wali that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WaliFindFirstOrThrowArgs} args - Arguments to find a Wali
     * @example
     * // Get one Wali
     * const wali = await prisma.wali.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends WaliFindFirstOrThrowArgs>(args?: SelectSubset<T, WaliFindFirstOrThrowArgs<ExtArgs>>): Prisma__WaliClient<$Result.GetResult<Prisma.$WaliPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Walis that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WaliFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Walis
     * const walis = await prisma.wali.findMany()
     * 
     * // Get first 10 Walis
     * const walis = await prisma.wali.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const waliWithIdOnly = await prisma.wali.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends WaliFindManyArgs>(args?: SelectSubset<T, WaliFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WaliPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Wali.
     * @param {WaliCreateArgs} args - Arguments to create a Wali.
     * @example
     * // Create one Wali
     * const Wali = await prisma.wali.create({
     *   data: {
     *     // ... data to create a Wali
     *   }
     * })
     * 
     */
    create<T extends WaliCreateArgs>(args: SelectSubset<T, WaliCreateArgs<ExtArgs>>): Prisma__WaliClient<$Result.GetResult<Prisma.$WaliPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Walis.
     * @param {WaliCreateManyArgs} args - Arguments to create many Walis.
     * @example
     * // Create many Walis
     * const wali = await prisma.wali.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends WaliCreateManyArgs>(args?: SelectSubset<T, WaliCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Walis and returns the data saved in the database.
     * @param {WaliCreateManyAndReturnArgs} args - Arguments to create many Walis.
     * @example
     * // Create many Walis
     * const wali = await prisma.wali.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Walis and only return the `id`
     * const waliWithIdOnly = await prisma.wali.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends WaliCreateManyAndReturnArgs>(args?: SelectSubset<T, WaliCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WaliPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Wali.
     * @param {WaliDeleteArgs} args - Arguments to delete one Wali.
     * @example
     * // Delete one Wali
     * const Wali = await prisma.wali.delete({
     *   where: {
     *     // ... filter to delete one Wali
     *   }
     * })
     * 
     */
    delete<T extends WaliDeleteArgs>(args: SelectSubset<T, WaliDeleteArgs<ExtArgs>>): Prisma__WaliClient<$Result.GetResult<Prisma.$WaliPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Wali.
     * @param {WaliUpdateArgs} args - Arguments to update one Wali.
     * @example
     * // Update one Wali
     * const wali = await prisma.wali.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends WaliUpdateArgs>(args: SelectSubset<T, WaliUpdateArgs<ExtArgs>>): Prisma__WaliClient<$Result.GetResult<Prisma.$WaliPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Walis.
     * @param {WaliDeleteManyArgs} args - Arguments to filter Walis to delete.
     * @example
     * // Delete a few Walis
     * const { count } = await prisma.wali.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends WaliDeleteManyArgs>(args?: SelectSubset<T, WaliDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Walis.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WaliUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Walis
     * const wali = await prisma.wali.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends WaliUpdateManyArgs>(args: SelectSubset<T, WaliUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Wali.
     * @param {WaliUpsertArgs} args - Arguments to update or create a Wali.
     * @example
     * // Update or create a Wali
     * const wali = await prisma.wali.upsert({
     *   create: {
     *     // ... data to create a Wali
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Wali we want to update
     *   }
     * })
     */
    upsert<T extends WaliUpsertArgs>(args: SelectSubset<T, WaliUpsertArgs<ExtArgs>>): Prisma__WaliClient<$Result.GetResult<Prisma.$WaliPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Walis.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WaliCountArgs} args - Arguments to filter Walis to count.
     * @example
     * // Count the number of Walis
     * const count = await prisma.wali.count({
     *   where: {
     *     // ... the filter for the Walis we want to count
     *   }
     * })
    **/
    count<T extends WaliCountArgs>(
      args?: Subset<T, WaliCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WaliCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Wali.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WaliAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WaliAggregateArgs>(args: Subset<T, WaliAggregateArgs>): Prisma.PrismaPromise<GetWaliAggregateType<T>>

    /**
     * Group by Wali.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WaliGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WaliGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WaliGroupByArgs['orderBy'] }
        : { orderBy?: WaliGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WaliGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWaliGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Wali model
   */
  readonly fields: WaliFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Wali.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__WaliClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    tenant<T extends TenantDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TenantDefaultArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    santris<T extends Wali$santrisArgs<ExtArgs> = {}>(args?: Subset<T, Wali$santrisArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SantriWaliPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Wali model
   */ 
  interface WaliFieldRefs {
    readonly id: FieldRef<"Wali", 'String'>
    readonly tenantId: FieldRef<"Wali", 'String'>
    readonly name: FieldRef<"Wali", 'String'>
    readonly relation: FieldRef<"Wali", 'String'>
    readonly phone: FieldRef<"Wali", 'String'>
    readonly email: FieldRef<"Wali", 'String'>
    readonly address: FieldRef<"Wali", 'String'>
    readonly createdAt: FieldRef<"Wali", 'DateTime'>
    readonly updatedAt: FieldRef<"Wali", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Wali findUnique
   */
  export type WaliFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Wali
     */
    select?: WaliSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WaliInclude<ExtArgs> | null
    /**
     * Filter, which Wali to fetch.
     */
    where: WaliWhereUniqueInput
  }

  /**
   * Wali findUniqueOrThrow
   */
  export type WaliFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Wali
     */
    select?: WaliSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WaliInclude<ExtArgs> | null
    /**
     * Filter, which Wali to fetch.
     */
    where: WaliWhereUniqueInput
  }

  /**
   * Wali findFirst
   */
  export type WaliFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Wali
     */
    select?: WaliSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WaliInclude<ExtArgs> | null
    /**
     * Filter, which Wali to fetch.
     */
    where?: WaliWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Walis to fetch.
     */
    orderBy?: WaliOrderByWithRelationInput | WaliOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Walis.
     */
    cursor?: WaliWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Walis from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Walis.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Walis.
     */
    distinct?: WaliScalarFieldEnum | WaliScalarFieldEnum[]
  }

  /**
   * Wali findFirstOrThrow
   */
  export type WaliFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Wali
     */
    select?: WaliSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WaliInclude<ExtArgs> | null
    /**
     * Filter, which Wali to fetch.
     */
    where?: WaliWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Walis to fetch.
     */
    orderBy?: WaliOrderByWithRelationInput | WaliOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Walis.
     */
    cursor?: WaliWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Walis from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Walis.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Walis.
     */
    distinct?: WaliScalarFieldEnum | WaliScalarFieldEnum[]
  }

  /**
   * Wali findMany
   */
  export type WaliFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Wali
     */
    select?: WaliSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WaliInclude<ExtArgs> | null
    /**
     * Filter, which Walis to fetch.
     */
    where?: WaliWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Walis to fetch.
     */
    orderBy?: WaliOrderByWithRelationInput | WaliOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Walis.
     */
    cursor?: WaliWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Walis from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Walis.
     */
    skip?: number
    distinct?: WaliScalarFieldEnum | WaliScalarFieldEnum[]
  }

  /**
   * Wali create
   */
  export type WaliCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Wali
     */
    select?: WaliSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WaliInclude<ExtArgs> | null
    /**
     * The data needed to create a Wali.
     */
    data: XOR<WaliCreateInput, WaliUncheckedCreateInput>
  }

  /**
   * Wali createMany
   */
  export type WaliCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Walis.
     */
    data: WaliCreateManyInput | WaliCreateManyInput[]
  }

  /**
   * Wali createManyAndReturn
   */
  export type WaliCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Wali
     */
    select?: WaliSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Walis.
     */
    data: WaliCreateManyInput | WaliCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WaliIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Wali update
   */
  export type WaliUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Wali
     */
    select?: WaliSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WaliInclude<ExtArgs> | null
    /**
     * The data needed to update a Wali.
     */
    data: XOR<WaliUpdateInput, WaliUncheckedUpdateInput>
    /**
     * Choose, which Wali to update.
     */
    where: WaliWhereUniqueInput
  }

  /**
   * Wali updateMany
   */
  export type WaliUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Walis.
     */
    data: XOR<WaliUpdateManyMutationInput, WaliUncheckedUpdateManyInput>
    /**
     * Filter which Walis to update
     */
    where?: WaliWhereInput
  }

  /**
   * Wali upsert
   */
  export type WaliUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Wali
     */
    select?: WaliSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WaliInclude<ExtArgs> | null
    /**
     * The filter to search for the Wali to update in case it exists.
     */
    where: WaliWhereUniqueInput
    /**
     * In case the Wali found by the `where` argument doesn't exist, create a new Wali with this data.
     */
    create: XOR<WaliCreateInput, WaliUncheckedCreateInput>
    /**
     * In case the Wali was found with the provided `where` argument, update it with this data.
     */
    update: XOR<WaliUpdateInput, WaliUncheckedUpdateInput>
  }

  /**
   * Wali delete
   */
  export type WaliDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Wali
     */
    select?: WaliSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WaliInclude<ExtArgs> | null
    /**
     * Filter which Wali to delete.
     */
    where: WaliWhereUniqueInput
  }

  /**
   * Wali deleteMany
   */
  export type WaliDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Walis to delete
     */
    where?: WaliWhereInput
  }

  /**
   * Wali.santris
   */
  export type Wali$santrisArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SantriWali
     */
    select?: SantriWaliSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SantriWaliInclude<ExtArgs> | null
    where?: SantriWaliWhereInput
    orderBy?: SantriWaliOrderByWithRelationInput | SantriWaliOrderByWithRelationInput[]
    cursor?: SantriWaliWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SantriWaliScalarFieldEnum | SantriWaliScalarFieldEnum[]
  }

  /**
   * Wali without action
   */
  export type WaliDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Wali
     */
    select?: WaliSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WaliInclude<ExtArgs> | null
  }


  /**
   * Model SantriWali
   */

  export type AggregateSantriWali = {
    _count: SantriWaliCountAggregateOutputType | null
    _min: SantriWaliMinAggregateOutputType | null
    _max: SantriWaliMaxAggregateOutputType | null
  }

  export type SantriWaliMinAggregateOutputType = {
    santriId: string | null
    waliId: string | null
    isPrimary: boolean | null
  }

  export type SantriWaliMaxAggregateOutputType = {
    santriId: string | null
    waliId: string | null
    isPrimary: boolean | null
  }

  export type SantriWaliCountAggregateOutputType = {
    santriId: number
    waliId: number
    isPrimary: number
    _all: number
  }


  export type SantriWaliMinAggregateInputType = {
    santriId?: true
    waliId?: true
    isPrimary?: true
  }

  export type SantriWaliMaxAggregateInputType = {
    santriId?: true
    waliId?: true
    isPrimary?: true
  }

  export type SantriWaliCountAggregateInputType = {
    santriId?: true
    waliId?: true
    isPrimary?: true
    _all?: true
  }

  export type SantriWaliAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SantriWali to aggregate.
     */
    where?: SantriWaliWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SantriWalis to fetch.
     */
    orderBy?: SantriWaliOrderByWithRelationInput | SantriWaliOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SantriWaliWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SantriWalis from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SantriWalis.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SantriWalis
    **/
    _count?: true | SantriWaliCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SantriWaliMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SantriWaliMaxAggregateInputType
  }

  export type GetSantriWaliAggregateType<T extends SantriWaliAggregateArgs> = {
        [P in keyof T & keyof AggregateSantriWali]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSantriWali[P]>
      : GetScalarType<T[P], AggregateSantriWali[P]>
  }




  export type SantriWaliGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SantriWaliWhereInput
    orderBy?: SantriWaliOrderByWithAggregationInput | SantriWaliOrderByWithAggregationInput[]
    by: SantriWaliScalarFieldEnum[] | SantriWaliScalarFieldEnum
    having?: SantriWaliScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SantriWaliCountAggregateInputType | true
    _min?: SantriWaliMinAggregateInputType
    _max?: SantriWaliMaxAggregateInputType
  }

  export type SantriWaliGroupByOutputType = {
    santriId: string
    waliId: string
    isPrimary: boolean
    _count: SantriWaliCountAggregateOutputType | null
    _min: SantriWaliMinAggregateOutputType | null
    _max: SantriWaliMaxAggregateOutputType | null
  }

  type GetSantriWaliGroupByPayload<T extends SantriWaliGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SantriWaliGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SantriWaliGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SantriWaliGroupByOutputType[P]>
            : GetScalarType<T[P], SantriWaliGroupByOutputType[P]>
        }
      >
    >


  export type SantriWaliSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    santriId?: boolean
    waliId?: boolean
    isPrimary?: boolean
    santri?: boolean | SantriDefaultArgs<ExtArgs>
    wali?: boolean | WaliDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["santriWali"]>

  export type SantriWaliSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    santriId?: boolean
    waliId?: boolean
    isPrimary?: boolean
    santri?: boolean | SantriDefaultArgs<ExtArgs>
    wali?: boolean | WaliDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["santriWali"]>

  export type SantriWaliSelectScalar = {
    santriId?: boolean
    waliId?: boolean
    isPrimary?: boolean
  }

  export type SantriWaliInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    santri?: boolean | SantriDefaultArgs<ExtArgs>
    wali?: boolean | WaliDefaultArgs<ExtArgs>
  }
  export type SantriWaliIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    santri?: boolean | SantriDefaultArgs<ExtArgs>
    wali?: boolean | WaliDefaultArgs<ExtArgs>
  }

  export type $SantriWaliPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SantriWali"
    objects: {
      santri: Prisma.$SantriPayload<ExtArgs>
      wali: Prisma.$WaliPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      santriId: string
      waliId: string
      isPrimary: boolean
    }, ExtArgs["result"]["santriWali"]>
    composites: {}
  }

  type SantriWaliGetPayload<S extends boolean | null | undefined | SantriWaliDefaultArgs> = $Result.GetResult<Prisma.$SantriWaliPayload, S>

  type SantriWaliCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<SantriWaliFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: SantriWaliCountAggregateInputType | true
    }

  export interface SantriWaliDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SantriWali'], meta: { name: 'SantriWali' } }
    /**
     * Find zero or one SantriWali that matches the filter.
     * @param {SantriWaliFindUniqueArgs} args - Arguments to find a SantriWali
     * @example
     * // Get one SantriWali
     * const santriWali = await prisma.santriWali.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SantriWaliFindUniqueArgs>(args: SelectSubset<T, SantriWaliFindUniqueArgs<ExtArgs>>): Prisma__SantriWaliClient<$Result.GetResult<Prisma.$SantriWaliPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one SantriWali that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {SantriWaliFindUniqueOrThrowArgs} args - Arguments to find a SantriWali
     * @example
     * // Get one SantriWali
     * const santriWali = await prisma.santriWali.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SantriWaliFindUniqueOrThrowArgs>(args: SelectSubset<T, SantriWaliFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SantriWaliClient<$Result.GetResult<Prisma.$SantriWaliPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first SantriWali that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SantriWaliFindFirstArgs} args - Arguments to find a SantriWali
     * @example
     * // Get one SantriWali
     * const santriWali = await prisma.santriWali.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SantriWaliFindFirstArgs>(args?: SelectSubset<T, SantriWaliFindFirstArgs<ExtArgs>>): Prisma__SantriWaliClient<$Result.GetResult<Prisma.$SantriWaliPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first SantriWali that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SantriWaliFindFirstOrThrowArgs} args - Arguments to find a SantriWali
     * @example
     * // Get one SantriWali
     * const santriWali = await prisma.santriWali.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SantriWaliFindFirstOrThrowArgs>(args?: SelectSubset<T, SantriWaliFindFirstOrThrowArgs<ExtArgs>>): Prisma__SantriWaliClient<$Result.GetResult<Prisma.$SantriWaliPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more SantriWalis that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SantriWaliFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SantriWalis
     * const santriWalis = await prisma.santriWali.findMany()
     * 
     * // Get first 10 SantriWalis
     * const santriWalis = await prisma.santriWali.findMany({ take: 10 })
     * 
     * // Only select the `santriId`
     * const santriWaliWithSantriIdOnly = await prisma.santriWali.findMany({ select: { santriId: true } })
     * 
     */
    findMany<T extends SantriWaliFindManyArgs>(args?: SelectSubset<T, SantriWaliFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SantriWaliPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a SantriWali.
     * @param {SantriWaliCreateArgs} args - Arguments to create a SantriWali.
     * @example
     * // Create one SantriWali
     * const SantriWali = await prisma.santriWali.create({
     *   data: {
     *     // ... data to create a SantriWali
     *   }
     * })
     * 
     */
    create<T extends SantriWaliCreateArgs>(args: SelectSubset<T, SantriWaliCreateArgs<ExtArgs>>): Prisma__SantriWaliClient<$Result.GetResult<Prisma.$SantriWaliPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many SantriWalis.
     * @param {SantriWaliCreateManyArgs} args - Arguments to create many SantriWalis.
     * @example
     * // Create many SantriWalis
     * const santriWali = await prisma.santriWali.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SantriWaliCreateManyArgs>(args?: SelectSubset<T, SantriWaliCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SantriWalis and returns the data saved in the database.
     * @param {SantriWaliCreateManyAndReturnArgs} args - Arguments to create many SantriWalis.
     * @example
     * // Create many SantriWalis
     * const santriWali = await prisma.santriWali.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SantriWalis and only return the `santriId`
     * const santriWaliWithSantriIdOnly = await prisma.santriWali.createManyAndReturn({ 
     *   select: { santriId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SantriWaliCreateManyAndReturnArgs>(args?: SelectSubset<T, SantriWaliCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SantriWaliPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a SantriWali.
     * @param {SantriWaliDeleteArgs} args - Arguments to delete one SantriWali.
     * @example
     * // Delete one SantriWali
     * const SantriWali = await prisma.santriWali.delete({
     *   where: {
     *     // ... filter to delete one SantriWali
     *   }
     * })
     * 
     */
    delete<T extends SantriWaliDeleteArgs>(args: SelectSubset<T, SantriWaliDeleteArgs<ExtArgs>>): Prisma__SantriWaliClient<$Result.GetResult<Prisma.$SantriWaliPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one SantriWali.
     * @param {SantriWaliUpdateArgs} args - Arguments to update one SantriWali.
     * @example
     * // Update one SantriWali
     * const santriWali = await prisma.santriWali.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SantriWaliUpdateArgs>(args: SelectSubset<T, SantriWaliUpdateArgs<ExtArgs>>): Prisma__SantriWaliClient<$Result.GetResult<Prisma.$SantriWaliPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more SantriWalis.
     * @param {SantriWaliDeleteManyArgs} args - Arguments to filter SantriWalis to delete.
     * @example
     * // Delete a few SantriWalis
     * const { count } = await prisma.santriWali.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SantriWaliDeleteManyArgs>(args?: SelectSubset<T, SantriWaliDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SantriWalis.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SantriWaliUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SantriWalis
     * const santriWali = await prisma.santriWali.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SantriWaliUpdateManyArgs>(args: SelectSubset<T, SantriWaliUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one SantriWali.
     * @param {SantriWaliUpsertArgs} args - Arguments to update or create a SantriWali.
     * @example
     * // Update or create a SantriWali
     * const santriWali = await prisma.santriWali.upsert({
     *   create: {
     *     // ... data to create a SantriWali
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SantriWali we want to update
     *   }
     * })
     */
    upsert<T extends SantriWaliUpsertArgs>(args: SelectSubset<T, SantriWaliUpsertArgs<ExtArgs>>): Prisma__SantriWaliClient<$Result.GetResult<Prisma.$SantriWaliPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of SantriWalis.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SantriWaliCountArgs} args - Arguments to filter SantriWalis to count.
     * @example
     * // Count the number of SantriWalis
     * const count = await prisma.santriWali.count({
     *   where: {
     *     // ... the filter for the SantriWalis we want to count
     *   }
     * })
    **/
    count<T extends SantriWaliCountArgs>(
      args?: Subset<T, SantriWaliCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SantriWaliCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SantriWali.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SantriWaliAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SantriWaliAggregateArgs>(args: Subset<T, SantriWaliAggregateArgs>): Prisma.PrismaPromise<GetSantriWaliAggregateType<T>>

    /**
     * Group by SantriWali.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SantriWaliGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SantriWaliGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SantriWaliGroupByArgs['orderBy'] }
        : { orderBy?: SantriWaliGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SantriWaliGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSantriWaliGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SantriWali model
   */
  readonly fields: SantriWaliFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SantriWali.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SantriWaliClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    santri<T extends SantriDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SantriDefaultArgs<ExtArgs>>): Prisma__SantriClient<$Result.GetResult<Prisma.$SantriPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    wali<T extends WaliDefaultArgs<ExtArgs> = {}>(args?: Subset<T, WaliDefaultArgs<ExtArgs>>): Prisma__WaliClient<$Result.GetResult<Prisma.$WaliPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SantriWali model
   */ 
  interface SantriWaliFieldRefs {
    readonly santriId: FieldRef<"SantriWali", 'String'>
    readonly waliId: FieldRef<"SantriWali", 'String'>
    readonly isPrimary: FieldRef<"SantriWali", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * SantriWali findUnique
   */
  export type SantriWaliFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SantriWali
     */
    select?: SantriWaliSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SantriWaliInclude<ExtArgs> | null
    /**
     * Filter, which SantriWali to fetch.
     */
    where: SantriWaliWhereUniqueInput
  }

  /**
   * SantriWali findUniqueOrThrow
   */
  export type SantriWaliFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SantriWali
     */
    select?: SantriWaliSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SantriWaliInclude<ExtArgs> | null
    /**
     * Filter, which SantriWali to fetch.
     */
    where: SantriWaliWhereUniqueInput
  }

  /**
   * SantriWali findFirst
   */
  export type SantriWaliFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SantriWali
     */
    select?: SantriWaliSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SantriWaliInclude<ExtArgs> | null
    /**
     * Filter, which SantriWali to fetch.
     */
    where?: SantriWaliWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SantriWalis to fetch.
     */
    orderBy?: SantriWaliOrderByWithRelationInput | SantriWaliOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SantriWalis.
     */
    cursor?: SantriWaliWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SantriWalis from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SantriWalis.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SantriWalis.
     */
    distinct?: SantriWaliScalarFieldEnum | SantriWaliScalarFieldEnum[]
  }

  /**
   * SantriWali findFirstOrThrow
   */
  export type SantriWaliFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SantriWali
     */
    select?: SantriWaliSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SantriWaliInclude<ExtArgs> | null
    /**
     * Filter, which SantriWali to fetch.
     */
    where?: SantriWaliWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SantriWalis to fetch.
     */
    orderBy?: SantriWaliOrderByWithRelationInput | SantriWaliOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SantriWalis.
     */
    cursor?: SantriWaliWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SantriWalis from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SantriWalis.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SantriWalis.
     */
    distinct?: SantriWaliScalarFieldEnum | SantriWaliScalarFieldEnum[]
  }

  /**
   * SantriWali findMany
   */
  export type SantriWaliFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SantriWali
     */
    select?: SantriWaliSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SantriWaliInclude<ExtArgs> | null
    /**
     * Filter, which SantriWalis to fetch.
     */
    where?: SantriWaliWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SantriWalis to fetch.
     */
    orderBy?: SantriWaliOrderByWithRelationInput | SantriWaliOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SantriWalis.
     */
    cursor?: SantriWaliWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SantriWalis from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SantriWalis.
     */
    skip?: number
    distinct?: SantriWaliScalarFieldEnum | SantriWaliScalarFieldEnum[]
  }

  /**
   * SantriWali create
   */
  export type SantriWaliCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SantriWali
     */
    select?: SantriWaliSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SantriWaliInclude<ExtArgs> | null
    /**
     * The data needed to create a SantriWali.
     */
    data: XOR<SantriWaliCreateInput, SantriWaliUncheckedCreateInput>
  }

  /**
   * SantriWali createMany
   */
  export type SantriWaliCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SantriWalis.
     */
    data: SantriWaliCreateManyInput | SantriWaliCreateManyInput[]
  }

  /**
   * SantriWali createManyAndReturn
   */
  export type SantriWaliCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SantriWali
     */
    select?: SantriWaliSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many SantriWalis.
     */
    data: SantriWaliCreateManyInput | SantriWaliCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SantriWaliIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * SantriWali update
   */
  export type SantriWaliUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SantriWali
     */
    select?: SantriWaliSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SantriWaliInclude<ExtArgs> | null
    /**
     * The data needed to update a SantriWali.
     */
    data: XOR<SantriWaliUpdateInput, SantriWaliUncheckedUpdateInput>
    /**
     * Choose, which SantriWali to update.
     */
    where: SantriWaliWhereUniqueInput
  }

  /**
   * SantriWali updateMany
   */
  export type SantriWaliUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SantriWalis.
     */
    data: XOR<SantriWaliUpdateManyMutationInput, SantriWaliUncheckedUpdateManyInput>
    /**
     * Filter which SantriWalis to update
     */
    where?: SantriWaliWhereInput
  }

  /**
   * SantriWali upsert
   */
  export type SantriWaliUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SantriWali
     */
    select?: SantriWaliSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SantriWaliInclude<ExtArgs> | null
    /**
     * The filter to search for the SantriWali to update in case it exists.
     */
    where: SantriWaliWhereUniqueInput
    /**
     * In case the SantriWali found by the `where` argument doesn't exist, create a new SantriWali with this data.
     */
    create: XOR<SantriWaliCreateInput, SantriWaliUncheckedCreateInput>
    /**
     * In case the SantriWali was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SantriWaliUpdateInput, SantriWaliUncheckedUpdateInput>
  }

  /**
   * SantriWali delete
   */
  export type SantriWaliDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SantriWali
     */
    select?: SantriWaliSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SantriWaliInclude<ExtArgs> | null
    /**
     * Filter which SantriWali to delete.
     */
    where: SantriWaliWhereUniqueInput
  }

  /**
   * SantriWali deleteMany
   */
  export type SantriWaliDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SantriWalis to delete
     */
    where?: SantriWaliWhereInput
  }

  /**
   * SantriWali without action
   */
  export type SantriWaliDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SantriWali
     */
    select?: SantriWaliSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SantriWaliInclude<ExtArgs> | null
  }


  /**
   * Model Izin
   */

  export type AggregateIzin = {
    _count: IzinCountAggregateOutputType | null
    _min: IzinMinAggregateOutputType | null
    _max: IzinMaxAggregateOutputType | null
  }

  export type IzinMinAggregateOutputType = {
    id: string | null
    tenantId: string | null
    santriId: string | null
    type: string | null
    reason: string | null
    startAt: Date | null
    endAt: Date | null
    status: string | null
    requestedBy: string | null
    approvedBy: string | null
    approvedAt: Date | null
    qrCodeData: string | null
    checkoutAt: Date | null
    checkoutBy: string | null
    checkinAt: Date | null
    checkinBy: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type IzinMaxAggregateOutputType = {
    id: string | null
    tenantId: string | null
    santriId: string | null
    type: string | null
    reason: string | null
    startAt: Date | null
    endAt: Date | null
    status: string | null
    requestedBy: string | null
    approvedBy: string | null
    approvedAt: Date | null
    qrCodeData: string | null
    checkoutAt: Date | null
    checkoutBy: string | null
    checkinAt: Date | null
    checkinBy: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type IzinCountAggregateOutputType = {
    id: number
    tenantId: number
    santriId: number
    type: number
    reason: number
    startAt: number
    endAt: number
    status: number
    requestedBy: number
    approvedBy: number
    approvedAt: number
    qrCodeData: number
    checkoutAt: number
    checkoutBy: number
    checkinAt: number
    checkinBy: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type IzinMinAggregateInputType = {
    id?: true
    tenantId?: true
    santriId?: true
    type?: true
    reason?: true
    startAt?: true
    endAt?: true
    status?: true
    requestedBy?: true
    approvedBy?: true
    approvedAt?: true
    qrCodeData?: true
    checkoutAt?: true
    checkoutBy?: true
    checkinAt?: true
    checkinBy?: true
    createdAt?: true
    updatedAt?: true
  }

  export type IzinMaxAggregateInputType = {
    id?: true
    tenantId?: true
    santriId?: true
    type?: true
    reason?: true
    startAt?: true
    endAt?: true
    status?: true
    requestedBy?: true
    approvedBy?: true
    approvedAt?: true
    qrCodeData?: true
    checkoutAt?: true
    checkoutBy?: true
    checkinAt?: true
    checkinBy?: true
    createdAt?: true
    updatedAt?: true
  }

  export type IzinCountAggregateInputType = {
    id?: true
    tenantId?: true
    santriId?: true
    type?: true
    reason?: true
    startAt?: true
    endAt?: true
    status?: true
    requestedBy?: true
    approvedBy?: true
    approvedAt?: true
    qrCodeData?: true
    checkoutAt?: true
    checkoutBy?: true
    checkinAt?: true
    checkinBy?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type IzinAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Izin to aggregate.
     */
    where?: IzinWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Izins to fetch.
     */
    orderBy?: IzinOrderByWithRelationInput | IzinOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: IzinWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Izins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Izins.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Izins
    **/
    _count?: true | IzinCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: IzinMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: IzinMaxAggregateInputType
  }

  export type GetIzinAggregateType<T extends IzinAggregateArgs> = {
        [P in keyof T & keyof AggregateIzin]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateIzin[P]>
      : GetScalarType<T[P], AggregateIzin[P]>
  }




  export type IzinGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: IzinWhereInput
    orderBy?: IzinOrderByWithAggregationInput | IzinOrderByWithAggregationInput[]
    by: IzinScalarFieldEnum[] | IzinScalarFieldEnum
    having?: IzinScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: IzinCountAggregateInputType | true
    _min?: IzinMinAggregateInputType
    _max?: IzinMaxAggregateInputType
  }

  export type IzinGroupByOutputType = {
    id: string
    tenantId: string
    santriId: string
    type: string
    reason: string
    startAt: Date
    endAt: Date
    status: string
    requestedBy: string
    approvedBy: string | null
    approvedAt: Date | null
    qrCodeData: string | null
    checkoutAt: Date | null
    checkoutBy: string | null
    checkinAt: Date | null
    checkinBy: string | null
    createdAt: Date
    updatedAt: Date
    _count: IzinCountAggregateOutputType | null
    _min: IzinMinAggregateOutputType | null
    _max: IzinMaxAggregateOutputType | null
  }

  type GetIzinGroupByPayload<T extends IzinGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<IzinGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof IzinGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], IzinGroupByOutputType[P]>
            : GetScalarType<T[P], IzinGroupByOutputType[P]>
        }
      >
    >


  export type IzinSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    santriId?: boolean
    type?: boolean
    reason?: boolean
    startAt?: boolean
    endAt?: boolean
    status?: boolean
    requestedBy?: boolean
    approvedBy?: boolean
    approvedAt?: boolean
    qrCodeData?: boolean
    checkoutAt?: boolean
    checkoutBy?: boolean
    checkinAt?: boolean
    checkinBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    santri?: boolean | SantriDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["izin"]>

  export type IzinSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    santriId?: boolean
    type?: boolean
    reason?: boolean
    startAt?: boolean
    endAt?: boolean
    status?: boolean
    requestedBy?: boolean
    approvedBy?: boolean
    approvedAt?: boolean
    qrCodeData?: boolean
    checkoutAt?: boolean
    checkoutBy?: boolean
    checkinAt?: boolean
    checkinBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    santri?: boolean | SantriDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["izin"]>

  export type IzinSelectScalar = {
    id?: boolean
    tenantId?: boolean
    santriId?: boolean
    type?: boolean
    reason?: boolean
    startAt?: boolean
    endAt?: boolean
    status?: boolean
    requestedBy?: boolean
    approvedBy?: boolean
    approvedAt?: boolean
    qrCodeData?: boolean
    checkoutAt?: boolean
    checkoutBy?: boolean
    checkinAt?: boolean
    checkinBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type IzinInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    santri?: boolean | SantriDefaultArgs<ExtArgs>
  }
  export type IzinIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    santri?: boolean | SantriDefaultArgs<ExtArgs>
  }

  export type $IzinPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Izin"
    objects: {
      tenant: Prisma.$TenantPayload<ExtArgs>
      santri: Prisma.$SantriPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      tenantId: string
      santriId: string
      type: string
      reason: string
      startAt: Date
      endAt: Date
      status: string
      requestedBy: string
      approvedBy: string | null
      approvedAt: Date | null
      qrCodeData: string | null
      checkoutAt: Date | null
      checkoutBy: string | null
      checkinAt: Date | null
      checkinBy: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["izin"]>
    composites: {}
  }

  type IzinGetPayload<S extends boolean | null | undefined | IzinDefaultArgs> = $Result.GetResult<Prisma.$IzinPayload, S>

  type IzinCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<IzinFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: IzinCountAggregateInputType | true
    }

  export interface IzinDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Izin'], meta: { name: 'Izin' } }
    /**
     * Find zero or one Izin that matches the filter.
     * @param {IzinFindUniqueArgs} args - Arguments to find a Izin
     * @example
     * // Get one Izin
     * const izin = await prisma.izin.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends IzinFindUniqueArgs>(args: SelectSubset<T, IzinFindUniqueArgs<ExtArgs>>): Prisma__IzinClient<$Result.GetResult<Prisma.$IzinPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Izin that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {IzinFindUniqueOrThrowArgs} args - Arguments to find a Izin
     * @example
     * // Get one Izin
     * const izin = await prisma.izin.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends IzinFindUniqueOrThrowArgs>(args: SelectSubset<T, IzinFindUniqueOrThrowArgs<ExtArgs>>): Prisma__IzinClient<$Result.GetResult<Prisma.$IzinPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Izin that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IzinFindFirstArgs} args - Arguments to find a Izin
     * @example
     * // Get one Izin
     * const izin = await prisma.izin.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends IzinFindFirstArgs>(args?: SelectSubset<T, IzinFindFirstArgs<ExtArgs>>): Prisma__IzinClient<$Result.GetResult<Prisma.$IzinPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Izin that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IzinFindFirstOrThrowArgs} args - Arguments to find a Izin
     * @example
     * // Get one Izin
     * const izin = await prisma.izin.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends IzinFindFirstOrThrowArgs>(args?: SelectSubset<T, IzinFindFirstOrThrowArgs<ExtArgs>>): Prisma__IzinClient<$Result.GetResult<Prisma.$IzinPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Izins that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IzinFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Izins
     * const izins = await prisma.izin.findMany()
     * 
     * // Get first 10 Izins
     * const izins = await prisma.izin.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const izinWithIdOnly = await prisma.izin.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends IzinFindManyArgs>(args?: SelectSubset<T, IzinFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IzinPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Izin.
     * @param {IzinCreateArgs} args - Arguments to create a Izin.
     * @example
     * // Create one Izin
     * const Izin = await prisma.izin.create({
     *   data: {
     *     // ... data to create a Izin
     *   }
     * })
     * 
     */
    create<T extends IzinCreateArgs>(args: SelectSubset<T, IzinCreateArgs<ExtArgs>>): Prisma__IzinClient<$Result.GetResult<Prisma.$IzinPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Izins.
     * @param {IzinCreateManyArgs} args - Arguments to create many Izins.
     * @example
     * // Create many Izins
     * const izin = await prisma.izin.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends IzinCreateManyArgs>(args?: SelectSubset<T, IzinCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Izins and returns the data saved in the database.
     * @param {IzinCreateManyAndReturnArgs} args - Arguments to create many Izins.
     * @example
     * // Create many Izins
     * const izin = await prisma.izin.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Izins and only return the `id`
     * const izinWithIdOnly = await prisma.izin.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends IzinCreateManyAndReturnArgs>(args?: SelectSubset<T, IzinCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IzinPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Izin.
     * @param {IzinDeleteArgs} args - Arguments to delete one Izin.
     * @example
     * // Delete one Izin
     * const Izin = await prisma.izin.delete({
     *   where: {
     *     // ... filter to delete one Izin
     *   }
     * })
     * 
     */
    delete<T extends IzinDeleteArgs>(args: SelectSubset<T, IzinDeleteArgs<ExtArgs>>): Prisma__IzinClient<$Result.GetResult<Prisma.$IzinPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Izin.
     * @param {IzinUpdateArgs} args - Arguments to update one Izin.
     * @example
     * // Update one Izin
     * const izin = await prisma.izin.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends IzinUpdateArgs>(args: SelectSubset<T, IzinUpdateArgs<ExtArgs>>): Prisma__IzinClient<$Result.GetResult<Prisma.$IzinPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Izins.
     * @param {IzinDeleteManyArgs} args - Arguments to filter Izins to delete.
     * @example
     * // Delete a few Izins
     * const { count } = await prisma.izin.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends IzinDeleteManyArgs>(args?: SelectSubset<T, IzinDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Izins.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IzinUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Izins
     * const izin = await prisma.izin.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends IzinUpdateManyArgs>(args: SelectSubset<T, IzinUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Izin.
     * @param {IzinUpsertArgs} args - Arguments to update or create a Izin.
     * @example
     * // Update or create a Izin
     * const izin = await prisma.izin.upsert({
     *   create: {
     *     // ... data to create a Izin
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Izin we want to update
     *   }
     * })
     */
    upsert<T extends IzinUpsertArgs>(args: SelectSubset<T, IzinUpsertArgs<ExtArgs>>): Prisma__IzinClient<$Result.GetResult<Prisma.$IzinPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Izins.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IzinCountArgs} args - Arguments to filter Izins to count.
     * @example
     * // Count the number of Izins
     * const count = await prisma.izin.count({
     *   where: {
     *     // ... the filter for the Izins we want to count
     *   }
     * })
    **/
    count<T extends IzinCountArgs>(
      args?: Subset<T, IzinCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], IzinCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Izin.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IzinAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends IzinAggregateArgs>(args: Subset<T, IzinAggregateArgs>): Prisma.PrismaPromise<GetIzinAggregateType<T>>

    /**
     * Group by Izin.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IzinGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends IzinGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: IzinGroupByArgs['orderBy'] }
        : { orderBy?: IzinGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, IzinGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetIzinGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Izin model
   */
  readonly fields: IzinFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Izin.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__IzinClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    tenant<T extends TenantDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TenantDefaultArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    santri<T extends SantriDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SantriDefaultArgs<ExtArgs>>): Prisma__SantriClient<$Result.GetResult<Prisma.$SantriPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Izin model
   */ 
  interface IzinFieldRefs {
    readonly id: FieldRef<"Izin", 'String'>
    readonly tenantId: FieldRef<"Izin", 'String'>
    readonly santriId: FieldRef<"Izin", 'String'>
    readonly type: FieldRef<"Izin", 'String'>
    readonly reason: FieldRef<"Izin", 'String'>
    readonly startAt: FieldRef<"Izin", 'DateTime'>
    readonly endAt: FieldRef<"Izin", 'DateTime'>
    readonly status: FieldRef<"Izin", 'String'>
    readonly requestedBy: FieldRef<"Izin", 'String'>
    readonly approvedBy: FieldRef<"Izin", 'String'>
    readonly approvedAt: FieldRef<"Izin", 'DateTime'>
    readonly qrCodeData: FieldRef<"Izin", 'String'>
    readonly checkoutAt: FieldRef<"Izin", 'DateTime'>
    readonly checkoutBy: FieldRef<"Izin", 'String'>
    readonly checkinAt: FieldRef<"Izin", 'DateTime'>
    readonly checkinBy: FieldRef<"Izin", 'String'>
    readonly createdAt: FieldRef<"Izin", 'DateTime'>
    readonly updatedAt: FieldRef<"Izin", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Izin findUnique
   */
  export type IzinFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Izin
     */
    select?: IzinSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IzinInclude<ExtArgs> | null
    /**
     * Filter, which Izin to fetch.
     */
    where: IzinWhereUniqueInput
  }

  /**
   * Izin findUniqueOrThrow
   */
  export type IzinFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Izin
     */
    select?: IzinSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IzinInclude<ExtArgs> | null
    /**
     * Filter, which Izin to fetch.
     */
    where: IzinWhereUniqueInput
  }

  /**
   * Izin findFirst
   */
  export type IzinFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Izin
     */
    select?: IzinSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IzinInclude<ExtArgs> | null
    /**
     * Filter, which Izin to fetch.
     */
    where?: IzinWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Izins to fetch.
     */
    orderBy?: IzinOrderByWithRelationInput | IzinOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Izins.
     */
    cursor?: IzinWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Izins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Izins.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Izins.
     */
    distinct?: IzinScalarFieldEnum | IzinScalarFieldEnum[]
  }

  /**
   * Izin findFirstOrThrow
   */
  export type IzinFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Izin
     */
    select?: IzinSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IzinInclude<ExtArgs> | null
    /**
     * Filter, which Izin to fetch.
     */
    where?: IzinWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Izins to fetch.
     */
    orderBy?: IzinOrderByWithRelationInput | IzinOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Izins.
     */
    cursor?: IzinWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Izins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Izins.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Izins.
     */
    distinct?: IzinScalarFieldEnum | IzinScalarFieldEnum[]
  }

  /**
   * Izin findMany
   */
  export type IzinFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Izin
     */
    select?: IzinSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IzinInclude<ExtArgs> | null
    /**
     * Filter, which Izins to fetch.
     */
    where?: IzinWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Izins to fetch.
     */
    orderBy?: IzinOrderByWithRelationInput | IzinOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Izins.
     */
    cursor?: IzinWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Izins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Izins.
     */
    skip?: number
    distinct?: IzinScalarFieldEnum | IzinScalarFieldEnum[]
  }

  /**
   * Izin create
   */
  export type IzinCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Izin
     */
    select?: IzinSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IzinInclude<ExtArgs> | null
    /**
     * The data needed to create a Izin.
     */
    data: XOR<IzinCreateInput, IzinUncheckedCreateInput>
  }

  /**
   * Izin createMany
   */
  export type IzinCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Izins.
     */
    data: IzinCreateManyInput | IzinCreateManyInput[]
  }

  /**
   * Izin createManyAndReturn
   */
  export type IzinCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Izin
     */
    select?: IzinSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Izins.
     */
    data: IzinCreateManyInput | IzinCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IzinIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Izin update
   */
  export type IzinUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Izin
     */
    select?: IzinSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IzinInclude<ExtArgs> | null
    /**
     * The data needed to update a Izin.
     */
    data: XOR<IzinUpdateInput, IzinUncheckedUpdateInput>
    /**
     * Choose, which Izin to update.
     */
    where: IzinWhereUniqueInput
  }

  /**
   * Izin updateMany
   */
  export type IzinUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Izins.
     */
    data: XOR<IzinUpdateManyMutationInput, IzinUncheckedUpdateManyInput>
    /**
     * Filter which Izins to update
     */
    where?: IzinWhereInput
  }

  /**
   * Izin upsert
   */
  export type IzinUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Izin
     */
    select?: IzinSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IzinInclude<ExtArgs> | null
    /**
     * The filter to search for the Izin to update in case it exists.
     */
    where: IzinWhereUniqueInput
    /**
     * In case the Izin found by the `where` argument doesn't exist, create a new Izin with this data.
     */
    create: XOR<IzinCreateInput, IzinUncheckedCreateInput>
    /**
     * In case the Izin was found with the provided `where` argument, update it with this data.
     */
    update: XOR<IzinUpdateInput, IzinUncheckedUpdateInput>
  }

  /**
   * Izin delete
   */
  export type IzinDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Izin
     */
    select?: IzinSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IzinInclude<ExtArgs> | null
    /**
     * Filter which Izin to delete.
     */
    where: IzinWhereUniqueInput
  }

  /**
   * Izin deleteMany
   */
  export type IzinDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Izins to delete
     */
    where?: IzinWhereInput
  }

  /**
   * Izin without action
   */
  export type IzinDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Izin
     */
    select?: IzinSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IzinInclude<ExtArgs> | null
  }


  /**
   * Model CatatanHarian
   */

  export type AggregateCatatanHarian = {
    _count: CatatanHarianCountAggregateOutputType | null
    _min: CatatanHarianMinAggregateOutputType | null
    _max: CatatanHarianMaxAggregateOutputType | null
  }

  export type CatatanHarianMinAggregateOutputType = {
    id: string | null
    tenantId: string | null
    santriId: string | null
    authorId: string | null
    date: Date | null
    content: string | null
    category: string | null
    attachments: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CatatanHarianMaxAggregateOutputType = {
    id: string | null
    tenantId: string | null
    santriId: string | null
    authorId: string | null
    date: Date | null
    content: string | null
    category: string | null
    attachments: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CatatanHarianCountAggregateOutputType = {
    id: number
    tenantId: number
    santriId: number
    authorId: number
    date: number
    content: number
    category: number
    attachments: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CatatanHarianMinAggregateInputType = {
    id?: true
    tenantId?: true
    santriId?: true
    authorId?: true
    date?: true
    content?: true
    category?: true
    attachments?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CatatanHarianMaxAggregateInputType = {
    id?: true
    tenantId?: true
    santriId?: true
    authorId?: true
    date?: true
    content?: true
    category?: true
    attachments?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CatatanHarianCountAggregateInputType = {
    id?: true
    tenantId?: true
    santriId?: true
    authorId?: true
    date?: true
    content?: true
    category?: true
    attachments?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CatatanHarianAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CatatanHarian to aggregate.
     */
    where?: CatatanHarianWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CatatanHarians to fetch.
     */
    orderBy?: CatatanHarianOrderByWithRelationInput | CatatanHarianOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CatatanHarianWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CatatanHarians from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CatatanHarians.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CatatanHarians
    **/
    _count?: true | CatatanHarianCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CatatanHarianMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CatatanHarianMaxAggregateInputType
  }

  export type GetCatatanHarianAggregateType<T extends CatatanHarianAggregateArgs> = {
        [P in keyof T & keyof AggregateCatatanHarian]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCatatanHarian[P]>
      : GetScalarType<T[P], AggregateCatatanHarian[P]>
  }




  export type CatatanHarianGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CatatanHarianWhereInput
    orderBy?: CatatanHarianOrderByWithAggregationInput | CatatanHarianOrderByWithAggregationInput[]
    by: CatatanHarianScalarFieldEnum[] | CatatanHarianScalarFieldEnum
    having?: CatatanHarianScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CatatanHarianCountAggregateInputType | true
    _min?: CatatanHarianMinAggregateInputType
    _max?: CatatanHarianMaxAggregateInputType
  }

  export type CatatanHarianGroupByOutputType = {
    id: string
    tenantId: string
    santriId: string
    authorId: string
    date: Date
    content: string
    category: string
    attachments: string | null
    createdAt: Date
    updatedAt: Date
    _count: CatatanHarianCountAggregateOutputType | null
    _min: CatatanHarianMinAggregateOutputType | null
    _max: CatatanHarianMaxAggregateOutputType | null
  }

  type GetCatatanHarianGroupByPayload<T extends CatatanHarianGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CatatanHarianGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CatatanHarianGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CatatanHarianGroupByOutputType[P]>
            : GetScalarType<T[P], CatatanHarianGroupByOutputType[P]>
        }
      >
    >


  export type CatatanHarianSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    santriId?: boolean
    authorId?: boolean
    date?: boolean
    content?: boolean
    category?: boolean
    attachments?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    santri?: boolean | SantriDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["catatanHarian"]>

  export type CatatanHarianSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    santriId?: boolean
    authorId?: boolean
    date?: boolean
    content?: boolean
    category?: boolean
    attachments?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    santri?: boolean | SantriDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["catatanHarian"]>

  export type CatatanHarianSelectScalar = {
    id?: boolean
    tenantId?: boolean
    santriId?: boolean
    authorId?: boolean
    date?: boolean
    content?: boolean
    category?: boolean
    attachments?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CatatanHarianInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    santri?: boolean | SantriDefaultArgs<ExtArgs>
  }
  export type CatatanHarianIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    santri?: boolean | SantriDefaultArgs<ExtArgs>
  }

  export type $CatatanHarianPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CatatanHarian"
    objects: {
      tenant: Prisma.$TenantPayload<ExtArgs>
      santri: Prisma.$SantriPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      tenantId: string
      santriId: string
      authorId: string
      date: Date
      content: string
      category: string
      attachments: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["catatanHarian"]>
    composites: {}
  }

  type CatatanHarianGetPayload<S extends boolean | null | undefined | CatatanHarianDefaultArgs> = $Result.GetResult<Prisma.$CatatanHarianPayload, S>

  type CatatanHarianCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CatatanHarianFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CatatanHarianCountAggregateInputType | true
    }

  export interface CatatanHarianDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CatatanHarian'], meta: { name: 'CatatanHarian' } }
    /**
     * Find zero or one CatatanHarian that matches the filter.
     * @param {CatatanHarianFindUniqueArgs} args - Arguments to find a CatatanHarian
     * @example
     * // Get one CatatanHarian
     * const catatanHarian = await prisma.catatanHarian.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CatatanHarianFindUniqueArgs>(args: SelectSubset<T, CatatanHarianFindUniqueArgs<ExtArgs>>): Prisma__CatatanHarianClient<$Result.GetResult<Prisma.$CatatanHarianPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one CatatanHarian that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {CatatanHarianFindUniqueOrThrowArgs} args - Arguments to find a CatatanHarian
     * @example
     * // Get one CatatanHarian
     * const catatanHarian = await prisma.catatanHarian.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CatatanHarianFindUniqueOrThrowArgs>(args: SelectSubset<T, CatatanHarianFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CatatanHarianClient<$Result.GetResult<Prisma.$CatatanHarianPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first CatatanHarian that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CatatanHarianFindFirstArgs} args - Arguments to find a CatatanHarian
     * @example
     * // Get one CatatanHarian
     * const catatanHarian = await prisma.catatanHarian.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CatatanHarianFindFirstArgs>(args?: SelectSubset<T, CatatanHarianFindFirstArgs<ExtArgs>>): Prisma__CatatanHarianClient<$Result.GetResult<Prisma.$CatatanHarianPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first CatatanHarian that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CatatanHarianFindFirstOrThrowArgs} args - Arguments to find a CatatanHarian
     * @example
     * // Get one CatatanHarian
     * const catatanHarian = await prisma.catatanHarian.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CatatanHarianFindFirstOrThrowArgs>(args?: SelectSubset<T, CatatanHarianFindFirstOrThrowArgs<ExtArgs>>): Prisma__CatatanHarianClient<$Result.GetResult<Prisma.$CatatanHarianPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more CatatanHarians that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CatatanHarianFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CatatanHarians
     * const catatanHarians = await prisma.catatanHarian.findMany()
     * 
     * // Get first 10 CatatanHarians
     * const catatanHarians = await prisma.catatanHarian.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const catatanHarianWithIdOnly = await prisma.catatanHarian.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CatatanHarianFindManyArgs>(args?: SelectSubset<T, CatatanHarianFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CatatanHarianPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a CatatanHarian.
     * @param {CatatanHarianCreateArgs} args - Arguments to create a CatatanHarian.
     * @example
     * // Create one CatatanHarian
     * const CatatanHarian = await prisma.catatanHarian.create({
     *   data: {
     *     // ... data to create a CatatanHarian
     *   }
     * })
     * 
     */
    create<T extends CatatanHarianCreateArgs>(args: SelectSubset<T, CatatanHarianCreateArgs<ExtArgs>>): Prisma__CatatanHarianClient<$Result.GetResult<Prisma.$CatatanHarianPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many CatatanHarians.
     * @param {CatatanHarianCreateManyArgs} args - Arguments to create many CatatanHarians.
     * @example
     * // Create many CatatanHarians
     * const catatanHarian = await prisma.catatanHarian.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CatatanHarianCreateManyArgs>(args?: SelectSubset<T, CatatanHarianCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CatatanHarians and returns the data saved in the database.
     * @param {CatatanHarianCreateManyAndReturnArgs} args - Arguments to create many CatatanHarians.
     * @example
     * // Create many CatatanHarians
     * const catatanHarian = await prisma.catatanHarian.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CatatanHarians and only return the `id`
     * const catatanHarianWithIdOnly = await prisma.catatanHarian.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CatatanHarianCreateManyAndReturnArgs>(args?: SelectSubset<T, CatatanHarianCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CatatanHarianPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a CatatanHarian.
     * @param {CatatanHarianDeleteArgs} args - Arguments to delete one CatatanHarian.
     * @example
     * // Delete one CatatanHarian
     * const CatatanHarian = await prisma.catatanHarian.delete({
     *   where: {
     *     // ... filter to delete one CatatanHarian
     *   }
     * })
     * 
     */
    delete<T extends CatatanHarianDeleteArgs>(args: SelectSubset<T, CatatanHarianDeleteArgs<ExtArgs>>): Prisma__CatatanHarianClient<$Result.GetResult<Prisma.$CatatanHarianPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one CatatanHarian.
     * @param {CatatanHarianUpdateArgs} args - Arguments to update one CatatanHarian.
     * @example
     * // Update one CatatanHarian
     * const catatanHarian = await prisma.catatanHarian.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CatatanHarianUpdateArgs>(args: SelectSubset<T, CatatanHarianUpdateArgs<ExtArgs>>): Prisma__CatatanHarianClient<$Result.GetResult<Prisma.$CatatanHarianPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more CatatanHarians.
     * @param {CatatanHarianDeleteManyArgs} args - Arguments to filter CatatanHarians to delete.
     * @example
     * // Delete a few CatatanHarians
     * const { count } = await prisma.catatanHarian.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CatatanHarianDeleteManyArgs>(args?: SelectSubset<T, CatatanHarianDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CatatanHarians.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CatatanHarianUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CatatanHarians
     * const catatanHarian = await prisma.catatanHarian.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CatatanHarianUpdateManyArgs>(args: SelectSubset<T, CatatanHarianUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one CatatanHarian.
     * @param {CatatanHarianUpsertArgs} args - Arguments to update or create a CatatanHarian.
     * @example
     * // Update or create a CatatanHarian
     * const catatanHarian = await prisma.catatanHarian.upsert({
     *   create: {
     *     // ... data to create a CatatanHarian
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CatatanHarian we want to update
     *   }
     * })
     */
    upsert<T extends CatatanHarianUpsertArgs>(args: SelectSubset<T, CatatanHarianUpsertArgs<ExtArgs>>): Prisma__CatatanHarianClient<$Result.GetResult<Prisma.$CatatanHarianPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of CatatanHarians.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CatatanHarianCountArgs} args - Arguments to filter CatatanHarians to count.
     * @example
     * // Count the number of CatatanHarians
     * const count = await prisma.catatanHarian.count({
     *   where: {
     *     // ... the filter for the CatatanHarians we want to count
     *   }
     * })
    **/
    count<T extends CatatanHarianCountArgs>(
      args?: Subset<T, CatatanHarianCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CatatanHarianCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CatatanHarian.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CatatanHarianAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CatatanHarianAggregateArgs>(args: Subset<T, CatatanHarianAggregateArgs>): Prisma.PrismaPromise<GetCatatanHarianAggregateType<T>>

    /**
     * Group by CatatanHarian.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CatatanHarianGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CatatanHarianGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CatatanHarianGroupByArgs['orderBy'] }
        : { orderBy?: CatatanHarianGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CatatanHarianGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCatatanHarianGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CatatanHarian model
   */
  readonly fields: CatatanHarianFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CatatanHarian.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CatatanHarianClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    tenant<T extends TenantDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TenantDefaultArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    santri<T extends SantriDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SantriDefaultArgs<ExtArgs>>): Prisma__SantriClient<$Result.GetResult<Prisma.$SantriPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CatatanHarian model
   */ 
  interface CatatanHarianFieldRefs {
    readonly id: FieldRef<"CatatanHarian", 'String'>
    readonly tenantId: FieldRef<"CatatanHarian", 'String'>
    readonly santriId: FieldRef<"CatatanHarian", 'String'>
    readonly authorId: FieldRef<"CatatanHarian", 'String'>
    readonly date: FieldRef<"CatatanHarian", 'DateTime'>
    readonly content: FieldRef<"CatatanHarian", 'String'>
    readonly category: FieldRef<"CatatanHarian", 'String'>
    readonly attachments: FieldRef<"CatatanHarian", 'String'>
    readonly createdAt: FieldRef<"CatatanHarian", 'DateTime'>
    readonly updatedAt: FieldRef<"CatatanHarian", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CatatanHarian findUnique
   */
  export type CatatanHarianFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CatatanHarian
     */
    select?: CatatanHarianSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CatatanHarianInclude<ExtArgs> | null
    /**
     * Filter, which CatatanHarian to fetch.
     */
    where: CatatanHarianWhereUniqueInput
  }

  /**
   * CatatanHarian findUniqueOrThrow
   */
  export type CatatanHarianFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CatatanHarian
     */
    select?: CatatanHarianSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CatatanHarianInclude<ExtArgs> | null
    /**
     * Filter, which CatatanHarian to fetch.
     */
    where: CatatanHarianWhereUniqueInput
  }

  /**
   * CatatanHarian findFirst
   */
  export type CatatanHarianFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CatatanHarian
     */
    select?: CatatanHarianSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CatatanHarianInclude<ExtArgs> | null
    /**
     * Filter, which CatatanHarian to fetch.
     */
    where?: CatatanHarianWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CatatanHarians to fetch.
     */
    orderBy?: CatatanHarianOrderByWithRelationInput | CatatanHarianOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CatatanHarians.
     */
    cursor?: CatatanHarianWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CatatanHarians from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CatatanHarians.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CatatanHarians.
     */
    distinct?: CatatanHarianScalarFieldEnum | CatatanHarianScalarFieldEnum[]
  }

  /**
   * CatatanHarian findFirstOrThrow
   */
  export type CatatanHarianFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CatatanHarian
     */
    select?: CatatanHarianSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CatatanHarianInclude<ExtArgs> | null
    /**
     * Filter, which CatatanHarian to fetch.
     */
    where?: CatatanHarianWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CatatanHarians to fetch.
     */
    orderBy?: CatatanHarianOrderByWithRelationInput | CatatanHarianOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CatatanHarians.
     */
    cursor?: CatatanHarianWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CatatanHarians from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CatatanHarians.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CatatanHarians.
     */
    distinct?: CatatanHarianScalarFieldEnum | CatatanHarianScalarFieldEnum[]
  }

  /**
   * CatatanHarian findMany
   */
  export type CatatanHarianFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CatatanHarian
     */
    select?: CatatanHarianSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CatatanHarianInclude<ExtArgs> | null
    /**
     * Filter, which CatatanHarians to fetch.
     */
    where?: CatatanHarianWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CatatanHarians to fetch.
     */
    orderBy?: CatatanHarianOrderByWithRelationInput | CatatanHarianOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CatatanHarians.
     */
    cursor?: CatatanHarianWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CatatanHarians from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CatatanHarians.
     */
    skip?: number
    distinct?: CatatanHarianScalarFieldEnum | CatatanHarianScalarFieldEnum[]
  }

  /**
   * CatatanHarian create
   */
  export type CatatanHarianCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CatatanHarian
     */
    select?: CatatanHarianSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CatatanHarianInclude<ExtArgs> | null
    /**
     * The data needed to create a CatatanHarian.
     */
    data: XOR<CatatanHarianCreateInput, CatatanHarianUncheckedCreateInput>
  }

  /**
   * CatatanHarian createMany
   */
  export type CatatanHarianCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CatatanHarians.
     */
    data: CatatanHarianCreateManyInput | CatatanHarianCreateManyInput[]
  }

  /**
   * CatatanHarian createManyAndReturn
   */
  export type CatatanHarianCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CatatanHarian
     */
    select?: CatatanHarianSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many CatatanHarians.
     */
    data: CatatanHarianCreateManyInput | CatatanHarianCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CatatanHarianIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CatatanHarian update
   */
  export type CatatanHarianUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CatatanHarian
     */
    select?: CatatanHarianSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CatatanHarianInclude<ExtArgs> | null
    /**
     * The data needed to update a CatatanHarian.
     */
    data: XOR<CatatanHarianUpdateInput, CatatanHarianUncheckedUpdateInput>
    /**
     * Choose, which CatatanHarian to update.
     */
    where: CatatanHarianWhereUniqueInput
  }

  /**
   * CatatanHarian updateMany
   */
  export type CatatanHarianUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CatatanHarians.
     */
    data: XOR<CatatanHarianUpdateManyMutationInput, CatatanHarianUncheckedUpdateManyInput>
    /**
     * Filter which CatatanHarians to update
     */
    where?: CatatanHarianWhereInput
  }

  /**
   * CatatanHarian upsert
   */
  export type CatatanHarianUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CatatanHarian
     */
    select?: CatatanHarianSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CatatanHarianInclude<ExtArgs> | null
    /**
     * The filter to search for the CatatanHarian to update in case it exists.
     */
    where: CatatanHarianWhereUniqueInput
    /**
     * In case the CatatanHarian found by the `where` argument doesn't exist, create a new CatatanHarian with this data.
     */
    create: XOR<CatatanHarianCreateInput, CatatanHarianUncheckedCreateInput>
    /**
     * In case the CatatanHarian was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CatatanHarianUpdateInput, CatatanHarianUncheckedUpdateInput>
  }

  /**
   * CatatanHarian delete
   */
  export type CatatanHarianDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CatatanHarian
     */
    select?: CatatanHarianSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CatatanHarianInclude<ExtArgs> | null
    /**
     * Filter which CatatanHarian to delete.
     */
    where: CatatanHarianWhereUniqueInput
  }

  /**
   * CatatanHarian deleteMany
   */
  export type CatatanHarianDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CatatanHarians to delete
     */
    where?: CatatanHarianWhereInput
  }

  /**
   * CatatanHarian without action
   */
  export type CatatanHarianDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CatatanHarian
     */
    select?: CatatanHarianSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CatatanHarianInclude<ExtArgs> | null
  }


  /**
   * Model Pengumuman
   */

  export type AggregatePengumuman = {
    _count: PengumumanCountAggregateOutputType | null
    _min: PengumumanMinAggregateOutputType | null
    _max: PengumumanMaxAggregateOutputType | null
  }

  export type PengumumanMinAggregateOutputType = {
    id: string | null
    tenantId: string | null
    title: string | null
    content: string | null
    audience: string | null
    pinnedUntil: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PengumumanMaxAggregateOutputType = {
    id: string | null
    tenantId: string | null
    title: string | null
    content: string | null
    audience: string | null
    pinnedUntil: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PengumumanCountAggregateOutputType = {
    id: number
    tenantId: number
    title: number
    content: number
    audience: number
    pinnedUntil: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PengumumanMinAggregateInputType = {
    id?: true
    tenantId?: true
    title?: true
    content?: true
    audience?: true
    pinnedUntil?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PengumumanMaxAggregateInputType = {
    id?: true
    tenantId?: true
    title?: true
    content?: true
    audience?: true
    pinnedUntil?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PengumumanCountAggregateInputType = {
    id?: true
    tenantId?: true
    title?: true
    content?: true
    audience?: true
    pinnedUntil?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PengumumanAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Pengumuman to aggregate.
     */
    where?: PengumumanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Pengumumen to fetch.
     */
    orderBy?: PengumumanOrderByWithRelationInput | PengumumanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PengumumanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Pengumumen from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Pengumumen.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Pengumumen
    **/
    _count?: true | PengumumanCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PengumumanMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PengumumanMaxAggregateInputType
  }

  export type GetPengumumanAggregateType<T extends PengumumanAggregateArgs> = {
        [P in keyof T & keyof AggregatePengumuman]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePengumuman[P]>
      : GetScalarType<T[P], AggregatePengumuman[P]>
  }




  export type PengumumanGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PengumumanWhereInput
    orderBy?: PengumumanOrderByWithAggregationInput | PengumumanOrderByWithAggregationInput[]
    by: PengumumanScalarFieldEnum[] | PengumumanScalarFieldEnum
    having?: PengumumanScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PengumumanCountAggregateInputType | true
    _min?: PengumumanMinAggregateInputType
    _max?: PengumumanMaxAggregateInputType
  }

  export type PengumumanGroupByOutputType = {
    id: string
    tenantId: string
    title: string
    content: string
    audience: string
    pinnedUntil: Date | null
    createdAt: Date
    updatedAt: Date
    _count: PengumumanCountAggregateOutputType | null
    _min: PengumumanMinAggregateOutputType | null
    _max: PengumumanMaxAggregateOutputType | null
  }

  type GetPengumumanGroupByPayload<T extends PengumumanGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PengumumanGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PengumumanGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PengumumanGroupByOutputType[P]>
            : GetScalarType<T[P], PengumumanGroupByOutputType[P]>
        }
      >
    >


  export type PengumumanSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    title?: boolean
    content?: boolean
    audience?: boolean
    pinnedUntil?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["pengumuman"]>

  export type PengumumanSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    title?: boolean
    content?: boolean
    audience?: boolean
    pinnedUntil?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["pengumuman"]>

  export type PengumumanSelectScalar = {
    id?: boolean
    tenantId?: boolean
    title?: boolean
    content?: boolean
    audience?: boolean
    pinnedUntil?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PengumumanInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }
  export type PengumumanIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }

  export type $PengumumanPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Pengumuman"
    objects: {
      tenant: Prisma.$TenantPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      tenantId: string
      title: string
      content: string
      audience: string
      pinnedUntil: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["pengumuman"]>
    composites: {}
  }

  type PengumumanGetPayload<S extends boolean | null | undefined | PengumumanDefaultArgs> = $Result.GetResult<Prisma.$PengumumanPayload, S>

  type PengumumanCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<PengumumanFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PengumumanCountAggregateInputType | true
    }

  export interface PengumumanDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Pengumuman'], meta: { name: 'Pengumuman' } }
    /**
     * Find zero or one Pengumuman that matches the filter.
     * @param {PengumumanFindUniqueArgs} args - Arguments to find a Pengumuman
     * @example
     * // Get one Pengumuman
     * const pengumuman = await prisma.pengumuman.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PengumumanFindUniqueArgs>(args: SelectSubset<T, PengumumanFindUniqueArgs<ExtArgs>>): Prisma__PengumumanClient<$Result.GetResult<Prisma.$PengumumanPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Pengumuman that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {PengumumanFindUniqueOrThrowArgs} args - Arguments to find a Pengumuman
     * @example
     * // Get one Pengumuman
     * const pengumuman = await prisma.pengumuman.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PengumumanFindUniqueOrThrowArgs>(args: SelectSubset<T, PengumumanFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PengumumanClient<$Result.GetResult<Prisma.$PengumumanPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Pengumuman that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PengumumanFindFirstArgs} args - Arguments to find a Pengumuman
     * @example
     * // Get one Pengumuman
     * const pengumuman = await prisma.pengumuman.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PengumumanFindFirstArgs>(args?: SelectSubset<T, PengumumanFindFirstArgs<ExtArgs>>): Prisma__PengumumanClient<$Result.GetResult<Prisma.$PengumumanPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Pengumuman that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PengumumanFindFirstOrThrowArgs} args - Arguments to find a Pengumuman
     * @example
     * // Get one Pengumuman
     * const pengumuman = await prisma.pengumuman.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PengumumanFindFirstOrThrowArgs>(args?: SelectSubset<T, PengumumanFindFirstOrThrowArgs<ExtArgs>>): Prisma__PengumumanClient<$Result.GetResult<Prisma.$PengumumanPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Pengumumen that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PengumumanFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Pengumumen
     * const pengumumen = await prisma.pengumuman.findMany()
     * 
     * // Get first 10 Pengumumen
     * const pengumumen = await prisma.pengumuman.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const pengumumanWithIdOnly = await prisma.pengumuman.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PengumumanFindManyArgs>(args?: SelectSubset<T, PengumumanFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PengumumanPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Pengumuman.
     * @param {PengumumanCreateArgs} args - Arguments to create a Pengumuman.
     * @example
     * // Create one Pengumuman
     * const Pengumuman = await prisma.pengumuman.create({
     *   data: {
     *     // ... data to create a Pengumuman
     *   }
     * })
     * 
     */
    create<T extends PengumumanCreateArgs>(args: SelectSubset<T, PengumumanCreateArgs<ExtArgs>>): Prisma__PengumumanClient<$Result.GetResult<Prisma.$PengumumanPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Pengumumen.
     * @param {PengumumanCreateManyArgs} args - Arguments to create many Pengumumen.
     * @example
     * // Create many Pengumumen
     * const pengumuman = await prisma.pengumuman.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PengumumanCreateManyArgs>(args?: SelectSubset<T, PengumumanCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Pengumumen and returns the data saved in the database.
     * @param {PengumumanCreateManyAndReturnArgs} args - Arguments to create many Pengumumen.
     * @example
     * // Create many Pengumumen
     * const pengumuman = await prisma.pengumuman.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Pengumumen and only return the `id`
     * const pengumumanWithIdOnly = await prisma.pengumuman.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PengumumanCreateManyAndReturnArgs>(args?: SelectSubset<T, PengumumanCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PengumumanPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Pengumuman.
     * @param {PengumumanDeleteArgs} args - Arguments to delete one Pengumuman.
     * @example
     * // Delete one Pengumuman
     * const Pengumuman = await prisma.pengumuman.delete({
     *   where: {
     *     // ... filter to delete one Pengumuman
     *   }
     * })
     * 
     */
    delete<T extends PengumumanDeleteArgs>(args: SelectSubset<T, PengumumanDeleteArgs<ExtArgs>>): Prisma__PengumumanClient<$Result.GetResult<Prisma.$PengumumanPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Pengumuman.
     * @param {PengumumanUpdateArgs} args - Arguments to update one Pengumuman.
     * @example
     * // Update one Pengumuman
     * const pengumuman = await prisma.pengumuman.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PengumumanUpdateArgs>(args: SelectSubset<T, PengumumanUpdateArgs<ExtArgs>>): Prisma__PengumumanClient<$Result.GetResult<Prisma.$PengumumanPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Pengumumen.
     * @param {PengumumanDeleteManyArgs} args - Arguments to filter Pengumumen to delete.
     * @example
     * // Delete a few Pengumumen
     * const { count } = await prisma.pengumuman.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PengumumanDeleteManyArgs>(args?: SelectSubset<T, PengumumanDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Pengumumen.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PengumumanUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Pengumumen
     * const pengumuman = await prisma.pengumuman.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PengumumanUpdateManyArgs>(args: SelectSubset<T, PengumumanUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Pengumuman.
     * @param {PengumumanUpsertArgs} args - Arguments to update or create a Pengumuman.
     * @example
     * // Update or create a Pengumuman
     * const pengumuman = await prisma.pengumuman.upsert({
     *   create: {
     *     // ... data to create a Pengumuman
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Pengumuman we want to update
     *   }
     * })
     */
    upsert<T extends PengumumanUpsertArgs>(args: SelectSubset<T, PengumumanUpsertArgs<ExtArgs>>): Prisma__PengumumanClient<$Result.GetResult<Prisma.$PengumumanPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Pengumumen.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PengumumanCountArgs} args - Arguments to filter Pengumumen to count.
     * @example
     * // Count the number of Pengumumen
     * const count = await prisma.pengumuman.count({
     *   where: {
     *     // ... the filter for the Pengumumen we want to count
     *   }
     * })
    **/
    count<T extends PengumumanCountArgs>(
      args?: Subset<T, PengumumanCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PengumumanCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Pengumuman.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PengumumanAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PengumumanAggregateArgs>(args: Subset<T, PengumumanAggregateArgs>): Prisma.PrismaPromise<GetPengumumanAggregateType<T>>

    /**
     * Group by Pengumuman.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PengumumanGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PengumumanGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PengumumanGroupByArgs['orderBy'] }
        : { orderBy?: PengumumanGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PengumumanGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPengumumanGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Pengumuman model
   */
  readonly fields: PengumumanFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Pengumuman.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PengumumanClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    tenant<T extends TenantDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TenantDefaultArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Pengumuman model
   */ 
  interface PengumumanFieldRefs {
    readonly id: FieldRef<"Pengumuman", 'String'>
    readonly tenantId: FieldRef<"Pengumuman", 'String'>
    readonly title: FieldRef<"Pengumuman", 'String'>
    readonly content: FieldRef<"Pengumuman", 'String'>
    readonly audience: FieldRef<"Pengumuman", 'String'>
    readonly pinnedUntil: FieldRef<"Pengumuman", 'DateTime'>
    readonly createdAt: FieldRef<"Pengumuman", 'DateTime'>
    readonly updatedAt: FieldRef<"Pengumuman", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Pengumuman findUnique
   */
  export type PengumumanFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pengumuman
     */
    select?: PengumumanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PengumumanInclude<ExtArgs> | null
    /**
     * Filter, which Pengumuman to fetch.
     */
    where: PengumumanWhereUniqueInput
  }

  /**
   * Pengumuman findUniqueOrThrow
   */
  export type PengumumanFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pengumuman
     */
    select?: PengumumanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PengumumanInclude<ExtArgs> | null
    /**
     * Filter, which Pengumuman to fetch.
     */
    where: PengumumanWhereUniqueInput
  }

  /**
   * Pengumuman findFirst
   */
  export type PengumumanFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pengumuman
     */
    select?: PengumumanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PengumumanInclude<ExtArgs> | null
    /**
     * Filter, which Pengumuman to fetch.
     */
    where?: PengumumanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Pengumumen to fetch.
     */
    orderBy?: PengumumanOrderByWithRelationInput | PengumumanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Pengumumen.
     */
    cursor?: PengumumanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Pengumumen from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Pengumumen.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Pengumumen.
     */
    distinct?: PengumumanScalarFieldEnum | PengumumanScalarFieldEnum[]
  }

  /**
   * Pengumuman findFirstOrThrow
   */
  export type PengumumanFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pengumuman
     */
    select?: PengumumanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PengumumanInclude<ExtArgs> | null
    /**
     * Filter, which Pengumuman to fetch.
     */
    where?: PengumumanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Pengumumen to fetch.
     */
    orderBy?: PengumumanOrderByWithRelationInput | PengumumanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Pengumumen.
     */
    cursor?: PengumumanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Pengumumen from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Pengumumen.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Pengumumen.
     */
    distinct?: PengumumanScalarFieldEnum | PengumumanScalarFieldEnum[]
  }

  /**
   * Pengumuman findMany
   */
  export type PengumumanFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pengumuman
     */
    select?: PengumumanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PengumumanInclude<ExtArgs> | null
    /**
     * Filter, which Pengumumen to fetch.
     */
    where?: PengumumanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Pengumumen to fetch.
     */
    orderBy?: PengumumanOrderByWithRelationInput | PengumumanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Pengumumen.
     */
    cursor?: PengumumanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Pengumumen from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Pengumumen.
     */
    skip?: number
    distinct?: PengumumanScalarFieldEnum | PengumumanScalarFieldEnum[]
  }

  /**
   * Pengumuman create
   */
  export type PengumumanCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pengumuman
     */
    select?: PengumumanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PengumumanInclude<ExtArgs> | null
    /**
     * The data needed to create a Pengumuman.
     */
    data: XOR<PengumumanCreateInput, PengumumanUncheckedCreateInput>
  }

  /**
   * Pengumuman createMany
   */
  export type PengumumanCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Pengumumen.
     */
    data: PengumumanCreateManyInput | PengumumanCreateManyInput[]
  }

  /**
   * Pengumuman createManyAndReturn
   */
  export type PengumumanCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pengumuman
     */
    select?: PengumumanSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Pengumumen.
     */
    data: PengumumanCreateManyInput | PengumumanCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PengumumanIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Pengumuman update
   */
  export type PengumumanUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pengumuman
     */
    select?: PengumumanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PengumumanInclude<ExtArgs> | null
    /**
     * The data needed to update a Pengumuman.
     */
    data: XOR<PengumumanUpdateInput, PengumumanUncheckedUpdateInput>
    /**
     * Choose, which Pengumuman to update.
     */
    where: PengumumanWhereUniqueInput
  }

  /**
   * Pengumuman updateMany
   */
  export type PengumumanUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Pengumumen.
     */
    data: XOR<PengumumanUpdateManyMutationInput, PengumumanUncheckedUpdateManyInput>
    /**
     * Filter which Pengumumen to update
     */
    where?: PengumumanWhereInput
  }

  /**
   * Pengumuman upsert
   */
  export type PengumumanUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pengumuman
     */
    select?: PengumumanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PengumumanInclude<ExtArgs> | null
    /**
     * The filter to search for the Pengumuman to update in case it exists.
     */
    where: PengumumanWhereUniqueInput
    /**
     * In case the Pengumuman found by the `where` argument doesn't exist, create a new Pengumuman with this data.
     */
    create: XOR<PengumumanCreateInput, PengumumanUncheckedCreateInput>
    /**
     * In case the Pengumuman was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PengumumanUpdateInput, PengumumanUncheckedUpdateInput>
  }

  /**
   * Pengumuman delete
   */
  export type PengumumanDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pengumuman
     */
    select?: PengumumanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PengumumanInclude<ExtArgs> | null
    /**
     * Filter which Pengumuman to delete.
     */
    where: PengumumanWhereUniqueInput
  }

  /**
   * Pengumuman deleteMany
   */
  export type PengumumanDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Pengumumen to delete
     */
    where?: PengumumanWhereInput
  }

  /**
   * Pengumuman without action
   */
  export type PengumumanDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pengumuman
     */
    select?: PengumumanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PengumumanInclude<ExtArgs> | null
  }


  /**
   * Model Invoice
   */

  export type AggregateInvoice = {
    _count: InvoiceCountAggregateOutputType | null
    _avg: InvoiceAvgAggregateOutputType | null
    _sum: InvoiceSumAggregateOutputType | null
    _min: InvoiceMinAggregateOutputType | null
    _max: InvoiceMaxAggregateOutputType | null
  }

  export type InvoiceAvgAggregateOutputType = {
    amountDue: number | null
  }

  export type InvoiceSumAggregateOutputType = {
    amountDue: number | null
  }

  export type InvoiceMinAggregateOutputType = {
    id: string | null
    tenantId: string | null
    santriId: string | null
    amountDue: number | null
    dueDate: Date | null
    status: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type InvoiceMaxAggregateOutputType = {
    id: string | null
    tenantId: string | null
    santriId: string | null
    amountDue: number | null
    dueDate: Date | null
    status: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type InvoiceCountAggregateOutputType = {
    id: number
    tenantId: number
    santriId: number
    amountDue: number
    dueDate: number
    status: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type InvoiceAvgAggregateInputType = {
    amountDue?: true
  }

  export type InvoiceSumAggregateInputType = {
    amountDue?: true
  }

  export type InvoiceMinAggregateInputType = {
    id?: true
    tenantId?: true
    santriId?: true
    amountDue?: true
    dueDate?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type InvoiceMaxAggregateInputType = {
    id?: true
    tenantId?: true
    santriId?: true
    amountDue?: true
    dueDate?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type InvoiceCountAggregateInputType = {
    id?: true
    tenantId?: true
    santriId?: true
    amountDue?: true
    dueDate?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type InvoiceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Invoice to aggregate.
     */
    where?: InvoiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Invoices to fetch.
     */
    orderBy?: InvoiceOrderByWithRelationInput | InvoiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: InvoiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Invoices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Invoices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Invoices
    **/
    _count?: true | InvoiceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: InvoiceAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: InvoiceSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InvoiceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InvoiceMaxAggregateInputType
  }

  export type GetInvoiceAggregateType<T extends InvoiceAggregateArgs> = {
        [P in keyof T & keyof AggregateInvoice]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInvoice[P]>
      : GetScalarType<T[P], AggregateInvoice[P]>
  }




  export type InvoiceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InvoiceWhereInput
    orderBy?: InvoiceOrderByWithAggregationInput | InvoiceOrderByWithAggregationInput[]
    by: InvoiceScalarFieldEnum[] | InvoiceScalarFieldEnum
    having?: InvoiceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InvoiceCountAggregateInputType | true
    _avg?: InvoiceAvgAggregateInputType
    _sum?: InvoiceSumAggregateInputType
    _min?: InvoiceMinAggregateInputType
    _max?: InvoiceMaxAggregateInputType
  }

  export type InvoiceGroupByOutputType = {
    id: string
    tenantId: string
    santriId: string
    amountDue: number
    dueDate: Date
    status: string
    createdAt: Date
    updatedAt: Date
    _count: InvoiceCountAggregateOutputType | null
    _avg: InvoiceAvgAggregateOutputType | null
    _sum: InvoiceSumAggregateOutputType | null
    _min: InvoiceMinAggregateOutputType | null
    _max: InvoiceMaxAggregateOutputType | null
  }

  type GetInvoiceGroupByPayload<T extends InvoiceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<InvoiceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InvoiceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InvoiceGroupByOutputType[P]>
            : GetScalarType<T[P], InvoiceGroupByOutputType[P]>
        }
      >
    >


  export type InvoiceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    santriId?: boolean
    amountDue?: boolean
    dueDate?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    santri?: boolean | SantriDefaultArgs<ExtArgs>
    lines?: boolean | Invoice$linesArgs<ExtArgs>
    payments?: boolean | Invoice$paymentsArgs<ExtArgs>
    _count?: boolean | InvoiceCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["invoice"]>

  export type InvoiceSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    santriId?: boolean
    amountDue?: boolean
    dueDate?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    santri?: boolean | SantriDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["invoice"]>

  export type InvoiceSelectScalar = {
    id?: boolean
    tenantId?: boolean
    santriId?: boolean
    amountDue?: boolean
    dueDate?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type InvoiceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    santri?: boolean | SantriDefaultArgs<ExtArgs>
    lines?: boolean | Invoice$linesArgs<ExtArgs>
    payments?: boolean | Invoice$paymentsArgs<ExtArgs>
    _count?: boolean | InvoiceCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type InvoiceIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    santri?: boolean | SantriDefaultArgs<ExtArgs>
  }

  export type $InvoicePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Invoice"
    objects: {
      tenant: Prisma.$TenantPayload<ExtArgs>
      santri: Prisma.$SantriPayload<ExtArgs>
      lines: Prisma.$InvoiceLinePayload<ExtArgs>[]
      payments: Prisma.$PaymentPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      tenantId: string
      santriId: string
      amountDue: number
      dueDate: Date
      status: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["invoice"]>
    composites: {}
  }

  type InvoiceGetPayload<S extends boolean | null | undefined | InvoiceDefaultArgs> = $Result.GetResult<Prisma.$InvoicePayload, S>

  type InvoiceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<InvoiceFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: InvoiceCountAggregateInputType | true
    }

  export interface InvoiceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Invoice'], meta: { name: 'Invoice' } }
    /**
     * Find zero or one Invoice that matches the filter.
     * @param {InvoiceFindUniqueArgs} args - Arguments to find a Invoice
     * @example
     * // Get one Invoice
     * const invoice = await prisma.invoice.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends InvoiceFindUniqueArgs>(args: SelectSubset<T, InvoiceFindUniqueArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Invoice that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {InvoiceFindUniqueOrThrowArgs} args - Arguments to find a Invoice
     * @example
     * // Get one Invoice
     * const invoice = await prisma.invoice.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends InvoiceFindUniqueOrThrowArgs>(args: SelectSubset<T, InvoiceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Invoice that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceFindFirstArgs} args - Arguments to find a Invoice
     * @example
     * // Get one Invoice
     * const invoice = await prisma.invoice.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends InvoiceFindFirstArgs>(args?: SelectSubset<T, InvoiceFindFirstArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Invoice that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceFindFirstOrThrowArgs} args - Arguments to find a Invoice
     * @example
     * // Get one Invoice
     * const invoice = await prisma.invoice.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends InvoiceFindFirstOrThrowArgs>(args?: SelectSubset<T, InvoiceFindFirstOrThrowArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Invoices that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Invoices
     * const invoices = await prisma.invoice.findMany()
     * 
     * // Get first 10 Invoices
     * const invoices = await prisma.invoice.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const invoiceWithIdOnly = await prisma.invoice.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends InvoiceFindManyArgs>(args?: SelectSubset<T, InvoiceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Invoice.
     * @param {InvoiceCreateArgs} args - Arguments to create a Invoice.
     * @example
     * // Create one Invoice
     * const Invoice = await prisma.invoice.create({
     *   data: {
     *     // ... data to create a Invoice
     *   }
     * })
     * 
     */
    create<T extends InvoiceCreateArgs>(args: SelectSubset<T, InvoiceCreateArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Invoices.
     * @param {InvoiceCreateManyArgs} args - Arguments to create many Invoices.
     * @example
     * // Create many Invoices
     * const invoice = await prisma.invoice.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends InvoiceCreateManyArgs>(args?: SelectSubset<T, InvoiceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Invoices and returns the data saved in the database.
     * @param {InvoiceCreateManyAndReturnArgs} args - Arguments to create many Invoices.
     * @example
     * // Create many Invoices
     * const invoice = await prisma.invoice.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Invoices and only return the `id`
     * const invoiceWithIdOnly = await prisma.invoice.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends InvoiceCreateManyAndReturnArgs>(args?: SelectSubset<T, InvoiceCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Invoice.
     * @param {InvoiceDeleteArgs} args - Arguments to delete one Invoice.
     * @example
     * // Delete one Invoice
     * const Invoice = await prisma.invoice.delete({
     *   where: {
     *     // ... filter to delete one Invoice
     *   }
     * })
     * 
     */
    delete<T extends InvoiceDeleteArgs>(args: SelectSubset<T, InvoiceDeleteArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Invoice.
     * @param {InvoiceUpdateArgs} args - Arguments to update one Invoice.
     * @example
     * // Update one Invoice
     * const invoice = await prisma.invoice.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends InvoiceUpdateArgs>(args: SelectSubset<T, InvoiceUpdateArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Invoices.
     * @param {InvoiceDeleteManyArgs} args - Arguments to filter Invoices to delete.
     * @example
     * // Delete a few Invoices
     * const { count } = await prisma.invoice.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends InvoiceDeleteManyArgs>(args?: SelectSubset<T, InvoiceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Invoices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Invoices
     * const invoice = await prisma.invoice.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends InvoiceUpdateManyArgs>(args: SelectSubset<T, InvoiceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Invoice.
     * @param {InvoiceUpsertArgs} args - Arguments to update or create a Invoice.
     * @example
     * // Update or create a Invoice
     * const invoice = await prisma.invoice.upsert({
     *   create: {
     *     // ... data to create a Invoice
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Invoice we want to update
     *   }
     * })
     */
    upsert<T extends InvoiceUpsertArgs>(args: SelectSubset<T, InvoiceUpsertArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Invoices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceCountArgs} args - Arguments to filter Invoices to count.
     * @example
     * // Count the number of Invoices
     * const count = await prisma.invoice.count({
     *   where: {
     *     // ... the filter for the Invoices we want to count
     *   }
     * })
    **/
    count<T extends InvoiceCountArgs>(
      args?: Subset<T, InvoiceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InvoiceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Invoice.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InvoiceAggregateArgs>(args: Subset<T, InvoiceAggregateArgs>): Prisma.PrismaPromise<GetInvoiceAggregateType<T>>

    /**
     * Group by Invoice.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends InvoiceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: InvoiceGroupByArgs['orderBy'] }
        : { orderBy?: InvoiceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, InvoiceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInvoiceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Invoice model
   */
  readonly fields: InvoiceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Invoice.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__InvoiceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    tenant<T extends TenantDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TenantDefaultArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    santri<T extends SantriDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SantriDefaultArgs<ExtArgs>>): Prisma__SantriClient<$Result.GetResult<Prisma.$SantriPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    lines<T extends Invoice$linesArgs<ExtArgs> = {}>(args?: Subset<T, Invoice$linesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvoiceLinePayload<ExtArgs>, T, "findMany"> | Null>
    payments<T extends Invoice$paymentsArgs<ExtArgs> = {}>(args?: Subset<T, Invoice$paymentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Invoice model
   */ 
  interface InvoiceFieldRefs {
    readonly id: FieldRef<"Invoice", 'String'>
    readonly tenantId: FieldRef<"Invoice", 'String'>
    readonly santriId: FieldRef<"Invoice", 'String'>
    readonly amountDue: FieldRef<"Invoice", 'Float'>
    readonly dueDate: FieldRef<"Invoice", 'DateTime'>
    readonly status: FieldRef<"Invoice", 'String'>
    readonly createdAt: FieldRef<"Invoice", 'DateTime'>
    readonly updatedAt: FieldRef<"Invoice", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Invoice findUnique
   */
  export type InvoiceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * Filter, which Invoice to fetch.
     */
    where: InvoiceWhereUniqueInput
  }

  /**
   * Invoice findUniqueOrThrow
   */
  export type InvoiceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * Filter, which Invoice to fetch.
     */
    where: InvoiceWhereUniqueInput
  }

  /**
   * Invoice findFirst
   */
  export type InvoiceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * Filter, which Invoice to fetch.
     */
    where?: InvoiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Invoices to fetch.
     */
    orderBy?: InvoiceOrderByWithRelationInput | InvoiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Invoices.
     */
    cursor?: InvoiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Invoices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Invoices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Invoices.
     */
    distinct?: InvoiceScalarFieldEnum | InvoiceScalarFieldEnum[]
  }

  /**
   * Invoice findFirstOrThrow
   */
  export type InvoiceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * Filter, which Invoice to fetch.
     */
    where?: InvoiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Invoices to fetch.
     */
    orderBy?: InvoiceOrderByWithRelationInput | InvoiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Invoices.
     */
    cursor?: InvoiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Invoices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Invoices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Invoices.
     */
    distinct?: InvoiceScalarFieldEnum | InvoiceScalarFieldEnum[]
  }

  /**
   * Invoice findMany
   */
  export type InvoiceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * Filter, which Invoices to fetch.
     */
    where?: InvoiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Invoices to fetch.
     */
    orderBy?: InvoiceOrderByWithRelationInput | InvoiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Invoices.
     */
    cursor?: InvoiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Invoices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Invoices.
     */
    skip?: number
    distinct?: InvoiceScalarFieldEnum | InvoiceScalarFieldEnum[]
  }

  /**
   * Invoice create
   */
  export type InvoiceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * The data needed to create a Invoice.
     */
    data: XOR<InvoiceCreateInput, InvoiceUncheckedCreateInput>
  }

  /**
   * Invoice createMany
   */
  export type InvoiceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Invoices.
     */
    data: InvoiceCreateManyInput | InvoiceCreateManyInput[]
  }

  /**
   * Invoice createManyAndReturn
   */
  export type InvoiceCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Invoices.
     */
    data: InvoiceCreateManyInput | InvoiceCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Invoice update
   */
  export type InvoiceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * The data needed to update a Invoice.
     */
    data: XOR<InvoiceUpdateInput, InvoiceUncheckedUpdateInput>
    /**
     * Choose, which Invoice to update.
     */
    where: InvoiceWhereUniqueInput
  }

  /**
   * Invoice updateMany
   */
  export type InvoiceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Invoices.
     */
    data: XOR<InvoiceUpdateManyMutationInput, InvoiceUncheckedUpdateManyInput>
    /**
     * Filter which Invoices to update
     */
    where?: InvoiceWhereInput
  }

  /**
   * Invoice upsert
   */
  export type InvoiceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * The filter to search for the Invoice to update in case it exists.
     */
    where: InvoiceWhereUniqueInput
    /**
     * In case the Invoice found by the `where` argument doesn't exist, create a new Invoice with this data.
     */
    create: XOR<InvoiceCreateInput, InvoiceUncheckedCreateInput>
    /**
     * In case the Invoice was found with the provided `where` argument, update it with this data.
     */
    update: XOR<InvoiceUpdateInput, InvoiceUncheckedUpdateInput>
  }

  /**
   * Invoice delete
   */
  export type InvoiceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * Filter which Invoice to delete.
     */
    where: InvoiceWhereUniqueInput
  }

  /**
   * Invoice deleteMany
   */
  export type InvoiceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Invoices to delete
     */
    where?: InvoiceWhereInput
  }

  /**
   * Invoice.lines
   */
  export type Invoice$linesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceLine
     */
    select?: InvoiceLineSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceLineInclude<ExtArgs> | null
    where?: InvoiceLineWhereInput
    orderBy?: InvoiceLineOrderByWithRelationInput | InvoiceLineOrderByWithRelationInput[]
    cursor?: InvoiceLineWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InvoiceLineScalarFieldEnum | InvoiceLineScalarFieldEnum[]
  }

  /**
   * Invoice.payments
   */
  export type Invoice$paymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    where?: PaymentWhereInput
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    cursor?: PaymentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * Invoice without action
   */
  export type InvoiceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
  }


  /**
   * Model InvoiceLine
   */

  export type AggregateInvoiceLine = {
    _count: InvoiceLineCountAggregateOutputType | null
    _avg: InvoiceLineAvgAggregateOutputType | null
    _sum: InvoiceLineSumAggregateOutputType | null
    _min: InvoiceLineMinAggregateOutputType | null
    _max: InvoiceLineMaxAggregateOutputType | null
  }

  export type InvoiceLineAvgAggregateOutputType = {
    amount: number | null
  }

  export type InvoiceLineSumAggregateOutputType = {
    amount: number | null
  }

  export type InvoiceLineMinAggregateOutputType = {
    id: string | null
    invoiceId: string | null
    description: string | null
    amount: number | null
    type: string | null
  }

  export type InvoiceLineMaxAggregateOutputType = {
    id: string | null
    invoiceId: string | null
    description: string | null
    amount: number | null
    type: string | null
  }

  export type InvoiceLineCountAggregateOutputType = {
    id: number
    invoiceId: number
    description: number
    amount: number
    type: number
    _all: number
  }


  export type InvoiceLineAvgAggregateInputType = {
    amount?: true
  }

  export type InvoiceLineSumAggregateInputType = {
    amount?: true
  }

  export type InvoiceLineMinAggregateInputType = {
    id?: true
    invoiceId?: true
    description?: true
    amount?: true
    type?: true
  }

  export type InvoiceLineMaxAggregateInputType = {
    id?: true
    invoiceId?: true
    description?: true
    amount?: true
    type?: true
  }

  export type InvoiceLineCountAggregateInputType = {
    id?: true
    invoiceId?: true
    description?: true
    amount?: true
    type?: true
    _all?: true
  }

  export type InvoiceLineAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which InvoiceLine to aggregate.
     */
    where?: InvoiceLineWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InvoiceLines to fetch.
     */
    orderBy?: InvoiceLineOrderByWithRelationInput | InvoiceLineOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: InvoiceLineWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InvoiceLines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InvoiceLines.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned InvoiceLines
    **/
    _count?: true | InvoiceLineCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: InvoiceLineAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: InvoiceLineSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InvoiceLineMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InvoiceLineMaxAggregateInputType
  }

  export type GetInvoiceLineAggregateType<T extends InvoiceLineAggregateArgs> = {
        [P in keyof T & keyof AggregateInvoiceLine]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInvoiceLine[P]>
      : GetScalarType<T[P], AggregateInvoiceLine[P]>
  }




  export type InvoiceLineGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InvoiceLineWhereInput
    orderBy?: InvoiceLineOrderByWithAggregationInput | InvoiceLineOrderByWithAggregationInput[]
    by: InvoiceLineScalarFieldEnum[] | InvoiceLineScalarFieldEnum
    having?: InvoiceLineScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InvoiceLineCountAggregateInputType | true
    _avg?: InvoiceLineAvgAggregateInputType
    _sum?: InvoiceLineSumAggregateInputType
    _min?: InvoiceLineMinAggregateInputType
    _max?: InvoiceLineMaxAggregateInputType
  }

  export type InvoiceLineGroupByOutputType = {
    id: string
    invoiceId: string
    description: string
    amount: number
    type: string
    _count: InvoiceLineCountAggregateOutputType | null
    _avg: InvoiceLineAvgAggregateOutputType | null
    _sum: InvoiceLineSumAggregateOutputType | null
    _min: InvoiceLineMinAggregateOutputType | null
    _max: InvoiceLineMaxAggregateOutputType | null
  }

  type GetInvoiceLineGroupByPayload<T extends InvoiceLineGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<InvoiceLineGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InvoiceLineGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InvoiceLineGroupByOutputType[P]>
            : GetScalarType<T[P], InvoiceLineGroupByOutputType[P]>
        }
      >
    >


  export type InvoiceLineSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    invoiceId?: boolean
    description?: boolean
    amount?: boolean
    type?: boolean
    invoice?: boolean | InvoiceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["invoiceLine"]>

  export type InvoiceLineSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    invoiceId?: boolean
    description?: boolean
    amount?: boolean
    type?: boolean
    invoice?: boolean | InvoiceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["invoiceLine"]>

  export type InvoiceLineSelectScalar = {
    id?: boolean
    invoiceId?: boolean
    description?: boolean
    amount?: boolean
    type?: boolean
  }

  export type InvoiceLineInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    invoice?: boolean | InvoiceDefaultArgs<ExtArgs>
  }
  export type InvoiceLineIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    invoice?: boolean | InvoiceDefaultArgs<ExtArgs>
  }

  export type $InvoiceLinePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "InvoiceLine"
    objects: {
      invoice: Prisma.$InvoicePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      invoiceId: string
      description: string
      amount: number
      type: string
    }, ExtArgs["result"]["invoiceLine"]>
    composites: {}
  }

  type InvoiceLineGetPayload<S extends boolean | null | undefined | InvoiceLineDefaultArgs> = $Result.GetResult<Prisma.$InvoiceLinePayload, S>

  type InvoiceLineCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<InvoiceLineFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: InvoiceLineCountAggregateInputType | true
    }

  export interface InvoiceLineDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['InvoiceLine'], meta: { name: 'InvoiceLine' } }
    /**
     * Find zero or one InvoiceLine that matches the filter.
     * @param {InvoiceLineFindUniqueArgs} args - Arguments to find a InvoiceLine
     * @example
     * // Get one InvoiceLine
     * const invoiceLine = await prisma.invoiceLine.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends InvoiceLineFindUniqueArgs>(args: SelectSubset<T, InvoiceLineFindUniqueArgs<ExtArgs>>): Prisma__InvoiceLineClient<$Result.GetResult<Prisma.$InvoiceLinePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one InvoiceLine that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {InvoiceLineFindUniqueOrThrowArgs} args - Arguments to find a InvoiceLine
     * @example
     * // Get one InvoiceLine
     * const invoiceLine = await prisma.invoiceLine.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends InvoiceLineFindUniqueOrThrowArgs>(args: SelectSubset<T, InvoiceLineFindUniqueOrThrowArgs<ExtArgs>>): Prisma__InvoiceLineClient<$Result.GetResult<Prisma.$InvoiceLinePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first InvoiceLine that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceLineFindFirstArgs} args - Arguments to find a InvoiceLine
     * @example
     * // Get one InvoiceLine
     * const invoiceLine = await prisma.invoiceLine.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends InvoiceLineFindFirstArgs>(args?: SelectSubset<T, InvoiceLineFindFirstArgs<ExtArgs>>): Prisma__InvoiceLineClient<$Result.GetResult<Prisma.$InvoiceLinePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first InvoiceLine that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceLineFindFirstOrThrowArgs} args - Arguments to find a InvoiceLine
     * @example
     * // Get one InvoiceLine
     * const invoiceLine = await prisma.invoiceLine.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends InvoiceLineFindFirstOrThrowArgs>(args?: SelectSubset<T, InvoiceLineFindFirstOrThrowArgs<ExtArgs>>): Prisma__InvoiceLineClient<$Result.GetResult<Prisma.$InvoiceLinePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more InvoiceLines that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceLineFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all InvoiceLines
     * const invoiceLines = await prisma.invoiceLine.findMany()
     * 
     * // Get first 10 InvoiceLines
     * const invoiceLines = await prisma.invoiceLine.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const invoiceLineWithIdOnly = await prisma.invoiceLine.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends InvoiceLineFindManyArgs>(args?: SelectSubset<T, InvoiceLineFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvoiceLinePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a InvoiceLine.
     * @param {InvoiceLineCreateArgs} args - Arguments to create a InvoiceLine.
     * @example
     * // Create one InvoiceLine
     * const InvoiceLine = await prisma.invoiceLine.create({
     *   data: {
     *     // ... data to create a InvoiceLine
     *   }
     * })
     * 
     */
    create<T extends InvoiceLineCreateArgs>(args: SelectSubset<T, InvoiceLineCreateArgs<ExtArgs>>): Prisma__InvoiceLineClient<$Result.GetResult<Prisma.$InvoiceLinePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many InvoiceLines.
     * @param {InvoiceLineCreateManyArgs} args - Arguments to create many InvoiceLines.
     * @example
     * // Create many InvoiceLines
     * const invoiceLine = await prisma.invoiceLine.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends InvoiceLineCreateManyArgs>(args?: SelectSubset<T, InvoiceLineCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many InvoiceLines and returns the data saved in the database.
     * @param {InvoiceLineCreateManyAndReturnArgs} args - Arguments to create many InvoiceLines.
     * @example
     * // Create many InvoiceLines
     * const invoiceLine = await prisma.invoiceLine.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many InvoiceLines and only return the `id`
     * const invoiceLineWithIdOnly = await prisma.invoiceLine.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends InvoiceLineCreateManyAndReturnArgs>(args?: SelectSubset<T, InvoiceLineCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvoiceLinePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a InvoiceLine.
     * @param {InvoiceLineDeleteArgs} args - Arguments to delete one InvoiceLine.
     * @example
     * // Delete one InvoiceLine
     * const InvoiceLine = await prisma.invoiceLine.delete({
     *   where: {
     *     // ... filter to delete one InvoiceLine
     *   }
     * })
     * 
     */
    delete<T extends InvoiceLineDeleteArgs>(args: SelectSubset<T, InvoiceLineDeleteArgs<ExtArgs>>): Prisma__InvoiceLineClient<$Result.GetResult<Prisma.$InvoiceLinePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one InvoiceLine.
     * @param {InvoiceLineUpdateArgs} args - Arguments to update one InvoiceLine.
     * @example
     * // Update one InvoiceLine
     * const invoiceLine = await prisma.invoiceLine.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends InvoiceLineUpdateArgs>(args: SelectSubset<T, InvoiceLineUpdateArgs<ExtArgs>>): Prisma__InvoiceLineClient<$Result.GetResult<Prisma.$InvoiceLinePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more InvoiceLines.
     * @param {InvoiceLineDeleteManyArgs} args - Arguments to filter InvoiceLines to delete.
     * @example
     * // Delete a few InvoiceLines
     * const { count } = await prisma.invoiceLine.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends InvoiceLineDeleteManyArgs>(args?: SelectSubset<T, InvoiceLineDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more InvoiceLines.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceLineUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many InvoiceLines
     * const invoiceLine = await prisma.invoiceLine.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends InvoiceLineUpdateManyArgs>(args: SelectSubset<T, InvoiceLineUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one InvoiceLine.
     * @param {InvoiceLineUpsertArgs} args - Arguments to update or create a InvoiceLine.
     * @example
     * // Update or create a InvoiceLine
     * const invoiceLine = await prisma.invoiceLine.upsert({
     *   create: {
     *     // ... data to create a InvoiceLine
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the InvoiceLine we want to update
     *   }
     * })
     */
    upsert<T extends InvoiceLineUpsertArgs>(args: SelectSubset<T, InvoiceLineUpsertArgs<ExtArgs>>): Prisma__InvoiceLineClient<$Result.GetResult<Prisma.$InvoiceLinePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of InvoiceLines.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceLineCountArgs} args - Arguments to filter InvoiceLines to count.
     * @example
     * // Count the number of InvoiceLines
     * const count = await prisma.invoiceLine.count({
     *   where: {
     *     // ... the filter for the InvoiceLines we want to count
     *   }
     * })
    **/
    count<T extends InvoiceLineCountArgs>(
      args?: Subset<T, InvoiceLineCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InvoiceLineCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a InvoiceLine.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceLineAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InvoiceLineAggregateArgs>(args: Subset<T, InvoiceLineAggregateArgs>): Prisma.PrismaPromise<GetInvoiceLineAggregateType<T>>

    /**
     * Group by InvoiceLine.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceLineGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends InvoiceLineGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: InvoiceLineGroupByArgs['orderBy'] }
        : { orderBy?: InvoiceLineGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, InvoiceLineGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInvoiceLineGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the InvoiceLine model
   */
  readonly fields: InvoiceLineFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for InvoiceLine.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__InvoiceLineClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    invoice<T extends InvoiceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, InvoiceDefaultArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the InvoiceLine model
   */ 
  interface InvoiceLineFieldRefs {
    readonly id: FieldRef<"InvoiceLine", 'String'>
    readonly invoiceId: FieldRef<"InvoiceLine", 'String'>
    readonly description: FieldRef<"InvoiceLine", 'String'>
    readonly amount: FieldRef<"InvoiceLine", 'Float'>
    readonly type: FieldRef<"InvoiceLine", 'String'>
  }
    

  // Custom InputTypes
  /**
   * InvoiceLine findUnique
   */
  export type InvoiceLineFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceLine
     */
    select?: InvoiceLineSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceLineInclude<ExtArgs> | null
    /**
     * Filter, which InvoiceLine to fetch.
     */
    where: InvoiceLineWhereUniqueInput
  }

  /**
   * InvoiceLine findUniqueOrThrow
   */
  export type InvoiceLineFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceLine
     */
    select?: InvoiceLineSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceLineInclude<ExtArgs> | null
    /**
     * Filter, which InvoiceLine to fetch.
     */
    where: InvoiceLineWhereUniqueInput
  }

  /**
   * InvoiceLine findFirst
   */
  export type InvoiceLineFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceLine
     */
    select?: InvoiceLineSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceLineInclude<ExtArgs> | null
    /**
     * Filter, which InvoiceLine to fetch.
     */
    where?: InvoiceLineWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InvoiceLines to fetch.
     */
    orderBy?: InvoiceLineOrderByWithRelationInput | InvoiceLineOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for InvoiceLines.
     */
    cursor?: InvoiceLineWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InvoiceLines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InvoiceLines.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of InvoiceLines.
     */
    distinct?: InvoiceLineScalarFieldEnum | InvoiceLineScalarFieldEnum[]
  }

  /**
   * InvoiceLine findFirstOrThrow
   */
  export type InvoiceLineFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceLine
     */
    select?: InvoiceLineSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceLineInclude<ExtArgs> | null
    /**
     * Filter, which InvoiceLine to fetch.
     */
    where?: InvoiceLineWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InvoiceLines to fetch.
     */
    orderBy?: InvoiceLineOrderByWithRelationInput | InvoiceLineOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for InvoiceLines.
     */
    cursor?: InvoiceLineWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InvoiceLines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InvoiceLines.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of InvoiceLines.
     */
    distinct?: InvoiceLineScalarFieldEnum | InvoiceLineScalarFieldEnum[]
  }

  /**
   * InvoiceLine findMany
   */
  export type InvoiceLineFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceLine
     */
    select?: InvoiceLineSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceLineInclude<ExtArgs> | null
    /**
     * Filter, which InvoiceLines to fetch.
     */
    where?: InvoiceLineWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InvoiceLines to fetch.
     */
    orderBy?: InvoiceLineOrderByWithRelationInput | InvoiceLineOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing InvoiceLines.
     */
    cursor?: InvoiceLineWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InvoiceLines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InvoiceLines.
     */
    skip?: number
    distinct?: InvoiceLineScalarFieldEnum | InvoiceLineScalarFieldEnum[]
  }

  /**
   * InvoiceLine create
   */
  export type InvoiceLineCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceLine
     */
    select?: InvoiceLineSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceLineInclude<ExtArgs> | null
    /**
     * The data needed to create a InvoiceLine.
     */
    data: XOR<InvoiceLineCreateInput, InvoiceLineUncheckedCreateInput>
  }

  /**
   * InvoiceLine createMany
   */
  export type InvoiceLineCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many InvoiceLines.
     */
    data: InvoiceLineCreateManyInput | InvoiceLineCreateManyInput[]
  }

  /**
   * InvoiceLine createManyAndReturn
   */
  export type InvoiceLineCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceLine
     */
    select?: InvoiceLineSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many InvoiceLines.
     */
    data: InvoiceLineCreateManyInput | InvoiceLineCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceLineIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * InvoiceLine update
   */
  export type InvoiceLineUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceLine
     */
    select?: InvoiceLineSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceLineInclude<ExtArgs> | null
    /**
     * The data needed to update a InvoiceLine.
     */
    data: XOR<InvoiceLineUpdateInput, InvoiceLineUncheckedUpdateInput>
    /**
     * Choose, which InvoiceLine to update.
     */
    where: InvoiceLineWhereUniqueInput
  }

  /**
   * InvoiceLine updateMany
   */
  export type InvoiceLineUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update InvoiceLines.
     */
    data: XOR<InvoiceLineUpdateManyMutationInput, InvoiceLineUncheckedUpdateManyInput>
    /**
     * Filter which InvoiceLines to update
     */
    where?: InvoiceLineWhereInput
  }

  /**
   * InvoiceLine upsert
   */
  export type InvoiceLineUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceLine
     */
    select?: InvoiceLineSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceLineInclude<ExtArgs> | null
    /**
     * The filter to search for the InvoiceLine to update in case it exists.
     */
    where: InvoiceLineWhereUniqueInput
    /**
     * In case the InvoiceLine found by the `where` argument doesn't exist, create a new InvoiceLine with this data.
     */
    create: XOR<InvoiceLineCreateInput, InvoiceLineUncheckedCreateInput>
    /**
     * In case the InvoiceLine was found with the provided `where` argument, update it with this data.
     */
    update: XOR<InvoiceLineUpdateInput, InvoiceLineUncheckedUpdateInput>
  }

  /**
   * InvoiceLine delete
   */
  export type InvoiceLineDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceLine
     */
    select?: InvoiceLineSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceLineInclude<ExtArgs> | null
    /**
     * Filter which InvoiceLine to delete.
     */
    where: InvoiceLineWhereUniqueInput
  }

  /**
   * InvoiceLine deleteMany
   */
  export type InvoiceLineDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which InvoiceLines to delete
     */
    where?: InvoiceLineWhereInput
  }

  /**
   * InvoiceLine without action
   */
  export type InvoiceLineDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceLine
     */
    select?: InvoiceLineSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceLineInclude<ExtArgs> | null
  }


  /**
   * Model Payment
   */

  export type AggregatePayment = {
    _count: PaymentCountAggregateOutputType | null
    _avg: PaymentAvgAggregateOutputType | null
    _sum: PaymentSumAggregateOutputType | null
    _min: PaymentMinAggregateOutputType | null
    _max: PaymentMaxAggregateOutputType | null
  }

  export type PaymentAvgAggregateOutputType = {
    amount: number | null
  }

  export type PaymentSumAggregateOutputType = {
    amount: number | null
  }

  export type PaymentMinAggregateOutputType = {
    id: string | null
    invoiceId: string | null
    method: string | null
    amount: number | null
    status: string | null
    transactionRef: string | null
    paidAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PaymentMaxAggregateOutputType = {
    id: string | null
    invoiceId: string | null
    method: string | null
    amount: number | null
    status: string | null
    transactionRef: string | null
    paidAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PaymentCountAggregateOutputType = {
    id: number
    invoiceId: number
    method: number
    amount: number
    status: number
    transactionRef: number
    paidAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PaymentAvgAggregateInputType = {
    amount?: true
  }

  export type PaymentSumAggregateInputType = {
    amount?: true
  }

  export type PaymentMinAggregateInputType = {
    id?: true
    invoiceId?: true
    method?: true
    amount?: true
    status?: true
    transactionRef?: true
    paidAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PaymentMaxAggregateInputType = {
    id?: true
    invoiceId?: true
    method?: true
    amount?: true
    status?: true
    transactionRef?: true
    paidAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PaymentCountAggregateInputType = {
    id?: true
    invoiceId?: true
    method?: true
    amount?: true
    status?: true
    transactionRef?: true
    paidAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PaymentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Payment to aggregate.
     */
    where?: PaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payments to fetch.
     */
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Payments
    **/
    _count?: true | PaymentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PaymentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PaymentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PaymentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PaymentMaxAggregateInputType
  }

  export type GetPaymentAggregateType<T extends PaymentAggregateArgs> = {
        [P in keyof T & keyof AggregatePayment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePayment[P]>
      : GetScalarType<T[P], AggregatePayment[P]>
  }




  export type PaymentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PaymentWhereInput
    orderBy?: PaymentOrderByWithAggregationInput | PaymentOrderByWithAggregationInput[]
    by: PaymentScalarFieldEnum[] | PaymentScalarFieldEnum
    having?: PaymentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PaymentCountAggregateInputType | true
    _avg?: PaymentAvgAggregateInputType
    _sum?: PaymentSumAggregateInputType
    _min?: PaymentMinAggregateInputType
    _max?: PaymentMaxAggregateInputType
  }

  export type PaymentGroupByOutputType = {
    id: string
    invoiceId: string
    method: string
    amount: number
    status: string
    transactionRef: string | null
    paidAt: Date | null
    createdAt: Date
    updatedAt: Date
    _count: PaymentCountAggregateOutputType | null
    _avg: PaymentAvgAggregateOutputType | null
    _sum: PaymentSumAggregateOutputType | null
    _min: PaymentMinAggregateOutputType | null
    _max: PaymentMaxAggregateOutputType | null
  }

  type GetPaymentGroupByPayload<T extends PaymentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PaymentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PaymentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PaymentGroupByOutputType[P]>
            : GetScalarType<T[P], PaymentGroupByOutputType[P]>
        }
      >
    >


  export type PaymentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    invoiceId?: boolean
    method?: boolean
    amount?: boolean
    status?: boolean
    transactionRef?: boolean
    paidAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    invoice?: boolean | InvoiceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["payment"]>

  export type PaymentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    invoiceId?: boolean
    method?: boolean
    amount?: boolean
    status?: boolean
    transactionRef?: boolean
    paidAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    invoice?: boolean | InvoiceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["payment"]>

  export type PaymentSelectScalar = {
    id?: boolean
    invoiceId?: boolean
    method?: boolean
    amount?: boolean
    status?: boolean
    transactionRef?: boolean
    paidAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PaymentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    invoice?: boolean | InvoiceDefaultArgs<ExtArgs>
  }
  export type PaymentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    invoice?: boolean | InvoiceDefaultArgs<ExtArgs>
  }

  export type $PaymentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Payment"
    objects: {
      invoice: Prisma.$InvoicePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      invoiceId: string
      method: string
      amount: number
      status: string
      transactionRef: string | null
      paidAt: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["payment"]>
    composites: {}
  }

  type PaymentGetPayload<S extends boolean | null | undefined | PaymentDefaultArgs> = $Result.GetResult<Prisma.$PaymentPayload, S>

  type PaymentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<PaymentFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PaymentCountAggregateInputType | true
    }

  export interface PaymentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Payment'], meta: { name: 'Payment' } }
    /**
     * Find zero or one Payment that matches the filter.
     * @param {PaymentFindUniqueArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PaymentFindUniqueArgs>(args: SelectSubset<T, PaymentFindUniqueArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Payment that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {PaymentFindUniqueOrThrowArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PaymentFindUniqueOrThrowArgs>(args: SelectSubset<T, PaymentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Payment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentFindFirstArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PaymentFindFirstArgs>(args?: SelectSubset<T, PaymentFindFirstArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Payment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentFindFirstOrThrowArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PaymentFindFirstOrThrowArgs>(args?: SelectSubset<T, PaymentFindFirstOrThrowArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Payments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Payments
     * const payments = await prisma.payment.findMany()
     * 
     * // Get first 10 Payments
     * const payments = await prisma.payment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const paymentWithIdOnly = await prisma.payment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PaymentFindManyArgs>(args?: SelectSubset<T, PaymentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Payment.
     * @param {PaymentCreateArgs} args - Arguments to create a Payment.
     * @example
     * // Create one Payment
     * const Payment = await prisma.payment.create({
     *   data: {
     *     // ... data to create a Payment
     *   }
     * })
     * 
     */
    create<T extends PaymentCreateArgs>(args: SelectSubset<T, PaymentCreateArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Payments.
     * @param {PaymentCreateManyArgs} args - Arguments to create many Payments.
     * @example
     * // Create many Payments
     * const payment = await prisma.payment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PaymentCreateManyArgs>(args?: SelectSubset<T, PaymentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Payments and returns the data saved in the database.
     * @param {PaymentCreateManyAndReturnArgs} args - Arguments to create many Payments.
     * @example
     * // Create many Payments
     * const payment = await prisma.payment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Payments and only return the `id`
     * const paymentWithIdOnly = await prisma.payment.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PaymentCreateManyAndReturnArgs>(args?: SelectSubset<T, PaymentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Payment.
     * @param {PaymentDeleteArgs} args - Arguments to delete one Payment.
     * @example
     * // Delete one Payment
     * const Payment = await prisma.payment.delete({
     *   where: {
     *     // ... filter to delete one Payment
     *   }
     * })
     * 
     */
    delete<T extends PaymentDeleteArgs>(args: SelectSubset<T, PaymentDeleteArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Payment.
     * @param {PaymentUpdateArgs} args - Arguments to update one Payment.
     * @example
     * // Update one Payment
     * const payment = await prisma.payment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PaymentUpdateArgs>(args: SelectSubset<T, PaymentUpdateArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Payments.
     * @param {PaymentDeleteManyArgs} args - Arguments to filter Payments to delete.
     * @example
     * // Delete a few Payments
     * const { count } = await prisma.payment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PaymentDeleteManyArgs>(args?: SelectSubset<T, PaymentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Payments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Payments
     * const payment = await prisma.payment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PaymentUpdateManyArgs>(args: SelectSubset<T, PaymentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Payment.
     * @param {PaymentUpsertArgs} args - Arguments to update or create a Payment.
     * @example
     * // Update or create a Payment
     * const payment = await prisma.payment.upsert({
     *   create: {
     *     // ... data to create a Payment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Payment we want to update
     *   }
     * })
     */
    upsert<T extends PaymentUpsertArgs>(args: SelectSubset<T, PaymentUpsertArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Payments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentCountArgs} args - Arguments to filter Payments to count.
     * @example
     * // Count the number of Payments
     * const count = await prisma.payment.count({
     *   where: {
     *     // ... the filter for the Payments we want to count
     *   }
     * })
    **/
    count<T extends PaymentCountArgs>(
      args?: Subset<T, PaymentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PaymentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Payment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PaymentAggregateArgs>(args: Subset<T, PaymentAggregateArgs>): Prisma.PrismaPromise<GetPaymentAggregateType<T>>

    /**
     * Group by Payment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PaymentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PaymentGroupByArgs['orderBy'] }
        : { orderBy?: PaymentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PaymentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPaymentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Payment model
   */
  readonly fields: PaymentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Payment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PaymentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    invoice<T extends InvoiceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, InvoiceDefaultArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Payment model
   */ 
  interface PaymentFieldRefs {
    readonly id: FieldRef<"Payment", 'String'>
    readonly invoiceId: FieldRef<"Payment", 'String'>
    readonly method: FieldRef<"Payment", 'String'>
    readonly amount: FieldRef<"Payment", 'Float'>
    readonly status: FieldRef<"Payment", 'String'>
    readonly transactionRef: FieldRef<"Payment", 'String'>
    readonly paidAt: FieldRef<"Payment", 'DateTime'>
    readonly createdAt: FieldRef<"Payment", 'DateTime'>
    readonly updatedAt: FieldRef<"Payment", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Payment findUnique
   */
  export type PaymentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payment to fetch.
     */
    where: PaymentWhereUniqueInput
  }

  /**
   * Payment findUniqueOrThrow
   */
  export type PaymentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payment to fetch.
     */
    where: PaymentWhereUniqueInput
  }

  /**
   * Payment findFirst
   */
  export type PaymentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payment to fetch.
     */
    where?: PaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payments to fetch.
     */
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Payments.
     */
    cursor?: PaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Payments.
     */
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * Payment findFirstOrThrow
   */
  export type PaymentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payment to fetch.
     */
    where?: PaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payments to fetch.
     */
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Payments.
     */
    cursor?: PaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Payments.
     */
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * Payment findMany
   */
  export type PaymentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payments to fetch.
     */
    where?: PaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payments to fetch.
     */
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Payments.
     */
    cursor?: PaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payments.
     */
    skip?: number
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * Payment create
   */
  export type PaymentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * The data needed to create a Payment.
     */
    data: XOR<PaymentCreateInput, PaymentUncheckedCreateInput>
  }

  /**
   * Payment createMany
   */
  export type PaymentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Payments.
     */
    data: PaymentCreateManyInput | PaymentCreateManyInput[]
  }

  /**
   * Payment createManyAndReturn
   */
  export type PaymentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Payments.
     */
    data: PaymentCreateManyInput | PaymentCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Payment update
   */
  export type PaymentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * The data needed to update a Payment.
     */
    data: XOR<PaymentUpdateInput, PaymentUncheckedUpdateInput>
    /**
     * Choose, which Payment to update.
     */
    where: PaymentWhereUniqueInput
  }

  /**
   * Payment updateMany
   */
  export type PaymentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Payments.
     */
    data: XOR<PaymentUpdateManyMutationInput, PaymentUncheckedUpdateManyInput>
    /**
     * Filter which Payments to update
     */
    where?: PaymentWhereInput
  }

  /**
   * Payment upsert
   */
  export type PaymentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * The filter to search for the Payment to update in case it exists.
     */
    where: PaymentWhereUniqueInput
    /**
     * In case the Payment found by the `where` argument doesn't exist, create a new Payment with this data.
     */
    create: XOR<PaymentCreateInput, PaymentUncheckedCreateInput>
    /**
     * In case the Payment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PaymentUpdateInput, PaymentUncheckedUpdateInput>
  }

  /**
   * Payment delete
   */
  export type PaymentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter which Payment to delete.
     */
    where: PaymentWhereUniqueInput
  }

  /**
   * Payment deleteMany
   */
  export type PaymentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Payments to delete
     */
    where?: PaymentWhereInput
  }

  /**
   * Payment without action
   */
  export type PaymentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
  }


  /**
   * Model Pelanggaran
   */

  export type AggregatePelanggaran = {
    _count: PelanggaranCountAggregateOutputType | null
    _avg: PelanggaranAvgAggregateOutputType | null
    _sum: PelanggaranSumAggregateOutputType | null
    _min: PelanggaranMinAggregateOutputType | null
    _max: PelanggaranMaxAggregateOutputType | null
  }

  export type PelanggaranAvgAggregateOutputType = {
    severity: number | null
    points: number | null
  }

  export type PelanggaranSumAggregateOutputType = {
    severity: number | null
    points: number | null
  }

  export type PelanggaranMinAggregateOutputType = {
    id: string | null
    tenantId: string | null
    santriId: string | null
    recordedBy: string | null
    category: string | null
    severity: number | null
    points: number | null
    description: string | null
    date: Date | null
    resolved: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PelanggaranMaxAggregateOutputType = {
    id: string | null
    tenantId: string | null
    santriId: string | null
    recordedBy: string | null
    category: string | null
    severity: number | null
    points: number | null
    description: string | null
    date: Date | null
    resolved: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PelanggaranCountAggregateOutputType = {
    id: number
    tenantId: number
    santriId: number
    recordedBy: number
    category: number
    severity: number
    points: number
    description: number
    date: number
    resolved: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PelanggaranAvgAggregateInputType = {
    severity?: true
    points?: true
  }

  export type PelanggaranSumAggregateInputType = {
    severity?: true
    points?: true
  }

  export type PelanggaranMinAggregateInputType = {
    id?: true
    tenantId?: true
    santriId?: true
    recordedBy?: true
    category?: true
    severity?: true
    points?: true
    description?: true
    date?: true
    resolved?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PelanggaranMaxAggregateInputType = {
    id?: true
    tenantId?: true
    santriId?: true
    recordedBy?: true
    category?: true
    severity?: true
    points?: true
    description?: true
    date?: true
    resolved?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PelanggaranCountAggregateInputType = {
    id?: true
    tenantId?: true
    santriId?: true
    recordedBy?: true
    category?: true
    severity?: true
    points?: true
    description?: true
    date?: true
    resolved?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PelanggaranAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Pelanggaran to aggregate.
     */
    where?: PelanggaranWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Pelanggarans to fetch.
     */
    orderBy?: PelanggaranOrderByWithRelationInput | PelanggaranOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PelanggaranWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Pelanggarans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Pelanggarans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Pelanggarans
    **/
    _count?: true | PelanggaranCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PelanggaranAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PelanggaranSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PelanggaranMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PelanggaranMaxAggregateInputType
  }

  export type GetPelanggaranAggregateType<T extends PelanggaranAggregateArgs> = {
        [P in keyof T & keyof AggregatePelanggaran]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePelanggaran[P]>
      : GetScalarType<T[P], AggregatePelanggaran[P]>
  }




  export type PelanggaranGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PelanggaranWhereInput
    orderBy?: PelanggaranOrderByWithAggregationInput | PelanggaranOrderByWithAggregationInput[]
    by: PelanggaranScalarFieldEnum[] | PelanggaranScalarFieldEnum
    having?: PelanggaranScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PelanggaranCountAggregateInputType | true
    _avg?: PelanggaranAvgAggregateInputType
    _sum?: PelanggaranSumAggregateInputType
    _min?: PelanggaranMinAggregateInputType
    _max?: PelanggaranMaxAggregateInputType
  }

  export type PelanggaranGroupByOutputType = {
    id: string
    tenantId: string
    santriId: string
    recordedBy: string
    category: string
    severity: number
    points: number
    description: string
    date: Date
    resolved: boolean
    createdAt: Date
    updatedAt: Date
    _count: PelanggaranCountAggregateOutputType | null
    _avg: PelanggaranAvgAggregateOutputType | null
    _sum: PelanggaranSumAggregateOutputType | null
    _min: PelanggaranMinAggregateOutputType | null
    _max: PelanggaranMaxAggregateOutputType | null
  }

  type GetPelanggaranGroupByPayload<T extends PelanggaranGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PelanggaranGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PelanggaranGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PelanggaranGroupByOutputType[P]>
            : GetScalarType<T[P], PelanggaranGroupByOutputType[P]>
        }
      >
    >


  export type PelanggaranSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    santriId?: boolean
    recordedBy?: boolean
    category?: boolean
    severity?: boolean
    points?: boolean
    description?: boolean
    date?: boolean
    resolved?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    santri?: boolean | SantriDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["pelanggaran"]>

  export type PelanggaranSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    santriId?: boolean
    recordedBy?: boolean
    category?: boolean
    severity?: boolean
    points?: boolean
    description?: boolean
    date?: boolean
    resolved?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    santri?: boolean | SantriDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["pelanggaran"]>

  export type PelanggaranSelectScalar = {
    id?: boolean
    tenantId?: boolean
    santriId?: boolean
    recordedBy?: boolean
    category?: boolean
    severity?: boolean
    points?: boolean
    description?: boolean
    date?: boolean
    resolved?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PelanggaranInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    santri?: boolean | SantriDefaultArgs<ExtArgs>
  }
  export type PelanggaranIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    santri?: boolean | SantriDefaultArgs<ExtArgs>
  }

  export type $PelanggaranPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Pelanggaran"
    objects: {
      tenant: Prisma.$TenantPayload<ExtArgs>
      santri: Prisma.$SantriPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      tenantId: string
      santriId: string
      recordedBy: string
      category: string
      severity: number
      points: number
      description: string
      date: Date
      resolved: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["pelanggaran"]>
    composites: {}
  }

  type PelanggaranGetPayload<S extends boolean | null | undefined | PelanggaranDefaultArgs> = $Result.GetResult<Prisma.$PelanggaranPayload, S>

  type PelanggaranCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<PelanggaranFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PelanggaranCountAggregateInputType | true
    }

  export interface PelanggaranDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Pelanggaran'], meta: { name: 'Pelanggaran' } }
    /**
     * Find zero or one Pelanggaran that matches the filter.
     * @param {PelanggaranFindUniqueArgs} args - Arguments to find a Pelanggaran
     * @example
     * // Get one Pelanggaran
     * const pelanggaran = await prisma.pelanggaran.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PelanggaranFindUniqueArgs>(args: SelectSubset<T, PelanggaranFindUniqueArgs<ExtArgs>>): Prisma__PelanggaranClient<$Result.GetResult<Prisma.$PelanggaranPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Pelanggaran that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {PelanggaranFindUniqueOrThrowArgs} args - Arguments to find a Pelanggaran
     * @example
     * // Get one Pelanggaran
     * const pelanggaran = await prisma.pelanggaran.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PelanggaranFindUniqueOrThrowArgs>(args: SelectSubset<T, PelanggaranFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PelanggaranClient<$Result.GetResult<Prisma.$PelanggaranPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Pelanggaran that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PelanggaranFindFirstArgs} args - Arguments to find a Pelanggaran
     * @example
     * // Get one Pelanggaran
     * const pelanggaran = await prisma.pelanggaran.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PelanggaranFindFirstArgs>(args?: SelectSubset<T, PelanggaranFindFirstArgs<ExtArgs>>): Prisma__PelanggaranClient<$Result.GetResult<Prisma.$PelanggaranPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Pelanggaran that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PelanggaranFindFirstOrThrowArgs} args - Arguments to find a Pelanggaran
     * @example
     * // Get one Pelanggaran
     * const pelanggaran = await prisma.pelanggaran.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PelanggaranFindFirstOrThrowArgs>(args?: SelectSubset<T, PelanggaranFindFirstOrThrowArgs<ExtArgs>>): Prisma__PelanggaranClient<$Result.GetResult<Prisma.$PelanggaranPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Pelanggarans that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PelanggaranFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Pelanggarans
     * const pelanggarans = await prisma.pelanggaran.findMany()
     * 
     * // Get first 10 Pelanggarans
     * const pelanggarans = await prisma.pelanggaran.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const pelanggaranWithIdOnly = await prisma.pelanggaran.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PelanggaranFindManyArgs>(args?: SelectSubset<T, PelanggaranFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PelanggaranPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Pelanggaran.
     * @param {PelanggaranCreateArgs} args - Arguments to create a Pelanggaran.
     * @example
     * // Create one Pelanggaran
     * const Pelanggaran = await prisma.pelanggaran.create({
     *   data: {
     *     // ... data to create a Pelanggaran
     *   }
     * })
     * 
     */
    create<T extends PelanggaranCreateArgs>(args: SelectSubset<T, PelanggaranCreateArgs<ExtArgs>>): Prisma__PelanggaranClient<$Result.GetResult<Prisma.$PelanggaranPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Pelanggarans.
     * @param {PelanggaranCreateManyArgs} args - Arguments to create many Pelanggarans.
     * @example
     * // Create many Pelanggarans
     * const pelanggaran = await prisma.pelanggaran.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PelanggaranCreateManyArgs>(args?: SelectSubset<T, PelanggaranCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Pelanggarans and returns the data saved in the database.
     * @param {PelanggaranCreateManyAndReturnArgs} args - Arguments to create many Pelanggarans.
     * @example
     * // Create many Pelanggarans
     * const pelanggaran = await prisma.pelanggaran.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Pelanggarans and only return the `id`
     * const pelanggaranWithIdOnly = await prisma.pelanggaran.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PelanggaranCreateManyAndReturnArgs>(args?: SelectSubset<T, PelanggaranCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PelanggaranPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Pelanggaran.
     * @param {PelanggaranDeleteArgs} args - Arguments to delete one Pelanggaran.
     * @example
     * // Delete one Pelanggaran
     * const Pelanggaran = await prisma.pelanggaran.delete({
     *   where: {
     *     // ... filter to delete one Pelanggaran
     *   }
     * })
     * 
     */
    delete<T extends PelanggaranDeleteArgs>(args: SelectSubset<T, PelanggaranDeleteArgs<ExtArgs>>): Prisma__PelanggaranClient<$Result.GetResult<Prisma.$PelanggaranPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Pelanggaran.
     * @param {PelanggaranUpdateArgs} args - Arguments to update one Pelanggaran.
     * @example
     * // Update one Pelanggaran
     * const pelanggaran = await prisma.pelanggaran.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PelanggaranUpdateArgs>(args: SelectSubset<T, PelanggaranUpdateArgs<ExtArgs>>): Prisma__PelanggaranClient<$Result.GetResult<Prisma.$PelanggaranPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Pelanggarans.
     * @param {PelanggaranDeleteManyArgs} args - Arguments to filter Pelanggarans to delete.
     * @example
     * // Delete a few Pelanggarans
     * const { count } = await prisma.pelanggaran.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PelanggaranDeleteManyArgs>(args?: SelectSubset<T, PelanggaranDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Pelanggarans.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PelanggaranUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Pelanggarans
     * const pelanggaran = await prisma.pelanggaran.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PelanggaranUpdateManyArgs>(args: SelectSubset<T, PelanggaranUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Pelanggaran.
     * @param {PelanggaranUpsertArgs} args - Arguments to update or create a Pelanggaran.
     * @example
     * // Update or create a Pelanggaran
     * const pelanggaran = await prisma.pelanggaran.upsert({
     *   create: {
     *     // ... data to create a Pelanggaran
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Pelanggaran we want to update
     *   }
     * })
     */
    upsert<T extends PelanggaranUpsertArgs>(args: SelectSubset<T, PelanggaranUpsertArgs<ExtArgs>>): Prisma__PelanggaranClient<$Result.GetResult<Prisma.$PelanggaranPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Pelanggarans.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PelanggaranCountArgs} args - Arguments to filter Pelanggarans to count.
     * @example
     * // Count the number of Pelanggarans
     * const count = await prisma.pelanggaran.count({
     *   where: {
     *     // ... the filter for the Pelanggarans we want to count
     *   }
     * })
    **/
    count<T extends PelanggaranCountArgs>(
      args?: Subset<T, PelanggaranCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PelanggaranCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Pelanggaran.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PelanggaranAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PelanggaranAggregateArgs>(args: Subset<T, PelanggaranAggregateArgs>): Prisma.PrismaPromise<GetPelanggaranAggregateType<T>>

    /**
     * Group by Pelanggaran.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PelanggaranGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PelanggaranGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PelanggaranGroupByArgs['orderBy'] }
        : { orderBy?: PelanggaranGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PelanggaranGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPelanggaranGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Pelanggaran model
   */
  readonly fields: PelanggaranFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Pelanggaran.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PelanggaranClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    tenant<T extends TenantDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TenantDefaultArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    santri<T extends SantriDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SantriDefaultArgs<ExtArgs>>): Prisma__SantriClient<$Result.GetResult<Prisma.$SantriPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Pelanggaran model
   */ 
  interface PelanggaranFieldRefs {
    readonly id: FieldRef<"Pelanggaran", 'String'>
    readonly tenantId: FieldRef<"Pelanggaran", 'String'>
    readonly santriId: FieldRef<"Pelanggaran", 'String'>
    readonly recordedBy: FieldRef<"Pelanggaran", 'String'>
    readonly category: FieldRef<"Pelanggaran", 'String'>
    readonly severity: FieldRef<"Pelanggaran", 'Int'>
    readonly points: FieldRef<"Pelanggaran", 'Int'>
    readonly description: FieldRef<"Pelanggaran", 'String'>
    readonly date: FieldRef<"Pelanggaran", 'DateTime'>
    readonly resolved: FieldRef<"Pelanggaran", 'Boolean'>
    readonly createdAt: FieldRef<"Pelanggaran", 'DateTime'>
    readonly updatedAt: FieldRef<"Pelanggaran", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Pelanggaran findUnique
   */
  export type PelanggaranFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pelanggaran
     */
    select?: PelanggaranSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PelanggaranInclude<ExtArgs> | null
    /**
     * Filter, which Pelanggaran to fetch.
     */
    where: PelanggaranWhereUniqueInput
  }

  /**
   * Pelanggaran findUniqueOrThrow
   */
  export type PelanggaranFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pelanggaran
     */
    select?: PelanggaranSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PelanggaranInclude<ExtArgs> | null
    /**
     * Filter, which Pelanggaran to fetch.
     */
    where: PelanggaranWhereUniqueInput
  }

  /**
   * Pelanggaran findFirst
   */
  export type PelanggaranFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pelanggaran
     */
    select?: PelanggaranSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PelanggaranInclude<ExtArgs> | null
    /**
     * Filter, which Pelanggaran to fetch.
     */
    where?: PelanggaranWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Pelanggarans to fetch.
     */
    orderBy?: PelanggaranOrderByWithRelationInput | PelanggaranOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Pelanggarans.
     */
    cursor?: PelanggaranWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Pelanggarans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Pelanggarans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Pelanggarans.
     */
    distinct?: PelanggaranScalarFieldEnum | PelanggaranScalarFieldEnum[]
  }

  /**
   * Pelanggaran findFirstOrThrow
   */
  export type PelanggaranFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pelanggaran
     */
    select?: PelanggaranSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PelanggaranInclude<ExtArgs> | null
    /**
     * Filter, which Pelanggaran to fetch.
     */
    where?: PelanggaranWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Pelanggarans to fetch.
     */
    orderBy?: PelanggaranOrderByWithRelationInput | PelanggaranOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Pelanggarans.
     */
    cursor?: PelanggaranWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Pelanggarans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Pelanggarans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Pelanggarans.
     */
    distinct?: PelanggaranScalarFieldEnum | PelanggaranScalarFieldEnum[]
  }

  /**
   * Pelanggaran findMany
   */
  export type PelanggaranFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pelanggaran
     */
    select?: PelanggaranSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PelanggaranInclude<ExtArgs> | null
    /**
     * Filter, which Pelanggarans to fetch.
     */
    where?: PelanggaranWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Pelanggarans to fetch.
     */
    orderBy?: PelanggaranOrderByWithRelationInput | PelanggaranOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Pelanggarans.
     */
    cursor?: PelanggaranWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Pelanggarans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Pelanggarans.
     */
    skip?: number
    distinct?: PelanggaranScalarFieldEnum | PelanggaranScalarFieldEnum[]
  }

  /**
   * Pelanggaran create
   */
  export type PelanggaranCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pelanggaran
     */
    select?: PelanggaranSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PelanggaranInclude<ExtArgs> | null
    /**
     * The data needed to create a Pelanggaran.
     */
    data: XOR<PelanggaranCreateInput, PelanggaranUncheckedCreateInput>
  }

  /**
   * Pelanggaran createMany
   */
  export type PelanggaranCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Pelanggarans.
     */
    data: PelanggaranCreateManyInput | PelanggaranCreateManyInput[]
  }

  /**
   * Pelanggaran createManyAndReturn
   */
  export type PelanggaranCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pelanggaran
     */
    select?: PelanggaranSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Pelanggarans.
     */
    data: PelanggaranCreateManyInput | PelanggaranCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PelanggaranIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Pelanggaran update
   */
  export type PelanggaranUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pelanggaran
     */
    select?: PelanggaranSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PelanggaranInclude<ExtArgs> | null
    /**
     * The data needed to update a Pelanggaran.
     */
    data: XOR<PelanggaranUpdateInput, PelanggaranUncheckedUpdateInput>
    /**
     * Choose, which Pelanggaran to update.
     */
    where: PelanggaranWhereUniqueInput
  }

  /**
   * Pelanggaran updateMany
   */
  export type PelanggaranUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Pelanggarans.
     */
    data: XOR<PelanggaranUpdateManyMutationInput, PelanggaranUncheckedUpdateManyInput>
    /**
     * Filter which Pelanggarans to update
     */
    where?: PelanggaranWhereInput
  }

  /**
   * Pelanggaran upsert
   */
  export type PelanggaranUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pelanggaran
     */
    select?: PelanggaranSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PelanggaranInclude<ExtArgs> | null
    /**
     * The filter to search for the Pelanggaran to update in case it exists.
     */
    where: PelanggaranWhereUniqueInput
    /**
     * In case the Pelanggaran found by the `where` argument doesn't exist, create a new Pelanggaran with this data.
     */
    create: XOR<PelanggaranCreateInput, PelanggaranUncheckedCreateInput>
    /**
     * In case the Pelanggaran was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PelanggaranUpdateInput, PelanggaranUncheckedUpdateInput>
  }

  /**
   * Pelanggaran delete
   */
  export type PelanggaranDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pelanggaran
     */
    select?: PelanggaranSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PelanggaranInclude<ExtArgs> | null
    /**
     * Filter which Pelanggaran to delete.
     */
    where: PelanggaranWhereUniqueInput
  }

  /**
   * Pelanggaran deleteMany
   */
  export type PelanggaranDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Pelanggarans to delete
     */
    where?: PelanggaranWhereInput
  }

  /**
   * Pelanggaran without action
   */
  export type PelanggaranDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pelanggaran
     */
    select?: PelanggaranSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PelanggaranInclude<ExtArgs> | null
  }


  /**
   * Model Pembinaan
   */

  export type AggregatePembinaan = {
    _count: PembinaanCountAggregateOutputType | null
    _min: PembinaanMinAggregateOutputType | null
    _max: PembinaanMaxAggregateOutputType | null
  }

  export type PembinaanMinAggregateOutputType = {
    id: string | null
    tenantId: string | null
    santriId: string | null
    plan: string | null
    targetDate: Date | null
    status: string | null
    assignedTo: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PembinaanMaxAggregateOutputType = {
    id: string | null
    tenantId: string | null
    santriId: string | null
    plan: string | null
    targetDate: Date | null
    status: string | null
    assignedTo: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PembinaanCountAggregateOutputType = {
    id: number
    tenantId: number
    santriId: number
    plan: number
    targetDate: number
    status: number
    assignedTo: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PembinaanMinAggregateInputType = {
    id?: true
    tenantId?: true
    santriId?: true
    plan?: true
    targetDate?: true
    status?: true
    assignedTo?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PembinaanMaxAggregateInputType = {
    id?: true
    tenantId?: true
    santriId?: true
    plan?: true
    targetDate?: true
    status?: true
    assignedTo?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PembinaanCountAggregateInputType = {
    id?: true
    tenantId?: true
    santriId?: true
    plan?: true
    targetDate?: true
    status?: true
    assignedTo?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PembinaanAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Pembinaan to aggregate.
     */
    where?: PembinaanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Pembinaans to fetch.
     */
    orderBy?: PembinaanOrderByWithRelationInput | PembinaanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PembinaanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Pembinaans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Pembinaans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Pembinaans
    **/
    _count?: true | PembinaanCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PembinaanMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PembinaanMaxAggregateInputType
  }

  export type GetPembinaanAggregateType<T extends PembinaanAggregateArgs> = {
        [P in keyof T & keyof AggregatePembinaan]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePembinaan[P]>
      : GetScalarType<T[P], AggregatePembinaan[P]>
  }




  export type PembinaanGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PembinaanWhereInput
    orderBy?: PembinaanOrderByWithAggregationInput | PembinaanOrderByWithAggregationInput[]
    by: PembinaanScalarFieldEnum[] | PembinaanScalarFieldEnum
    having?: PembinaanScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PembinaanCountAggregateInputType | true
    _min?: PembinaanMinAggregateInputType
    _max?: PembinaanMaxAggregateInputType
  }

  export type PembinaanGroupByOutputType = {
    id: string
    tenantId: string
    santriId: string
    plan: string
    targetDate: Date
    status: string
    assignedTo: string
    createdAt: Date
    updatedAt: Date
    _count: PembinaanCountAggregateOutputType | null
    _min: PembinaanMinAggregateOutputType | null
    _max: PembinaanMaxAggregateOutputType | null
  }

  type GetPembinaanGroupByPayload<T extends PembinaanGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PembinaanGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PembinaanGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PembinaanGroupByOutputType[P]>
            : GetScalarType<T[P], PembinaanGroupByOutputType[P]>
        }
      >
    >


  export type PembinaanSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    santriId?: boolean
    plan?: boolean
    targetDate?: boolean
    status?: boolean
    assignedTo?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    santri?: boolean | SantriDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["pembinaan"]>

  export type PembinaanSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    santriId?: boolean
    plan?: boolean
    targetDate?: boolean
    status?: boolean
    assignedTo?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    santri?: boolean | SantriDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["pembinaan"]>

  export type PembinaanSelectScalar = {
    id?: boolean
    tenantId?: boolean
    santriId?: boolean
    plan?: boolean
    targetDate?: boolean
    status?: boolean
    assignedTo?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PembinaanInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    santri?: boolean | SantriDefaultArgs<ExtArgs>
  }
  export type PembinaanIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    santri?: boolean | SantriDefaultArgs<ExtArgs>
  }

  export type $PembinaanPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Pembinaan"
    objects: {
      tenant: Prisma.$TenantPayload<ExtArgs>
      santri: Prisma.$SantriPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      tenantId: string
      santriId: string
      plan: string
      targetDate: Date
      status: string
      assignedTo: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["pembinaan"]>
    composites: {}
  }

  type PembinaanGetPayload<S extends boolean | null | undefined | PembinaanDefaultArgs> = $Result.GetResult<Prisma.$PembinaanPayload, S>

  type PembinaanCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<PembinaanFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PembinaanCountAggregateInputType | true
    }

  export interface PembinaanDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Pembinaan'], meta: { name: 'Pembinaan' } }
    /**
     * Find zero or one Pembinaan that matches the filter.
     * @param {PembinaanFindUniqueArgs} args - Arguments to find a Pembinaan
     * @example
     * // Get one Pembinaan
     * const pembinaan = await prisma.pembinaan.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PembinaanFindUniqueArgs>(args: SelectSubset<T, PembinaanFindUniqueArgs<ExtArgs>>): Prisma__PembinaanClient<$Result.GetResult<Prisma.$PembinaanPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Pembinaan that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {PembinaanFindUniqueOrThrowArgs} args - Arguments to find a Pembinaan
     * @example
     * // Get one Pembinaan
     * const pembinaan = await prisma.pembinaan.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PembinaanFindUniqueOrThrowArgs>(args: SelectSubset<T, PembinaanFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PembinaanClient<$Result.GetResult<Prisma.$PembinaanPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Pembinaan that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PembinaanFindFirstArgs} args - Arguments to find a Pembinaan
     * @example
     * // Get one Pembinaan
     * const pembinaan = await prisma.pembinaan.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PembinaanFindFirstArgs>(args?: SelectSubset<T, PembinaanFindFirstArgs<ExtArgs>>): Prisma__PembinaanClient<$Result.GetResult<Prisma.$PembinaanPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Pembinaan that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PembinaanFindFirstOrThrowArgs} args - Arguments to find a Pembinaan
     * @example
     * // Get one Pembinaan
     * const pembinaan = await prisma.pembinaan.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PembinaanFindFirstOrThrowArgs>(args?: SelectSubset<T, PembinaanFindFirstOrThrowArgs<ExtArgs>>): Prisma__PembinaanClient<$Result.GetResult<Prisma.$PembinaanPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Pembinaans that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PembinaanFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Pembinaans
     * const pembinaans = await prisma.pembinaan.findMany()
     * 
     * // Get first 10 Pembinaans
     * const pembinaans = await prisma.pembinaan.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const pembinaanWithIdOnly = await prisma.pembinaan.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PembinaanFindManyArgs>(args?: SelectSubset<T, PembinaanFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PembinaanPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Pembinaan.
     * @param {PembinaanCreateArgs} args - Arguments to create a Pembinaan.
     * @example
     * // Create one Pembinaan
     * const Pembinaan = await prisma.pembinaan.create({
     *   data: {
     *     // ... data to create a Pembinaan
     *   }
     * })
     * 
     */
    create<T extends PembinaanCreateArgs>(args: SelectSubset<T, PembinaanCreateArgs<ExtArgs>>): Prisma__PembinaanClient<$Result.GetResult<Prisma.$PembinaanPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Pembinaans.
     * @param {PembinaanCreateManyArgs} args - Arguments to create many Pembinaans.
     * @example
     * // Create many Pembinaans
     * const pembinaan = await prisma.pembinaan.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PembinaanCreateManyArgs>(args?: SelectSubset<T, PembinaanCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Pembinaans and returns the data saved in the database.
     * @param {PembinaanCreateManyAndReturnArgs} args - Arguments to create many Pembinaans.
     * @example
     * // Create many Pembinaans
     * const pembinaan = await prisma.pembinaan.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Pembinaans and only return the `id`
     * const pembinaanWithIdOnly = await prisma.pembinaan.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PembinaanCreateManyAndReturnArgs>(args?: SelectSubset<T, PembinaanCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PembinaanPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Pembinaan.
     * @param {PembinaanDeleteArgs} args - Arguments to delete one Pembinaan.
     * @example
     * // Delete one Pembinaan
     * const Pembinaan = await prisma.pembinaan.delete({
     *   where: {
     *     // ... filter to delete one Pembinaan
     *   }
     * })
     * 
     */
    delete<T extends PembinaanDeleteArgs>(args: SelectSubset<T, PembinaanDeleteArgs<ExtArgs>>): Prisma__PembinaanClient<$Result.GetResult<Prisma.$PembinaanPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Pembinaan.
     * @param {PembinaanUpdateArgs} args - Arguments to update one Pembinaan.
     * @example
     * // Update one Pembinaan
     * const pembinaan = await prisma.pembinaan.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PembinaanUpdateArgs>(args: SelectSubset<T, PembinaanUpdateArgs<ExtArgs>>): Prisma__PembinaanClient<$Result.GetResult<Prisma.$PembinaanPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Pembinaans.
     * @param {PembinaanDeleteManyArgs} args - Arguments to filter Pembinaans to delete.
     * @example
     * // Delete a few Pembinaans
     * const { count } = await prisma.pembinaan.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PembinaanDeleteManyArgs>(args?: SelectSubset<T, PembinaanDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Pembinaans.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PembinaanUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Pembinaans
     * const pembinaan = await prisma.pembinaan.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PembinaanUpdateManyArgs>(args: SelectSubset<T, PembinaanUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Pembinaan.
     * @param {PembinaanUpsertArgs} args - Arguments to update or create a Pembinaan.
     * @example
     * // Update or create a Pembinaan
     * const pembinaan = await prisma.pembinaan.upsert({
     *   create: {
     *     // ... data to create a Pembinaan
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Pembinaan we want to update
     *   }
     * })
     */
    upsert<T extends PembinaanUpsertArgs>(args: SelectSubset<T, PembinaanUpsertArgs<ExtArgs>>): Prisma__PembinaanClient<$Result.GetResult<Prisma.$PembinaanPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Pembinaans.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PembinaanCountArgs} args - Arguments to filter Pembinaans to count.
     * @example
     * // Count the number of Pembinaans
     * const count = await prisma.pembinaan.count({
     *   where: {
     *     // ... the filter for the Pembinaans we want to count
     *   }
     * })
    **/
    count<T extends PembinaanCountArgs>(
      args?: Subset<T, PembinaanCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PembinaanCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Pembinaan.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PembinaanAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PembinaanAggregateArgs>(args: Subset<T, PembinaanAggregateArgs>): Prisma.PrismaPromise<GetPembinaanAggregateType<T>>

    /**
     * Group by Pembinaan.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PembinaanGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PembinaanGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PembinaanGroupByArgs['orderBy'] }
        : { orderBy?: PembinaanGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PembinaanGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPembinaanGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Pembinaan model
   */
  readonly fields: PembinaanFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Pembinaan.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PembinaanClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    tenant<T extends TenantDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TenantDefaultArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    santri<T extends SantriDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SantriDefaultArgs<ExtArgs>>): Prisma__SantriClient<$Result.GetResult<Prisma.$SantriPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Pembinaan model
   */ 
  interface PembinaanFieldRefs {
    readonly id: FieldRef<"Pembinaan", 'String'>
    readonly tenantId: FieldRef<"Pembinaan", 'String'>
    readonly santriId: FieldRef<"Pembinaan", 'String'>
    readonly plan: FieldRef<"Pembinaan", 'String'>
    readonly targetDate: FieldRef<"Pembinaan", 'DateTime'>
    readonly status: FieldRef<"Pembinaan", 'String'>
    readonly assignedTo: FieldRef<"Pembinaan", 'String'>
    readonly createdAt: FieldRef<"Pembinaan", 'DateTime'>
    readonly updatedAt: FieldRef<"Pembinaan", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Pembinaan findUnique
   */
  export type PembinaanFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pembinaan
     */
    select?: PembinaanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PembinaanInclude<ExtArgs> | null
    /**
     * Filter, which Pembinaan to fetch.
     */
    where: PembinaanWhereUniqueInput
  }

  /**
   * Pembinaan findUniqueOrThrow
   */
  export type PembinaanFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pembinaan
     */
    select?: PembinaanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PembinaanInclude<ExtArgs> | null
    /**
     * Filter, which Pembinaan to fetch.
     */
    where: PembinaanWhereUniqueInput
  }

  /**
   * Pembinaan findFirst
   */
  export type PembinaanFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pembinaan
     */
    select?: PembinaanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PembinaanInclude<ExtArgs> | null
    /**
     * Filter, which Pembinaan to fetch.
     */
    where?: PembinaanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Pembinaans to fetch.
     */
    orderBy?: PembinaanOrderByWithRelationInput | PembinaanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Pembinaans.
     */
    cursor?: PembinaanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Pembinaans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Pembinaans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Pembinaans.
     */
    distinct?: PembinaanScalarFieldEnum | PembinaanScalarFieldEnum[]
  }

  /**
   * Pembinaan findFirstOrThrow
   */
  export type PembinaanFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pembinaan
     */
    select?: PembinaanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PembinaanInclude<ExtArgs> | null
    /**
     * Filter, which Pembinaan to fetch.
     */
    where?: PembinaanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Pembinaans to fetch.
     */
    orderBy?: PembinaanOrderByWithRelationInput | PembinaanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Pembinaans.
     */
    cursor?: PembinaanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Pembinaans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Pembinaans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Pembinaans.
     */
    distinct?: PembinaanScalarFieldEnum | PembinaanScalarFieldEnum[]
  }

  /**
   * Pembinaan findMany
   */
  export type PembinaanFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pembinaan
     */
    select?: PembinaanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PembinaanInclude<ExtArgs> | null
    /**
     * Filter, which Pembinaans to fetch.
     */
    where?: PembinaanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Pembinaans to fetch.
     */
    orderBy?: PembinaanOrderByWithRelationInput | PembinaanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Pembinaans.
     */
    cursor?: PembinaanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Pembinaans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Pembinaans.
     */
    skip?: number
    distinct?: PembinaanScalarFieldEnum | PembinaanScalarFieldEnum[]
  }

  /**
   * Pembinaan create
   */
  export type PembinaanCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pembinaan
     */
    select?: PembinaanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PembinaanInclude<ExtArgs> | null
    /**
     * The data needed to create a Pembinaan.
     */
    data: XOR<PembinaanCreateInput, PembinaanUncheckedCreateInput>
  }

  /**
   * Pembinaan createMany
   */
  export type PembinaanCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Pembinaans.
     */
    data: PembinaanCreateManyInput | PembinaanCreateManyInput[]
  }

  /**
   * Pembinaan createManyAndReturn
   */
  export type PembinaanCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pembinaan
     */
    select?: PembinaanSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Pembinaans.
     */
    data: PembinaanCreateManyInput | PembinaanCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PembinaanIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Pembinaan update
   */
  export type PembinaanUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pembinaan
     */
    select?: PembinaanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PembinaanInclude<ExtArgs> | null
    /**
     * The data needed to update a Pembinaan.
     */
    data: XOR<PembinaanUpdateInput, PembinaanUncheckedUpdateInput>
    /**
     * Choose, which Pembinaan to update.
     */
    where: PembinaanWhereUniqueInput
  }

  /**
   * Pembinaan updateMany
   */
  export type PembinaanUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Pembinaans.
     */
    data: XOR<PembinaanUpdateManyMutationInput, PembinaanUncheckedUpdateManyInput>
    /**
     * Filter which Pembinaans to update
     */
    where?: PembinaanWhereInput
  }

  /**
   * Pembinaan upsert
   */
  export type PembinaanUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pembinaan
     */
    select?: PembinaanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PembinaanInclude<ExtArgs> | null
    /**
     * The filter to search for the Pembinaan to update in case it exists.
     */
    where: PembinaanWhereUniqueInput
    /**
     * In case the Pembinaan found by the `where` argument doesn't exist, create a new Pembinaan with this data.
     */
    create: XOR<PembinaanCreateInput, PembinaanUncheckedCreateInput>
    /**
     * In case the Pembinaan was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PembinaanUpdateInput, PembinaanUncheckedUpdateInput>
  }

  /**
   * Pembinaan delete
   */
  export type PembinaanDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pembinaan
     */
    select?: PembinaanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PembinaanInclude<ExtArgs> | null
    /**
     * Filter which Pembinaan to delete.
     */
    where: PembinaanWhereUniqueInput
  }

  /**
   * Pembinaan deleteMany
   */
  export type PembinaanDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Pembinaans to delete
     */
    where?: PembinaanWhereInput
  }

  /**
   * Pembinaan without action
   */
  export type PembinaanDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pembinaan
     */
    select?: PembinaanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PembinaanInclude<ExtArgs> | null
  }


  /**
   * Model Kunjungan
   */

  export type AggregateKunjungan = {
    _count: KunjunganCountAggregateOutputType | null
    _avg: KunjunganAvgAggregateOutputType | null
    _sum: KunjunganSumAggregateOutputType | null
    _min: KunjunganMinAggregateOutputType | null
    _max: KunjunganMaxAggregateOutputType | null
  }

  export type KunjunganAvgAggregateOutputType = {
    visitorLimit: number | null
  }

  export type KunjunganSumAggregateOutputType = {
    visitorLimit: number | null
  }

  export type KunjunganMinAggregateOutputType = {
    id: string | null
    tenantId: string | null
    santriId: string | null
    scheduledAt: Date | null
    slot: string | null
    visitorLimit: number | null
    status: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type KunjunganMaxAggregateOutputType = {
    id: string | null
    tenantId: string | null
    santriId: string | null
    scheduledAt: Date | null
    slot: string | null
    visitorLimit: number | null
    status: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type KunjunganCountAggregateOutputType = {
    id: number
    tenantId: number
    santriId: number
    scheduledAt: number
    slot: number
    visitorLimit: number
    status: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type KunjunganAvgAggregateInputType = {
    visitorLimit?: true
  }

  export type KunjunganSumAggregateInputType = {
    visitorLimit?: true
  }

  export type KunjunganMinAggregateInputType = {
    id?: true
    tenantId?: true
    santriId?: true
    scheduledAt?: true
    slot?: true
    visitorLimit?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type KunjunganMaxAggregateInputType = {
    id?: true
    tenantId?: true
    santriId?: true
    scheduledAt?: true
    slot?: true
    visitorLimit?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type KunjunganCountAggregateInputType = {
    id?: true
    tenantId?: true
    santriId?: true
    scheduledAt?: true
    slot?: true
    visitorLimit?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type KunjunganAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Kunjungan to aggregate.
     */
    where?: KunjunganWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Kunjungans to fetch.
     */
    orderBy?: KunjunganOrderByWithRelationInput | KunjunganOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: KunjunganWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Kunjungans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Kunjungans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Kunjungans
    **/
    _count?: true | KunjunganCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: KunjunganAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: KunjunganSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: KunjunganMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: KunjunganMaxAggregateInputType
  }

  export type GetKunjunganAggregateType<T extends KunjunganAggregateArgs> = {
        [P in keyof T & keyof AggregateKunjungan]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateKunjungan[P]>
      : GetScalarType<T[P], AggregateKunjungan[P]>
  }




  export type KunjunganGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: KunjunganWhereInput
    orderBy?: KunjunganOrderByWithAggregationInput | KunjunganOrderByWithAggregationInput[]
    by: KunjunganScalarFieldEnum[] | KunjunganScalarFieldEnum
    having?: KunjunganScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: KunjunganCountAggregateInputType | true
    _avg?: KunjunganAvgAggregateInputType
    _sum?: KunjunganSumAggregateInputType
    _min?: KunjunganMinAggregateInputType
    _max?: KunjunganMaxAggregateInputType
  }

  export type KunjunganGroupByOutputType = {
    id: string
    tenantId: string
    santriId: string
    scheduledAt: Date
    slot: string
    visitorLimit: number
    status: string
    createdAt: Date
    updatedAt: Date
    _count: KunjunganCountAggregateOutputType | null
    _avg: KunjunganAvgAggregateOutputType | null
    _sum: KunjunganSumAggregateOutputType | null
    _min: KunjunganMinAggregateOutputType | null
    _max: KunjunganMaxAggregateOutputType | null
  }

  type GetKunjunganGroupByPayload<T extends KunjunganGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<KunjunganGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof KunjunganGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], KunjunganGroupByOutputType[P]>
            : GetScalarType<T[P], KunjunganGroupByOutputType[P]>
        }
      >
    >


  export type KunjunganSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    santriId?: boolean
    scheduledAt?: boolean
    slot?: boolean
    visitorLimit?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    santri?: boolean | SantriDefaultArgs<ExtArgs>
    tamu?: boolean | Kunjungan$tamuArgs<ExtArgs>
    _count?: boolean | KunjunganCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["kunjungan"]>

  export type KunjunganSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    santriId?: boolean
    scheduledAt?: boolean
    slot?: boolean
    visitorLimit?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    santri?: boolean | SantriDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["kunjungan"]>

  export type KunjunganSelectScalar = {
    id?: boolean
    tenantId?: boolean
    santriId?: boolean
    scheduledAt?: boolean
    slot?: boolean
    visitorLimit?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type KunjunganInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    santri?: boolean | SantriDefaultArgs<ExtArgs>
    tamu?: boolean | Kunjungan$tamuArgs<ExtArgs>
    _count?: boolean | KunjunganCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type KunjunganIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    santri?: boolean | SantriDefaultArgs<ExtArgs>
  }

  export type $KunjunganPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Kunjungan"
    objects: {
      tenant: Prisma.$TenantPayload<ExtArgs>
      santri: Prisma.$SantriPayload<ExtArgs>
      tamu: Prisma.$TamuPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      tenantId: string
      santriId: string
      scheduledAt: Date
      slot: string
      visitorLimit: number
      status: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["kunjungan"]>
    composites: {}
  }

  type KunjunganGetPayload<S extends boolean | null | undefined | KunjunganDefaultArgs> = $Result.GetResult<Prisma.$KunjunganPayload, S>

  type KunjunganCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<KunjunganFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: KunjunganCountAggregateInputType | true
    }

  export interface KunjunganDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Kunjungan'], meta: { name: 'Kunjungan' } }
    /**
     * Find zero or one Kunjungan that matches the filter.
     * @param {KunjunganFindUniqueArgs} args - Arguments to find a Kunjungan
     * @example
     * // Get one Kunjungan
     * const kunjungan = await prisma.kunjungan.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends KunjunganFindUniqueArgs>(args: SelectSubset<T, KunjunganFindUniqueArgs<ExtArgs>>): Prisma__KunjunganClient<$Result.GetResult<Prisma.$KunjunganPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Kunjungan that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {KunjunganFindUniqueOrThrowArgs} args - Arguments to find a Kunjungan
     * @example
     * // Get one Kunjungan
     * const kunjungan = await prisma.kunjungan.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends KunjunganFindUniqueOrThrowArgs>(args: SelectSubset<T, KunjunganFindUniqueOrThrowArgs<ExtArgs>>): Prisma__KunjunganClient<$Result.GetResult<Prisma.$KunjunganPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Kunjungan that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KunjunganFindFirstArgs} args - Arguments to find a Kunjungan
     * @example
     * // Get one Kunjungan
     * const kunjungan = await prisma.kunjungan.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends KunjunganFindFirstArgs>(args?: SelectSubset<T, KunjunganFindFirstArgs<ExtArgs>>): Prisma__KunjunganClient<$Result.GetResult<Prisma.$KunjunganPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Kunjungan that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KunjunganFindFirstOrThrowArgs} args - Arguments to find a Kunjungan
     * @example
     * // Get one Kunjungan
     * const kunjungan = await prisma.kunjungan.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends KunjunganFindFirstOrThrowArgs>(args?: SelectSubset<T, KunjunganFindFirstOrThrowArgs<ExtArgs>>): Prisma__KunjunganClient<$Result.GetResult<Prisma.$KunjunganPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Kunjungans that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KunjunganFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Kunjungans
     * const kunjungans = await prisma.kunjungan.findMany()
     * 
     * // Get first 10 Kunjungans
     * const kunjungans = await prisma.kunjungan.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const kunjunganWithIdOnly = await prisma.kunjungan.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends KunjunganFindManyArgs>(args?: SelectSubset<T, KunjunganFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$KunjunganPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Kunjungan.
     * @param {KunjunganCreateArgs} args - Arguments to create a Kunjungan.
     * @example
     * // Create one Kunjungan
     * const Kunjungan = await prisma.kunjungan.create({
     *   data: {
     *     // ... data to create a Kunjungan
     *   }
     * })
     * 
     */
    create<T extends KunjunganCreateArgs>(args: SelectSubset<T, KunjunganCreateArgs<ExtArgs>>): Prisma__KunjunganClient<$Result.GetResult<Prisma.$KunjunganPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Kunjungans.
     * @param {KunjunganCreateManyArgs} args - Arguments to create many Kunjungans.
     * @example
     * // Create many Kunjungans
     * const kunjungan = await prisma.kunjungan.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends KunjunganCreateManyArgs>(args?: SelectSubset<T, KunjunganCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Kunjungans and returns the data saved in the database.
     * @param {KunjunganCreateManyAndReturnArgs} args - Arguments to create many Kunjungans.
     * @example
     * // Create many Kunjungans
     * const kunjungan = await prisma.kunjungan.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Kunjungans and only return the `id`
     * const kunjunganWithIdOnly = await prisma.kunjungan.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends KunjunganCreateManyAndReturnArgs>(args?: SelectSubset<T, KunjunganCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$KunjunganPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Kunjungan.
     * @param {KunjunganDeleteArgs} args - Arguments to delete one Kunjungan.
     * @example
     * // Delete one Kunjungan
     * const Kunjungan = await prisma.kunjungan.delete({
     *   where: {
     *     // ... filter to delete one Kunjungan
     *   }
     * })
     * 
     */
    delete<T extends KunjunganDeleteArgs>(args: SelectSubset<T, KunjunganDeleteArgs<ExtArgs>>): Prisma__KunjunganClient<$Result.GetResult<Prisma.$KunjunganPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Kunjungan.
     * @param {KunjunganUpdateArgs} args - Arguments to update one Kunjungan.
     * @example
     * // Update one Kunjungan
     * const kunjungan = await prisma.kunjungan.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends KunjunganUpdateArgs>(args: SelectSubset<T, KunjunganUpdateArgs<ExtArgs>>): Prisma__KunjunganClient<$Result.GetResult<Prisma.$KunjunganPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Kunjungans.
     * @param {KunjunganDeleteManyArgs} args - Arguments to filter Kunjungans to delete.
     * @example
     * // Delete a few Kunjungans
     * const { count } = await prisma.kunjungan.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends KunjunganDeleteManyArgs>(args?: SelectSubset<T, KunjunganDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Kunjungans.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KunjunganUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Kunjungans
     * const kunjungan = await prisma.kunjungan.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends KunjunganUpdateManyArgs>(args: SelectSubset<T, KunjunganUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Kunjungan.
     * @param {KunjunganUpsertArgs} args - Arguments to update or create a Kunjungan.
     * @example
     * // Update or create a Kunjungan
     * const kunjungan = await prisma.kunjungan.upsert({
     *   create: {
     *     // ... data to create a Kunjungan
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Kunjungan we want to update
     *   }
     * })
     */
    upsert<T extends KunjunganUpsertArgs>(args: SelectSubset<T, KunjunganUpsertArgs<ExtArgs>>): Prisma__KunjunganClient<$Result.GetResult<Prisma.$KunjunganPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Kunjungans.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KunjunganCountArgs} args - Arguments to filter Kunjungans to count.
     * @example
     * // Count the number of Kunjungans
     * const count = await prisma.kunjungan.count({
     *   where: {
     *     // ... the filter for the Kunjungans we want to count
     *   }
     * })
    **/
    count<T extends KunjunganCountArgs>(
      args?: Subset<T, KunjunganCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], KunjunganCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Kunjungan.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KunjunganAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends KunjunganAggregateArgs>(args: Subset<T, KunjunganAggregateArgs>): Prisma.PrismaPromise<GetKunjunganAggregateType<T>>

    /**
     * Group by Kunjungan.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KunjunganGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends KunjunganGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: KunjunganGroupByArgs['orderBy'] }
        : { orderBy?: KunjunganGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, KunjunganGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetKunjunganGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Kunjungan model
   */
  readonly fields: KunjunganFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Kunjungan.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__KunjunganClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    tenant<T extends TenantDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TenantDefaultArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    santri<T extends SantriDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SantriDefaultArgs<ExtArgs>>): Prisma__SantriClient<$Result.GetResult<Prisma.$SantriPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    tamu<T extends Kunjungan$tamuArgs<ExtArgs> = {}>(args?: Subset<T, Kunjungan$tamuArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TamuPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Kunjungan model
   */ 
  interface KunjunganFieldRefs {
    readonly id: FieldRef<"Kunjungan", 'String'>
    readonly tenantId: FieldRef<"Kunjungan", 'String'>
    readonly santriId: FieldRef<"Kunjungan", 'String'>
    readonly scheduledAt: FieldRef<"Kunjungan", 'DateTime'>
    readonly slot: FieldRef<"Kunjungan", 'String'>
    readonly visitorLimit: FieldRef<"Kunjungan", 'Int'>
    readonly status: FieldRef<"Kunjungan", 'String'>
    readonly createdAt: FieldRef<"Kunjungan", 'DateTime'>
    readonly updatedAt: FieldRef<"Kunjungan", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Kunjungan findUnique
   */
  export type KunjunganFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Kunjungan
     */
    select?: KunjunganSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KunjunganInclude<ExtArgs> | null
    /**
     * Filter, which Kunjungan to fetch.
     */
    where: KunjunganWhereUniqueInput
  }

  /**
   * Kunjungan findUniqueOrThrow
   */
  export type KunjunganFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Kunjungan
     */
    select?: KunjunganSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KunjunganInclude<ExtArgs> | null
    /**
     * Filter, which Kunjungan to fetch.
     */
    where: KunjunganWhereUniqueInput
  }

  /**
   * Kunjungan findFirst
   */
  export type KunjunganFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Kunjungan
     */
    select?: KunjunganSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KunjunganInclude<ExtArgs> | null
    /**
     * Filter, which Kunjungan to fetch.
     */
    where?: KunjunganWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Kunjungans to fetch.
     */
    orderBy?: KunjunganOrderByWithRelationInput | KunjunganOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Kunjungans.
     */
    cursor?: KunjunganWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Kunjungans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Kunjungans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Kunjungans.
     */
    distinct?: KunjunganScalarFieldEnum | KunjunganScalarFieldEnum[]
  }

  /**
   * Kunjungan findFirstOrThrow
   */
  export type KunjunganFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Kunjungan
     */
    select?: KunjunganSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KunjunganInclude<ExtArgs> | null
    /**
     * Filter, which Kunjungan to fetch.
     */
    where?: KunjunganWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Kunjungans to fetch.
     */
    orderBy?: KunjunganOrderByWithRelationInput | KunjunganOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Kunjungans.
     */
    cursor?: KunjunganWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Kunjungans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Kunjungans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Kunjungans.
     */
    distinct?: KunjunganScalarFieldEnum | KunjunganScalarFieldEnum[]
  }

  /**
   * Kunjungan findMany
   */
  export type KunjunganFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Kunjungan
     */
    select?: KunjunganSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KunjunganInclude<ExtArgs> | null
    /**
     * Filter, which Kunjungans to fetch.
     */
    where?: KunjunganWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Kunjungans to fetch.
     */
    orderBy?: KunjunganOrderByWithRelationInput | KunjunganOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Kunjungans.
     */
    cursor?: KunjunganWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Kunjungans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Kunjungans.
     */
    skip?: number
    distinct?: KunjunganScalarFieldEnum | KunjunganScalarFieldEnum[]
  }

  /**
   * Kunjungan create
   */
  export type KunjunganCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Kunjungan
     */
    select?: KunjunganSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KunjunganInclude<ExtArgs> | null
    /**
     * The data needed to create a Kunjungan.
     */
    data: XOR<KunjunganCreateInput, KunjunganUncheckedCreateInput>
  }

  /**
   * Kunjungan createMany
   */
  export type KunjunganCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Kunjungans.
     */
    data: KunjunganCreateManyInput | KunjunganCreateManyInput[]
  }

  /**
   * Kunjungan createManyAndReturn
   */
  export type KunjunganCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Kunjungan
     */
    select?: KunjunganSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Kunjungans.
     */
    data: KunjunganCreateManyInput | KunjunganCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KunjunganIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Kunjungan update
   */
  export type KunjunganUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Kunjungan
     */
    select?: KunjunganSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KunjunganInclude<ExtArgs> | null
    /**
     * The data needed to update a Kunjungan.
     */
    data: XOR<KunjunganUpdateInput, KunjunganUncheckedUpdateInput>
    /**
     * Choose, which Kunjungan to update.
     */
    where: KunjunganWhereUniqueInput
  }

  /**
   * Kunjungan updateMany
   */
  export type KunjunganUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Kunjungans.
     */
    data: XOR<KunjunganUpdateManyMutationInput, KunjunganUncheckedUpdateManyInput>
    /**
     * Filter which Kunjungans to update
     */
    where?: KunjunganWhereInput
  }

  /**
   * Kunjungan upsert
   */
  export type KunjunganUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Kunjungan
     */
    select?: KunjunganSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KunjunganInclude<ExtArgs> | null
    /**
     * The filter to search for the Kunjungan to update in case it exists.
     */
    where: KunjunganWhereUniqueInput
    /**
     * In case the Kunjungan found by the `where` argument doesn't exist, create a new Kunjungan with this data.
     */
    create: XOR<KunjunganCreateInput, KunjunganUncheckedCreateInput>
    /**
     * In case the Kunjungan was found with the provided `where` argument, update it with this data.
     */
    update: XOR<KunjunganUpdateInput, KunjunganUncheckedUpdateInput>
  }

  /**
   * Kunjungan delete
   */
  export type KunjunganDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Kunjungan
     */
    select?: KunjunganSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KunjunganInclude<ExtArgs> | null
    /**
     * Filter which Kunjungan to delete.
     */
    where: KunjunganWhereUniqueInput
  }

  /**
   * Kunjungan deleteMany
   */
  export type KunjunganDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Kunjungans to delete
     */
    where?: KunjunganWhereInput
  }

  /**
   * Kunjungan.tamu
   */
  export type Kunjungan$tamuArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tamu
     */
    select?: TamuSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TamuInclude<ExtArgs> | null
    where?: TamuWhereInput
    orderBy?: TamuOrderByWithRelationInput | TamuOrderByWithRelationInput[]
    cursor?: TamuWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TamuScalarFieldEnum | TamuScalarFieldEnum[]
  }

  /**
   * Kunjungan without action
   */
  export type KunjunganDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Kunjungan
     */
    select?: KunjunganSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KunjunganInclude<ExtArgs> | null
  }


  /**
   * Model Tamu
   */

  export type AggregateTamu = {
    _count: TamuCountAggregateOutputType | null
    _min: TamuMinAggregateOutputType | null
    _max: TamuMaxAggregateOutputType | null
  }

  export type TamuMinAggregateOutputType = {
    id: string | null
    kunjunganId: string | null
    name: string | null
    phone: string | null
    idNumber: string | null
    checkinAt: Date | null
    createdAt: Date | null
  }

  export type TamuMaxAggregateOutputType = {
    id: string | null
    kunjunganId: string | null
    name: string | null
    phone: string | null
    idNumber: string | null
    checkinAt: Date | null
    createdAt: Date | null
  }

  export type TamuCountAggregateOutputType = {
    id: number
    kunjunganId: number
    name: number
    phone: number
    idNumber: number
    checkinAt: number
    createdAt: number
    _all: number
  }


  export type TamuMinAggregateInputType = {
    id?: true
    kunjunganId?: true
    name?: true
    phone?: true
    idNumber?: true
    checkinAt?: true
    createdAt?: true
  }

  export type TamuMaxAggregateInputType = {
    id?: true
    kunjunganId?: true
    name?: true
    phone?: true
    idNumber?: true
    checkinAt?: true
    createdAt?: true
  }

  export type TamuCountAggregateInputType = {
    id?: true
    kunjunganId?: true
    name?: true
    phone?: true
    idNumber?: true
    checkinAt?: true
    createdAt?: true
    _all?: true
  }

  export type TamuAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Tamu to aggregate.
     */
    where?: TamuWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tamus to fetch.
     */
    orderBy?: TamuOrderByWithRelationInput | TamuOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TamuWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tamus from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tamus.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Tamus
    **/
    _count?: true | TamuCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TamuMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TamuMaxAggregateInputType
  }

  export type GetTamuAggregateType<T extends TamuAggregateArgs> = {
        [P in keyof T & keyof AggregateTamu]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTamu[P]>
      : GetScalarType<T[P], AggregateTamu[P]>
  }




  export type TamuGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TamuWhereInput
    orderBy?: TamuOrderByWithAggregationInput | TamuOrderByWithAggregationInput[]
    by: TamuScalarFieldEnum[] | TamuScalarFieldEnum
    having?: TamuScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TamuCountAggregateInputType | true
    _min?: TamuMinAggregateInputType
    _max?: TamuMaxAggregateInputType
  }

  export type TamuGroupByOutputType = {
    id: string
    kunjunganId: string
    name: string
    phone: string | null
    idNumber: string | null
    checkinAt: Date | null
    createdAt: Date
    _count: TamuCountAggregateOutputType | null
    _min: TamuMinAggregateOutputType | null
    _max: TamuMaxAggregateOutputType | null
  }

  type GetTamuGroupByPayload<T extends TamuGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TamuGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TamuGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TamuGroupByOutputType[P]>
            : GetScalarType<T[P], TamuGroupByOutputType[P]>
        }
      >
    >


  export type TamuSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    kunjunganId?: boolean
    name?: boolean
    phone?: boolean
    idNumber?: boolean
    checkinAt?: boolean
    createdAt?: boolean
    kunjungan?: boolean | KunjunganDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tamu"]>

  export type TamuSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    kunjunganId?: boolean
    name?: boolean
    phone?: boolean
    idNumber?: boolean
    checkinAt?: boolean
    createdAt?: boolean
    kunjungan?: boolean | KunjunganDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tamu"]>

  export type TamuSelectScalar = {
    id?: boolean
    kunjunganId?: boolean
    name?: boolean
    phone?: boolean
    idNumber?: boolean
    checkinAt?: boolean
    createdAt?: boolean
  }

  export type TamuInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    kunjungan?: boolean | KunjunganDefaultArgs<ExtArgs>
  }
  export type TamuIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    kunjungan?: boolean | KunjunganDefaultArgs<ExtArgs>
  }

  export type $TamuPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Tamu"
    objects: {
      kunjungan: Prisma.$KunjunganPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      kunjunganId: string
      name: string
      phone: string | null
      idNumber: string | null
      checkinAt: Date | null
      createdAt: Date
    }, ExtArgs["result"]["tamu"]>
    composites: {}
  }

  type TamuGetPayload<S extends boolean | null | undefined | TamuDefaultArgs> = $Result.GetResult<Prisma.$TamuPayload, S>

  type TamuCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<TamuFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: TamuCountAggregateInputType | true
    }

  export interface TamuDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Tamu'], meta: { name: 'Tamu' } }
    /**
     * Find zero or one Tamu that matches the filter.
     * @param {TamuFindUniqueArgs} args - Arguments to find a Tamu
     * @example
     * // Get one Tamu
     * const tamu = await prisma.tamu.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TamuFindUniqueArgs>(args: SelectSubset<T, TamuFindUniqueArgs<ExtArgs>>): Prisma__TamuClient<$Result.GetResult<Prisma.$TamuPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Tamu that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {TamuFindUniqueOrThrowArgs} args - Arguments to find a Tamu
     * @example
     * // Get one Tamu
     * const tamu = await prisma.tamu.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TamuFindUniqueOrThrowArgs>(args: SelectSubset<T, TamuFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TamuClient<$Result.GetResult<Prisma.$TamuPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Tamu that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TamuFindFirstArgs} args - Arguments to find a Tamu
     * @example
     * // Get one Tamu
     * const tamu = await prisma.tamu.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TamuFindFirstArgs>(args?: SelectSubset<T, TamuFindFirstArgs<ExtArgs>>): Prisma__TamuClient<$Result.GetResult<Prisma.$TamuPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Tamu that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TamuFindFirstOrThrowArgs} args - Arguments to find a Tamu
     * @example
     * // Get one Tamu
     * const tamu = await prisma.tamu.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TamuFindFirstOrThrowArgs>(args?: SelectSubset<T, TamuFindFirstOrThrowArgs<ExtArgs>>): Prisma__TamuClient<$Result.GetResult<Prisma.$TamuPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Tamus that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TamuFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Tamus
     * const tamus = await prisma.tamu.findMany()
     * 
     * // Get first 10 Tamus
     * const tamus = await prisma.tamu.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const tamuWithIdOnly = await prisma.tamu.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TamuFindManyArgs>(args?: SelectSubset<T, TamuFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TamuPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Tamu.
     * @param {TamuCreateArgs} args - Arguments to create a Tamu.
     * @example
     * // Create one Tamu
     * const Tamu = await prisma.tamu.create({
     *   data: {
     *     // ... data to create a Tamu
     *   }
     * })
     * 
     */
    create<T extends TamuCreateArgs>(args: SelectSubset<T, TamuCreateArgs<ExtArgs>>): Prisma__TamuClient<$Result.GetResult<Prisma.$TamuPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Tamus.
     * @param {TamuCreateManyArgs} args - Arguments to create many Tamus.
     * @example
     * // Create many Tamus
     * const tamu = await prisma.tamu.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TamuCreateManyArgs>(args?: SelectSubset<T, TamuCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Tamus and returns the data saved in the database.
     * @param {TamuCreateManyAndReturnArgs} args - Arguments to create many Tamus.
     * @example
     * // Create many Tamus
     * const tamu = await prisma.tamu.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Tamus and only return the `id`
     * const tamuWithIdOnly = await prisma.tamu.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TamuCreateManyAndReturnArgs>(args?: SelectSubset<T, TamuCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TamuPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Tamu.
     * @param {TamuDeleteArgs} args - Arguments to delete one Tamu.
     * @example
     * // Delete one Tamu
     * const Tamu = await prisma.tamu.delete({
     *   where: {
     *     // ... filter to delete one Tamu
     *   }
     * })
     * 
     */
    delete<T extends TamuDeleteArgs>(args: SelectSubset<T, TamuDeleteArgs<ExtArgs>>): Prisma__TamuClient<$Result.GetResult<Prisma.$TamuPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Tamu.
     * @param {TamuUpdateArgs} args - Arguments to update one Tamu.
     * @example
     * // Update one Tamu
     * const tamu = await prisma.tamu.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TamuUpdateArgs>(args: SelectSubset<T, TamuUpdateArgs<ExtArgs>>): Prisma__TamuClient<$Result.GetResult<Prisma.$TamuPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Tamus.
     * @param {TamuDeleteManyArgs} args - Arguments to filter Tamus to delete.
     * @example
     * // Delete a few Tamus
     * const { count } = await prisma.tamu.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TamuDeleteManyArgs>(args?: SelectSubset<T, TamuDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tamus.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TamuUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Tamus
     * const tamu = await prisma.tamu.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TamuUpdateManyArgs>(args: SelectSubset<T, TamuUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Tamu.
     * @param {TamuUpsertArgs} args - Arguments to update or create a Tamu.
     * @example
     * // Update or create a Tamu
     * const tamu = await prisma.tamu.upsert({
     *   create: {
     *     // ... data to create a Tamu
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Tamu we want to update
     *   }
     * })
     */
    upsert<T extends TamuUpsertArgs>(args: SelectSubset<T, TamuUpsertArgs<ExtArgs>>): Prisma__TamuClient<$Result.GetResult<Prisma.$TamuPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Tamus.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TamuCountArgs} args - Arguments to filter Tamus to count.
     * @example
     * // Count the number of Tamus
     * const count = await prisma.tamu.count({
     *   where: {
     *     // ... the filter for the Tamus we want to count
     *   }
     * })
    **/
    count<T extends TamuCountArgs>(
      args?: Subset<T, TamuCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TamuCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Tamu.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TamuAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TamuAggregateArgs>(args: Subset<T, TamuAggregateArgs>): Prisma.PrismaPromise<GetTamuAggregateType<T>>

    /**
     * Group by Tamu.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TamuGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TamuGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TamuGroupByArgs['orderBy'] }
        : { orderBy?: TamuGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TamuGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTamuGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Tamu model
   */
  readonly fields: TamuFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Tamu.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TamuClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    kunjungan<T extends KunjunganDefaultArgs<ExtArgs> = {}>(args?: Subset<T, KunjunganDefaultArgs<ExtArgs>>): Prisma__KunjunganClient<$Result.GetResult<Prisma.$KunjunganPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Tamu model
   */ 
  interface TamuFieldRefs {
    readonly id: FieldRef<"Tamu", 'String'>
    readonly kunjunganId: FieldRef<"Tamu", 'String'>
    readonly name: FieldRef<"Tamu", 'String'>
    readonly phone: FieldRef<"Tamu", 'String'>
    readonly idNumber: FieldRef<"Tamu", 'String'>
    readonly checkinAt: FieldRef<"Tamu", 'DateTime'>
    readonly createdAt: FieldRef<"Tamu", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Tamu findUnique
   */
  export type TamuFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tamu
     */
    select?: TamuSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TamuInclude<ExtArgs> | null
    /**
     * Filter, which Tamu to fetch.
     */
    where: TamuWhereUniqueInput
  }

  /**
   * Tamu findUniqueOrThrow
   */
  export type TamuFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tamu
     */
    select?: TamuSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TamuInclude<ExtArgs> | null
    /**
     * Filter, which Tamu to fetch.
     */
    where: TamuWhereUniqueInput
  }

  /**
   * Tamu findFirst
   */
  export type TamuFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tamu
     */
    select?: TamuSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TamuInclude<ExtArgs> | null
    /**
     * Filter, which Tamu to fetch.
     */
    where?: TamuWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tamus to fetch.
     */
    orderBy?: TamuOrderByWithRelationInput | TamuOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tamus.
     */
    cursor?: TamuWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tamus from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tamus.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tamus.
     */
    distinct?: TamuScalarFieldEnum | TamuScalarFieldEnum[]
  }

  /**
   * Tamu findFirstOrThrow
   */
  export type TamuFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tamu
     */
    select?: TamuSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TamuInclude<ExtArgs> | null
    /**
     * Filter, which Tamu to fetch.
     */
    where?: TamuWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tamus to fetch.
     */
    orderBy?: TamuOrderByWithRelationInput | TamuOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tamus.
     */
    cursor?: TamuWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tamus from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tamus.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tamus.
     */
    distinct?: TamuScalarFieldEnum | TamuScalarFieldEnum[]
  }

  /**
   * Tamu findMany
   */
  export type TamuFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tamu
     */
    select?: TamuSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TamuInclude<ExtArgs> | null
    /**
     * Filter, which Tamus to fetch.
     */
    where?: TamuWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tamus to fetch.
     */
    orderBy?: TamuOrderByWithRelationInput | TamuOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Tamus.
     */
    cursor?: TamuWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tamus from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tamus.
     */
    skip?: number
    distinct?: TamuScalarFieldEnum | TamuScalarFieldEnum[]
  }

  /**
   * Tamu create
   */
  export type TamuCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tamu
     */
    select?: TamuSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TamuInclude<ExtArgs> | null
    /**
     * The data needed to create a Tamu.
     */
    data: XOR<TamuCreateInput, TamuUncheckedCreateInput>
  }

  /**
   * Tamu createMany
   */
  export type TamuCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Tamus.
     */
    data: TamuCreateManyInput | TamuCreateManyInput[]
  }

  /**
   * Tamu createManyAndReturn
   */
  export type TamuCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tamu
     */
    select?: TamuSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Tamus.
     */
    data: TamuCreateManyInput | TamuCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TamuIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Tamu update
   */
  export type TamuUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tamu
     */
    select?: TamuSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TamuInclude<ExtArgs> | null
    /**
     * The data needed to update a Tamu.
     */
    data: XOR<TamuUpdateInput, TamuUncheckedUpdateInput>
    /**
     * Choose, which Tamu to update.
     */
    where: TamuWhereUniqueInput
  }

  /**
   * Tamu updateMany
   */
  export type TamuUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Tamus.
     */
    data: XOR<TamuUpdateManyMutationInput, TamuUncheckedUpdateManyInput>
    /**
     * Filter which Tamus to update
     */
    where?: TamuWhereInput
  }

  /**
   * Tamu upsert
   */
  export type TamuUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tamu
     */
    select?: TamuSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TamuInclude<ExtArgs> | null
    /**
     * The filter to search for the Tamu to update in case it exists.
     */
    where: TamuWhereUniqueInput
    /**
     * In case the Tamu found by the `where` argument doesn't exist, create a new Tamu with this data.
     */
    create: XOR<TamuCreateInput, TamuUncheckedCreateInput>
    /**
     * In case the Tamu was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TamuUpdateInput, TamuUncheckedUpdateInput>
  }

  /**
   * Tamu delete
   */
  export type TamuDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tamu
     */
    select?: TamuSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TamuInclude<ExtArgs> | null
    /**
     * Filter which Tamu to delete.
     */
    where: TamuWhereUniqueInput
  }

  /**
   * Tamu deleteMany
   */
  export type TamuDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Tamus to delete
     */
    where?: TamuWhereInput
  }

  /**
   * Tamu without action
   */
  export type TamuDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tamu
     */
    select?: TamuSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TamuInclude<ExtArgs> | null
  }


  /**
   * Model HealthRecord
   */

  export type AggregateHealthRecord = {
    _count: HealthRecordCountAggregateOutputType | null
    _min: HealthRecordMinAggregateOutputType | null
    _max: HealthRecordMaxAggregateOutputType | null
  }

  export type HealthRecordMinAggregateOutputType = {
    id: string | null
    tenantId: string | null
    santriId: string | null
    recordedBy: string | null
    symptoms: string | null
    diagnosis: string | null
    actionTaken: string | null
    referred: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type HealthRecordMaxAggregateOutputType = {
    id: string | null
    tenantId: string | null
    santriId: string | null
    recordedBy: string | null
    symptoms: string | null
    diagnosis: string | null
    actionTaken: string | null
    referred: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type HealthRecordCountAggregateOutputType = {
    id: number
    tenantId: number
    santriId: number
    recordedBy: number
    symptoms: number
    diagnosis: number
    actionTaken: number
    referred: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type HealthRecordMinAggregateInputType = {
    id?: true
    tenantId?: true
    santriId?: true
    recordedBy?: true
    symptoms?: true
    diagnosis?: true
    actionTaken?: true
    referred?: true
    createdAt?: true
    updatedAt?: true
  }

  export type HealthRecordMaxAggregateInputType = {
    id?: true
    tenantId?: true
    santriId?: true
    recordedBy?: true
    symptoms?: true
    diagnosis?: true
    actionTaken?: true
    referred?: true
    createdAt?: true
    updatedAt?: true
  }

  export type HealthRecordCountAggregateInputType = {
    id?: true
    tenantId?: true
    santriId?: true
    recordedBy?: true
    symptoms?: true
    diagnosis?: true
    actionTaken?: true
    referred?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type HealthRecordAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which HealthRecord to aggregate.
     */
    where?: HealthRecordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HealthRecords to fetch.
     */
    orderBy?: HealthRecordOrderByWithRelationInput | HealthRecordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: HealthRecordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HealthRecords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HealthRecords.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned HealthRecords
    **/
    _count?: true | HealthRecordCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: HealthRecordMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: HealthRecordMaxAggregateInputType
  }

  export type GetHealthRecordAggregateType<T extends HealthRecordAggregateArgs> = {
        [P in keyof T & keyof AggregateHealthRecord]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateHealthRecord[P]>
      : GetScalarType<T[P], AggregateHealthRecord[P]>
  }




  export type HealthRecordGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: HealthRecordWhereInput
    orderBy?: HealthRecordOrderByWithAggregationInput | HealthRecordOrderByWithAggregationInput[]
    by: HealthRecordScalarFieldEnum[] | HealthRecordScalarFieldEnum
    having?: HealthRecordScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: HealthRecordCountAggregateInputType | true
    _min?: HealthRecordMinAggregateInputType
    _max?: HealthRecordMaxAggregateInputType
  }

  export type HealthRecordGroupByOutputType = {
    id: string
    tenantId: string
    santriId: string
    recordedBy: string
    symptoms: string
    diagnosis: string | null
    actionTaken: string | null
    referred: boolean
    createdAt: Date
    updatedAt: Date
    _count: HealthRecordCountAggregateOutputType | null
    _min: HealthRecordMinAggregateOutputType | null
    _max: HealthRecordMaxAggregateOutputType | null
  }

  type GetHealthRecordGroupByPayload<T extends HealthRecordGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<HealthRecordGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof HealthRecordGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], HealthRecordGroupByOutputType[P]>
            : GetScalarType<T[P], HealthRecordGroupByOutputType[P]>
        }
      >
    >


  export type HealthRecordSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    santriId?: boolean
    recordedBy?: boolean
    symptoms?: boolean
    diagnosis?: boolean
    actionTaken?: boolean
    referred?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    santri?: boolean | SantriDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["healthRecord"]>

  export type HealthRecordSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    santriId?: boolean
    recordedBy?: boolean
    symptoms?: boolean
    diagnosis?: boolean
    actionTaken?: boolean
    referred?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    santri?: boolean | SantriDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["healthRecord"]>

  export type HealthRecordSelectScalar = {
    id?: boolean
    tenantId?: boolean
    santriId?: boolean
    recordedBy?: boolean
    symptoms?: boolean
    diagnosis?: boolean
    actionTaken?: boolean
    referred?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type HealthRecordInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    santri?: boolean | SantriDefaultArgs<ExtArgs>
  }
  export type HealthRecordIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    santri?: boolean | SantriDefaultArgs<ExtArgs>
  }

  export type $HealthRecordPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "HealthRecord"
    objects: {
      tenant: Prisma.$TenantPayload<ExtArgs>
      santri: Prisma.$SantriPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      tenantId: string
      santriId: string
      recordedBy: string
      symptoms: string
      diagnosis: string | null
      actionTaken: string | null
      referred: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["healthRecord"]>
    composites: {}
  }

  type HealthRecordGetPayload<S extends boolean | null | undefined | HealthRecordDefaultArgs> = $Result.GetResult<Prisma.$HealthRecordPayload, S>

  type HealthRecordCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<HealthRecordFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: HealthRecordCountAggregateInputType | true
    }

  export interface HealthRecordDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['HealthRecord'], meta: { name: 'HealthRecord' } }
    /**
     * Find zero or one HealthRecord that matches the filter.
     * @param {HealthRecordFindUniqueArgs} args - Arguments to find a HealthRecord
     * @example
     * // Get one HealthRecord
     * const healthRecord = await prisma.healthRecord.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends HealthRecordFindUniqueArgs>(args: SelectSubset<T, HealthRecordFindUniqueArgs<ExtArgs>>): Prisma__HealthRecordClient<$Result.GetResult<Prisma.$HealthRecordPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one HealthRecord that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {HealthRecordFindUniqueOrThrowArgs} args - Arguments to find a HealthRecord
     * @example
     * // Get one HealthRecord
     * const healthRecord = await prisma.healthRecord.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends HealthRecordFindUniqueOrThrowArgs>(args: SelectSubset<T, HealthRecordFindUniqueOrThrowArgs<ExtArgs>>): Prisma__HealthRecordClient<$Result.GetResult<Prisma.$HealthRecordPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first HealthRecord that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HealthRecordFindFirstArgs} args - Arguments to find a HealthRecord
     * @example
     * // Get one HealthRecord
     * const healthRecord = await prisma.healthRecord.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends HealthRecordFindFirstArgs>(args?: SelectSubset<T, HealthRecordFindFirstArgs<ExtArgs>>): Prisma__HealthRecordClient<$Result.GetResult<Prisma.$HealthRecordPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first HealthRecord that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HealthRecordFindFirstOrThrowArgs} args - Arguments to find a HealthRecord
     * @example
     * // Get one HealthRecord
     * const healthRecord = await prisma.healthRecord.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends HealthRecordFindFirstOrThrowArgs>(args?: SelectSubset<T, HealthRecordFindFirstOrThrowArgs<ExtArgs>>): Prisma__HealthRecordClient<$Result.GetResult<Prisma.$HealthRecordPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more HealthRecords that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HealthRecordFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all HealthRecords
     * const healthRecords = await prisma.healthRecord.findMany()
     * 
     * // Get first 10 HealthRecords
     * const healthRecords = await prisma.healthRecord.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const healthRecordWithIdOnly = await prisma.healthRecord.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends HealthRecordFindManyArgs>(args?: SelectSubset<T, HealthRecordFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HealthRecordPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a HealthRecord.
     * @param {HealthRecordCreateArgs} args - Arguments to create a HealthRecord.
     * @example
     * // Create one HealthRecord
     * const HealthRecord = await prisma.healthRecord.create({
     *   data: {
     *     // ... data to create a HealthRecord
     *   }
     * })
     * 
     */
    create<T extends HealthRecordCreateArgs>(args: SelectSubset<T, HealthRecordCreateArgs<ExtArgs>>): Prisma__HealthRecordClient<$Result.GetResult<Prisma.$HealthRecordPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many HealthRecords.
     * @param {HealthRecordCreateManyArgs} args - Arguments to create many HealthRecords.
     * @example
     * // Create many HealthRecords
     * const healthRecord = await prisma.healthRecord.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends HealthRecordCreateManyArgs>(args?: SelectSubset<T, HealthRecordCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many HealthRecords and returns the data saved in the database.
     * @param {HealthRecordCreateManyAndReturnArgs} args - Arguments to create many HealthRecords.
     * @example
     * // Create many HealthRecords
     * const healthRecord = await prisma.healthRecord.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many HealthRecords and only return the `id`
     * const healthRecordWithIdOnly = await prisma.healthRecord.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends HealthRecordCreateManyAndReturnArgs>(args?: SelectSubset<T, HealthRecordCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HealthRecordPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a HealthRecord.
     * @param {HealthRecordDeleteArgs} args - Arguments to delete one HealthRecord.
     * @example
     * // Delete one HealthRecord
     * const HealthRecord = await prisma.healthRecord.delete({
     *   where: {
     *     // ... filter to delete one HealthRecord
     *   }
     * })
     * 
     */
    delete<T extends HealthRecordDeleteArgs>(args: SelectSubset<T, HealthRecordDeleteArgs<ExtArgs>>): Prisma__HealthRecordClient<$Result.GetResult<Prisma.$HealthRecordPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one HealthRecord.
     * @param {HealthRecordUpdateArgs} args - Arguments to update one HealthRecord.
     * @example
     * // Update one HealthRecord
     * const healthRecord = await prisma.healthRecord.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends HealthRecordUpdateArgs>(args: SelectSubset<T, HealthRecordUpdateArgs<ExtArgs>>): Prisma__HealthRecordClient<$Result.GetResult<Prisma.$HealthRecordPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more HealthRecords.
     * @param {HealthRecordDeleteManyArgs} args - Arguments to filter HealthRecords to delete.
     * @example
     * // Delete a few HealthRecords
     * const { count } = await prisma.healthRecord.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends HealthRecordDeleteManyArgs>(args?: SelectSubset<T, HealthRecordDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more HealthRecords.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HealthRecordUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many HealthRecords
     * const healthRecord = await prisma.healthRecord.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends HealthRecordUpdateManyArgs>(args: SelectSubset<T, HealthRecordUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one HealthRecord.
     * @param {HealthRecordUpsertArgs} args - Arguments to update or create a HealthRecord.
     * @example
     * // Update or create a HealthRecord
     * const healthRecord = await prisma.healthRecord.upsert({
     *   create: {
     *     // ... data to create a HealthRecord
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the HealthRecord we want to update
     *   }
     * })
     */
    upsert<T extends HealthRecordUpsertArgs>(args: SelectSubset<T, HealthRecordUpsertArgs<ExtArgs>>): Prisma__HealthRecordClient<$Result.GetResult<Prisma.$HealthRecordPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of HealthRecords.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HealthRecordCountArgs} args - Arguments to filter HealthRecords to count.
     * @example
     * // Count the number of HealthRecords
     * const count = await prisma.healthRecord.count({
     *   where: {
     *     // ... the filter for the HealthRecords we want to count
     *   }
     * })
    **/
    count<T extends HealthRecordCountArgs>(
      args?: Subset<T, HealthRecordCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], HealthRecordCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a HealthRecord.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HealthRecordAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends HealthRecordAggregateArgs>(args: Subset<T, HealthRecordAggregateArgs>): Prisma.PrismaPromise<GetHealthRecordAggregateType<T>>

    /**
     * Group by HealthRecord.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HealthRecordGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends HealthRecordGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: HealthRecordGroupByArgs['orderBy'] }
        : { orderBy?: HealthRecordGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, HealthRecordGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetHealthRecordGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the HealthRecord model
   */
  readonly fields: HealthRecordFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for HealthRecord.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__HealthRecordClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    tenant<T extends TenantDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TenantDefaultArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    santri<T extends SantriDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SantriDefaultArgs<ExtArgs>>): Prisma__SantriClient<$Result.GetResult<Prisma.$SantriPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the HealthRecord model
   */ 
  interface HealthRecordFieldRefs {
    readonly id: FieldRef<"HealthRecord", 'String'>
    readonly tenantId: FieldRef<"HealthRecord", 'String'>
    readonly santriId: FieldRef<"HealthRecord", 'String'>
    readonly recordedBy: FieldRef<"HealthRecord", 'String'>
    readonly symptoms: FieldRef<"HealthRecord", 'String'>
    readonly diagnosis: FieldRef<"HealthRecord", 'String'>
    readonly actionTaken: FieldRef<"HealthRecord", 'String'>
    readonly referred: FieldRef<"HealthRecord", 'Boolean'>
    readonly createdAt: FieldRef<"HealthRecord", 'DateTime'>
    readonly updatedAt: FieldRef<"HealthRecord", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * HealthRecord findUnique
   */
  export type HealthRecordFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HealthRecord
     */
    select?: HealthRecordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HealthRecordInclude<ExtArgs> | null
    /**
     * Filter, which HealthRecord to fetch.
     */
    where: HealthRecordWhereUniqueInput
  }

  /**
   * HealthRecord findUniqueOrThrow
   */
  export type HealthRecordFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HealthRecord
     */
    select?: HealthRecordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HealthRecordInclude<ExtArgs> | null
    /**
     * Filter, which HealthRecord to fetch.
     */
    where: HealthRecordWhereUniqueInput
  }

  /**
   * HealthRecord findFirst
   */
  export type HealthRecordFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HealthRecord
     */
    select?: HealthRecordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HealthRecordInclude<ExtArgs> | null
    /**
     * Filter, which HealthRecord to fetch.
     */
    where?: HealthRecordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HealthRecords to fetch.
     */
    orderBy?: HealthRecordOrderByWithRelationInput | HealthRecordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for HealthRecords.
     */
    cursor?: HealthRecordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HealthRecords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HealthRecords.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of HealthRecords.
     */
    distinct?: HealthRecordScalarFieldEnum | HealthRecordScalarFieldEnum[]
  }

  /**
   * HealthRecord findFirstOrThrow
   */
  export type HealthRecordFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HealthRecord
     */
    select?: HealthRecordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HealthRecordInclude<ExtArgs> | null
    /**
     * Filter, which HealthRecord to fetch.
     */
    where?: HealthRecordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HealthRecords to fetch.
     */
    orderBy?: HealthRecordOrderByWithRelationInput | HealthRecordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for HealthRecords.
     */
    cursor?: HealthRecordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HealthRecords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HealthRecords.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of HealthRecords.
     */
    distinct?: HealthRecordScalarFieldEnum | HealthRecordScalarFieldEnum[]
  }

  /**
   * HealthRecord findMany
   */
  export type HealthRecordFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HealthRecord
     */
    select?: HealthRecordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HealthRecordInclude<ExtArgs> | null
    /**
     * Filter, which HealthRecords to fetch.
     */
    where?: HealthRecordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HealthRecords to fetch.
     */
    orderBy?: HealthRecordOrderByWithRelationInput | HealthRecordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing HealthRecords.
     */
    cursor?: HealthRecordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HealthRecords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HealthRecords.
     */
    skip?: number
    distinct?: HealthRecordScalarFieldEnum | HealthRecordScalarFieldEnum[]
  }

  /**
   * HealthRecord create
   */
  export type HealthRecordCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HealthRecord
     */
    select?: HealthRecordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HealthRecordInclude<ExtArgs> | null
    /**
     * The data needed to create a HealthRecord.
     */
    data: XOR<HealthRecordCreateInput, HealthRecordUncheckedCreateInput>
  }

  /**
   * HealthRecord createMany
   */
  export type HealthRecordCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many HealthRecords.
     */
    data: HealthRecordCreateManyInput | HealthRecordCreateManyInput[]
  }

  /**
   * HealthRecord createManyAndReturn
   */
  export type HealthRecordCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HealthRecord
     */
    select?: HealthRecordSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many HealthRecords.
     */
    data: HealthRecordCreateManyInput | HealthRecordCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HealthRecordIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * HealthRecord update
   */
  export type HealthRecordUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HealthRecord
     */
    select?: HealthRecordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HealthRecordInclude<ExtArgs> | null
    /**
     * The data needed to update a HealthRecord.
     */
    data: XOR<HealthRecordUpdateInput, HealthRecordUncheckedUpdateInput>
    /**
     * Choose, which HealthRecord to update.
     */
    where: HealthRecordWhereUniqueInput
  }

  /**
   * HealthRecord updateMany
   */
  export type HealthRecordUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update HealthRecords.
     */
    data: XOR<HealthRecordUpdateManyMutationInput, HealthRecordUncheckedUpdateManyInput>
    /**
     * Filter which HealthRecords to update
     */
    where?: HealthRecordWhereInput
  }

  /**
   * HealthRecord upsert
   */
  export type HealthRecordUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HealthRecord
     */
    select?: HealthRecordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HealthRecordInclude<ExtArgs> | null
    /**
     * The filter to search for the HealthRecord to update in case it exists.
     */
    where: HealthRecordWhereUniqueInput
    /**
     * In case the HealthRecord found by the `where` argument doesn't exist, create a new HealthRecord with this data.
     */
    create: XOR<HealthRecordCreateInput, HealthRecordUncheckedCreateInput>
    /**
     * In case the HealthRecord was found with the provided `where` argument, update it with this data.
     */
    update: XOR<HealthRecordUpdateInput, HealthRecordUncheckedUpdateInput>
  }

  /**
   * HealthRecord delete
   */
  export type HealthRecordDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HealthRecord
     */
    select?: HealthRecordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HealthRecordInclude<ExtArgs> | null
    /**
     * Filter which HealthRecord to delete.
     */
    where: HealthRecordWhereUniqueInput
  }

  /**
   * HealthRecord deleteMany
   */
  export type HealthRecordDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which HealthRecords to delete
     */
    where?: HealthRecordWhereInput
  }

  /**
   * HealthRecord without action
   */
  export type HealthRecordDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HealthRecord
     */
    select?: HealthRecordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HealthRecordInclude<ExtArgs> | null
  }


  /**
   * Model Medication
   */

  export type AggregateMedication = {
    _count: MedicationCountAggregateOutputType | null
    _min: MedicationMinAggregateOutputType | null
    _max: MedicationMaxAggregateOutputType | null
  }

  export type MedicationMinAggregateOutputType = {
    id: string | null
    santriId: string | null
    medicineName: string | null
    dose: string | null
    schedule: string | null
    givenBy: string | null
    givenAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MedicationMaxAggregateOutputType = {
    id: string | null
    santriId: string | null
    medicineName: string | null
    dose: string | null
    schedule: string | null
    givenBy: string | null
    givenAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MedicationCountAggregateOutputType = {
    id: number
    santriId: number
    medicineName: number
    dose: number
    schedule: number
    givenBy: number
    givenAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type MedicationMinAggregateInputType = {
    id?: true
    santriId?: true
    medicineName?: true
    dose?: true
    schedule?: true
    givenBy?: true
    givenAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MedicationMaxAggregateInputType = {
    id?: true
    santriId?: true
    medicineName?: true
    dose?: true
    schedule?: true
    givenBy?: true
    givenAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MedicationCountAggregateInputType = {
    id?: true
    santriId?: true
    medicineName?: true
    dose?: true
    schedule?: true
    givenBy?: true
    givenAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type MedicationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Medication to aggregate.
     */
    where?: MedicationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Medications to fetch.
     */
    orderBy?: MedicationOrderByWithRelationInput | MedicationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MedicationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Medications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Medications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Medications
    **/
    _count?: true | MedicationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MedicationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MedicationMaxAggregateInputType
  }

  export type GetMedicationAggregateType<T extends MedicationAggregateArgs> = {
        [P in keyof T & keyof AggregateMedication]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMedication[P]>
      : GetScalarType<T[P], AggregateMedication[P]>
  }




  export type MedicationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MedicationWhereInput
    orderBy?: MedicationOrderByWithAggregationInput | MedicationOrderByWithAggregationInput[]
    by: MedicationScalarFieldEnum[] | MedicationScalarFieldEnum
    having?: MedicationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MedicationCountAggregateInputType | true
    _min?: MedicationMinAggregateInputType
    _max?: MedicationMaxAggregateInputType
  }

  export type MedicationGroupByOutputType = {
    id: string
    santriId: string
    medicineName: string
    dose: string
    schedule: string
    givenBy: string | null
    givenAt: Date | null
    createdAt: Date
    updatedAt: Date
    _count: MedicationCountAggregateOutputType | null
    _min: MedicationMinAggregateOutputType | null
    _max: MedicationMaxAggregateOutputType | null
  }

  type GetMedicationGroupByPayload<T extends MedicationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MedicationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MedicationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MedicationGroupByOutputType[P]>
            : GetScalarType<T[P], MedicationGroupByOutputType[P]>
        }
      >
    >


  export type MedicationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    santriId?: boolean
    medicineName?: boolean
    dose?: boolean
    schedule?: boolean
    givenBy?: boolean
    givenAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    santri?: boolean | SantriDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["medication"]>

  export type MedicationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    santriId?: boolean
    medicineName?: boolean
    dose?: boolean
    schedule?: boolean
    givenBy?: boolean
    givenAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    santri?: boolean | SantriDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["medication"]>

  export type MedicationSelectScalar = {
    id?: boolean
    santriId?: boolean
    medicineName?: boolean
    dose?: boolean
    schedule?: boolean
    givenBy?: boolean
    givenAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type MedicationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    santri?: boolean | SantriDefaultArgs<ExtArgs>
  }
  export type MedicationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    santri?: boolean | SantriDefaultArgs<ExtArgs>
  }

  export type $MedicationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Medication"
    objects: {
      santri: Prisma.$SantriPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      santriId: string
      medicineName: string
      dose: string
      schedule: string
      givenBy: string | null
      givenAt: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["medication"]>
    composites: {}
  }

  type MedicationGetPayload<S extends boolean | null | undefined | MedicationDefaultArgs> = $Result.GetResult<Prisma.$MedicationPayload, S>

  type MedicationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<MedicationFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: MedicationCountAggregateInputType | true
    }

  export interface MedicationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Medication'], meta: { name: 'Medication' } }
    /**
     * Find zero or one Medication that matches the filter.
     * @param {MedicationFindUniqueArgs} args - Arguments to find a Medication
     * @example
     * // Get one Medication
     * const medication = await prisma.medication.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MedicationFindUniqueArgs>(args: SelectSubset<T, MedicationFindUniqueArgs<ExtArgs>>): Prisma__MedicationClient<$Result.GetResult<Prisma.$MedicationPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Medication that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {MedicationFindUniqueOrThrowArgs} args - Arguments to find a Medication
     * @example
     * // Get one Medication
     * const medication = await prisma.medication.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MedicationFindUniqueOrThrowArgs>(args: SelectSubset<T, MedicationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MedicationClient<$Result.GetResult<Prisma.$MedicationPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Medication that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MedicationFindFirstArgs} args - Arguments to find a Medication
     * @example
     * // Get one Medication
     * const medication = await prisma.medication.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MedicationFindFirstArgs>(args?: SelectSubset<T, MedicationFindFirstArgs<ExtArgs>>): Prisma__MedicationClient<$Result.GetResult<Prisma.$MedicationPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Medication that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MedicationFindFirstOrThrowArgs} args - Arguments to find a Medication
     * @example
     * // Get one Medication
     * const medication = await prisma.medication.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MedicationFindFirstOrThrowArgs>(args?: SelectSubset<T, MedicationFindFirstOrThrowArgs<ExtArgs>>): Prisma__MedicationClient<$Result.GetResult<Prisma.$MedicationPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Medications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MedicationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Medications
     * const medications = await prisma.medication.findMany()
     * 
     * // Get first 10 Medications
     * const medications = await prisma.medication.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const medicationWithIdOnly = await prisma.medication.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MedicationFindManyArgs>(args?: SelectSubset<T, MedicationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MedicationPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Medication.
     * @param {MedicationCreateArgs} args - Arguments to create a Medication.
     * @example
     * // Create one Medication
     * const Medication = await prisma.medication.create({
     *   data: {
     *     // ... data to create a Medication
     *   }
     * })
     * 
     */
    create<T extends MedicationCreateArgs>(args: SelectSubset<T, MedicationCreateArgs<ExtArgs>>): Prisma__MedicationClient<$Result.GetResult<Prisma.$MedicationPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Medications.
     * @param {MedicationCreateManyArgs} args - Arguments to create many Medications.
     * @example
     * // Create many Medications
     * const medication = await prisma.medication.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MedicationCreateManyArgs>(args?: SelectSubset<T, MedicationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Medications and returns the data saved in the database.
     * @param {MedicationCreateManyAndReturnArgs} args - Arguments to create many Medications.
     * @example
     * // Create many Medications
     * const medication = await prisma.medication.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Medications and only return the `id`
     * const medicationWithIdOnly = await prisma.medication.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MedicationCreateManyAndReturnArgs>(args?: SelectSubset<T, MedicationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MedicationPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Medication.
     * @param {MedicationDeleteArgs} args - Arguments to delete one Medication.
     * @example
     * // Delete one Medication
     * const Medication = await prisma.medication.delete({
     *   where: {
     *     // ... filter to delete one Medication
     *   }
     * })
     * 
     */
    delete<T extends MedicationDeleteArgs>(args: SelectSubset<T, MedicationDeleteArgs<ExtArgs>>): Prisma__MedicationClient<$Result.GetResult<Prisma.$MedicationPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Medication.
     * @param {MedicationUpdateArgs} args - Arguments to update one Medication.
     * @example
     * // Update one Medication
     * const medication = await prisma.medication.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MedicationUpdateArgs>(args: SelectSubset<T, MedicationUpdateArgs<ExtArgs>>): Prisma__MedicationClient<$Result.GetResult<Prisma.$MedicationPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Medications.
     * @param {MedicationDeleteManyArgs} args - Arguments to filter Medications to delete.
     * @example
     * // Delete a few Medications
     * const { count } = await prisma.medication.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MedicationDeleteManyArgs>(args?: SelectSubset<T, MedicationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Medications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MedicationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Medications
     * const medication = await prisma.medication.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MedicationUpdateManyArgs>(args: SelectSubset<T, MedicationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Medication.
     * @param {MedicationUpsertArgs} args - Arguments to update or create a Medication.
     * @example
     * // Update or create a Medication
     * const medication = await prisma.medication.upsert({
     *   create: {
     *     // ... data to create a Medication
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Medication we want to update
     *   }
     * })
     */
    upsert<T extends MedicationUpsertArgs>(args: SelectSubset<T, MedicationUpsertArgs<ExtArgs>>): Prisma__MedicationClient<$Result.GetResult<Prisma.$MedicationPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Medications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MedicationCountArgs} args - Arguments to filter Medications to count.
     * @example
     * // Count the number of Medications
     * const count = await prisma.medication.count({
     *   where: {
     *     // ... the filter for the Medications we want to count
     *   }
     * })
    **/
    count<T extends MedicationCountArgs>(
      args?: Subset<T, MedicationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MedicationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Medication.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MedicationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MedicationAggregateArgs>(args: Subset<T, MedicationAggregateArgs>): Prisma.PrismaPromise<GetMedicationAggregateType<T>>

    /**
     * Group by Medication.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MedicationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MedicationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MedicationGroupByArgs['orderBy'] }
        : { orderBy?: MedicationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MedicationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMedicationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Medication model
   */
  readonly fields: MedicationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Medication.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MedicationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    santri<T extends SantriDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SantriDefaultArgs<ExtArgs>>): Prisma__SantriClient<$Result.GetResult<Prisma.$SantriPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Medication model
   */ 
  interface MedicationFieldRefs {
    readonly id: FieldRef<"Medication", 'String'>
    readonly santriId: FieldRef<"Medication", 'String'>
    readonly medicineName: FieldRef<"Medication", 'String'>
    readonly dose: FieldRef<"Medication", 'String'>
    readonly schedule: FieldRef<"Medication", 'String'>
    readonly givenBy: FieldRef<"Medication", 'String'>
    readonly givenAt: FieldRef<"Medication", 'DateTime'>
    readonly createdAt: FieldRef<"Medication", 'DateTime'>
    readonly updatedAt: FieldRef<"Medication", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Medication findUnique
   */
  export type MedicationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Medication
     */
    select?: MedicationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicationInclude<ExtArgs> | null
    /**
     * Filter, which Medication to fetch.
     */
    where: MedicationWhereUniqueInput
  }

  /**
   * Medication findUniqueOrThrow
   */
  export type MedicationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Medication
     */
    select?: MedicationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicationInclude<ExtArgs> | null
    /**
     * Filter, which Medication to fetch.
     */
    where: MedicationWhereUniqueInput
  }

  /**
   * Medication findFirst
   */
  export type MedicationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Medication
     */
    select?: MedicationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicationInclude<ExtArgs> | null
    /**
     * Filter, which Medication to fetch.
     */
    where?: MedicationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Medications to fetch.
     */
    orderBy?: MedicationOrderByWithRelationInput | MedicationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Medications.
     */
    cursor?: MedicationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Medications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Medications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Medications.
     */
    distinct?: MedicationScalarFieldEnum | MedicationScalarFieldEnum[]
  }

  /**
   * Medication findFirstOrThrow
   */
  export type MedicationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Medication
     */
    select?: MedicationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicationInclude<ExtArgs> | null
    /**
     * Filter, which Medication to fetch.
     */
    where?: MedicationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Medications to fetch.
     */
    orderBy?: MedicationOrderByWithRelationInput | MedicationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Medications.
     */
    cursor?: MedicationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Medications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Medications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Medications.
     */
    distinct?: MedicationScalarFieldEnum | MedicationScalarFieldEnum[]
  }

  /**
   * Medication findMany
   */
  export type MedicationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Medication
     */
    select?: MedicationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicationInclude<ExtArgs> | null
    /**
     * Filter, which Medications to fetch.
     */
    where?: MedicationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Medications to fetch.
     */
    orderBy?: MedicationOrderByWithRelationInput | MedicationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Medications.
     */
    cursor?: MedicationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Medications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Medications.
     */
    skip?: number
    distinct?: MedicationScalarFieldEnum | MedicationScalarFieldEnum[]
  }

  /**
   * Medication create
   */
  export type MedicationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Medication
     */
    select?: MedicationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicationInclude<ExtArgs> | null
    /**
     * The data needed to create a Medication.
     */
    data: XOR<MedicationCreateInput, MedicationUncheckedCreateInput>
  }

  /**
   * Medication createMany
   */
  export type MedicationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Medications.
     */
    data: MedicationCreateManyInput | MedicationCreateManyInput[]
  }

  /**
   * Medication createManyAndReturn
   */
  export type MedicationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Medication
     */
    select?: MedicationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Medications.
     */
    data: MedicationCreateManyInput | MedicationCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Medication update
   */
  export type MedicationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Medication
     */
    select?: MedicationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicationInclude<ExtArgs> | null
    /**
     * The data needed to update a Medication.
     */
    data: XOR<MedicationUpdateInput, MedicationUncheckedUpdateInput>
    /**
     * Choose, which Medication to update.
     */
    where: MedicationWhereUniqueInput
  }

  /**
   * Medication updateMany
   */
  export type MedicationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Medications.
     */
    data: XOR<MedicationUpdateManyMutationInput, MedicationUncheckedUpdateManyInput>
    /**
     * Filter which Medications to update
     */
    where?: MedicationWhereInput
  }

  /**
   * Medication upsert
   */
  export type MedicationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Medication
     */
    select?: MedicationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicationInclude<ExtArgs> | null
    /**
     * The filter to search for the Medication to update in case it exists.
     */
    where: MedicationWhereUniqueInput
    /**
     * In case the Medication found by the `where` argument doesn't exist, create a new Medication with this data.
     */
    create: XOR<MedicationCreateInput, MedicationUncheckedCreateInput>
    /**
     * In case the Medication was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MedicationUpdateInput, MedicationUncheckedUpdateInput>
  }

  /**
   * Medication delete
   */
  export type MedicationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Medication
     */
    select?: MedicationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicationInclude<ExtArgs> | null
    /**
     * Filter which Medication to delete.
     */
    where: MedicationWhereUniqueInput
  }

  /**
   * Medication deleteMany
   */
  export type MedicationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Medications to delete
     */
    where?: MedicationWhereInput
  }

  /**
   * Medication without action
   */
  export type MedicationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Medication
     */
    select?: MedicationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicationInclude<ExtArgs> | null
  }


  /**
   * Model AuditLog
   */

  export type AggregateAuditLog = {
    _count: AuditLogCountAggregateOutputType | null
    _min: AuditLogMinAggregateOutputType | null
    _max: AuditLogMaxAggregateOutputType | null
  }

  export type AuditLogMinAggregateOutputType = {
    id: string | null
    tenantId: string | null
    userId: string | null
    action: string | null
    entity: string | null
    entityId: string | null
    oldValue: string | null
    newValue: string | null
    ip: string | null
    createdAt: Date | null
  }

  export type AuditLogMaxAggregateOutputType = {
    id: string | null
    tenantId: string | null
    userId: string | null
    action: string | null
    entity: string | null
    entityId: string | null
    oldValue: string | null
    newValue: string | null
    ip: string | null
    createdAt: Date | null
  }

  export type AuditLogCountAggregateOutputType = {
    id: number
    tenantId: number
    userId: number
    action: number
    entity: number
    entityId: number
    oldValue: number
    newValue: number
    ip: number
    createdAt: number
    _all: number
  }


  export type AuditLogMinAggregateInputType = {
    id?: true
    tenantId?: true
    userId?: true
    action?: true
    entity?: true
    entityId?: true
    oldValue?: true
    newValue?: true
    ip?: true
    createdAt?: true
  }

  export type AuditLogMaxAggregateInputType = {
    id?: true
    tenantId?: true
    userId?: true
    action?: true
    entity?: true
    entityId?: true
    oldValue?: true
    newValue?: true
    ip?: true
    createdAt?: true
  }

  export type AuditLogCountAggregateInputType = {
    id?: true
    tenantId?: true
    userId?: true
    action?: true
    entity?: true
    entityId?: true
    oldValue?: true
    newValue?: true
    ip?: true
    createdAt?: true
    _all?: true
  }

  export type AuditLogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AuditLog to aggregate.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AuditLogs
    **/
    _count?: true | AuditLogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AuditLogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AuditLogMaxAggregateInputType
  }

  export type GetAuditLogAggregateType<T extends AuditLogAggregateArgs> = {
        [P in keyof T & keyof AggregateAuditLog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAuditLog[P]>
      : GetScalarType<T[P], AggregateAuditLog[P]>
  }




  export type AuditLogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AuditLogWhereInput
    orderBy?: AuditLogOrderByWithAggregationInput | AuditLogOrderByWithAggregationInput[]
    by: AuditLogScalarFieldEnum[] | AuditLogScalarFieldEnum
    having?: AuditLogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AuditLogCountAggregateInputType | true
    _min?: AuditLogMinAggregateInputType
    _max?: AuditLogMaxAggregateInputType
  }

  export type AuditLogGroupByOutputType = {
    id: string
    tenantId: string | null
    userId: string | null
    action: string
    entity: string
    entityId: string
    oldValue: string | null
    newValue: string | null
    ip: string | null
    createdAt: Date
    _count: AuditLogCountAggregateOutputType | null
    _min: AuditLogMinAggregateOutputType | null
    _max: AuditLogMaxAggregateOutputType | null
  }

  type GetAuditLogGroupByPayload<T extends AuditLogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AuditLogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AuditLogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AuditLogGroupByOutputType[P]>
            : GetScalarType<T[P], AuditLogGroupByOutputType[P]>
        }
      >
    >


  export type AuditLogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    userId?: boolean
    action?: boolean
    entity?: boolean
    entityId?: boolean
    oldValue?: boolean
    newValue?: boolean
    ip?: boolean
    createdAt?: boolean
    tenant?: boolean | AuditLog$tenantArgs<ExtArgs>
    user?: boolean | AuditLog$userArgs<ExtArgs>
  }, ExtArgs["result"]["auditLog"]>

  export type AuditLogSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    userId?: boolean
    action?: boolean
    entity?: boolean
    entityId?: boolean
    oldValue?: boolean
    newValue?: boolean
    ip?: boolean
    createdAt?: boolean
    tenant?: boolean | AuditLog$tenantArgs<ExtArgs>
    user?: boolean | AuditLog$userArgs<ExtArgs>
  }, ExtArgs["result"]["auditLog"]>

  export type AuditLogSelectScalar = {
    id?: boolean
    tenantId?: boolean
    userId?: boolean
    action?: boolean
    entity?: boolean
    entityId?: boolean
    oldValue?: boolean
    newValue?: boolean
    ip?: boolean
    createdAt?: boolean
  }

  export type AuditLogInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | AuditLog$tenantArgs<ExtArgs>
    user?: boolean | AuditLog$userArgs<ExtArgs>
  }
  export type AuditLogIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | AuditLog$tenantArgs<ExtArgs>
    user?: boolean | AuditLog$userArgs<ExtArgs>
  }

  export type $AuditLogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AuditLog"
    objects: {
      tenant: Prisma.$TenantPayload<ExtArgs> | null
      user: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      tenantId: string | null
      userId: string | null
      action: string
      entity: string
      entityId: string
      oldValue: string | null
      newValue: string | null
      ip: string | null
      createdAt: Date
    }, ExtArgs["result"]["auditLog"]>
    composites: {}
  }

  type AuditLogGetPayload<S extends boolean | null | undefined | AuditLogDefaultArgs> = $Result.GetResult<Prisma.$AuditLogPayload, S>

  type AuditLogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<AuditLogFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: AuditLogCountAggregateInputType | true
    }

  export interface AuditLogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AuditLog'], meta: { name: 'AuditLog' } }
    /**
     * Find zero or one AuditLog that matches the filter.
     * @param {AuditLogFindUniqueArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AuditLogFindUniqueArgs>(args: SelectSubset<T, AuditLogFindUniqueArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one AuditLog that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {AuditLogFindUniqueOrThrowArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AuditLogFindUniqueOrThrowArgs>(args: SelectSubset<T, AuditLogFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first AuditLog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogFindFirstArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AuditLogFindFirstArgs>(args?: SelectSubset<T, AuditLogFindFirstArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first AuditLog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogFindFirstOrThrowArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AuditLogFindFirstOrThrowArgs>(args?: SelectSubset<T, AuditLogFindFirstOrThrowArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more AuditLogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AuditLogs
     * const auditLogs = await prisma.auditLog.findMany()
     * 
     * // Get first 10 AuditLogs
     * const auditLogs = await prisma.auditLog.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const auditLogWithIdOnly = await prisma.auditLog.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AuditLogFindManyArgs>(args?: SelectSubset<T, AuditLogFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a AuditLog.
     * @param {AuditLogCreateArgs} args - Arguments to create a AuditLog.
     * @example
     * // Create one AuditLog
     * const AuditLog = await prisma.auditLog.create({
     *   data: {
     *     // ... data to create a AuditLog
     *   }
     * })
     * 
     */
    create<T extends AuditLogCreateArgs>(args: SelectSubset<T, AuditLogCreateArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many AuditLogs.
     * @param {AuditLogCreateManyArgs} args - Arguments to create many AuditLogs.
     * @example
     * // Create many AuditLogs
     * const auditLog = await prisma.auditLog.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AuditLogCreateManyArgs>(args?: SelectSubset<T, AuditLogCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AuditLogs and returns the data saved in the database.
     * @param {AuditLogCreateManyAndReturnArgs} args - Arguments to create many AuditLogs.
     * @example
     * // Create many AuditLogs
     * const auditLog = await prisma.auditLog.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AuditLogs and only return the `id`
     * const auditLogWithIdOnly = await prisma.auditLog.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AuditLogCreateManyAndReturnArgs>(args?: SelectSubset<T, AuditLogCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a AuditLog.
     * @param {AuditLogDeleteArgs} args - Arguments to delete one AuditLog.
     * @example
     * // Delete one AuditLog
     * const AuditLog = await prisma.auditLog.delete({
     *   where: {
     *     // ... filter to delete one AuditLog
     *   }
     * })
     * 
     */
    delete<T extends AuditLogDeleteArgs>(args: SelectSubset<T, AuditLogDeleteArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one AuditLog.
     * @param {AuditLogUpdateArgs} args - Arguments to update one AuditLog.
     * @example
     * // Update one AuditLog
     * const auditLog = await prisma.auditLog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AuditLogUpdateArgs>(args: SelectSubset<T, AuditLogUpdateArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more AuditLogs.
     * @param {AuditLogDeleteManyArgs} args - Arguments to filter AuditLogs to delete.
     * @example
     * // Delete a few AuditLogs
     * const { count } = await prisma.auditLog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AuditLogDeleteManyArgs>(args?: SelectSubset<T, AuditLogDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AuditLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AuditLogs
     * const auditLog = await prisma.auditLog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AuditLogUpdateManyArgs>(args: SelectSubset<T, AuditLogUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one AuditLog.
     * @param {AuditLogUpsertArgs} args - Arguments to update or create a AuditLog.
     * @example
     * // Update or create a AuditLog
     * const auditLog = await prisma.auditLog.upsert({
     *   create: {
     *     // ... data to create a AuditLog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AuditLog we want to update
     *   }
     * })
     */
    upsert<T extends AuditLogUpsertArgs>(args: SelectSubset<T, AuditLogUpsertArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of AuditLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogCountArgs} args - Arguments to filter AuditLogs to count.
     * @example
     * // Count the number of AuditLogs
     * const count = await prisma.auditLog.count({
     *   where: {
     *     // ... the filter for the AuditLogs we want to count
     *   }
     * })
    **/
    count<T extends AuditLogCountArgs>(
      args?: Subset<T, AuditLogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AuditLogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AuditLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AuditLogAggregateArgs>(args: Subset<T, AuditLogAggregateArgs>): Prisma.PrismaPromise<GetAuditLogAggregateType<T>>

    /**
     * Group by AuditLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AuditLogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AuditLogGroupByArgs['orderBy'] }
        : { orderBy?: AuditLogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AuditLogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAuditLogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AuditLog model
   */
  readonly fields: AuditLogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AuditLog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AuditLogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    tenant<T extends AuditLog$tenantArgs<ExtArgs> = {}>(args?: Subset<T, AuditLog$tenantArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    user<T extends AuditLog$userArgs<ExtArgs> = {}>(args?: Subset<T, AuditLog$userArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AuditLog model
   */ 
  interface AuditLogFieldRefs {
    readonly id: FieldRef<"AuditLog", 'String'>
    readonly tenantId: FieldRef<"AuditLog", 'String'>
    readonly userId: FieldRef<"AuditLog", 'String'>
    readonly action: FieldRef<"AuditLog", 'String'>
    readonly entity: FieldRef<"AuditLog", 'String'>
    readonly entityId: FieldRef<"AuditLog", 'String'>
    readonly oldValue: FieldRef<"AuditLog", 'String'>
    readonly newValue: FieldRef<"AuditLog", 'String'>
    readonly ip: FieldRef<"AuditLog", 'String'>
    readonly createdAt: FieldRef<"AuditLog", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AuditLog findUnique
   */
  export type AuditLogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog findUniqueOrThrow
   */
  export type AuditLogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog findFirst
   */
  export type AuditLogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AuditLogs.
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AuditLogs.
     */
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * AuditLog findFirstOrThrow
   */
  export type AuditLogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AuditLogs.
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AuditLogs.
     */
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * AuditLog findMany
   */
  export type AuditLogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLogs to fetch.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AuditLogs.
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * AuditLog create
   */
  export type AuditLogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * The data needed to create a AuditLog.
     */
    data: XOR<AuditLogCreateInput, AuditLogUncheckedCreateInput>
  }

  /**
   * AuditLog createMany
   */
  export type AuditLogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AuditLogs.
     */
    data: AuditLogCreateManyInput | AuditLogCreateManyInput[]
  }

  /**
   * AuditLog createManyAndReturn
   */
  export type AuditLogCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many AuditLogs.
     */
    data: AuditLogCreateManyInput | AuditLogCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AuditLog update
   */
  export type AuditLogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * The data needed to update a AuditLog.
     */
    data: XOR<AuditLogUpdateInput, AuditLogUncheckedUpdateInput>
    /**
     * Choose, which AuditLog to update.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog updateMany
   */
  export type AuditLogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AuditLogs.
     */
    data: XOR<AuditLogUpdateManyMutationInput, AuditLogUncheckedUpdateManyInput>
    /**
     * Filter which AuditLogs to update
     */
    where?: AuditLogWhereInput
  }

  /**
   * AuditLog upsert
   */
  export type AuditLogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * The filter to search for the AuditLog to update in case it exists.
     */
    where: AuditLogWhereUniqueInput
    /**
     * In case the AuditLog found by the `where` argument doesn't exist, create a new AuditLog with this data.
     */
    create: XOR<AuditLogCreateInput, AuditLogUncheckedCreateInput>
    /**
     * In case the AuditLog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AuditLogUpdateInput, AuditLogUncheckedUpdateInput>
  }

  /**
   * AuditLog delete
   */
  export type AuditLogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter which AuditLog to delete.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog deleteMany
   */
  export type AuditLogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AuditLogs to delete
     */
    where?: AuditLogWhereInput
  }

  /**
   * AuditLog.tenant
   */
  export type AuditLog$tenantArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tenant
     */
    select?: TenantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantInclude<ExtArgs> | null
    where?: TenantWhereInput
  }

  /**
   * AuditLog.user
   */
  export type AuditLog$userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * AuditLog without action
   */
  export type AuditLogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
  }


  /**
   * Model Notification
   */

  export type AggregateNotification = {
    _count: NotificationCountAggregateOutputType | null
    _min: NotificationMinAggregateOutputType | null
    _max: NotificationMaxAggregateOutputType | null
  }

  export type NotificationMinAggregateOutputType = {
    id: string | null
    tenantId: string | null
    userId: string | null
    type: string | null
    title: string | null
    body: string | null
    read: boolean | null
    createdAt: Date | null
  }

  export type NotificationMaxAggregateOutputType = {
    id: string | null
    tenantId: string | null
    userId: string | null
    type: string | null
    title: string | null
    body: string | null
    read: boolean | null
    createdAt: Date | null
  }

  export type NotificationCountAggregateOutputType = {
    id: number
    tenantId: number
    userId: number
    type: number
    title: number
    body: number
    read: number
    createdAt: number
    _all: number
  }


  export type NotificationMinAggregateInputType = {
    id?: true
    tenantId?: true
    userId?: true
    type?: true
    title?: true
    body?: true
    read?: true
    createdAt?: true
  }

  export type NotificationMaxAggregateInputType = {
    id?: true
    tenantId?: true
    userId?: true
    type?: true
    title?: true
    body?: true
    read?: true
    createdAt?: true
  }

  export type NotificationCountAggregateInputType = {
    id?: true
    tenantId?: true
    userId?: true
    type?: true
    title?: true
    body?: true
    read?: true
    createdAt?: true
    _all?: true
  }

  export type NotificationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Notification to aggregate.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Notifications
    **/
    _count?: true | NotificationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NotificationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NotificationMaxAggregateInputType
  }

  export type GetNotificationAggregateType<T extends NotificationAggregateArgs> = {
        [P in keyof T & keyof AggregateNotification]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNotification[P]>
      : GetScalarType<T[P], AggregateNotification[P]>
  }




  export type NotificationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationWhereInput
    orderBy?: NotificationOrderByWithAggregationInput | NotificationOrderByWithAggregationInput[]
    by: NotificationScalarFieldEnum[] | NotificationScalarFieldEnum
    having?: NotificationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NotificationCountAggregateInputType | true
    _min?: NotificationMinAggregateInputType
    _max?: NotificationMaxAggregateInputType
  }

  export type NotificationGroupByOutputType = {
    id: string
    tenantId: string
    userId: string
    type: string
    title: string
    body: string
    read: boolean
    createdAt: Date
    _count: NotificationCountAggregateOutputType | null
    _min: NotificationMinAggregateOutputType | null
    _max: NotificationMaxAggregateOutputType | null
  }

  type GetNotificationGroupByPayload<T extends NotificationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NotificationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NotificationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NotificationGroupByOutputType[P]>
            : GetScalarType<T[P], NotificationGroupByOutputType[P]>
        }
      >
    >


  export type NotificationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    userId?: boolean
    type?: boolean
    title?: boolean
    body?: boolean
    read?: boolean
    createdAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notification"]>

  export type NotificationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    userId?: boolean
    type?: boolean
    title?: boolean
    body?: boolean
    read?: boolean
    createdAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notification"]>

  export type NotificationSelectScalar = {
    id?: boolean
    tenantId?: boolean
    userId?: boolean
    type?: boolean
    title?: boolean
    body?: boolean
    read?: boolean
    createdAt?: boolean
  }

  export type NotificationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type NotificationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $NotificationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Notification"
    objects: {
      tenant: Prisma.$TenantPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      tenantId: string
      userId: string
      type: string
      title: string
      body: string
      read: boolean
      createdAt: Date
    }, ExtArgs["result"]["notification"]>
    composites: {}
  }

  type NotificationGetPayload<S extends boolean | null | undefined | NotificationDefaultArgs> = $Result.GetResult<Prisma.$NotificationPayload, S>

  type NotificationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<NotificationFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: NotificationCountAggregateInputType | true
    }

  export interface NotificationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Notification'], meta: { name: 'Notification' } }
    /**
     * Find zero or one Notification that matches the filter.
     * @param {NotificationFindUniqueArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends NotificationFindUniqueArgs>(args: SelectSubset<T, NotificationFindUniqueArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Notification that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {NotificationFindUniqueOrThrowArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends NotificationFindUniqueOrThrowArgs>(args: SelectSubset<T, NotificationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Notification that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindFirstArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends NotificationFindFirstArgs>(args?: SelectSubset<T, NotificationFindFirstArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Notification that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindFirstOrThrowArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends NotificationFindFirstOrThrowArgs>(args?: SelectSubset<T, NotificationFindFirstOrThrowArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Notifications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Notifications
     * const notifications = await prisma.notification.findMany()
     * 
     * // Get first 10 Notifications
     * const notifications = await prisma.notification.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const notificationWithIdOnly = await prisma.notification.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends NotificationFindManyArgs>(args?: SelectSubset<T, NotificationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Notification.
     * @param {NotificationCreateArgs} args - Arguments to create a Notification.
     * @example
     * // Create one Notification
     * const Notification = await prisma.notification.create({
     *   data: {
     *     // ... data to create a Notification
     *   }
     * })
     * 
     */
    create<T extends NotificationCreateArgs>(args: SelectSubset<T, NotificationCreateArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Notifications.
     * @param {NotificationCreateManyArgs} args - Arguments to create many Notifications.
     * @example
     * // Create many Notifications
     * const notification = await prisma.notification.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends NotificationCreateManyArgs>(args?: SelectSubset<T, NotificationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Notifications and returns the data saved in the database.
     * @param {NotificationCreateManyAndReturnArgs} args - Arguments to create many Notifications.
     * @example
     * // Create many Notifications
     * const notification = await prisma.notification.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Notifications and only return the `id`
     * const notificationWithIdOnly = await prisma.notification.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends NotificationCreateManyAndReturnArgs>(args?: SelectSubset<T, NotificationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Notification.
     * @param {NotificationDeleteArgs} args - Arguments to delete one Notification.
     * @example
     * // Delete one Notification
     * const Notification = await prisma.notification.delete({
     *   where: {
     *     // ... filter to delete one Notification
     *   }
     * })
     * 
     */
    delete<T extends NotificationDeleteArgs>(args: SelectSubset<T, NotificationDeleteArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Notification.
     * @param {NotificationUpdateArgs} args - Arguments to update one Notification.
     * @example
     * // Update one Notification
     * const notification = await prisma.notification.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends NotificationUpdateArgs>(args: SelectSubset<T, NotificationUpdateArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Notifications.
     * @param {NotificationDeleteManyArgs} args - Arguments to filter Notifications to delete.
     * @example
     * // Delete a few Notifications
     * const { count } = await prisma.notification.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends NotificationDeleteManyArgs>(args?: SelectSubset<T, NotificationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Notifications
     * const notification = await prisma.notification.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends NotificationUpdateManyArgs>(args: SelectSubset<T, NotificationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Notification.
     * @param {NotificationUpsertArgs} args - Arguments to update or create a Notification.
     * @example
     * // Update or create a Notification
     * const notification = await prisma.notification.upsert({
     *   create: {
     *     // ... data to create a Notification
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Notification we want to update
     *   }
     * })
     */
    upsert<T extends NotificationUpsertArgs>(args: SelectSubset<T, NotificationUpsertArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationCountArgs} args - Arguments to filter Notifications to count.
     * @example
     * // Count the number of Notifications
     * const count = await prisma.notification.count({
     *   where: {
     *     // ... the filter for the Notifications we want to count
     *   }
     * })
    **/
    count<T extends NotificationCountArgs>(
      args?: Subset<T, NotificationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NotificationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Notification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NotificationAggregateArgs>(args: Subset<T, NotificationAggregateArgs>): Prisma.PrismaPromise<GetNotificationAggregateType<T>>

    /**
     * Group by Notification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NotificationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NotificationGroupByArgs['orderBy'] }
        : { orderBy?: NotificationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NotificationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNotificationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Notification model
   */
  readonly fields: NotificationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Notification.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__NotificationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    tenant<T extends TenantDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TenantDefaultArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Notification model
   */ 
  interface NotificationFieldRefs {
    readonly id: FieldRef<"Notification", 'String'>
    readonly tenantId: FieldRef<"Notification", 'String'>
    readonly userId: FieldRef<"Notification", 'String'>
    readonly type: FieldRef<"Notification", 'String'>
    readonly title: FieldRef<"Notification", 'String'>
    readonly body: FieldRef<"Notification", 'String'>
    readonly read: FieldRef<"Notification", 'Boolean'>
    readonly createdAt: FieldRef<"Notification", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Notification findUnique
   */
  export type NotificationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification findUniqueOrThrow
   */
  export type NotificationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification findFirst
   */
  export type NotificationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Notifications.
     */
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification findFirstOrThrow
   */
  export type NotificationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Notifications.
     */
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification findMany
   */
  export type NotificationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notifications to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification create
   */
  export type NotificationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The data needed to create a Notification.
     */
    data: XOR<NotificationCreateInput, NotificationUncheckedCreateInput>
  }

  /**
   * Notification createMany
   */
  export type NotificationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Notifications.
     */
    data: NotificationCreateManyInput | NotificationCreateManyInput[]
  }

  /**
   * Notification createManyAndReturn
   */
  export type NotificationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Notifications.
     */
    data: NotificationCreateManyInput | NotificationCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Notification update
   */
  export type NotificationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The data needed to update a Notification.
     */
    data: XOR<NotificationUpdateInput, NotificationUncheckedUpdateInput>
    /**
     * Choose, which Notification to update.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification updateMany
   */
  export type NotificationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Notifications.
     */
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyInput>
    /**
     * Filter which Notifications to update
     */
    where?: NotificationWhereInput
  }

  /**
   * Notification upsert
   */
  export type NotificationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The filter to search for the Notification to update in case it exists.
     */
    where: NotificationWhereUniqueInput
    /**
     * In case the Notification found by the `where` argument doesn't exist, create a new Notification with this data.
     */
    create: XOR<NotificationCreateInput, NotificationUncheckedCreateInput>
    /**
     * In case the Notification was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NotificationUpdateInput, NotificationUncheckedUpdateInput>
  }

  /**
   * Notification delete
   */
  export type NotificationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter which Notification to delete.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification deleteMany
   */
  export type NotificationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Notifications to delete
     */
    where?: NotificationWhereInput
  }

  /**
   * Notification without action
   */
  export type NotificationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
  }


  /**
   * Model WebhookEvent
   */

  export type AggregateWebhookEvent = {
    _count: WebhookEventCountAggregateOutputType | null
    _min: WebhookEventMinAggregateOutputType | null
    _max: WebhookEventMaxAggregateOutputType | null
  }

  export type WebhookEventMinAggregateOutputType = {
    id: string | null
    tenantId: string | null
    eventType: string | null
    payload: string | null
    status: string | null
    error: string | null
    createdAt: Date | null
    processedAt: Date | null
  }

  export type WebhookEventMaxAggregateOutputType = {
    id: string | null
    tenantId: string | null
    eventType: string | null
    payload: string | null
    status: string | null
    error: string | null
    createdAt: Date | null
    processedAt: Date | null
  }

  export type WebhookEventCountAggregateOutputType = {
    id: number
    tenantId: number
    eventType: number
    payload: number
    status: number
    error: number
    createdAt: number
    processedAt: number
    _all: number
  }


  export type WebhookEventMinAggregateInputType = {
    id?: true
    tenantId?: true
    eventType?: true
    payload?: true
    status?: true
    error?: true
    createdAt?: true
    processedAt?: true
  }

  export type WebhookEventMaxAggregateInputType = {
    id?: true
    tenantId?: true
    eventType?: true
    payload?: true
    status?: true
    error?: true
    createdAt?: true
    processedAt?: true
  }

  export type WebhookEventCountAggregateInputType = {
    id?: true
    tenantId?: true
    eventType?: true
    payload?: true
    status?: true
    error?: true
    createdAt?: true
    processedAt?: true
    _all?: true
  }

  export type WebhookEventAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WebhookEvent to aggregate.
     */
    where?: WebhookEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WebhookEvents to fetch.
     */
    orderBy?: WebhookEventOrderByWithRelationInput | WebhookEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: WebhookEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WebhookEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WebhookEvents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned WebhookEvents
    **/
    _count?: true | WebhookEventCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WebhookEventMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WebhookEventMaxAggregateInputType
  }

  export type GetWebhookEventAggregateType<T extends WebhookEventAggregateArgs> = {
        [P in keyof T & keyof AggregateWebhookEvent]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWebhookEvent[P]>
      : GetScalarType<T[P], AggregateWebhookEvent[P]>
  }




  export type WebhookEventGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WebhookEventWhereInput
    orderBy?: WebhookEventOrderByWithAggregationInput | WebhookEventOrderByWithAggregationInput[]
    by: WebhookEventScalarFieldEnum[] | WebhookEventScalarFieldEnum
    having?: WebhookEventScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WebhookEventCountAggregateInputType | true
    _min?: WebhookEventMinAggregateInputType
    _max?: WebhookEventMaxAggregateInputType
  }

  export type WebhookEventGroupByOutputType = {
    id: string
    tenantId: string | null
    eventType: string
    payload: string
    status: string
    error: string | null
    createdAt: Date
    processedAt: Date | null
    _count: WebhookEventCountAggregateOutputType | null
    _min: WebhookEventMinAggregateOutputType | null
    _max: WebhookEventMaxAggregateOutputType | null
  }

  type GetWebhookEventGroupByPayload<T extends WebhookEventGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<WebhookEventGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WebhookEventGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WebhookEventGroupByOutputType[P]>
            : GetScalarType<T[P], WebhookEventGroupByOutputType[P]>
        }
      >
    >


  export type WebhookEventSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    eventType?: boolean
    payload?: boolean
    status?: boolean
    error?: boolean
    createdAt?: boolean
    processedAt?: boolean
    tenant?: boolean | WebhookEvent$tenantArgs<ExtArgs>
  }, ExtArgs["result"]["webhookEvent"]>

  export type WebhookEventSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    eventType?: boolean
    payload?: boolean
    status?: boolean
    error?: boolean
    createdAt?: boolean
    processedAt?: boolean
    tenant?: boolean | WebhookEvent$tenantArgs<ExtArgs>
  }, ExtArgs["result"]["webhookEvent"]>

  export type WebhookEventSelectScalar = {
    id?: boolean
    tenantId?: boolean
    eventType?: boolean
    payload?: boolean
    status?: boolean
    error?: boolean
    createdAt?: boolean
    processedAt?: boolean
  }

  export type WebhookEventInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | WebhookEvent$tenantArgs<ExtArgs>
  }
  export type WebhookEventIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | WebhookEvent$tenantArgs<ExtArgs>
  }

  export type $WebhookEventPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "WebhookEvent"
    objects: {
      tenant: Prisma.$TenantPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      tenantId: string | null
      eventType: string
      payload: string
      status: string
      error: string | null
      createdAt: Date
      processedAt: Date | null
    }, ExtArgs["result"]["webhookEvent"]>
    composites: {}
  }

  type WebhookEventGetPayload<S extends boolean | null | undefined | WebhookEventDefaultArgs> = $Result.GetResult<Prisma.$WebhookEventPayload, S>

  type WebhookEventCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<WebhookEventFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: WebhookEventCountAggregateInputType | true
    }

  export interface WebhookEventDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['WebhookEvent'], meta: { name: 'WebhookEvent' } }
    /**
     * Find zero or one WebhookEvent that matches the filter.
     * @param {WebhookEventFindUniqueArgs} args - Arguments to find a WebhookEvent
     * @example
     * // Get one WebhookEvent
     * const webhookEvent = await prisma.webhookEvent.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends WebhookEventFindUniqueArgs>(args: SelectSubset<T, WebhookEventFindUniqueArgs<ExtArgs>>): Prisma__WebhookEventClient<$Result.GetResult<Prisma.$WebhookEventPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one WebhookEvent that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {WebhookEventFindUniqueOrThrowArgs} args - Arguments to find a WebhookEvent
     * @example
     * // Get one WebhookEvent
     * const webhookEvent = await prisma.webhookEvent.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends WebhookEventFindUniqueOrThrowArgs>(args: SelectSubset<T, WebhookEventFindUniqueOrThrowArgs<ExtArgs>>): Prisma__WebhookEventClient<$Result.GetResult<Prisma.$WebhookEventPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first WebhookEvent that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WebhookEventFindFirstArgs} args - Arguments to find a WebhookEvent
     * @example
     * // Get one WebhookEvent
     * const webhookEvent = await prisma.webhookEvent.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends WebhookEventFindFirstArgs>(args?: SelectSubset<T, WebhookEventFindFirstArgs<ExtArgs>>): Prisma__WebhookEventClient<$Result.GetResult<Prisma.$WebhookEventPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first WebhookEvent that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WebhookEventFindFirstOrThrowArgs} args - Arguments to find a WebhookEvent
     * @example
     * // Get one WebhookEvent
     * const webhookEvent = await prisma.webhookEvent.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends WebhookEventFindFirstOrThrowArgs>(args?: SelectSubset<T, WebhookEventFindFirstOrThrowArgs<ExtArgs>>): Prisma__WebhookEventClient<$Result.GetResult<Prisma.$WebhookEventPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more WebhookEvents that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WebhookEventFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all WebhookEvents
     * const webhookEvents = await prisma.webhookEvent.findMany()
     * 
     * // Get first 10 WebhookEvents
     * const webhookEvents = await prisma.webhookEvent.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const webhookEventWithIdOnly = await prisma.webhookEvent.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends WebhookEventFindManyArgs>(args?: SelectSubset<T, WebhookEventFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WebhookEventPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a WebhookEvent.
     * @param {WebhookEventCreateArgs} args - Arguments to create a WebhookEvent.
     * @example
     * // Create one WebhookEvent
     * const WebhookEvent = await prisma.webhookEvent.create({
     *   data: {
     *     // ... data to create a WebhookEvent
     *   }
     * })
     * 
     */
    create<T extends WebhookEventCreateArgs>(args: SelectSubset<T, WebhookEventCreateArgs<ExtArgs>>): Prisma__WebhookEventClient<$Result.GetResult<Prisma.$WebhookEventPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many WebhookEvents.
     * @param {WebhookEventCreateManyArgs} args - Arguments to create many WebhookEvents.
     * @example
     * // Create many WebhookEvents
     * const webhookEvent = await prisma.webhookEvent.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends WebhookEventCreateManyArgs>(args?: SelectSubset<T, WebhookEventCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many WebhookEvents and returns the data saved in the database.
     * @param {WebhookEventCreateManyAndReturnArgs} args - Arguments to create many WebhookEvents.
     * @example
     * // Create many WebhookEvents
     * const webhookEvent = await prisma.webhookEvent.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many WebhookEvents and only return the `id`
     * const webhookEventWithIdOnly = await prisma.webhookEvent.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends WebhookEventCreateManyAndReturnArgs>(args?: SelectSubset<T, WebhookEventCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WebhookEventPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a WebhookEvent.
     * @param {WebhookEventDeleteArgs} args - Arguments to delete one WebhookEvent.
     * @example
     * // Delete one WebhookEvent
     * const WebhookEvent = await prisma.webhookEvent.delete({
     *   where: {
     *     // ... filter to delete one WebhookEvent
     *   }
     * })
     * 
     */
    delete<T extends WebhookEventDeleteArgs>(args: SelectSubset<T, WebhookEventDeleteArgs<ExtArgs>>): Prisma__WebhookEventClient<$Result.GetResult<Prisma.$WebhookEventPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one WebhookEvent.
     * @param {WebhookEventUpdateArgs} args - Arguments to update one WebhookEvent.
     * @example
     * // Update one WebhookEvent
     * const webhookEvent = await prisma.webhookEvent.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends WebhookEventUpdateArgs>(args: SelectSubset<T, WebhookEventUpdateArgs<ExtArgs>>): Prisma__WebhookEventClient<$Result.GetResult<Prisma.$WebhookEventPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more WebhookEvents.
     * @param {WebhookEventDeleteManyArgs} args - Arguments to filter WebhookEvents to delete.
     * @example
     * // Delete a few WebhookEvents
     * const { count } = await prisma.webhookEvent.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends WebhookEventDeleteManyArgs>(args?: SelectSubset<T, WebhookEventDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WebhookEvents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WebhookEventUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many WebhookEvents
     * const webhookEvent = await prisma.webhookEvent.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends WebhookEventUpdateManyArgs>(args: SelectSubset<T, WebhookEventUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one WebhookEvent.
     * @param {WebhookEventUpsertArgs} args - Arguments to update or create a WebhookEvent.
     * @example
     * // Update or create a WebhookEvent
     * const webhookEvent = await prisma.webhookEvent.upsert({
     *   create: {
     *     // ... data to create a WebhookEvent
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the WebhookEvent we want to update
     *   }
     * })
     */
    upsert<T extends WebhookEventUpsertArgs>(args: SelectSubset<T, WebhookEventUpsertArgs<ExtArgs>>): Prisma__WebhookEventClient<$Result.GetResult<Prisma.$WebhookEventPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of WebhookEvents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WebhookEventCountArgs} args - Arguments to filter WebhookEvents to count.
     * @example
     * // Count the number of WebhookEvents
     * const count = await prisma.webhookEvent.count({
     *   where: {
     *     // ... the filter for the WebhookEvents we want to count
     *   }
     * })
    **/
    count<T extends WebhookEventCountArgs>(
      args?: Subset<T, WebhookEventCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WebhookEventCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a WebhookEvent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WebhookEventAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WebhookEventAggregateArgs>(args: Subset<T, WebhookEventAggregateArgs>): Prisma.PrismaPromise<GetWebhookEventAggregateType<T>>

    /**
     * Group by WebhookEvent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WebhookEventGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WebhookEventGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WebhookEventGroupByArgs['orderBy'] }
        : { orderBy?: WebhookEventGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WebhookEventGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWebhookEventGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the WebhookEvent model
   */
  readonly fields: WebhookEventFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for WebhookEvent.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__WebhookEventClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    tenant<T extends WebhookEvent$tenantArgs<ExtArgs> = {}>(args?: Subset<T, WebhookEvent$tenantArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the WebhookEvent model
   */ 
  interface WebhookEventFieldRefs {
    readonly id: FieldRef<"WebhookEvent", 'String'>
    readonly tenantId: FieldRef<"WebhookEvent", 'String'>
    readonly eventType: FieldRef<"WebhookEvent", 'String'>
    readonly payload: FieldRef<"WebhookEvent", 'String'>
    readonly status: FieldRef<"WebhookEvent", 'String'>
    readonly error: FieldRef<"WebhookEvent", 'String'>
    readonly createdAt: FieldRef<"WebhookEvent", 'DateTime'>
    readonly processedAt: FieldRef<"WebhookEvent", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * WebhookEvent findUnique
   */
  export type WebhookEventFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WebhookEvent
     */
    select?: WebhookEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WebhookEventInclude<ExtArgs> | null
    /**
     * Filter, which WebhookEvent to fetch.
     */
    where: WebhookEventWhereUniqueInput
  }

  /**
   * WebhookEvent findUniqueOrThrow
   */
  export type WebhookEventFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WebhookEvent
     */
    select?: WebhookEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WebhookEventInclude<ExtArgs> | null
    /**
     * Filter, which WebhookEvent to fetch.
     */
    where: WebhookEventWhereUniqueInput
  }

  /**
   * WebhookEvent findFirst
   */
  export type WebhookEventFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WebhookEvent
     */
    select?: WebhookEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WebhookEventInclude<ExtArgs> | null
    /**
     * Filter, which WebhookEvent to fetch.
     */
    where?: WebhookEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WebhookEvents to fetch.
     */
    orderBy?: WebhookEventOrderByWithRelationInput | WebhookEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WebhookEvents.
     */
    cursor?: WebhookEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WebhookEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WebhookEvents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WebhookEvents.
     */
    distinct?: WebhookEventScalarFieldEnum | WebhookEventScalarFieldEnum[]
  }

  /**
   * WebhookEvent findFirstOrThrow
   */
  export type WebhookEventFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WebhookEvent
     */
    select?: WebhookEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WebhookEventInclude<ExtArgs> | null
    /**
     * Filter, which WebhookEvent to fetch.
     */
    where?: WebhookEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WebhookEvents to fetch.
     */
    orderBy?: WebhookEventOrderByWithRelationInput | WebhookEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WebhookEvents.
     */
    cursor?: WebhookEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WebhookEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WebhookEvents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WebhookEvents.
     */
    distinct?: WebhookEventScalarFieldEnum | WebhookEventScalarFieldEnum[]
  }

  /**
   * WebhookEvent findMany
   */
  export type WebhookEventFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WebhookEvent
     */
    select?: WebhookEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WebhookEventInclude<ExtArgs> | null
    /**
     * Filter, which WebhookEvents to fetch.
     */
    where?: WebhookEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WebhookEvents to fetch.
     */
    orderBy?: WebhookEventOrderByWithRelationInput | WebhookEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing WebhookEvents.
     */
    cursor?: WebhookEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WebhookEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WebhookEvents.
     */
    skip?: number
    distinct?: WebhookEventScalarFieldEnum | WebhookEventScalarFieldEnum[]
  }

  /**
   * WebhookEvent create
   */
  export type WebhookEventCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WebhookEvent
     */
    select?: WebhookEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WebhookEventInclude<ExtArgs> | null
    /**
     * The data needed to create a WebhookEvent.
     */
    data: XOR<WebhookEventCreateInput, WebhookEventUncheckedCreateInput>
  }

  /**
   * WebhookEvent createMany
   */
  export type WebhookEventCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many WebhookEvents.
     */
    data: WebhookEventCreateManyInput | WebhookEventCreateManyInput[]
  }

  /**
   * WebhookEvent createManyAndReturn
   */
  export type WebhookEventCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WebhookEvent
     */
    select?: WebhookEventSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many WebhookEvents.
     */
    data: WebhookEventCreateManyInput | WebhookEventCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WebhookEventIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * WebhookEvent update
   */
  export type WebhookEventUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WebhookEvent
     */
    select?: WebhookEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WebhookEventInclude<ExtArgs> | null
    /**
     * The data needed to update a WebhookEvent.
     */
    data: XOR<WebhookEventUpdateInput, WebhookEventUncheckedUpdateInput>
    /**
     * Choose, which WebhookEvent to update.
     */
    where: WebhookEventWhereUniqueInput
  }

  /**
   * WebhookEvent updateMany
   */
  export type WebhookEventUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update WebhookEvents.
     */
    data: XOR<WebhookEventUpdateManyMutationInput, WebhookEventUncheckedUpdateManyInput>
    /**
     * Filter which WebhookEvents to update
     */
    where?: WebhookEventWhereInput
  }

  /**
   * WebhookEvent upsert
   */
  export type WebhookEventUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WebhookEvent
     */
    select?: WebhookEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WebhookEventInclude<ExtArgs> | null
    /**
     * The filter to search for the WebhookEvent to update in case it exists.
     */
    where: WebhookEventWhereUniqueInput
    /**
     * In case the WebhookEvent found by the `where` argument doesn't exist, create a new WebhookEvent with this data.
     */
    create: XOR<WebhookEventCreateInput, WebhookEventUncheckedCreateInput>
    /**
     * In case the WebhookEvent was found with the provided `where` argument, update it with this data.
     */
    update: XOR<WebhookEventUpdateInput, WebhookEventUncheckedUpdateInput>
  }

  /**
   * WebhookEvent delete
   */
  export type WebhookEventDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WebhookEvent
     */
    select?: WebhookEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WebhookEventInclude<ExtArgs> | null
    /**
     * Filter which WebhookEvent to delete.
     */
    where: WebhookEventWhereUniqueInput
  }

  /**
   * WebhookEvent deleteMany
   */
  export type WebhookEventDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WebhookEvents to delete
     */
    where?: WebhookEventWhereInput
  }

  /**
   * WebhookEvent.tenant
   */
  export type WebhookEvent$tenantArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tenant
     */
    select?: TenantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantInclude<ExtArgs> | null
    where?: TenantWhereInput
  }

  /**
   * WebhookEvent without action
   */
  export type WebhookEventDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WebhookEvent
     */
    select?: WebhookEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WebhookEventInclude<ExtArgs> | null
  }


  /**
   * Model Tahfidz
   */

  export type AggregateTahfidz = {
    _count: TahfidzCountAggregateOutputType | null
    _min: TahfidzMinAggregateOutputType | null
    _max: TahfidzMaxAggregateOutputType | null
  }

  export type TahfidzMinAggregateOutputType = {
    id: string | null
    tenantId: string | null
    santriId: string | null
    surah: string | null
    ayat: string | null
    type: string | null
    grade: string | null
    notes: string | null
    recordedBy: string | null
    date: Date | null
    createdAt: Date | null
  }

  export type TahfidzMaxAggregateOutputType = {
    id: string | null
    tenantId: string | null
    santriId: string | null
    surah: string | null
    ayat: string | null
    type: string | null
    grade: string | null
    notes: string | null
    recordedBy: string | null
    date: Date | null
    createdAt: Date | null
  }

  export type TahfidzCountAggregateOutputType = {
    id: number
    tenantId: number
    santriId: number
    surah: number
    ayat: number
    type: number
    grade: number
    notes: number
    recordedBy: number
    date: number
    createdAt: number
    _all: number
  }


  export type TahfidzMinAggregateInputType = {
    id?: true
    tenantId?: true
    santriId?: true
    surah?: true
    ayat?: true
    type?: true
    grade?: true
    notes?: true
    recordedBy?: true
    date?: true
    createdAt?: true
  }

  export type TahfidzMaxAggregateInputType = {
    id?: true
    tenantId?: true
    santriId?: true
    surah?: true
    ayat?: true
    type?: true
    grade?: true
    notes?: true
    recordedBy?: true
    date?: true
    createdAt?: true
  }

  export type TahfidzCountAggregateInputType = {
    id?: true
    tenantId?: true
    santriId?: true
    surah?: true
    ayat?: true
    type?: true
    grade?: true
    notes?: true
    recordedBy?: true
    date?: true
    createdAt?: true
    _all?: true
  }

  export type TahfidzAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Tahfidz to aggregate.
     */
    where?: TahfidzWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tahfidzs to fetch.
     */
    orderBy?: TahfidzOrderByWithRelationInput | TahfidzOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TahfidzWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tahfidzs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tahfidzs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Tahfidzs
    **/
    _count?: true | TahfidzCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TahfidzMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TahfidzMaxAggregateInputType
  }

  export type GetTahfidzAggregateType<T extends TahfidzAggregateArgs> = {
        [P in keyof T & keyof AggregateTahfidz]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTahfidz[P]>
      : GetScalarType<T[P], AggregateTahfidz[P]>
  }




  export type TahfidzGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TahfidzWhereInput
    orderBy?: TahfidzOrderByWithAggregationInput | TahfidzOrderByWithAggregationInput[]
    by: TahfidzScalarFieldEnum[] | TahfidzScalarFieldEnum
    having?: TahfidzScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TahfidzCountAggregateInputType | true
    _min?: TahfidzMinAggregateInputType
    _max?: TahfidzMaxAggregateInputType
  }

  export type TahfidzGroupByOutputType = {
    id: string
    tenantId: string
    santriId: string
    surah: string
    ayat: string | null
    type: string
    grade: string | null
    notes: string | null
    recordedBy: string
    date: Date
    createdAt: Date
    _count: TahfidzCountAggregateOutputType | null
    _min: TahfidzMinAggregateOutputType | null
    _max: TahfidzMaxAggregateOutputType | null
  }

  type GetTahfidzGroupByPayload<T extends TahfidzGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TahfidzGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TahfidzGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TahfidzGroupByOutputType[P]>
            : GetScalarType<T[P], TahfidzGroupByOutputType[P]>
        }
      >
    >


  export type TahfidzSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    santriId?: boolean
    surah?: boolean
    ayat?: boolean
    type?: boolean
    grade?: boolean
    notes?: boolean
    recordedBy?: boolean
    date?: boolean
    createdAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    santri?: boolean | SantriDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tahfidz"]>

  export type TahfidzSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    santriId?: boolean
    surah?: boolean
    ayat?: boolean
    type?: boolean
    grade?: boolean
    notes?: boolean
    recordedBy?: boolean
    date?: boolean
    createdAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    santri?: boolean | SantriDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tahfidz"]>

  export type TahfidzSelectScalar = {
    id?: boolean
    tenantId?: boolean
    santriId?: boolean
    surah?: boolean
    ayat?: boolean
    type?: boolean
    grade?: boolean
    notes?: boolean
    recordedBy?: boolean
    date?: boolean
    createdAt?: boolean
  }

  export type TahfidzInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    santri?: boolean | SantriDefaultArgs<ExtArgs>
  }
  export type TahfidzIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    santri?: boolean | SantriDefaultArgs<ExtArgs>
  }

  export type $TahfidzPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Tahfidz"
    objects: {
      tenant: Prisma.$TenantPayload<ExtArgs>
      santri: Prisma.$SantriPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      tenantId: string
      santriId: string
      surah: string
      ayat: string | null
      type: string
      grade: string | null
      notes: string | null
      recordedBy: string
      date: Date
      createdAt: Date
    }, ExtArgs["result"]["tahfidz"]>
    composites: {}
  }

  type TahfidzGetPayload<S extends boolean | null | undefined | TahfidzDefaultArgs> = $Result.GetResult<Prisma.$TahfidzPayload, S>

  type TahfidzCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<TahfidzFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: TahfidzCountAggregateInputType | true
    }

  export interface TahfidzDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Tahfidz'], meta: { name: 'Tahfidz' } }
    /**
     * Find zero or one Tahfidz that matches the filter.
     * @param {TahfidzFindUniqueArgs} args - Arguments to find a Tahfidz
     * @example
     * // Get one Tahfidz
     * const tahfidz = await prisma.tahfidz.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TahfidzFindUniqueArgs>(args: SelectSubset<T, TahfidzFindUniqueArgs<ExtArgs>>): Prisma__TahfidzClient<$Result.GetResult<Prisma.$TahfidzPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Tahfidz that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {TahfidzFindUniqueOrThrowArgs} args - Arguments to find a Tahfidz
     * @example
     * // Get one Tahfidz
     * const tahfidz = await prisma.tahfidz.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TahfidzFindUniqueOrThrowArgs>(args: SelectSubset<T, TahfidzFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TahfidzClient<$Result.GetResult<Prisma.$TahfidzPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Tahfidz that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TahfidzFindFirstArgs} args - Arguments to find a Tahfidz
     * @example
     * // Get one Tahfidz
     * const tahfidz = await prisma.tahfidz.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TahfidzFindFirstArgs>(args?: SelectSubset<T, TahfidzFindFirstArgs<ExtArgs>>): Prisma__TahfidzClient<$Result.GetResult<Prisma.$TahfidzPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Tahfidz that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TahfidzFindFirstOrThrowArgs} args - Arguments to find a Tahfidz
     * @example
     * // Get one Tahfidz
     * const tahfidz = await prisma.tahfidz.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TahfidzFindFirstOrThrowArgs>(args?: SelectSubset<T, TahfidzFindFirstOrThrowArgs<ExtArgs>>): Prisma__TahfidzClient<$Result.GetResult<Prisma.$TahfidzPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Tahfidzs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TahfidzFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Tahfidzs
     * const tahfidzs = await prisma.tahfidz.findMany()
     * 
     * // Get first 10 Tahfidzs
     * const tahfidzs = await prisma.tahfidz.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const tahfidzWithIdOnly = await prisma.tahfidz.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TahfidzFindManyArgs>(args?: SelectSubset<T, TahfidzFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TahfidzPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Tahfidz.
     * @param {TahfidzCreateArgs} args - Arguments to create a Tahfidz.
     * @example
     * // Create one Tahfidz
     * const Tahfidz = await prisma.tahfidz.create({
     *   data: {
     *     // ... data to create a Tahfidz
     *   }
     * })
     * 
     */
    create<T extends TahfidzCreateArgs>(args: SelectSubset<T, TahfidzCreateArgs<ExtArgs>>): Prisma__TahfidzClient<$Result.GetResult<Prisma.$TahfidzPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Tahfidzs.
     * @param {TahfidzCreateManyArgs} args - Arguments to create many Tahfidzs.
     * @example
     * // Create many Tahfidzs
     * const tahfidz = await prisma.tahfidz.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TahfidzCreateManyArgs>(args?: SelectSubset<T, TahfidzCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Tahfidzs and returns the data saved in the database.
     * @param {TahfidzCreateManyAndReturnArgs} args - Arguments to create many Tahfidzs.
     * @example
     * // Create many Tahfidzs
     * const tahfidz = await prisma.tahfidz.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Tahfidzs and only return the `id`
     * const tahfidzWithIdOnly = await prisma.tahfidz.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TahfidzCreateManyAndReturnArgs>(args?: SelectSubset<T, TahfidzCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TahfidzPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Tahfidz.
     * @param {TahfidzDeleteArgs} args - Arguments to delete one Tahfidz.
     * @example
     * // Delete one Tahfidz
     * const Tahfidz = await prisma.tahfidz.delete({
     *   where: {
     *     // ... filter to delete one Tahfidz
     *   }
     * })
     * 
     */
    delete<T extends TahfidzDeleteArgs>(args: SelectSubset<T, TahfidzDeleteArgs<ExtArgs>>): Prisma__TahfidzClient<$Result.GetResult<Prisma.$TahfidzPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Tahfidz.
     * @param {TahfidzUpdateArgs} args - Arguments to update one Tahfidz.
     * @example
     * // Update one Tahfidz
     * const tahfidz = await prisma.tahfidz.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TahfidzUpdateArgs>(args: SelectSubset<T, TahfidzUpdateArgs<ExtArgs>>): Prisma__TahfidzClient<$Result.GetResult<Prisma.$TahfidzPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Tahfidzs.
     * @param {TahfidzDeleteManyArgs} args - Arguments to filter Tahfidzs to delete.
     * @example
     * // Delete a few Tahfidzs
     * const { count } = await prisma.tahfidz.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TahfidzDeleteManyArgs>(args?: SelectSubset<T, TahfidzDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tahfidzs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TahfidzUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Tahfidzs
     * const tahfidz = await prisma.tahfidz.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TahfidzUpdateManyArgs>(args: SelectSubset<T, TahfidzUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Tahfidz.
     * @param {TahfidzUpsertArgs} args - Arguments to update or create a Tahfidz.
     * @example
     * // Update or create a Tahfidz
     * const tahfidz = await prisma.tahfidz.upsert({
     *   create: {
     *     // ... data to create a Tahfidz
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Tahfidz we want to update
     *   }
     * })
     */
    upsert<T extends TahfidzUpsertArgs>(args: SelectSubset<T, TahfidzUpsertArgs<ExtArgs>>): Prisma__TahfidzClient<$Result.GetResult<Prisma.$TahfidzPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Tahfidzs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TahfidzCountArgs} args - Arguments to filter Tahfidzs to count.
     * @example
     * // Count the number of Tahfidzs
     * const count = await prisma.tahfidz.count({
     *   where: {
     *     // ... the filter for the Tahfidzs we want to count
     *   }
     * })
    **/
    count<T extends TahfidzCountArgs>(
      args?: Subset<T, TahfidzCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TahfidzCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Tahfidz.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TahfidzAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TahfidzAggregateArgs>(args: Subset<T, TahfidzAggregateArgs>): Prisma.PrismaPromise<GetTahfidzAggregateType<T>>

    /**
     * Group by Tahfidz.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TahfidzGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TahfidzGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TahfidzGroupByArgs['orderBy'] }
        : { orderBy?: TahfidzGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TahfidzGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTahfidzGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Tahfidz model
   */
  readonly fields: TahfidzFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Tahfidz.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TahfidzClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    tenant<T extends TenantDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TenantDefaultArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    santri<T extends SantriDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SantriDefaultArgs<ExtArgs>>): Prisma__SantriClient<$Result.GetResult<Prisma.$SantriPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Tahfidz model
   */ 
  interface TahfidzFieldRefs {
    readonly id: FieldRef<"Tahfidz", 'String'>
    readonly tenantId: FieldRef<"Tahfidz", 'String'>
    readonly santriId: FieldRef<"Tahfidz", 'String'>
    readonly surah: FieldRef<"Tahfidz", 'String'>
    readonly ayat: FieldRef<"Tahfidz", 'String'>
    readonly type: FieldRef<"Tahfidz", 'String'>
    readonly grade: FieldRef<"Tahfidz", 'String'>
    readonly notes: FieldRef<"Tahfidz", 'String'>
    readonly recordedBy: FieldRef<"Tahfidz", 'String'>
    readonly date: FieldRef<"Tahfidz", 'DateTime'>
    readonly createdAt: FieldRef<"Tahfidz", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Tahfidz findUnique
   */
  export type TahfidzFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tahfidz
     */
    select?: TahfidzSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TahfidzInclude<ExtArgs> | null
    /**
     * Filter, which Tahfidz to fetch.
     */
    where: TahfidzWhereUniqueInput
  }

  /**
   * Tahfidz findUniqueOrThrow
   */
  export type TahfidzFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tahfidz
     */
    select?: TahfidzSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TahfidzInclude<ExtArgs> | null
    /**
     * Filter, which Tahfidz to fetch.
     */
    where: TahfidzWhereUniqueInput
  }

  /**
   * Tahfidz findFirst
   */
  export type TahfidzFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tahfidz
     */
    select?: TahfidzSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TahfidzInclude<ExtArgs> | null
    /**
     * Filter, which Tahfidz to fetch.
     */
    where?: TahfidzWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tahfidzs to fetch.
     */
    orderBy?: TahfidzOrderByWithRelationInput | TahfidzOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tahfidzs.
     */
    cursor?: TahfidzWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tahfidzs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tahfidzs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tahfidzs.
     */
    distinct?: TahfidzScalarFieldEnum | TahfidzScalarFieldEnum[]
  }

  /**
   * Tahfidz findFirstOrThrow
   */
  export type TahfidzFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tahfidz
     */
    select?: TahfidzSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TahfidzInclude<ExtArgs> | null
    /**
     * Filter, which Tahfidz to fetch.
     */
    where?: TahfidzWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tahfidzs to fetch.
     */
    orderBy?: TahfidzOrderByWithRelationInput | TahfidzOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tahfidzs.
     */
    cursor?: TahfidzWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tahfidzs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tahfidzs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tahfidzs.
     */
    distinct?: TahfidzScalarFieldEnum | TahfidzScalarFieldEnum[]
  }

  /**
   * Tahfidz findMany
   */
  export type TahfidzFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tahfidz
     */
    select?: TahfidzSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TahfidzInclude<ExtArgs> | null
    /**
     * Filter, which Tahfidzs to fetch.
     */
    where?: TahfidzWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tahfidzs to fetch.
     */
    orderBy?: TahfidzOrderByWithRelationInput | TahfidzOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Tahfidzs.
     */
    cursor?: TahfidzWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tahfidzs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tahfidzs.
     */
    skip?: number
    distinct?: TahfidzScalarFieldEnum | TahfidzScalarFieldEnum[]
  }

  /**
   * Tahfidz create
   */
  export type TahfidzCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tahfidz
     */
    select?: TahfidzSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TahfidzInclude<ExtArgs> | null
    /**
     * The data needed to create a Tahfidz.
     */
    data: XOR<TahfidzCreateInput, TahfidzUncheckedCreateInput>
  }

  /**
   * Tahfidz createMany
   */
  export type TahfidzCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Tahfidzs.
     */
    data: TahfidzCreateManyInput | TahfidzCreateManyInput[]
  }

  /**
   * Tahfidz createManyAndReturn
   */
  export type TahfidzCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tahfidz
     */
    select?: TahfidzSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Tahfidzs.
     */
    data: TahfidzCreateManyInput | TahfidzCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TahfidzIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Tahfidz update
   */
  export type TahfidzUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tahfidz
     */
    select?: TahfidzSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TahfidzInclude<ExtArgs> | null
    /**
     * The data needed to update a Tahfidz.
     */
    data: XOR<TahfidzUpdateInput, TahfidzUncheckedUpdateInput>
    /**
     * Choose, which Tahfidz to update.
     */
    where: TahfidzWhereUniqueInput
  }

  /**
   * Tahfidz updateMany
   */
  export type TahfidzUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Tahfidzs.
     */
    data: XOR<TahfidzUpdateManyMutationInput, TahfidzUncheckedUpdateManyInput>
    /**
     * Filter which Tahfidzs to update
     */
    where?: TahfidzWhereInput
  }

  /**
   * Tahfidz upsert
   */
  export type TahfidzUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tahfidz
     */
    select?: TahfidzSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TahfidzInclude<ExtArgs> | null
    /**
     * The filter to search for the Tahfidz to update in case it exists.
     */
    where: TahfidzWhereUniqueInput
    /**
     * In case the Tahfidz found by the `where` argument doesn't exist, create a new Tahfidz with this data.
     */
    create: XOR<TahfidzCreateInput, TahfidzUncheckedCreateInput>
    /**
     * In case the Tahfidz was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TahfidzUpdateInput, TahfidzUncheckedUpdateInput>
  }

  /**
   * Tahfidz delete
   */
  export type TahfidzDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tahfidz
     */
    select?: TahfidzSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TahfidzInclude<ExtArgs> | null
    /**
     * Filter which Tahfidz to delete.
     */
    where: TahfidzWhereUniqueInput
  }

  /**
   * Tahfidz deleteMany
   */
  export type TahfidzDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Tahfidzs to delete
     */
    where?: TahfidzWhereInput
  }

  /**
   * Tahfidz without action
   */
  export type TahfidzDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tahfidz
     */
    select?: TahfidzSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TahfidzInclude<ExtArgs> | null
  }


  /**
   * Model Mutabaah
   */

  export type AggregateMutabaah = {
    _count: MutabaahCountAggregateOutputType | null
    _min: MutabaahMinAggregateOutputType | null
    _max: MutabaahMaxAggregateOutputType | null
  }

  export type MutabaahMinAggregateOutputType = {
    id: string | null
    tenantId: string | null
    santriId: string | null
    date: Date | null
    sholatWajib: boolean | null
    tahajud: boolean | null
    dhuha: boolean | null
    puasaSunnah: boolean | null
    bacaQuran: boolean | null
    notes: string | null
    recordedBy: string | null
    createdAt: Date | null
  }

  export type MutabaahMaxAggregateOutputType = {
    id: string | null
    tenantId: string | null
    santriId: string | null
    date: Date | null
    sholatWajib: boolean | null
    tahajud: boolean | null
    dhuha: boolean | null
    puasaSunnah: boolean | null
    bacaQuran: boolean | null
    notes: string | null
    recordedBy: string | null
    createdAt: Date | null
  }

  export type MutabaahCountAggregateOutputType = {
    id: number
    tenantId: number
    santriId: number
    date: number
    sholatWajib: number
    tahajud: number
    dhuha: number
    puasaSunnah: number
    bacaQuran: number
    notes: number
    recordedBy: number
    createdAt: number
    _all: number
  }


  export type MutabaahMinAggregateInputType = {
    id?: true
    tenantId?: true
    santriId?: true
    date?: true
    sholatWajib?: true
    tahajud?: true
    dhuha?: true
    puasaSunnah?: true
    bacaQuran?: true
    notes?: true
    recordedBy?: true
    createdAt?: true
  }

  export type MutabaahMaxAggregateInputType = {
    id?: true
    tenantId?: true
    santriId?: true
    date?: true
    sholatWajib?: true
    tahajud?: true
    dhuha?: true
    puasaSunnah?: true
    bacaQuran?: true
    notes?: true
    recordedBy?: true
    createdAt?: true
  }

  export type MutabaahCountAggregateInputType = {
    id?: true
    tenantId?: true
    santriId?: true
    date?: true
    sholatWajib?: true
    tahajud?: true
    dhuha?: true
    puasaSunnah?: true
    bacaQuran?: true
    notes?: true
    recordedBy?: true
    createdAt?: true
    _all?: true
  }

  export type MutabaahAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Mutabaah to aggregate.
     */
    where?: MutabaahWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Mutabaahs to fetch.
     */
    orderBy?: MutabaahOrderByWithRelationInput | MutabaahOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MutabaahWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Mutabaahs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Mutabaahs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Mutabaahs
    **/
    _count?: true | MutabaahCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MutabaahMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MutabaahMaxAggregateInputType
  }

  export type GetMutabaahAggregateType<T extends MutabaahAggregateArgs> = {
        [P in keyof T & keyof AggregateMutabaah]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMutabaah[P]>
      : GetScalarType<T[P], AggregateMutabaah[P]>
  }




  export type MutabaahGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MutabaahWhereInput
    orderBy?: MutabaahOrderByWithAggregationInput | MutabaahOrderByWithAggregationInput[]
    by: MutabaahScalarFieldEnum[] | MutabaahScalarFieldEnum
    having?: MutabaahScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MutabaahCountAggregateInputType | true
    _min?: MutabaahMinAggregateInputType
    _max?: MutabaahMaxAggregateInputType
  }

  export type MutabaahGroupByOutputType = {
    id: string
    tenantId: string
    santriId: string
    date: Date
    sholatWajib: boolean
    tahajud: boolean
    dhuha: boolean
    puasaSunnah: boolean
    bacaQuran: boolean
    notes: string | null
    recordedBy: string | null
    createdAt: Date
    _count: MutabaahCountAggregateOutputType | null
    _min: MutabaahMinAggregateOutputType | null
    _max: MutabaahMaxAggregateOutputType | null
  }

  type GetMutabaahGroupByPayload<T extends MutabaahGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MutabaahGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MutabaahGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MutabaahGroupByOutputType[P]>
            : GetScalarType<T[P], MutabaahGroupByOutputType[P]>
        }
      >
    >


  export type MutabaahSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    santriId?: boolean
    date?: boolean
    sholatWajib?: boolean
    tahajud?: boolean
    dhuha?: boolean
    puasaSunnah?: boolean
    bacaQuran?: boolean
    notes?: boolean
    recordedBy?: boolean
    createdAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    santri?: boolean | SantriDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["mutabaah"]>

  export type MutabaahSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    santriId?: boolean
    date?: boolean
    sholatWajib?: boolean
    tahajud?: boolean
    dhuha?: boolean
    puasaSunnah?: boolean
    bacaQuran?: boolean
    notes?: boolean
    recordedBy?: boolean
    createdAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    santri?: boolean | SantriDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["mutabaah"]>

  export type MutabaahSelectScalar = {
    id?: boolean
    tenantId?: boolean
    santriId?: boolean
    date?: boolean
    sholatWajib?: boolean
    tahajud?: boolean
    dhuha?: boolean
    puasaSunnah?: boolean
    bacaQuran?: boolean
    notes?: boolean
    recordedBy?: boolean
    createdAt?: boolean
  }

  export type MutabaahInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    santri?: boolean | SantriDefaultArgs<ExtArgs>
  }
  export type MutabaahIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    santri?: boolean | SantriDefaultArgs<ExtArgs>
  }

  export type $MutabaahPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Mutabaah"
    objects: {
      tenant: Prisma.$TenantPayload<ExtArgs>
      santri: Prisma.$SantriPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      tenantId: string
      santriId: string
      date: Date
      sholatWajib: boolean
      tahajud: boolean
      dhuha: boolean
      puasaSunnah: boolean
      bacaQuran: boolean
      notes: string | null
      recordedBy: string | null
      createdAt: Date
    }, ExtArgs["result"]["mutabaah"]>
    composites: {}
  }

  type MutabaahGetPayload<S extends boolean | null | undefined | MutabaahDefaultArgs> = $Result.GetResult<Prisma.$MutabaahPayload, S>

  type MutabaahCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<MutabaahFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: MutabaahCountAggregateInputType | true
    }

  export interface MutabaahDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Mutabaah'], meta: { name: 'Mutabaah' } }
    /**
     * Find zero or one Mutabaah that matches the filter.
     * @param {MutabaahFindUniqueArgs} args - Arguments to find a Mutabaah
     * @example
     * // Get one Mutabaah
     * const mutabaah = await prisma.mutabaah.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MutabaahFindUniqueArgs>(args: SelectSubset<T, MutabaahFindUniqueArgs<ExtArgs>>): Prisma__MutabaahClient<$Result.GetResult<Prisma.$MutabaahPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Mutabaah that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {MutabaahFindUniqueOrThrowArgs} args - Arguments to find a Mutabaah
     * @example
     * // Get one Mutabaah
     * const mutabaah = await prisma.mutabaah.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MutabaahFindUniqueOrThrowArgs>(args: SelectSubset<T, MutabaahFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MutabaahClient<$Result.GetResult<Prisma.$MutabaahPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Mutabaah that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MutabaahFindFirstArgs} args - Arguments to find a Mutabaah
     * @example
     * // Get one Mutabaah
     * const mutabaah = await prisma.mutabaah.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MutabaahFindFirstArgs>(args?: SelectSubset<T, MutabaahFindFirstArgs<ExtArgs>>): Prisma__MutabaahClient<$Result.GetResult<Prisma.$MutabaahPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Mutabaah that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MutabaahFindFirstOrThrowArgs} args - Arguments to find a Mutabaah
     * @example
     * // Get one Mutabaah
     * const mutabaah = await prisma.mutabaah.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MutabaahFindFirstOrThrowArgs>(args?: SelectSubset<T, MutabaahFindFirstOrThrowArgs<ExtArgs>>): Prisma__MutabaahClient<$Result.GetResult<Prisma.$MutabaahPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Mutabaahs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MutabaahFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Mutabaahs
     * const mutabaahs = await prisma.mutabaah.findMany()
     * 
     * // Get first 10 Mutabaahs
     * const mutabaahs = await prisma.mutabaah.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const mutabaahWithIdOnly = await prisma.mutabaah.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MutabaahFindManyArgs>(args?: SelectSubset<T, MutabaahFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MutabaahPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Mutabaah.
     * @param {MutabaahCreateArgs} args - Arguments to create a Mutabaah.
     * @example
     * // Create one Mutabaah
     * const Mutabaah = await prisma.mutabaah.create({
     *   data: {
     *     // ... data to create a Mutabaah
     *   }
     * })
     * 
     */
    create<T extends MutabaahCreateArgs>(args: SelectSubset<T, MutabaahCreateArgs<ExtArgs>>): Prisma__MutabaahClient<$Result.GetResult<Prisma.$MutabaahPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Mutabaahs.
     * @param {MutabaahCreateManyArgs} args - Arguments to create many Mutabaahs.
     * @example
     * // Create many Mutabaahs
     * const mutabaah = await prisma.mutabaah.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MutabaahCreateManyArgs>(args?: SelectSubset<T, MutabaahCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Mutabaahs and returns the data saved in the database.
     * @param {MutabaahCreateManyAndReturnArgs} args - Arguments to create many Mutabaahs.
     * @example
     * // Create many Mutabaahs
     * const mutabaah = await prisma.mutabaah.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Mutabaahs and only return the `id`
     * const mutabaahWithIdOnly = await prisma.mutabaah.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MutabaahCreateManyAndReturnArgs>(args?: SelectSubset<T, MutabaahCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MutabaahPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Mutabaah.
     * @param {MutabaahDeleteArgs} args - Arguments to delete one Mutabaah.
     * @example
     * // Delete one Mutabaah
     * const Mutabaah = await prisma.mutabaah.delete({
     *   where: {
     *     // ... filter to delete one Mutabaah
     *   }
     * })
     * 
     */
    delete<T extends MutabaahDeleteArgs>(args: SelectSubset<T, MutabaahDeleteArgs<ExtArgs>>): Prisma__MutabaahClient<$Result.GetResult<Prisma.$MutabaahPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Mutabaah.
     * @param {MutabaahUpdateArgs} args - Arguments to update one Mutabaah.
     * @example
     * // Update one Mutabaah
     * const mutabaah = await prisma.mutabaah.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MutabaahUpdateArgs>(args: SelectSubset<T, MutabaahUpdateArgs<ExtArgs>>): Prisma__MutabaahClient<$Result.GetResult<Prisma.$MutabaahPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Mutabaahs.
     * @param {MutabaahDeleteManyArgs} args - Arguments to filter Mutabaahs to delete.
     * @example
     * // Delete a few Mutabaahs
     * const { count } = await prisma.mutabaah.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MutabaahDeleteManyArgs>(args?: SelectSubset<T, MutabaahDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Mutabaahs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MutabaahUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Mutabaahs
     * const mutabaah = await prisma.mutabaah.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MutabaahUpdateManyArgs>(args: SelectSubset<T, MutabaahUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Mutabaah.
     * @param {MutabaahUpsertArgs} args - Arguments to update or create a Mutabaah.
     * @example
     * // Update or create a Mutabaah
     * const mutabaah = await prisma.mutabaah.upsert({
     *   create: {
     *     // ... data to create a Mutabaah
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Mutabaah we want to update
     *   }
     * })
     */
    upsert<T extends MutabaahUpsertArgs>(args: SelectSubset<T, MutabaahUpsertArgs<ExtArgs>>): Prisma__MutabaahClient<$Result.GetResult<Prisma.$MutabaahPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Mutabaahs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MutabaahCountArgs} args - Arguments to filter Mutabaahs to count.
     * @example
     * // Count the number of Mutabaahs
     * const count = await prisma.mutabaah.count({
     *   where: {
     *     // ... the filter for the Mutabaahs we want to count
     *   }
     * })
    **/
    count<T extends MutabaahCountArgs>(
      args?: Subset<T, MutabaahCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MutabaahCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Mutabaah.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MutabaahAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MutabaahAggregateArgs>(args: Subset<T, MutabaahAggregateArgs>): Prisma.PrismaPromise<GetMutabaahAggregateType<T>>

    /**
     * Group by Mutabaah.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MutabaahGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MutabaahGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MutabaahGroupByArgs['orderBy'] }
        : { orderBy?: MutabaahGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MutabaahGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMutabaahGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Mutabaah model
   */
  readonly fields: MutabaahFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Mutabaah.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MutabaahClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    tenant<T extends TenantDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TenantDefaultArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    santri<T extends SantriDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SantriDefaultArgs<ExtArgs>>): Prisma__SantriClient<$Result.GetResult<Prisma.$SantriPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Mutabaah model
   */ 
  interface MutabaahFieldRefs {
    readonly id: FieldRef<"Mutabaah", 'String'>
    readonly tenantId: FieldRef<"Mutabaah", 'String'>
    readonly santriId: FieldRef<"Mutabaah", 'String'>
    readonly date: FieldRef<"Mutabaah", 'DateTime'>
    readonly sholatWajib: FieldRef<"Mutabaah", 'Boolean'>
    readonly tahajud: FieldRef<"Mutabaah", 'Boolean'>
    readonly dhuha: FieldRef<"Mutabaah", 'Boolean'>
    readonly puasaSunnah: FieldRef<"Mutabaah", 'Boolean'>
    readonly bacaQuran: FieldRef<"Mutabaah", 'Boolean'>
    readonly notes: FieldRef<"Mutabaah", 'String'>
    readonly recordedBy: FieldRef<"Mutabaah", 'String'>
    readonly createdAt: FieldRef<"Mutabaah", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Mutabaah findUnique
   */
  export type MutabaahFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Mutabaah
     */
    select?: MutabaahSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MutabaahInclude<ExtArgs> | null
    /**
     * Filter, which Mutabaah to fetch.
     */
    where: MutabaahWhereUniqueInput
  }

  /**
   * Mutabaah findUniqueOrThrow
   */
  export type MutabaahFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Mutabaah
     */
    select?: MutabaahSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MutabaahInclude<ExtArgs> | null
    /**
     * Filter, which Mutabaah to fetch.
     */
    where: MutabaahWhereUniqueInput
  }

  /**
   * Mutabaah findFirst
   */
  export type MutabaahFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Mutabaah
     */
    select?: MutabaahSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MutabaahInclude<ExtArgs> | null
    /**
     * Filter, which Mutabaah to fetch.
     */
    where?: MutabaahWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Mutabaahs to fetch.
     */
    orderBy?: MutabaahOrderByWithRelationInput | MutabaahOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Mutabaahs.
     */
    cursor?: MutabaahWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Mutabaahs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Mutabaahs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Mutabaahs.
     */
    distinct?: MutabaahScalarFieldEnum | MutabaahScalarFieldEnum[]
  }

  /**
   * Mutabaah findFirstOrThrow
   */
  export type MutabaahFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Mutabaah
     */
    select?: MutabaahSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MutabaahInclude<ExtArgs> | null
    /**
     * Filter, which Mutabaah to fetch.
     */
    where?: MutabaahWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Mutabaahs to fetch.
     */
    orderBy?: MutabaahOrderByWithRelationInput | MutabaahOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Mutabaahs.
     */
    cursor?: MutabaahWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Mutabaahs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Mutabaahs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Mutabaahs.
     */
    distinct?: MutabaahScalarFieldEnum | MutabaahScalarFieldEnum[]
  }

  /**
   * Mutabaah findMany
   */
  export type MutabaahFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Mutabaah
     */
    select?: MutabaahSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MutabaahInclude<ExtArgs> | null
    /**
     * Filter, which Mutabaahs to fetch.
     */
    where?: MutabaahWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Mutabaahs to fetch.
     */
    orderBy?: MutabaahOrderByWithRelationInput | MutabaahOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Mutabaahs.
     */
    cursor?: MutabaahWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Mutabaahs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Mutabaahs.
     */
    skip?: number
    distinct?: MutabaahScalarFieldEnum | MutabaahScalarFieldEnum[]
  }

  /**
   * Mutabaah create
   */
  export type MutabaahCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Mutabaah
     */
    select?: MutabaahSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MutabaahInclude<ExtArgs> | null
    /**
     * The data needed to create a Mutabaah.
     */
    data: XOR<MutabaahCreateInput, MutabaahUncheckedCreateInput>
  }

  /**
   * Mutabaah createMany
   */
  export type MutabaahCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Mutabaahs.
     */
    data: MutabaahCreateManyInput | MutabaahCreateManyInput[]
  }

  /**
   * Mutabaah createManyAndReturn
   */
  export type MutabaahCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Mutabaah
     */
    select?: MutabaahSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Mutabaahs.
     */
    data: MutabaahCreateManyInput | MutabaahCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MutabaahIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Mutabaah update
   */
  export type MutabaahUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Mutabaah
     */
    select?: MutabaahSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MutabaahInclude<ExtArgs> | null
    /**
     * The data needed to update a Mutabaah.
     */
    data: XOR<MutabaahUpdateInput, MutabaahUncheckedUpdateInput>
    /**
     * Choose, which Mutabaah to update.
     */
    where: MutabaahWhereUniqueInput
  }

  /**
   * Mutabaah updateMany
   */
  export type MutabaahUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Mutabaahs.
     */
    data: XOR<MutabaahUpdateManyMutationInput, MutabaahUncheckedUpdateManyInput>
    /**
     * Filter which Mutabaahs to update
     */
    where?: MutabaahWhereInput
  }

  /**
   * Mutabaah upsert
   */
  export type MutabaahUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Mutabaah
     */
    select?: MutabaahSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MutabaahInclude<ExtArgs> | null
    /**
     * The filter to search for the Mutabaah to update in case it exists.
     */
    where: MutabaahWhereUniqueInput
    /**
     * In case the Mutabaah found by the `where` argument doesn't exist, create a new Mutabaah with this data.
     */
    create: XOR<MutabaahCreateInput, MutabaahUncheckedCreateInput>
    /**
     * In case the Mutabaah was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MutabaahUpdateInput, MutabaahUncheckedUpdateInput>
  }

  /**
   * Mutabaah delete
   */
  export type MutabaahDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Mutabaah
     */
    select?: MutabaahSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MutabaahInclude<ExtArgs> | null
    /**
     * Filter which Mutabaah to delete.
     */
    where: MutabaahWhereUniqueInput
  }

  /**
   * Mutabaah deleteMany
   */
  export type MutabaahDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Mutabaahs to delete
     */
    where?: MutabaahWhereInput
  }

  /**
   * Mutabaah without action
   */
  export type MutabaahDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Mutabaah
     */
    select?: MutabaahSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MutabaahInclude<ExtArgs> | null
  }


  /**
   * Model Wallet
   */

  export type AggregateWallet = {
    _count: WalletCountAggregateOutputType | null
    _avg: WalletAvgAggregateOutputType | null
    _sum: WalletSumAggregateOutputType | null
    _min: WalletMinAggregateOutputType | null
    _max: WalletMaxAggregateOutputType | null
  }

  export type WalletAvgAggregateOutputType = {
    balance: number | null
  }

  export type WalletSumAggregateOutputType = {
    balance: number | null
  }

  export type WalletMinAggregateOutputType = {
    id: string | null
    tenantId: string | null
    santriId: string | null
    balance: number | null
    pin: string | null
    isActive: boolean | null
    updatedAt: Date | null
  }

  export type WalletMaxAggregateOutputType = {
    id: string | null
    tenantId: string | null
    santriId: string | null
    balance: number | null
    pin: string | null
    isActive: boolean | null
    updatedAt: Date | null
  }

  export type WalletCountAggregateOutputType = {
    id: number
    tenantId: number
    santriId: number
    balance: number
    pin: number
    isActive: number
    updatedAt: number
    _all: number
  }


  export type WalletAvgAggregateInputType = {
    balance?: true
  }

  export type WalletSumAggregateInputType = {
    balance?: true
  }

  export type WalletMinAggregateInputType = {
    id?: true
    tenantId?: true
    santriId?: true
    balance?: true
    pin?: true
    isActive?: true
    updatedAt?: true
  }

  export type WalletMaxAggregateInputType = {
    id?: true
    tenantId?: true
    santriId?: true
    balance?: true
    pin?: true
    isActive?: true
    updatedAt?: true
  }

  export type WalletCountAggregateInputType = {
    id?: true
    tenantId?: true
    santriId?: true
    balance?: true
    pin?: true
    isActive?: true
    updatedAt?: true
    _all?: true
  }

  export type WalletAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Wallet to aggregate.
     */
    where?: WalletWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Wallets to fetch.
     */
    orderBy?: WalletOrderByWithRelationInput | WalletOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: WalletWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Wallets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Wallets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Wallets
    **/
    _count?: true | WalletCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: WalletAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: WalletSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WalletMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WalletMaxAggregateInputType
  }

  export type GetWalletAggregateType<T extends WalletAggregateArgs> = {
        [P in keyof T & keyof AggregateWallet]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWallet[P]>
      : GetScalarType<T[P], AggregateWallet[P]>
  }




  export type WalletGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WalletWhereInput
    orderBy?: WalletOrderByWithAggregationInput | WalletOrderByWithAggregationInput[]
    by: WalletScalarFieldEnum[] | WalletScalarFieldEnum
    having?: WalletScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WalletCountAggregateInputType | true
    _avg?: WalletAvgAggregateInputType
    _sum?: WalletSumAggregateInputType
    _min?: WalletMinAggregateInputType
    _max?: WalletMaxAggregateInputType
  }

  export type WalletGroupByOutputType = {
    id: string
    tenantId: string
    santriId: string
    balance: number
    pin: string | null
    isActive: boolean
    updatedAt: Date
    _count: WalletCountAggregateOutputType | null
    _avg: WalletAvgAggregateOutputType | null
    _sum: WalletSumAggregateOutputType | null
    _min: WalletMinAggregateOutputType | null
    _max: WalletMaxAggregateOutputType | null
  }

  type GetWalletGroupByPayload<T extends WalletGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<WalletGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WalletGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WalletGroupByOutputType[P]>
            : GetScalarType<T[P], WalletGroupByOutputType[P]>
        }
      >
    >


  export type WalletSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    santriId?: boolean
    balance?: boolean
    pin?: boolean
    isActive?: boolean
    updatedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    santri?: boolean | SantriDefaultArgs<ExtArgs>
    transactions?: boolean | Wallet$transactionsArgs<ExtArgs>
    _count?: boolean | WalletCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["wallet"]>

  export type WalletSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    santriId?: boolean
    balance?: boolean
    pin?: boolean
    isActive?: boolean
    updatedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    santri?: boolean | SantriDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["wallet"]>

  export type WalletSelectScalar = {
    id?: boolean
    tenantId?: boolean
    santriId?: boolean
    balance?: boolean
    pin?: boolean
    isActive?: boolean
    updatedAt?: boolean
  }

  export type WalletInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    santri?: boolean | SantriDefaultArgs<ExtArgs>
    transactions?: boolean | Wallet$transactionsArgs<ExtArgs>
    _count?: boolean | WalletCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type WalletIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    santri?: boolean | SantriDefaultArgs<ExtArgs>
  }

  export type $WalletPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Wallet"
    objects: {
      tenant: Prisma.$TenantPayload<ExtArgs>
      santri: Prisma.$SantriPayload<ExtArgs>
      transactions: Prisma.$WalletTransactionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      tenantId: string
      santriId: string
      balance: number
      pin: string | null
      isActive: boolean
      updatedAt: Date
    }, ExtArgs["result"]["wallet"]>
    composites: {}
  }

  type WalletGetPayload<S extends boolean | null | undefined | WalletDefaultArgs> = $Result.GetResult<Prisma.$WalletPayload, S>

  type WalletCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<WalletFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: WalletCountAggregateInputType | true
    }

  export interface WalletDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Wallet'], meta: { name: 'Wallet' } }
    /**
     * Find zero or one Wallet that matches the filter.
     * @param {WalletFindUniqueArgs} args - Arguments to find a Wallet
     * @example
     * // Get one Wallet
     * const wallet = await prisma.wallet.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends WalletFindUniqueArgs>(args: SelectSubset<T, WalletFindUniqueArgs<ExtArgs>>): Prisma__WalletClient<$Result.GetResult<Prisma.$WalletPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Wallet that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {WalletFindUniqueOrThrowArgs} args - Arguments to find a Wallet
     * @example
     * // Get one Wallet
     * const wallet = await prisma.wallet.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends WalletFindUniqueOrThrowArgs>(args: SelectSubset<T, WalletFindUniqueOrThrowArgs<ExtArgs>>): Prisma__WalletClient<$Result.GetResult<Prisma.$WalletPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Wallet that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WalletFindFirstArgs} args - Arguments to find a Wallet
     * @example
     * // Get one Wallet
     * const wallet = await prisma.wallet.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends WalletFindFirstArgs>(args?: SelectSubset<T, WalletFindFirstArgs<ExtArgs>>): Prisma__WalletClient<$Result.GetResult<Prisma.$WalletPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Wallet that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WalletFindFirstOrThrowArgs} args - Arguments to find a Wallet
     * @example
     * // Get one Wallet
     * const wallet = await prisma.wallet.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends WalletFindFirstOrThrowArgs>(args?: SelectSubset<T, WalletFindFirstOrThrowArgs<ExtArgs>>): Prisma__WalletClient<$Result.GetResult<Prisma.$WalletPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Wallets that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WalletFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Wallets
     * const wallets = await prisma.wallet.findMany()
     * 
     * // Get first 10 Wallets
     * const wallets = await prisma.wallet.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const walletWithIdOnly = await prisma.wallet.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends WalletFindManyArgs>(args?: SelectSubset<T, WalletFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WalletPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Wallet.
     * @param {WalletCreateArgs} args - Arguments to create a Wallet.
     * @example
     * // Create one Wallet
     * const Wallet = await prisma.wallet.create({
     *   data: {
     *     // ... data to create a Wallet
     *   }
     * })
     * 
     */
    create<T extends WalletCreateArgs>(args: SelectSubset<T, WalletCreateArgs<ExtArgs>>): Prisma__WalletClient<$Result.GetResult<Prisma.$WalletPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Wallets.
     * @param {WalletCreateManyArgs} args - Arguments to create many Wallets.
     * @example
     * // Create many Wallets
     * const wallet = await prisma.wallet.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends WalletCreateManyArgs>(args?: SelectSubset<T, WalletCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Wallets and returns the data saved in the database.
     * @param {WalletCreateManyAndReturnArgs} args - Arguments to create many Wallets.
     * @example
     * // Create many Wallets
     * const wallet = await prisma.wallet.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Wallets and only return the `id`
     * const walletWithIdOnly = await prisma.wallet.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends WalletCreateManyAndReturnArgs>(args?: SelectSubset<T, WalletCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WalletPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Wallet.
     * @param {WalletDeleteArgs} args - Arguments to delete one Wallet.
     * @example
     * // Delete one Wallet
     * const Wallet = await prisma.wallet.delete({
     *   where: {
     *     // ... filter to delete one Wallet
     *   }
     * })
     * 
     */
    delete<T extends WalletDeleteArgs>(args: SelectSubset<T, WalletDeleteArgs<ExtArgs>>): Prisma__WalletClient<$Result.GetResult<Prisma.$WalletPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Wallet.
     * @param {WalletUpdateArgs} args - Arguments to update one Wallet.
     * @example
     * // Update one Wallet
     * const wallet = await prisma.wallet.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends WalletUpdateArgs>(args: SelectSubset<T, WalletUpdateArgs<ExtArgs>>): Prisma__WalletClient<$Result.GetResult<Prisma.$WalletPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Wallets.
     * @param {WalletDeleteManyArgs} args - Arguments to filter Wallets to delete.
     * @example
     * // Delete a few Wallets
     * const { count } = await prisma.wallet.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends WalletDeleteManyArgs>(args?: SelectSubset<T, WalletDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Wallets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WalletUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Wallets
     * const wallet = await prisma.wallet.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends WalletUpdateManyArgs>(args: SelectSubset<T, WalletUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Wallet.
     * @param {WalletUpsertArgs} args - Arguments to update or create a Wallet.
     * @example
     * // Update or create a Wallet
     * const wallet = await prisma.wallet.upsert({
     *   create: {
     *     // ... data to create a Wallet
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Wallet we want to update
     *   }
     * })
     */
    upsert<T extends WalletUpsertArgs>(args: SelectSubset<T, WalletUpsertArgs<ExtArgs>>): Prisma__WalletClient<$Result.GetResult<Prisma.$WalletPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Wallets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WalletCountArgs} args - Arguments to filter Wallets to count.
     * @example
     * // Count the number of Wallets
     * const count = await prisma.wallet.count({
     *   where: {
     *     // ... the filter for the Wallets we want to count
     *   }
     * })
    **/
    count<T extends WalletCountArgs>(
      args?: Subset<T, WalletCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WalletCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Wallet.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WalletAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WalletAggregateArgs>(args: Subset<T, WalletAggregateArgs>): Prisma.PrismaPromise<GetWalletAggregateType<T>>

    /**
     * Group by Wallet.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WalletGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WalletGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WalletGroupByArgs['orderBy'] }
        : { orderBy?: WalletGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WalletGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWalletGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Wallet model
   */
  readonly fields: WalletFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Wallet.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__WalletClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    tenant<T extends TenantDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TenantDefaultArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    santri<T extends SantriDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SantriDefaultArgs<ExtArgs>>): Prisma__SantriClient<$Result.GetResult<Prisma.$SantriPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    transactions<T extends Wallet$transactionsArgs<ExtArgs> = {}>(args?: Subset<T, Wallet$transactionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WalletTransactionPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Wallet model
   */ 
  interface WalletFieldRefs {
    readonly id: FieldRef<"Wallet", 'String'>
    readonly tenantId: FieldRef<"Wallet", 'String'>
    readonly santriId: FieldRef<"Wallet", 'String'>
    readonly balance: FieldRef<"Wallet", 'Float'>
    readonly pin: FieldRef<"Wallet", 'String'>
    readonly isActive: FieldRef<"Wallet", 'Boolean'>
    readonly updatedAt: FieldRef<"Wallet", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Wallet findUnique
   */
  export type WalletFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Wallet
     */
    select?: WalletSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WalletInclude<ExtArgs> | null
    /**
     * Filter, which Wallet to fetch.
     */
    where: WalletWhereUniqueInput
  }

  /**
   * Wallet findUniqueOrThrow
   */
  export type WalletFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Wallet
     */
    select?: WalletSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WalletInclude<ExtArgs> | null
    /**
     * Filter, which Wallet to fetch.
     */
    where: WalletWhereUniqueInput
  }

  /**
   * Wallet findFirst
   */
  export type WalletFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Wallet
     */
    select?: WalletSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WalletInclude<ExtArgs> | null
    /**
     * Filter, which Wallet to fetch.
     */
    where?: WalletWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Wallets to fetch.
     */
    orderBy?: WalletOrderByWithRelationInput | WalletOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Wallets.
     */
    cursor?: WalletWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Wallets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Wallets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Wallets.
     */
    distinct?: WalletScalarFieldEnum | WalletScalarFieldEnum[]
  }

  /**
   * Wallet findFirstOrThrow
   */
  export type WalletFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Wallet
     */
    select?: WalletSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WalletInclude<ExtArgs> | null
    /**
     * Filter, which Wallet to fetch.
     */
    where?: WalletWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Wallets to fetch.
     */
    orderBy?: WalletOrderByWithRelationInput | WalletOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Wallets.
     */
    cursor?: WalletWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Wallets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Wallets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Wallets.
     */
    distinct?: WalletScalarFieldEnum | WalletScalarFieldEnum[]
  }

  /**
   * Wallet findMany
   */
  export type WalletFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Wallet
     */
    select?: WalletSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WalletInclude<ExtArgs> | null
    /**
     * Filter, which Wallets to fetch.
     */
    where?: WalletWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Wallets to fetch.
     */
    orderBy?: WalletOrderByWithRelationInput | WalletOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Wallets.
     */
    cursor?: WalletWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Wallets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Wallets.
     */
    skip?: number
    distinct?: WalletScalarFieldEnum | WalletScalarFieldEnum[]
  }

  /**
   * Wallet create
   */
  export type WalletCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Wallet
     */
    select?: WalletSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WalletInclude<ExtArgs> | null
    /**
     * The data needed to create a Wallet.
     */
    data: XOR<WalletCreateInput, WalletUncheckedCreateInput>
  }

  /**
   * Wallet createMany
   */
  export type WalletCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Wallets.
     */
    data: WalletCreateManyInput | WalletCreateManyInput[]
  }

  /**
   * Wallet createManyAndReturn
   */
  export type WalletCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Wallet
     */
    select?: WalletSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Wallets.
     */
    data: WalletCreateManyInput | WalletCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WalletIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Wallet update
   */
  export type WalletUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Wallet
     */
    select?: WalletSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WalletInclude<ExtArgs> | null
    /**
     * The data needed to update a Wallet.
     */
    data: XOR<WalletUpdateInput, WalletUncheckedUpdateInput>
    /**
     * Choose, which Wallet to update.
     */
    where: WalletWhereUniqueInput
  }

  /**
   * Wallet updateMany
   */
  export type WalletUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Wallets.
     */
    data: XOR<WalletUpdateManyMutationInput, WalletUncheckedUpdateManyInput>
    /**
     * Filter which Wallets to update
     */
    where?: WalletWhereInput
  }

  /**
   * Wallet upsert
   */
  export type WalletUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Wallet
     */
    select?: WalletSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WalletInclude<ExtArgs> | null
    /**
     * The filter to search for the Wallet to update in case it exists.
     */
    where: WalletWhereUniqueInput
    /**
     * In case the Wallet found by the `where` argument doesn't exist, create a new Wallet with this data.
     */
    create: XOR<WalletCreateInput, WalletUncheckedCreateInput>
    /**
     * In case the Wallet was found with the provided `where` argument, update it with this data.
     */
    update: XOR<WalletUpdateInput, WalletUncheckedUpdateInput>
  }

  /**
   * Wallet delete
   */
  export type WalletDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Wallet
     */
    select?: WalletSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WalletInclude<ExtArgs> | null
    /**
     * Filter which Wallet to delete.
     */
    where: WalletWhereUniqueInput
  }

  /**
   * Wallet deleteMany
   */
  export type WalletDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Wallets to delete
     */
    where?: WalletWhereInput
  }

  /**
   * Wallet.transactions
   */
  export type Wallet$transactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WalletTransaction
     */
    select?: WalletTransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WalletTransactionInclude<ExtArgs> | null
    where?: WalletTransactionWhereInput
    orderBy?: WalletTransactionOrderByWithRelationInput | WalletTransactionOrderByWithRelationInput[]
    cursor?: WalletTransactionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WalletTransactionScalarFieldEnum | WalletTransactionScalarFieldEnum[]
  }

  /**
   * Wallet without action
   */
  export type WalletDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Wallet
     */
    select?: WalletSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WalletInclude<ExtArgs> | null
  }


  /**
   * Model WalletTransaction
   */

  export type AggregateWalletTransaction = {
    _count: WalletTransactionCountAggregateOutputType | null
    _avg: WalletTransactionAvgAggregateOutputType | null
    _sum: WalletTransactionSumAggregateOutputType | null
    _min: WalletTransactionMinAggregateOutputType | null
    _max: WalletTransactionMaxAggregateOutputType | null
  }

  export type WalletTransactionAvgAggregateOutputType = {
    amount: number | null
  }

  export type WalletTransactionSumAggregateOutputType = {
    amount: number | null
  }

  export type WalletTransactionMinAggregateOutputType = {
    id: string | null
    walletId: string | null
    amount: number | null
    type: string | null
    method: string | null
    description: string | null
    reference: string | null
    status: string | null
    handledBy: string | null
    createdAt: Date | null
  }

  export type WalletTransactionMaxAggregateOutputType = {
    id: string | null
    walletId: string | null
    amount: number | null
    type: string | null
    method: string | null
    description: string | null
    reference: string | null
    status: string | null
    handledBy: string | null
    createdAt: Date | null
  }

  export type WalletTransactionCountAggregateOutputType = {
    id: number
    walletId: number
    amount: number
    type: number
    method: number
    description: number
    reference: number
    status: number
    handledBy: number
    createdAt: number
    _all: number
  }


  export type WalletTransactionAvgAggregateInputType = {
    amount?: true
  }

  export type WalletTransactionSumAggregateInputType = {
    amount?: true
  }

  export type WalletTransactionMinAggregateInputType = {
    id?: true
    walletId?: true
    amount?: true
    type?: true
    method?: true
    description?: true
    reference?: true
    status?: true
    handledBy?: true
    createdAt?: true
  }

  export type WalletTransactionMaxAggregateInputType = {
    id?: true
    walletId?: true
    amount?: true
    type?: true
    method?: true
    description?: true
    reference?: true
    status?: true
    handledBy?: true
    createdAt?: true
  }

  export type WalletTransactionCountAggregateInputType = {
    id?: true
    walletId?: true
    amount?: true
    type?: true
    method?: true
    description?: true
    reference?: true
    status?: true
    handledBy?: true
    createdAt?: true
    _all?: true
  }

  export type WalletTransactionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WalletTransaction to aggregate.
     */
    where?: WalletTransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WalletTransactions to fetch.
     */
    orderBy?: WalletTransactionOrderByWithRelationInput | WalletTransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: WalletTransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WalletTransactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WalletTransactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned WalletTransactions
    **/
    _count?: true | WalletTransactionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: WalletTransactionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: WalletTransactionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WalletTransactionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WalletTransactionMaxAggregateInputType
  }

  export type GetWalletTransactionAggregateType<T extends WalletTransactionAggregateArgs> = {
        [P in keyof T & keyof AggregateWalletTransaction]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWalletTransaction[P]>
      : GetScalarType<T[P], AggregateWalletTransaction[P]>
  }




  export type WalletTransactionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WalletTransactionWhereInput
    orderBy?: WalletTransactionOrderByWithAggregationInput | WalletTransactionOrderByWithAggregationInput[]
    by: WalletTransactionScalarFieldEnum[] | WalletTransactionScalarFieldEnum
    having?: WalletTransactionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WalletTransactionCountAggregateInputType | true
    _avg?: WalletTransactionAvgAggregateInputType
    _sum?: WalletTransactionSumAggregateInputType
    _min?: WalletTransactionMinAggregateInputType
    _max?: WalletTransactionMaxAggregateInputType
  }

  export type WalletTransactionGroupByOutputType = {
    id: string
    walletId: string
    amount: number
    type: string
    method: string
    description: string | null
    reference: string | null
    status: string
    handledBy: string | null
    createdAt: Date
    _count: WalletTransactionCountAggregateOutputType | null
    _avg: WalletTransactionAvgAggregateOutputType | null
    _sum: WalletTransactionSumAggregateOutputType | null
    _min: WalletTransactionMinAggregateOutputType | null
    _max: WalletTransactionMaxAggregateOutputType | null
  }

  type GetWalletTransactionGroupByPayload<T extends WalletTransactionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<WalletTransactionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WalletTransactionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WalletTransactionGroupByOutputType[P]>
            : GetScalarType<T[P], WalletTransactionGroupByOutputType[P]>
        }
      >
    >


  export type WalletTransactionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    walletId?: boolean
    amount?: boolean
    type?: boolean
    method?: boolean
    description?: boolean
    reference?: boolean
    status?: boolean
    handledBy?: boolean
    createdAt?: boolean
    wallet?: boolean | WalletDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["walletTransaction"]>

  export type WalletTransactionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    walletId?: boolean
    amount?: boolean
    type?: boolean
    method?: boolean
    description?: boolean
    reference?: boolean
    status?: boolean
    handledBy?: boolean
    createdAt?: boolean
    wallet?: boolean | WalletDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["walletTransaction"]>

  export type WalletTransactionSelectScalar = {
    id?: boolean
    walletId?: boolean
    amount?: boolean
    type?: boolean
    method?: boolean
    description?: boolean
    reference?: boolean
    status?: boolean
    handledBy?: boolean
    createdAt?: boolean
  }

  export type WalletTransactionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    wallet?: boolean | WalletDefaultArgs<ExtArgs>
  }
  export type WalletTransactionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    wallet?: boolean | WalletDefaultArgs<ExtArgs>
  }

  export type $WalletTransactionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "WalletTransaction"
    objects: {
      wallet: Prisma.$WalletPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      walletId: string
      amount: number
      type: string
      method: string
      description: string | null
      reference: string | null
      status: string
      handledBy: string | null
      createdAt: Date
    }, ExtArgs["result"]["walletTransaction"]>
    composites: {}
  }

  type WalletTransactionGetPayload<S extends boolean | null | undefined | WalletTransactionDefaultArgs> = $Result.GetResult<Prisma.$WalletTransactionPayload, S>

  type WalletTransactionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<WalletTransactionFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: WalletTransactionCountAggregateInputType | true
    }

  export interface WalletTransactionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['WalletTransaction'], meta: { name: 'WalletTransaction' } }
    /**
     * Find zero or one WalletTransaction that matches the filter.
     * @param {WalletTransactionFindUniqueArgs} args - Arguments to find a WalletTransaction
     * @example
     * // Get one WalletTransaction
     * const walletTransaction = await prisma.walletTransaction.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends WalletTransactionFindUniqueArgs>(args: SelectSubset<T, WalletTransactionFindUniqueArgs<ExtArgs>>): Prisma__WalletTransactionClient<$Result.GetResult<Prisma.$WalletTransactionPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one WalletTransaction that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {WalletTransactionFindUniqueOrThrowArgs} args - Arguments to find a WalletTransaction
     * @example
     * // Get one WalletTransaction
     * const walletTransaction = await prisma.walletTransaction.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends WalletTransactionFindUniqueOrThrowArgs>(args: SelectSubset<T, WalletTransactionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__WalletTransactionClient<$Result.GetResult<Prisma.$WalletTransactionPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first WalletTransaction that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WalletTransactionFindFirstArgs} args - Arguments to find a WalletTransaction
     * @example
     * // Get one WalletTransaction
     * const walletTransaction = await prisma.walletTransaction.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends WalletTransactionFindFirstArgs>(args?: SelectSubset<T, WalletTransactionFindFirstArgs<ExtArgs>>): Prisma__WalletTransactionClient<$Result.GetResult<Prisma.$WalletTransactionPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first WalletTransaction that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WalletTransactionFindFirstOrThrowArgs} args - Arguments to find a WalletTransaction
     * @example
     * // Get one WalletTransaction
     * const walletTransaction = await prisma.walletTransaction.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends WalletTransactionFindFirstOrThrowArgs>(args?: SelectSubset<T, WalletTransactionFindFirstOrThrowArgs<ExtArgs>>): Prisma__WalletTransactionClient<$Result.GetResult<Prisma.$WalletTransactionPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more WalletTransactions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WalletTransactionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all WalletTransactions
     * const walletTransactions = await prisma.walletTransaction.findMany()
     * 
     * // Get first 10 WalletTransactions
     * const walletTransactions = await prisma.walletTransaction.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const walletTransactionWithIdOnly = await prisma.walletTransaction.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends WalletTransactionFindManyArgs>(args?: SelectSubset<T, WalletTransactionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WalletTransactionPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a WalletTransaction.
     * @param {WalletTransactionCreateArgs} args - Arguments to create a WalletTransaction.
     * @example
     * // Create one WalletTransaction
     * const WalletTransaction = await prisma.walletTransaction.create({
     *   data: {
     *     // ... data to create a WalletTransaction
     *   }
     * })
     * 
     */
    create<T extends WalletTransactionCreateArgs>(args: SelectSubset<T, WalletTransactionCreateArgs<ExtArgs>>): Prisma__WalletTransactionClient<$Result.GetResult<Prisma.$WalletTransactionPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many WalletTransactions.
     * @param {WalletTransactionCreateManyArgs} args - Arguments to create many WalletTransactions.
     * @example
     * // Create many WalletTransactions
     * const walletTransaction = await prisma.walletTransaction.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends WalletTransactionCreateManyArgs>(args?: SelectSubset<T, WalletTransactionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many WalletTransactions and returns the data saved in the database.
     * @param {WalletTransactionCreateManyAndReturnArgs} args - Arguments to create many WalletTransactions.
     * @example
     * // Create many WalletTransactions
     * const walletTransaction = await prisma.walletTransaction.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many WalletTransactions and only return the `id`
     * const walletTransactionWithIdOnly = await prisma.walletTransaction.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends WalletTransactionCreateManyAndReturnArgs>(args?: SelectSubset<T, WalletTransactionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WalletTransactionPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a WalletTransaction.
     * @param {WalletTransactionDeleteArgs} args - Arguments to delete one WalletTransaction.
     * @example
     * // Delete one WalletTransaction
     * const WalletTransaction = await prisma.walletTransaction.delete({
     *   where: {
     *     // ... filter to delete one WalletTransaction
     *   }
     * })
     * 
     */
    delete<T extends WalletTransactionDeleteArgs>(args: SelectSubset<T, WalletTransactionDeleteArgs<ExtArgs>>): Prisma__WalletTransactionClient<$Result.GetResult<Prisma.$WalletTransactionPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one WalletTransaction.
     * @param {WalletTransactionUpdateArgs} args - Arguments to update one WalletTransaction.
     * @example
     * // Update one WalletTransaction
     * const walletTransaction = await prisma.walletTransaction.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends WalletTransactionUpdateArgs>(args: SelectSubset<T, WalletTransactionUpdateArgs<ExtArgs>>): Prisma__WalletTransactionClient<$Result.GetResult<Prisma.$WalletTransactionPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more WalletTransactions.
     * @param {WalletTransactionDeleteManyArgs} args - Arguments to filter WalletTransactions to delete.
     * @example
     * // Delete a few WalletTransactions
     * const { count } = await prisma.walletTransaction.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends WalletTransactionDeleteManyArgs>(args?: SelectSubset<T, WalletTransactionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WalletTransactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WalletTransactionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many WalletTransactions
     * const walletTransaction = await prisma.walletTransaction.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends WalletTransactionUpdateManyArgs>(args: SelectSubset<T, WalletTransactionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one WalletTransaction.
     * @param {WalletTransactionUpsertArgs} args - Arguments to update or create a WalletTransaction.
     * @example
     * // Update or create a WalletTransaction
     * const walletTransaction = await prisma.walletTransaction.upsert({
     *   create: {
     *     // ... data to create a WalletTransaction
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the WalletTransaction we want to update
     *   }
     * })
     */
    upsert<T extends WalletTransactionUpsertArgs>(args: SelectSubset<T, WalletTransactionUpsertArgs<ExtArgs>>): Prisma__WalletTransactionClient<$Result.GetResult<Prisma.$WalletTransactionPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of WalletTransactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WalletTransactionCountArgs} args - Arguments to filter WalletTransactions to count.
     * @example
     * // Count the number of WalletTransactions
     * const count = await prisma.walletTransaction.count({
     *   where: {
     *     // ... the filter for the WalletTransactions we want to count
     *   }
     * })
    **/
    count<T extends WalletTransactionCountArgs>(
      args?: Subset<T, WalletTransactionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WalletTransactionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a WalletTransaction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WalletTransactionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WalletTransactionAggregateArgs>(args: Subset<T, WalletTransactionAggregateArgs>): Prisma.PrismaPromise<GetWalletTransactionAggregateType<T>>

    /**
     * Group by WalletTransaction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WalletTransactionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WalletTransactionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WalletTransactionGroupByArgs['orderBy'] }
        : { orderBy?: WalletTransactionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WalletTransactionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWalletTransactionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the WalletTransaction model
   */
  readonly fields: WalletTransactionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for WalletTransaction.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__WalletTransactionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    wallet<T extends WalletDefaultArgs<ExtArgs> = {}>(args?: Subset<T, WalletDefaultArgs<ExtArgs>>): Prisma__WalletClient<$Result.GetResult<Prisma.$WalletPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the WalletTransaction model
   */ 
  interface WalletTransactionFieldRefs {
    readonly id: FieldRef<"WalletTransaction", 'String'>
    readonly walletId: FieldRef<"WalletTransaction", 'String'>
    readonly amount: FieldRef<"WalletTransaction", 'Float'>
    readonly type: FieldRef<"WalletTransaction", 'String'>
    readonly method: FieldRef<"WalletTransaction", 'String'>
    readonly description: FieldRef<"WalletTransaction", 'String'>
    readonly reference: FieldRef<"WalletTransaction", 'String'>
    readonly status: FieldRef<"WalletTransaction", 'String'>
    readonly handledBy: FieldRef<"WalletTransaction", 'String'>
    readonly createdAt: FieldRef<"WalletTransaction", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * WalletTransaction findUnique
   */
  export type WalletTransactionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WalletTransaction
     */
    select?: WalletTransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WalletTransactionInclude<ExtArgs> | null
    /**
     * Filter, which WalletTransaction to fetch.
     */
    where: WalletTransactionWhereUniqueInput
  }

  /**
   * WalletTransaction findUniqueOrThrow
   */
  export type WalletTransactionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WalletTransaction
     */
    select?: WalletTransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WalletTransactionInclude<ExtArgs> | null
    /**
     * Filter, which WalletTransaction to fetch.
     */
    where: WalletTransactionWhereUniqueInput
  }

  /**
   * WalletTransaction findFirst
   */
  export type WalletTransactionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WalletTransaction
     */
    select?: WalletTransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WalletTransactionInclude<ExtArgs> | null
    /**
     * Filter, which WalletTransaction to fetch.
     */
    where?: WalletTransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WalletTransactions to fetch.
     */
    orderBy?: WalletTransactionOrderByWithRelationInput | WalletTransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WalletTransactions.
     */
    cursor?: WalletTransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WalletTransactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WalletTransactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WalletTransactions.
     */
    distinct?: WalletTransactionScalarFieldEnum | WalletTransactionScalarFieldEnum[]
  }

  /**
   * WalletTransaction findFirstOrThrow
   */
  export type WalletTransactionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WalletTransaction
     */
    select?: WalletTransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WalletTransactionInclude<ExtArgs> | null
    /**
     * Filter, which WalletTransaction to fetch.
     */
    where?: WalletTransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WalletTransactions to fetch.
     */
    orderBy?: WalletTransactionOrderByWithRelationInput | WalletTransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WalletTransactions.
     */
    cursor?: WalletTransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WalletTransactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WalletTransactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WalletTransactions.
     */
    distinct?: WalletTransactionScalarFieldEnum | WalletTransactionScalarFieldEnum[]
  }

  /**
   * WalletTransaction findMany
   */
  export type WalletTransactionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WalletTransaction
     */
    select?: WalletTransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WalletTransactionInclude<ExtArgs> | null
    /**
     * Filter, which WalletTransactions to fetch.
     */
    where?: WalletTransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WalletTransactions to fetch.
     */
    orderBy?: WalletTransactionOrderByWithRelationInput | WalletTransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing WalletTransactions.
     */
    cursor?: WalletTransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WalletTransactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WalletTransactions.
     */
    skip?: number
    distinct?: WalletTransactionScalarFieldEnum | WalletTransactionScalarFieldEnum[]
  }

  /**
   * WalletTransaction create
   */
  export type WalletTransactionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WalletTransaction
     */
    select?: WalletTransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WalletTransactionInclude<ExtArgs> | null
    /**
     * The data needed to create a WalletTransaction.
     */
    data: XOR<WalletTransactionCreateInput, WalletTransactionUncheckedCreateInput>
  }

  /**
   * WalletTransaction createMany
   */
  export type WalletTransactionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many WalletTransactions.
     */
    data: WalletTransactionCreateManyInput | WalletTransactionCreateManyInput[]
  }

  /**
   * WalletTransaction createManyAndReturn
   */
  export type WalletTransactionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WalletTransaction
     */
    select?: WalletTransactionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many WalletTransactions.
     */
    data: WalletTransactionCreateManyInput | WalletTransactionCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WalletTransactionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * WalletTransaction update
   */
  export type WalletTransactionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WalletTransaction
     */
    select?: WalletTransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WalletTransactionInclude<ExtArgs> | null
    /**
     * The data needed to update a WalletTransaction.
     */
    data: XOR<WalletTransactionUpdateInput, WalletTransactionUncheckedUpdateInput>
    /**
     * Choose, which WalletTransaction to update.
     */
    where: WalletTransactionWhereUniqueInput
  }

  /**
   * WalletTransaction updateMany
   */
  export type WalletTransactionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update WalletTransactions.
     */
    data: XOR<WalletTransactionUpdateManyMutationInput, WalletTransactionUncheckedUpdateManyInput>
    /**
     * Filter which WalletTransactions to update
     */
    where?: WalletTransactionWhereInput
  }

  /**
   * WalletTransaction upsert
   */
  export type WalletTransactionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WalletTransaction
     */
    select?: WalletTransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WalletTransactionInclude<ExtArgs> | null
    /**
     * The filter to search for the WalletTransaction to update in case it exists.
     */
    where: WalletTransactionWhereUniqueInput
    /**
     * In case the WalletTransaction found by the `where` argument doesn't exist, create a new WalletTransaction with this data.
     */
    create: XOR<WalletTransactionCreateInput, WalletTransactionUncheckedCreateInput>
    /**
     * In case the WalletTransaction was found with the provided `where` argument, update it with this data.
     */
    update: XOR<WalletTransactionUpdateInput, WalletTransactionUncheckedUpdateInput>
  }

  /**
   * WalletTransaction delete
   */
  export type WalletTransactionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WalletTransaction
     */
    select?: WalletTransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WalletTransactionInclude<ExtArgs> | null
    /**
     * Filter which WalletTransaction to delete.
     */
    where: WalletTransactionWhereUniqueInput
  }

  /**
   * WalletTransaction deleteMany
   */
  export type WalletTransactionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WalletTransactions to delete
     */
    where?: WalletTransactionWhereInput
  }

  /**
   * WalletTransaction without action
   */
  export type WalletTransactionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WalletTransaction
     */
    select?: WalletTransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WalletTransactionInclude<ExtArgs> | null
  }


  /**
   * Model Employee
   */

  export type AggregateEmployee = {
    _count: EmployeeCountAggregateOutputType | null
    _min: EmployeeMinAggregateOutputType | null
    _max: EmployeeMaxAggregateOutputType | null
  }

  export type EmployeeMinAggregateOutputType = {
    id: string | null
    tenantId: string | null
    userId: string | null
    nip: string | null
    name: string | null
    position: string | null
    phone: string | null
    address: string | null
    joinDate: Date | null
    status: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type EmployeeMaxAggregateOutputType = {
    id: string | null
    tenantId: string | null
    userId: string | null
    nip: string | null
    name: string | null
    position: string | null
    phone: string | null
    address: string | null
    joinDate: Date | null
    status: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type EmployeeCountAggregateOutputType = {
    id: number
    tenantId: number
    userId: number
    nip: number
    name: number
    position: number
    phone: number
    address: number
    joinDate: number
    status: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type EmployeeMinAggregateInputType = {
    id?: true
    tenantId?: true
    userId?: true
    nip?: true
    name?: true
    position?: true
    phone?: true
    address?: true
    joinDate?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type EmployeeMaxAggregateInputType = {
    id?: true
    tenantId?: true
    userId?: true
    nip?: true
    name?: true
    position?: true
    phone?: true
    address?: true
    joinDate?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type EmployeeCountAggregateInputType = {
    id?: true
    tenantId?: true
    userId?: true
    nip?: true
    name?: true
    position?: true
    phone?: true
    address?: true
    joinDate?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type EmployeeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Employee to aggregate.
     */
    where?: EmployeeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Employees to fetch.
     */
    orderBy?: EmployeeOrderByWithRelationInput | EmployeeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EmployeeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Employees from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Employees.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Employees
    **/
    _count?: true | EmployeeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EmployeeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EmployeeMaxAggregateInputType
  }

  export type GetEmployeeAggregateType<T extends EmployeeAggregateArgs> = {
        [P in keyof T & keyof AggregateEmployee]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEmployee[P]>
      : GetScalarType<T[P], AggregateEmployee[P]>
  }




  export type EmployeeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmployeeWhereInput
    orderBy?: EmployeeOrderByWithAggregationInput | EmployeeOrderByWithAggregationInput[]
    by: EmployeeScalarFieldEnum[] | EmployeeScalarFieldEnum
    having?: EmployeeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EmployeeCountAggregateInputType | true
    _min?: EmployeeMinAggregateInputType
    _max?: EmployeeMaxAggregateInputType
  }

  export type EmployeeGroupByOutputType = {
    id: string
    tenantId: string
    userId: string | null
    nip: string | null
    name: string
    position: string
    phone: string | null
    address: string | null
    joinDate: Date | null
    status: string
    createdAt: Date
    updatedAt: Date
    _count: EmployeeCountAggregateOutputType | null
    _min: EmployeeMinAggregateOutputType | null
    _max: EmployeeMaxAggregateOutputType | null
  }

  type GetEmployeeGroupByPayload<T extends EmployeeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EmployeeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EmployeeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EmployeeGroupByOutputType[P]>
            : GetScalarType<T[P], EmployeeGroupByOutputType[P]>
        }
      >
    >


  export type EmployeeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    userId?: boolean
    nip?: boolean
    name?: boolean
    position?: boolean
    phone?: boolean
    address?: boolean
    joinDate?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    payrolls?: boolean | Employee$payrollsArgs<ExtArgs>
    _count?: boolean | EmployeeCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["employee"]>

  export type EmployeeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    userId?: boolean
    nip?: boolean
    name?: boolean
    position?: boolean
    phone?: boolean
    address?: boolean
    joinDate?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["employee"]>

  export type EmployeeSelectScalar = {
    id?: boolean
    tenantId?: boolean
    userId?: boolean
    nip?: boolean
    name?: boolean
    position?: boolean
    phone?: boolean
    address?: boolean
    joinDate?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type EmployeeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    payrolls?: boolean | Employee$payrollsArgs<ExtArgs>
    _count?: boolean | EmployeeCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type EmployeeIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }

  export type $EmployeePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Employee"
    objects: {
      tenant: Prisma.$TenantPayload<ExtArgs>
      payrolls: Prisma.$PayrollPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      tenantId: string
      userId: string | null
      nip: string | null
      name: string
      position: string
      phone: string | null
      address: string | null
      joinDate: Date | null
      status: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["employee"]>
    composites: {}
  }

  type EmployeeGetPayload<S extends boolean | null | undefined | EmployeeDefaultArgs> = $Result.GetResult<Prisma.$EmployeePayload, S>

  type EmployeeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<EmployeeFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: EmployeeCountAggregateInputType | true
    }

  export interface EmployeeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Employee'], meta: { name: 'Employee' } }
    /**
     * Find zero or one Employee that matches the filter.
     * @param {EmployeeFindUniqueArgs} args - Arguments to find a Employee
     * @example
     * // Get one Employee
     * const employee = await prisma.employee.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EmployeeFindUniqueArgs>(args: SelectSubset<T, EmployeeFindUniqueArgs<ExtArgs>>): Prisma__EmployeeClient<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Employee that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {EmployeeFindUniqueOrThrowArgs} args - Arguments to find a Employee
     * @example
     * // Get one Employee
     * const employee = await prisma.employee.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EmployeeFindUniqueOrThrowArgs>(args: SelectSubset<T, EmployeeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EmployeeClient<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Employee that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeFindFirstArgs} args - Arguments to find a Employee
     * @example
     * // Get one Employee
     * const employee = await prisma.employee.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EmployeeFindFirstArgs>(args?: SelectSubset<T, EmployeeFindFirstArgs<ExtArgs>>): Prisma__EmployeeClient<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Employee that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeFindFirstOrThrowArgs} args - Arguments to find a Employee
     * @example
     * // Get one Employee
     * const employee = await prisma.employee.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EmployeeFindFirstOrThrowArgs>(args?: SelectSubset<T, EmployeeFindFirstOrThrowArgs<ExtArgs>>): Prisma__EmployeeClient<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Employees that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Employees
     * const employees = await prisma.employee.findMany()
     * 
     * // Get first 10 Employees
     * const employees = await prisma.employee.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const employeeWithIdOnly = await prisma.employee.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends EmployeeFindManyArgs>(args?: SelectSubset<T, EmployeeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Employee.
     * @param {EmployeeCreateArgs} args - Arguments to create a Employee.
     * @example
     * // Create one Employee
     * const Employee = await prisma.employee.create({
     *   data: {
     *     // ... data to create a Employee
     *   }
     * })
     * 
     */
    create<T extends EmployeeCreateArgs>(args: SelectSubset<T, EmployeeCreateArgs<ExtArgs>>): Prisma__EmployeeClient<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Employees.
     * @param {EmployeeCreateManyArgs} args - Arguments to create many Employees.
     * @example
     * // Create many Employees
     * const employee = await prisma.employee.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EmployeeCreateManyArgs>(args?: SelectSubset<T, EmployeeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Employees and returns the data saved in the database.
     * @param {EmployeeCreateManyAndReturnArgs} args - Arguments to create many Employees.
     * @example
     * // Create many Employees
     * const employee = await prisma.employee.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Employees and only return the `id`
     * const employeeWithIdOnly = await prisma.employee.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends EmployeeCreateManyAndReturnArgs>(args?: SelectSubset<T, EmployeeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Employee.
     * @param {EmployeeDeleteArgs} args - Arguments to delete one Employee.
     * @example
     * // Delete one Employee
     * const Employee = await prisma.employee.delete({
     *   where: {
     *     // ... filter to delete one Employee
     *   }
     * })
     * 
     */
    delete<T extends EmployeeDeleteArgs>(args: SelectSubset<T, EmployeeDeleteArgs<ExtArgs>>): Prisma__EmployeeClient<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Employee.
     * @param {EmployeeUpdateArgs} args - Arguments to update one Employee.
     * @example
     * // Update one Employee
     * const employee = await prisma.employee.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EmployeeUpdateArgs>(args: SelectSubset<T, EmployeeUpdateArgs<ExtArgs>>): Prisma__EmployeeClient<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Employees.
     * @param {EmployeeDeleteManyArgs} args - Arguments to filter Employees to delete.
     * @example
     * // Delete a few Employees
     * const { count } = await prisma.employee.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EmployeeDeleteManyArgs>(args?: SelectSubset<T, EmployeeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Employees.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Employees
     * const employee = await prisma.employee.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EmployeeUpdateManyArgs>(args: SelectSubset<T, EmployeeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Employee.
     * @param {EmployeeUpsertArgs} args - Arguments to update or create a Employee.
     * @example
     * // Update or create a Employee
     * const employee = await prisma.employee.upsert({
     *   create: {
     *     // ... data to create a Employee
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Employee we want to update
     *   }
     * })
     */
    upsert<T extends EmployeeUpsertArgs>(args: SelectSubset<T, EmployeeUpsertArgs<ExtArgs>>): Prisma__EmployeeClient<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Employees.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeCountArgs} args - Arguments to filter Employees to count.
     * @example
     * // Count the number of Employees
     * const count = await prisma.employee.count({
     *   where: {
     *     // ... the filter for the Employees we want to count
     *   }
     * })
    **/
    count<T extends EmployeeCountArgs>(
      args?: Subset<T, EmployeeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EmployeeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Employee.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EmployeeAggregateArgs>(args: Subset<T, EmployeeAggregateArgs>): Prisma.PrismaPromise<GetEmployeeAggregateType<T>>

    /**
     * Group by Employee.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EmployeeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EmployeeGroupByArgs['orderBy'] }
        : { orderBy?: EmployeeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EmployeeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEmployeeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Employee model
   */
  readonly fields: EmployeeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Employee.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EmployeeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    tenant<T extends TenantDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TenantDefaultArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    payrolls<T extends Employee$payrollsArgs<ExtArgs> = {}>(args?: Subset<T, Employee$payrollsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PayrollPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Employee model
   */ 
  interface EmployeeFieldRefs {
    readonly id: FieldRef<"Employee", 'String'>
    readonly tenantId: FieldRef<"Employee", 'String'>
    readonly userId: FieldRef<"Employee", 'String'>
    readonly nip: FieldRef<"Employee", 'String'>
    readonly name: FieldRef<"Employee", 'String'>
    readonly position: FieldRef<"Employee", 'String'>
    readonly phone: FieldRef<"Employee", 'String'>
    readonly address: FieldRef<"Employee", 'String'>
    readonly joinDate: FieldRef<"Employee", 'DateTime'>
    readonly status: FieldRef<"Employee", 'String'>
    readonly createdAt: FieldRef<"Employee", 'DateTime'>
    readonly updatedAt: FieldRef<"Employee", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Employee findUnique
   */
  export type EmployeeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeInclude<ExtArgs> | null
    /**
     * Filter, which Employee to fetch.
     */
    where: EmployeeWhereUniqueInput
  }

  /**
   * Employee findUniqueOrThrow
   */
  export type EmployeeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeInclude<ExtArgs> | null
    /**
     * Filter, which Employee to fetch.
     */
    where: EmployeeWhereUniqueInput
  }

  /**
   * Employee findFirst
   */
  export type EmployeeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeInclude<ExtArgs> | null
    /**
     * Filter, which Employee to fetch.
     */
    where?: EmployeeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Employees to fetch.
     */
    orderBy?: EmployeeOrderByWithRelationInput | EmployeeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Employees.
     */
    cursor?: EmployeeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Employees from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Employees.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Employees.
     */
    distinct?: EmployeeScalarFieldEnum | EmployeeScalarFieldEnum[]
  }

  /**
   * Employee findFirstOrThrow
   */
  export type EmployeeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeInclude<ExtArgs> | null
    /**
     * Filter, which Employee to fetch.
     */
    where?: EmployeeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Employees to fetch.
     */
    orderBy?: EmployeeOrderByWithRelationInput | EmployeeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Employees.
     */
    cursor?: EmployeeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Employees from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Employees.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Employees.
     */
    distinct?: EmployeeScalarFieldEnum | EmployeeScalarFieldEnum[]
  }

  /**
   * Employee findMany
   */
  export type EmployeeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeInclude<ExtArgs> | null
    /**
     * Filter, which Employees to fetch.
     */
    where?: EmployeeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Employees to fetch.
     */
    orderBy?: EmployeeOrderByWithRelationInput | EmployeeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Employees.
     */
    cursor?: EmployeeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Employees from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Employees.
     */
    skip?: number
    distinct?: EmployeeScalarFieldEnum | EmployeeScalarFieldEnum[]
  }

  /**
   * Employee create
   */
  export type EmployeeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeInclude<ExtArgs> | null
    /**
     * The data needed to create a Employee.
     */
    data: XOR<EmployeeCreateInput, EmployeeUncheckedCreateInput>
  }

  /**
   * Employee createMany
   */
  export type EmployeeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Employees.
     */
    data: EmployeeCreateManyInput | EmployeeCreateManyInput[]
  }

  /**
   * Employee createManyAndReturn
   */
  export type EmployeeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Employees.
     */
    data: EmployeeCreateManyInput | EmployeeCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Employee update
   */
  export type EmployeeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeInclude<ExtArgs> | null
    /**
     * The data needed to update a Employee.
     */
    data: XOR<EmployeeUpdateInput, EmployeeUncheckedUpdateInput>
    /**
     * Choose, which Employee to update.
     */
    where: EmployeeWhereUniqueInput
  }

  /**
   * Employee updateMany
   */
  export type EmployeeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Employees.
     */
    data: XOR<EmployeeUpdateManyMutationInput, EmployeeUncheckedUpdateManyInput>
    /**
     * Filter which Employees to update
     */
    where?: EmployeeWhereInput
  }

  /**
   * Employee upsert
   */
  export type EmployeeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeInclude<ExtArgs> | null
    /**
     * The filter to search for the Employee to update in case it exists.
     */
    where: EmployeeWhereUniqueInput
    /**
     * In case the Employee found by the `where` argument doesn't exist, create a new Employee with this data.
     */
    create: XOR<EmployeeCreateInput, EmployeeUncheckedCreateInput>
    /**
     * In case the Employee was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EmployeeUpdateInput, EmployeeUncheckedUpdateInput>
  }

  /**
   * Employee delete
   */
  export type EmployeeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeInclude<ExtArgs> | null
    /**
     * Filter which Employee to delete.
     */
    where: EmployeeWhereUniqueInput
  }

  /**
   * Employee deleteMany
   */
  export type EmployeeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Employees to delete
     */
    where?: EmployeeWhereInput
  }

  /**
   * Employee.payrolls
   */
  export type Employee$payrollsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payroll
     */
    select?: PayrollSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PayrollInclude<ExtArgs> | null
    where?: PayrollWhereInput
    orderBy?: PayrollOrderByWithRelationInput | PayrollOrderByWithRelationInput[]
    cursor?: PayrollWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PayrollScalarFieldEnum | PayrollScalarFieldEnum[]
  }

  /**
   * Employee without action
   */
  export type EmployeeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeInclude<ExtArgs> | null
  }


  /**
   * Model Payroll
   */

  export type AggregatePayroll = {
    _count: PayrollCountAggregateOutputType | null
    _avg: PayrollAvgAggregateOutputType | null
    _sum: PayrollSumAggregateOutputType | null
    _min: PayrollMinAggregateOutputType | null
    _max: PayrollMaxAggregateOutputType | null
  }

  export type PayrollAvgAggregateOutputType = {
    month: number | null
    year: number | null
    baseSalary: number | null
    allowances: number | null
    deductions: number | null
    netAmount: number | null
  }

  export type PayrollSumAggregateOutputType = {
    month: number | null
    year: number | null
    baseSalary: number | null
    allowances: number | null
    deductions: number | null
    netAmount: number | null
  }

  export type PayrollMinAggregateOutputType = {
    id: string | null
    tenantId: string | null
    employeeId: string | null
    month: number | null
    year: number | null
    baseSalary: number | null
    allowances: number | null
    deductions: number | null
    netAmount: number | null
    status: string | null
    paidAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PayrollMaxAggregateOutputType = {
    id: string | null
    tenantId: string | null
    employeeId: string | null
    month: number | null
    year: number | null
    baseSalary: number | null
    allowances: number | null
    deductions: number | null
    netAmount: number | null
    status: string | null
    paidAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PayrollCountAggregateOutputType = {
    id: number
    tenantId: number
    employeeId: number
    month: number
    year: number
    baseSalary: number
    allowances: number
    deductions: number
    netAmount: number
    status: number
    paidAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PayrollAvgAggregateInputType = {
    month?: true
    year?: true
    baseSalary?: true
    allowances?: true
    deductions?: true
    netAmount?: true
  }

  export type PayrollSumAggregateInputType = {
    month?: true
    year?: true
    baseSalary?: true
    allowances?: true
    deductions?: true
    netAmount?: true
  }

  export type PayrollMinAggregateInputType = {
    id?: true
    tenantId?: true
    employeeId?: true
    month?: true
    year?: true
    baseSalary?: true
    allowances?: true
    deductions?: true
    netAmount?: true
    status?: true
    paidAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PayrollMaxAggregateInputType = {
    id?: true
    tenantId?: true
    employeeId?: true
    month?: true
    year?: true
    baseSalary?: true
    allowances?: true
    deductions?: true
    netAmount?: true
    status?: true
    paidAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PayrollCountAggregateInputType = {
    id?: true
    tenantId?: true
    employeeId?: true
    month?: true
    year?: true
    baseSalary?: true
    allowances?: true
    deductions?: true
    netAmount?: true
    status?: true
    paidAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PayrollAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Payroll to aggregate.
     */
    where?: PayrollWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payrolls to fetch.
     */
    orderBy?: PayrollOrderByWithRelationInput | PayrollOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PayrollWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payrolls from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payrolls.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Payrolls
    **/
    _count?: true | PayrollCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PayrollAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PayrollSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PayrollMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PayrollMaxAggregateInputType
  }

  export type GetPayrollAggregateType<T extends PayrollAggregateArgs> = {
        [P in keyof T & keyof AggregatePayroll]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePayroll[P]>
      : GetScalarType<T[P], AggregatePayroll[P]>
  }




  export type PayrollGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PayrollWhereInput
    orderBy?: PayrollOrderByWithAggregationInput | PayrollOrderByWithAggregationInput[]
    by: PayrollScalarFieldEnum[] | PayrollScalarFieldEnum
    having?: PayrollScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PayrollCountAggregateInputType | true
    _avg?: PayrollAvgAggregateInputType
    _sum?: PayrollSumAggregateInputType
    _min?: PayrollMinAggregateInputType
    _max?: PayrollMaxAggregateInputType
  }

  export type PayrollGroupByOutputType = {
    id: string
    tenantId: string
    employeeId: string
    month: number
    year: number
    baseSalary: number
    allowances: number
    deductions: number
    netAmount: number
    status: string
    paidAt: Date | null
    createdAt: Date
    updatedAt: Date
    _count: PayrollCountAggregateOutputType | null
    _avg: PayrollAvgAggregateOutputType | null
    _sum: PayrollSumAggregateOutputType | null
    _min: PayrollMinAggregateOutputType | null
    _max: PayrollMaxAggregateOutputType | null
  }

  type GetPayrollGroupByPayload<T extends PayrollGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PayrollGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PayrollGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PayrollGroupByOutputType[P]>
            : GetScalarType<T[P], PayrollGroupByOutputType[P]>
        }
      >
    >


  export type PayrollSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    employeeId?: boolean
    month?: boolean
    year?: boolean
    baseSalary?: boolean
    allowances?: boolean
    deductions?: boolean
    netAmount?: boolean
    status?: boolean
    paidAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["payroll"]>

  export type PayrollSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    employeeId?: boolean
    month?: boolean
    year?: boolean
    baseSalary?: boolean
    allowances?: boolean
    deductions?: boolean
    netAmount?: boolean
    status?: boolean
    paidAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["payroll"]>

  export type PayrollSelectScalar = {
    id?: boolean
    tenantId?: boolean
    employeeId?: boolean
    month?: boolean
    year?: boolean
    baseSalary?: boolean
    allowances?: boolean
    deductions?: boolean
    netAmount?: boolean
    status?: boolean
    paidAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PayrollInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
  }
  export type PayrollIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
  }

  export type $PayrollPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Payroll"
    objects: {
      tenant: Prisma.$TenantPayload<ExtArgs>
      employee: Prisma.$EmployeePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      tenantId: string
      employeeId: string
      month: number
      year: number
      baseSalary: number
      allowances: number
      deductions: number
      netAmount: number
      status: string
      paidAt: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["payroll"]>
    composites: {}
  }

  type PayrollGetPayload<S extends boolean | null | undefined | PayrollDefaultArgs> = $Result.GetResult<Prisma.$PayrollPayload, S>

  type PayrollCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<PayrollFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PayrollCountAggregateInputType | true
    }

  export interface PayrollDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Payroll'], meta: { name: 'Payroll' } }
    /**
     * Find zero or one Payroll that matches the filter.
     * @param {PayrollFindUniqueArgs} args - Arguments to find a Payroll
     * @example
     * // Get one Payroll
     * const payroll = await prisma.payroll.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PayrollFindUniqueArgs>(args: SelectSubset<T, PayrollFindUniqueArgs<ExtArgs>>): Prisma__PayrollClient<$Result.GetResult<Prisma.$PayrollPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Payroll that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {PayrollFindUniqueOrThrowArgs} args - Arguments to find a Payroll
     * @example
     * // Get one Payroll
     * const payroll = await prisma.payroll.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PayrollFindUniqueOrThrowArgs>(args: SelectSubset<T, PayrollFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PayrollClient<$Result.GetResult<Prisma.$PayrollPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Payroll that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PayrollFindFirstArgs} args - Arguments to find a Payroll
     * @example
     * // Get one Payroll
     * const payroll = await prisma.payroll.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PayrollFindFirstArgs>(args?: SelectSubset<T, PayrollFindFirstArgs<ExtArgs>>): Prisma__PayrollClient<$Result.GetResult<Prisma.$PayrollPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Payroll that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PayrollFindFirstOrThrowArgs} args - Arguments to find a Payroll
     * @example
     * // Get one Payroll
     * const payroll = await prisma.payroll.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PayrollFindFirstOrThrowArgs>(args?: SelectSubset<T, PayrollFindFirstOrThrowArgs<ExtArgs>>): Prisma__PayrollClient<$Result.GetResult<Prisma.$PayrollPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Payrolls that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PayrollFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Payrolls
     * const payrolls = await prisma.payroll.findMany()
     * 
     * // Get first 10 Payrolls
     * const payrolls = await prisma.payroll.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const payrollWithIdOnly = await prisma.payroll.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PayrollFindManyArgs>(args?: SelectSubset<T, PayrollFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PayrollPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Payroll.
     * @param {PayrollCreateArgs} args - Arguments to create a Payroll.
     * @example
     * // Create one Payroll
     * const Payroll = await prisma.payroll.create({
     *   data: {
     *     // ... data to create a Payroll
     *   }
     * })
     * 
     */
    create<T extends PayrollCreateArgs>(args: SelectSubset<T, PayrollCreateArgs<ExtArgs>>): Prisma__PayrollClient<$Result.GetResult<Prisma.$PayrollPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Payrolls.
     * @param {PayrollCreateManyArgs} args - Arguments to create many Payrolls.
     * @example
     * // Create many Payrolls
     * const payroll = await prisma.payroll.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PayrollCreateManyArgs>(args?: SelectSubset<T, PayrollCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Payrolls and returns the data saved in the database.
     * @param {PayrollCreateManyAndReturnArgs} args - Arguments to create many Payrolls.
     * @example
     * // Create many Payrolls
     * const payroll = await prisma.payroll.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Payrolls and only return the `id`
     * const payrollWithIdOnly = await prisma.payroll.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PayrollCreateManyAndReturnArgs>(args?: SelectSubset<T, PayrollCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PayrollPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Payroll.
     * @param {PayrollDeleteArgs} args - Arguments to delete one Payroll.
     * @example
     * // Delete one Payroll
     * const Payroll = await prisma.payroll.delete({
     *   where: {
     *     // ... filter to delete one Payroll
     *   }
     * })
     * 
     */
    delete<T extends PayrollDeleteArgs>(args: SelectSubset<T, PayrollDeleteArgs<ExtArgs>>): Prisma__PayrollClient<$Result.GetResult<Prisma.$PayrollPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Payroll.
     * @param {PayrollUpdateArgs} args - Arguments to update one Payroll.
     * @example
     * // Update one Payroll
     * const payroll = await prisma.payroll.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PayrollUpdateArgs>(args: SelectSubset<T, PayrollUpdateArgs<ExtArgs>>): Prisma__PayrollClient<$Result.GetResult<Prisma.$PayrollPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Payrolls.
     * @param {PayrollDeleteManyArgs} args - Arguments to filter Payrolls to delete.
     * @example
     * // Delete a few Payrolls
     * const { count } = await prisma.payroll.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PayrollDeleteManyArgs>(args?: SelectSubset<T, PayrollDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Payrolls.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PayrollUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Payrolls
     * const payroll = await prisma.payroll.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PayrollUpdateManyArgs>(args: SelectSubset<T, PayrollUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Payroll.
     * @param {PayrollUpsertArgs} args - Arguments to update or create a Payroll.
     * @example
     * // Update or create a Payroll
     * const payroll = await prisma.payroll.upsert({
     *   create: {
     *     // ... data to create a Payroll
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Payroll we want to update
     *   }
     * })
     */
    upsert<T extends PayrollUpsertArgs>(args: SelectSubset<T, PayrollUpsertArgs<ExtArgs>>): Prisma__PayrollClient<$Result.GetResult<Prisma.$PayrollPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Payrolls.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PayrollCountArgs} args - Arguments to filter Payrolls to count.
     * @example
     * // Count the number of Payrolls
     * const count = await prisma.payroll.count({
     *   where: {
     *     // ... the filter for the Payrolls we want to count
     *   }
     * })
    **/
    count<T extends PayrollCountArgs>(
      args?: Subset<T, PayrollCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PayrollCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Payroll.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PayrollAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PayrollAggregateArgs>(args: Subset<T, PayrollAggregateArgs>): Prisma.PrismaPromise<GetPayrollAggregateType<T>>

    /**
     * Group by Payroll.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PayrollGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PayrollGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PayrollGroupByArgs['orderBy'] }
        : { orderBy?: PayrollGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PayrollGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPayrollGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Payroll model
   */
  readonly fields: PayrollFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Payroll.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PayrollClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    tenant<T extends TenantDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TenantDefaultArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    employee<T extends EmployeeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EmployeeDefaultArgs<ExtArgs>>): Prisma__EmployeeClient<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Payroll model
   */ 
  interface PayrollFieldRefs {
    readonly id: FieldRef<"Payroll", 'String'>
    readonly tenantId: FieldRef<"Payroll", 'String'>
    readonly employeeId: FieldRef<"Payroll", 'String'>
    readonly month: FieldRef<"Payroll", 'Int'>
    readonly year: FieldRef<"Payroll", 'Int'>
    readonly baseSalary: FieldRef<"Payroll", 'Float'>
    readonly allowances: FieldRef<"Payroll", 'Float'>
    readonly deductions: FieldRef<"Payroll", 'Float'>
    readonly netAmount: FieldRef<"Payroll", 'Float'>
    readonly status: FieldRef<"Payroll", 'String'>
    readonly paidAt: FieldRef<"Payroll", 'DateTime'>
    readonly createdAt: FieldRef<"Payroll", 'DateTime'>
    readonly updatedAt: FieldRef<"Payroll", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Payroll findUnique
   */
  export type PayrollFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payroll
     */
    select?: PayrollSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PayrollInclude<ExtArgs> | null
    /**
     * Filter, which Payroll to fetch.
     */
    where: PayrollWhereUniqueInput
  }

  /**
   * Payroll findUniqueOrThrow
   */
  export type PayrollFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payroll
     */
    select?: PayrollSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PayrollInclude<ExtArgs> | null
    /**
     * Filter, which Payroll to fetch.
     */
    where: PayrollWhereUniqueInput
  }

  /**
   * Payroll findFirst
   */
  export type PayrollFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payroll
     */
    select?: PayrollSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PayrollInclude<ExtArgs> | null
    /**
     * Filter, which Payroll to fetch.
     */
    where?: PayrollWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payrolls to fetch.
     */
    orderBy?: PayrollOrderByWithRelationInput | PayrollOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Payrolls.
     */
    cursor?: PayrollWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payrolls from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payrolls.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Payrolls.
     */
    distinct?: PayrollScalarFieldEnum | PayrollScalarFieldEnum[]
  }

  /**
   * Payroll findFirstOrThrow
   */
  export type PayrollFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payroll
     */
    select?: PayrollSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PayrollInclude<ExtArgs> | null
    /**
     * Filter, which Payroll to fetch.
     */
    where?: PayrollWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payrolls to fetch.
     */
    orderBy?: PayrollOrderByWithRelationInput | PayrollOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Payrolls.
     */
    cursor?: PayrollWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payrolls from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payrolls.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Payrolls.
     */
    distinct?: PayrollScalarFieldEnum | PayrollScalarFieldEnum[]
  }

  /**
   * Payroll findMany
   */
  export type PayrollFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payroll
     */
    select?: PayrollSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PayrollInclude<ExtArgs> | null
    /**
     * Filter, which Payrolls to fetch.
     */
    where?: PayrollWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payrolls to fetch.
     */
    orderBy?: PayrollOrderByWithRelationInput | PayrollOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Payrolls.
     */
    cursor?: PayrollWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payrolls from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payrolls.
     */
    skip?: number
    distinct?: PayrollScalarFieldEnum | PayrollScalarFieldEnum[]
  }

  /**
   * Payroll create
   */
  export type PayrollCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payroll
     */
    select?: PayrollSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PayrollInclude<ExtArgs> | null
    /**
     * The data needed to create a Payroll.
     */
    data: XOR<PayrollCreateInput, PayrollUncheckedCreateInput>
  }

  /**
   * Payroll createMany
   */
  export type PayrollCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Payrolls.
     */
    data: PayrollCreateManyInput | PayrollCreateManyInput[]
  }

  /**
   * Payroll createManyAndReturn
   */
  export type PayrollCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payroll
     */
    select?: PayrollSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Payrolls.
     */
    data: PayrollCreateManyInput | PayrollCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PayrollIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Payroll update
   */
  export type PayrollUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payroll
     */
    select?: PayrollSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PayrollInclude<ExtArgs> | null
    /**
     * The data needed to update a Payroll.
     */
    data: XOR<PayrollUpdateInput, PayrollUncheckedUpdateInput>
    /**
     * Choose, which Payroll to update.
     */
    where: PayrollWhereUniqueInput
  }

  /**
   * Payroll updateMany
   */
  export type PayrollUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Payrolls.
     */
    data: XOR<PayrollUpdateManyMutationInput, PayrollUncheckedUpdateManyInput>
    /**
     * Filter which Payrolls to update
     */
    where?: PayrollWhereInput
  }

  /**
   * Payroll upsert
   */
  export type PayrollUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payroll
     */
    select?: PayrollSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PayrollInclude<ExtArgs> | null
    /**
     * The filter to search for the Payroll to update in case it exists.
     */
    where: PayrollWhereUniqueInput
    /**
     * In case the Payroll found by the `where` argument doesn't exist, create a new Payroll with this data.
     */
    create: XOR<PayrollCreateInput, PayrollUncheckedCreateInput>
    /**
     * In case the Payroll was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PayrollUpdateInput, PayrollUncheckedUpdateInput>
  }

  /**
   * Payroll delete
   */
  export type PayrollDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payroll
     */
    select?: PayrollSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PayrollInclude<ExtArgs> | null
    /**
     * Filter which Payroll to delete.
     */
    where: PayrollWhereUniqueInput
  }

  /**
   * Payroll deleteMany
   */
  export type PayrollDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Payrolls to delete
     */
    where?: PayrollWhereInput
  }

  /**
   * Payroll without action
   */
  export type PayrollDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payroll
     */
    select?: PayrollSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PayrollInclude<ExtArgs> | null
  }


  /**
   * Model AcademicSchedule
   */

  export type AggregateAcademicSchedule = {
    _count: AcademicScheduleCountAggregateOutputType | null
    _avg: AcademicScheduleAvgAggregateOutputType | null
    _sum: AcademicScheduleSumAggregateOutputType | null
    _min: AcademicScheduleMinAggregateOutputType | null
    _max: AcademicScheduleMaxAggregateOutputType | null
  }

  export type AcademicScheduleAvgAggregateOutputType = {
    dayOfWeek: number | null
  }

  export type AcademicScheduleSumAggregateOutputType = {
    dayOfWeek: number | null
  }

  export type AcademicScheduleMinAggregateOutputType = {
    id: string | null
    tenantId: string | null
    subject: string | null
    teacherId: string | null
    kelas: string | null
    dayOfWeek: number | null
    startTime: string | null
    endTime: string | null
    room: string | null
    createdAt: Date | null
  }

  export type AcademicScheduleMaxAggregateOutputType = {
    id: string | null
    tenantId: string | null
    subject: string | null
    teacherId: string | null
    kelas: string | null
    dayOfWeek: number | null
    startTime: string | null
    endTime: string | null
    room: string | null
    createdAt: Date | null
  }

  export type AcademicScheduleCountAggregateOutputType = {
    id: number
    tenantId: number
    subject: number
    teacherId: number
    kelas: number
    dayOfWeek: number
    startTime: number
    endTime: number
    room: number
    createdAt: number
    _all: number
  }


  export type AcademicScheduleAvgAggregateInputType = {
    dayOfWeek?: true
  }

  export type AcademicScheduleSumAggregateInputType = {
    dayOfWeek?: true
  }

  export type AcademicScheduleMinAggregateInputType = {
    id?: true
    tenantId?: true
    subject?: true
    teacherId?: true
    kelas?: true
    dayOfWeek?: true
    startTime?: true
    endTime?: true
    room?: true
    createdAt?: true
  }

  export type AcademicScheduleMaxAggregateInputType = {
    id?: true
    tenantId?: true
    subject?: true
    teacherId?: true
    kelas?: true
    dayOfWeek?: true
    startTime?: true
    endTime?: true
    room?: true
    createdAt?: true
  }

  export type AcademicScheduleCountAggregateInputType = {
    id?: true
    tenantId?: true
    subject?: true
    teacherId?: true
    kelas?: true
    dayOfWeek?: true
    startTime?: true
    endTime?: true
    room?: true
    createdAt?: true
    _all?: true
  }

  export type AcademicScheduleAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AcademicSchedule to aggregate.
     */
    where?: AcademicScheduleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AcademicSchedules to fetch.
     */
    orderBy?: AcademicScheduleOrderByWithRelationInput | AcademicScheduleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AcademicScheduleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AcademicSchedules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AcademicSchedules.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AcademicSchedules
    **/
    _count?: true | AcademicScheduleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AcademicScheduleAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AcademicScheduleSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AcademicScheduleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AcademicScheduleMaxAggregateInputType
  }

  export type GetAcademicScheduleAggregateType<T extends AcademicScheduleAggregateArgs> = {
        [P in keyof T & keyof AggregateAcademicSchedule]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAcademicSchedule[P]>
      : GetScalarType<T[P], AggregateAcademicSchedule[P]>
  }




  export type AcademicScheduleGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AcademicScheduleWhereInput
    orderBy?: AcademicScheduleOrderByWithAggregationInput | AcademicScheduleOrderByWithAggregationInput[]
    by: AcademicScheduleScalarFieldEnum[] | AcademicScheduleScalarFieldEnum
    having?: AcademicScheduleScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AcademicScheduleCountAggregateInputType | true
    _avg?: AcademicScheduleAvgAggregateInputType
    _sum?: AcademicScheduleSumAggregateInputType
    _min?: AcademicScheduleMinAggregateInputType
    _max?: AcademicScheduleMaxAggregateInputType
  }

  export type AcademicScheduleGroupByOutputType = {
    id: string
    tenantId: string
    subject: string
    teacherId: string
    kelas: string
    dayOfWeek: number
    startTime: string
    endTime: string
    room: string | null
    createdAt: Date
    _count: AcademicScheduleCountAggregateOutputType | null
    _avg: AcademicScheduleAvgAggregateOutputType | null
    _sum: AcademicScheduleSumAggregateOutputType | null
    _min: AcademicScheduleMinAggregateOutputType | null
    _max: AcademicScheduleMaxAggregateOutputType | null
  }

  type GetAcademicScheduleGroupByPayload<T extends AcademicScheduleGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AcademicScheduleGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AcademicScheduleGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AcademicScheduleGroupByOutputType[P]>
            : GetScalarType<T[P], AcademicScheduleGroupByOutputType[P]>
        }
      >
    >


  export type AcademicScheduleSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    subject?: boolean
    teacherId?: boolean
    kelas?: boolean
    dayOfWeek?: boolean
    startTime?: boolean
    endTime?: boolean
    room?: boolean
    createdAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["academicSchedule"]>

  export type AcademicScheduleSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    subject?: boolean
    teacherId?: boolean
    kelas?: boolean
    dayOfWeek?: boolean
    startTime?: boolean
    endTime?: boolean
    room?: boolean
    createdAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["academicSchedule"]>

  export type AcademicScheduleSelectScalar = {
    id?: boolean
    tenantId?: boolean
    subject?: boolean
    teacherId?: boolean
    kelas?: boolean
    dayOfWeek?: boolean
    startTime?: boolean
    endTime?: boolean
    room?: boolean
    createdAt?: boolean
  }

  export type AcademicScheduleInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }
  export type AcademicScheduleIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }

  export type $AcademicSchedulePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AcademicSchedule"
    objects: {
      tenant: Prisma.$TenantPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      tenantId: string
      subject: string
      teacherId: string
      kelas: string
      dayOfWeek: number
      startTime: string
      endTime: string
      room: string | null
      createdAt: Date
    }, ExtArgs["result"]["academicSchedule"]>
    composites: {}
  }

  type AcademicScheduleGetPayload<S extends boolean | null | undefined | AcademicScheduleDefaultArgs> = $Result.GetResult<Prisma.$AcademicSchedulePayload, S>

  type AcademicScheduleCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<AcademicScheduleFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: AcademicScheduleCountAggregateInputType | true
    }

  export interface AcademicScheduleDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AcademicSchedule'], meta: { name: 'AcademicSchedule' } }
    /**
     * Find zero or one AcademicSchedule that matches the filter.
     * @param {AcademicScheduleFindUniqueArgs} args - Arguments to find a AcademicSchedule
     * @example
     * // Get one AcademicSchedule
     * const academicSchedule = await prisma.academicSchedule.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AcademicScheduleFindUniqueArgs>(args: SelectSubset<T, AcademicScheduleFindUniqueArgs<ExtArgs>>): Prisma__AcademicScheduleClient<$Result.GetResult<Prisma.$AcademicSchedulePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one AcademicSchedule that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {AcademicScheduleFindUniqueOrThrowArgs} args - Arguments to find a AcademicSchedule
     * @example
     * // Get one AcademicSchedule
     * const academicSchedule = await prisma.academicSchedule.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AcademicScheduleFindUniqueOrThrowArgs>(args: SelectSubset<T, AcademicScheduleFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AcademicScheduleClient<$Result.GetResult<Prisma.$AcademicSchedulePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first AcademicSchedule that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AcademicScheduleFindFirstArgs} args - Arguments to find a AcademicSchedule
     * @example
     * // Get one AcademicSchedule
     * const academicSchedule = await prisma.academicSchedule.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AcademicScheduleFindFirstArgs>(args?: SelectSubset<T, AcademicScheduleFindFirstArgs<ExtArgs>>): Prisma__AcademicScheduleClient<$Result.GetResult<Prisma.$AcademicSchedulePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first AcademicSchedule that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AcademicScheduleFindFirstOrThrowArgs} args - Arguments to find a AcademicSchedule
     * @example
     * // Get one AcademicSchedule
     * const academicSchedule = await prisma.academicSchedule.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AcademicScheduleFindFirstOrThrowArgs>(args?: SelectSubset<T, AcademicScheduleFindFirstOrThrowArgs<ExtArgs>>): Prisma__AcademicScheduleClient<$Result.GetResult<Prisma.$AcademicSchedulePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more AcademicSchedules that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AcademicScheduleFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AcademicSchedules
     * const academicSchedules = await prisma.academicSchedule.findMany()
     * 
     * // Get first 10 AcademicSchedules
     * const academicSchedules = await prisma.academicSchedule.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const academicScheduleWithIdOnly = await prisma.academicSchedule.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AcademicScheduleFindManyArgs>(args?: SelectSubset<T, AcademicScheduleFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AcademicSchedulePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a AcademicSchedule.
     * @param {AcademicScheduleCreateArgs} args - Arguments to create a AcademicSchedule.
     * @example
     * // Create one AcademicSchedule
     * const AcademicSchedule = await prisma.academicSchedule.create({
     *   data: {
     *     // ... data to create a AcademicSchedule
     *   }
     * })
     * 
     */
    create<T extends AcademicScheduleCreateArgs>(args: SelectSubset<T, AcademicScheduleCreateArgs<ExtArgs>>): Prisma__AcademicScheduleClient<$Result.GetResult<Prisma.$AcademicSchedulePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many AcademicSchedules.
     * @param {AcademicScheduleCreateManyArgs} args - Arguments to create many AcademicSchedules.
     * @example
     * // Create many AcademicSchedules
     * const academicSchedule = await prisma.academicSchedule.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AcademicScheduleCreateManyArgs>(args?: SelectSubset<T, AcademicScheduleCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AcademicSchedules and returns the data saved in the database.
     * @param {AcademicScheduleCreateManyAndReturnArgs} args - Arguments to create many AcademicSchedules.
     * @example
     * // Create many AcademicSchedules
     * const academicSchedule = await prisma.academicSchedule.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AcademicSchedules and only return the `id`
     * const academicScheduleWithIdOnly = await prisma.academicSchedule.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AcademicScheduleCreateManyAndReturnArgs>(args?: SelectSubset<T, AcademicScheduleCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AcademicSchedulePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a AcademicSchedule.
     * @param {AcademicScheduleDeleteArgs} args - Arguments to delete one AcademicSchedule.
     * @example
     * // Delete one AcademicSchedule
     * const AcademicSchedule = await prisma.academicSchedule.delete({
     *   where: {
     *     // ... filter to delete one AcademicSchedule
     *   }
     * })
     * 
     */
    delete<T extends AcademicScheduleDeleteArgs>(args: SelectSubset<T, AcademicScheduleDeleteArgs<ExtArgs>>): Prisma__AcademicScheduleClient<$Result.GetResult<Prisma.$AcademicSchedulePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one AcademicSchedule.
     * @param {AcademicScheduleUpdateArgs} args - Arguments to update one AcademicSchedule.
     * @example
     * // Update one AcademicSchedule
     * const academicSchedule = await prisma.academicSchedule.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AcademicScheduleUpdateArgs>(args: SelectSubset<T, AcademicScheduleUpdateArgs<ExtArgs>>): Prisma__AcademicScheduleClient<$Result.GetResult<Prisma.$AcademicSchedulePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more AcademicSchedules.
     * @param {AcademicScheduleDeleteManyArgs} args - Arguments to filter AcademicSchedules to delete.
     * @example
     * // Delete a few AcademicSchedules
     * const { count } = await prisma.academicSchedule.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AcademicScheduleDeleteManyArgs>(args?: SelectSubset<T, AcademicScheduleDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AcademicSchedules.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AcademicScheduleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AcademicSchedules
     * const academicSchedule = await prisma.academicSchedule.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AcademicScheduleUpdateManyArgs>(args: SelectSubset<T, AcademicScheduleUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one AcademicSchedule.
     * @param {AcademicScheduleUpsertArgs} args - Arguments to update or create a AcademicSchedule.
     * @example
     * // Update or create a AcademicSchedule
     * const academicSchedule = await prisma.academicSchedule.upsert({
     *   create: {
     *     // ... data to create a AcademicSchedule
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AcademicSchedule we want to update
     *   }
     * })
     */
    upsert<T extends AcademicScheduleUpsertArgs>(args: SelectSubset<T, AcademicScheduleUpsertArgs<ExtArgs>>): Prisma__AcademicScheduleClient<$Result.GetResult<Prisma.$AcademicSchedulePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of AcademicSchedules.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AcademicScheduleCountArgs} args - Arguments to filter AcademicSchedules to count.
     * @example
     * // Count the number of AcademicSchedules
     * const count = await prisma.academicSchedule.count({
     *   where: {
     *     // ... the filter for the AcademicSchedules we want to count
     *   }
     * })
    **/
    count<T extends AcademicScheduleCountArgs>(
      args?: Subset<T, AcademicScheduleCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AcademicScheduleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AcademicSchedule.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AcademicScheduleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AcademicScheduleAggregateArgs>(args: Subset<T, AcademicScheduleAggregateArgs>): Prisma.PrismaPromise<GetAcademicScheduleAggregateType<T>>

    /**
     * Group by AcademicSchedule.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AcademicScheduleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AcademicScheduleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AcademicScheduleGroupByArgs['orderBy'] }
        : { orderBy?: AcademicScheduleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AcademicScheduleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAcademicScheduleGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AcademicSchedule model
   */
  readonly fields: AcademicScheduleFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AcademicSchedule.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AcademicScheduleClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    tenant<T extends TenantDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TenantDefaultArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AcademicSchedule model
   */ 
  interface AcademicScheduleFieldRefs {
    readonly id: FieldRef<"AcademicSchedule", 'String'>
    readonly tenantId: FieldRef<"AcademicSchedule", 'String'>
    readonly subject: FieldRef<"AcademicSchedule", 'String'>
    readonly teacherId: FieldRef<"AcademicSchedule", 'String'>
    readonly kelas: FieldRef<"AcademicSchedule", 'String'>
    readonly dayOfWeek: FieldRef<"AcademicSchedule", 'Int'>
    readonly startTime: FieldRef<"AcademicSchedule", 'String'>
    readonly endTime: FieldRef<"AcademicSchedule", 'String'>
    readonly room: FieldRef<"AcademicSchedule", 'String'>
    readonly createdAt: FieldRef<"AcademicSchedule", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AcademicSchedule findUnique
   */
  export type AcademicScheduleFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AcademicSchedule
     */
    select?: AcademicScheduleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AcademicScheduleInclude<ExtArgs> | null
    /**
     * Filter, which AcademicSchedule to fetch.
     */
    where: AcademicScheduleWhereUniqueInput
  }

  /**
   * AcademicSchedule findUniqueOrThrow
   */
  export type AcademicScheduleFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AcademicSchedule
     */
    select?: AcademicScheduleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AcademicScheduleInclude<ExtArgs> | null
    /**
     * Filter, which AcademicSchedule to fetch.
     */
    where: AcademicScheduleWhereUniqueInput
  }

  /**
   * AcademicSchedule findFirst
   */
  export type AcademicScheduleFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AcademicSchedule
     */
    select?: AcademicScheduleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AcademicScheduleInclude<ExtArgs> | null
    /**
     * Filter, which AcademicSchedule to fetch.
     */
    where?: AcademicScheduleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AcademicSchedules to fetch.
     */
    orderBy?: AcademicScheduleOrderByWithRelationInput | AcademicScheduleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AcademicSchedules.
     */
    cursor?: AcademicScheduleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AcademicSchedules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AcademicSchedules.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AcademicSchedules.
     */
    distinct?: AcademicScheduleScalarFieldEnum | AcademicScheduleScalarFieldEnum[]
  }

  /**
   * AcademicSchedule findFirstOrThrow
   */
  export type AcademicScheduleFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AcademicSchedule
     */
    select?: AcademicScheduleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AcademicScheduleInclude<ExtArgs> | null
    /**
     * Filter, which AcademicSchedule to fetch.
     */
    where?: AcademicScheduleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AcademicSchedules to fetch.
     */
    orderBy?: AcademicScheduleOrderByWithRelationInput | AcademicScheduleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AcademicSchedules.
     */
    cursor?: AcademicScheduleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AcademicSchedules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AcademicSchedules.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AcademicSchedules.
     */
    distinct?: AcademicScheduleScalarFieldEnum | AcademicScheduleScalarFieldEnum[]
  }

  /**
   * AcademicSchedule findMany
   */
  export type AcademicScheduleFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AcademicSchedule
     */
    select?: AcademicScheduleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AcademicScheduleInclude<ExtArgs> | null
    /**
     * Filter, which AcademicSchedules to fetch.
     */
    where?: AcademicScheduleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AcademicSchedules to fetch.
     */
    orderBy?: AcademicScheduleOrderByWithRelationInput | AcademicScheduleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AcademicSchedules.
     */
    cursor?: AcademicScheduleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AcademicSchedules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AcademicSchedules.
     */
    skip?: number
    distinct?: AcademicScheduleScalarFieldEnum | AcademicScheduleScalarFieldEnum[]
  }

  /**
   * AcademicSchedule create
   */
  export type AcademicScheduleCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AcademicSchedule
     */
    select?: AcademicScheduleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AcademicScheduleInclude<ExtArgs> | null
    /**
     * The data needed to create a AcademicSchedule.
     */
    data: XOR<AcademicScheduleCreateInput, AcademicScheduleUncheckedCreateInput>
  }

  /**
   * AcademicSchedule createMany
   */
  export type AcademicScheduleCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AcademicSchedules.
     */
    data: AcademicScheduleCreateManyInput | AcademicScheduleCreateManyInput[]
  }

  /**
   * AcademicSchedule createManyAndReturn
   */
  export type AcademicScheduleCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AcademicSchedule
     */
    select?: AcademicScheduleSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many AcademicSchedules.
     */
    data: AcademicScheduleCreateManyInput | AcademicScheduleCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AcademicScheduleIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AcademicSchedule update
   */
  export type AcademicScheduleUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AcademicSchedule
     */
    select?: AcademicScheduleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AcademicScheduleInclude<ExtArgs> | null
    /**
     * The data needed to update a AcademicSchedule.
     */
    data: XOR<AcademicScheduleUpdateInput, AcademicScheduleUncheckedUpdateInput>
    /**
     * Choose, which AcademicSchedule to update.
     */
    where: AcademicScheduleWhereUniqueInput
  }

  /**
   * AcademicSchedule updateMany
   */
  export type AcademicScheduleUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AcademicSchedules.
     */
    data: XOR<AcademicScheduleUpdateManyMutationInput, AcademicScheduleUncheckedUpdateManyInput>
    /**
     * Filter which AcademicSchedules to update
     */
    where?: AcademicScheduleWhereInput
  }

  /**
   * AcademicSchedule upsert
   */
  export type AcademicScheduleUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AcademicSchedule
     */
    select?: AcademicScheduleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AcademicScheduleInclude<ExtArgs> | null
    /**
     * The filter to search for the AcademicSchedule to update in case it exists.
     */
    where: AcademicScheduleWhereUniqueInput
    /**
     * In case the AcademicSchedule found by the `where` argument doesn't exist, create a new AcademicSchedule with this data.
     */
    create: XOR<AcademicScheduleCreateInput, AcademicScheduleUncheckedCreateInput>
    /**
     * In case the AcademicSchedule was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AcademicScheduleUpdateInput, AcademicScheduleUncheckedUpdateInput>
  }

  /**
   * AcademicSchedule delete
   */
  export type AcademicScheduleDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AcademicSchedule
     */
    select?: AcademicScheduleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AcademicScheduleInclude<ExtArgs> | null
    /**
     * Filter which AcademicSchedule to delete.
     */
    where: AcademicScheduleWhereUniqueInput
  }

  /**
   * AcademicSchedule deleteMany
   */
  export type AcademicScheduleDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AcademicSchedules to delete
     */
    where?: AcademicScheduleWhereInput
  }

  /**
   * AcademicSchedule without action
   */
  export type AcademicScheduleDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AcademicSchedule
     */
    select?: AcademicScheduleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AcademicScheduleInclude<ExtArgs> | null
  }


  /**
   * Model Attendance
   */

  export type AggregateAttendance = {
    _count: AttendanceCountAggregateOutputType | null
    _min: AttendanceMinAggregateOutputType | null
    _max: AttendanceMaxAggregateOutputType | null
  }

  export type AttendanceMinAggregateOutputType = {
    id: string | null
    tenantId: string | null
    santriId: string | null
    scheduleId: string | null
    date: Date | null
    status: string | null
    notes: string | null
    recordedBy: string | null
    createdAt: Date | null
  }

  export type AttendanceMaxAggregateOutputType = {
    id: string | null
    tenantId: string | null
    santriId: string | null
    scheduleId: string | null
    date: Date | null
    status: string | null
    notes: string | null
    recordedBy: string | null
    createdAt: Date | null
  }

  export type AttendanceCountAggregateOutputType = {
    id: number
    tenantId: number
    santriId: number
    scheduleId: number
    date: number
    status: number
    notes: number
    recordedBy: number
    createdAt: number
    _all: number
  }


  export type AttendanceMinAggregateInputType = {
    id?: true
    tenantId?: true
    santriId?: true
    scheduleId?: true
    date?: true
    status?: true
    notes?: true
    recordedBy?: true
    createdAt?: true
  }

  export type AttendanceMaxAggregateInputType = {
    id?: true
    tenantId?: true
    santriId?: true
    scheduleId?: true
    date?: true
    status?: true
    notes?: true
    recordedBy?: true
    createdAt?: true
  }

  export type AttendanceCountAggregateInputType = {
    id?: true
    tenantId?: true
    santriId?: true
    scheduleId?: true
    date?: true
    status?: true
    notes?: true
    recordedBy?: true
    createdAt?: true
    _all?: true
  }

  export type AttendanceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Attendance to aggregate.
     */
    where?: AttendanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Attendances to fetch.
     */
    orderBy?: AttendanceOrderByWithRelationInput | AttendanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AttendanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Attendances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Attendances.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Attendances
    **/
    _count?: true | AttendanceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AttendanceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AttendanceMaxAggregateInputType
  }

  export type GetAttendanceAggregateType<T extends AttendanceAggregateArgs> = {
        [P in keyof T & keyof AggregateAttendance]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAttendance[P]>
      : GetScalarType<T[P], AggregateAttendance[P]>
  }




  export type AttendanceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AttendanceWhereInput
    orderBy?: AttendanceOrderByWithAggregationInput | AttendanceOrderByWithAggregationInput[]
    by: AttendanceScalarFieldEnum[] | AttendanceScalarFieldEnum
    having?: AttendanceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AttendanceCountAggregateInputType | true
    _min?: AttendanceMinAggregateInputType
    _max?: AttendanceMaxAggregateInputType
  }

  export type AttendanceGroupByOutputType = {
    id: string
    tenantId: string
    santriId: string
    scheduleId: string | null
    date: Date
    status: string
    notes: string | null
    recordedBy: string | null
    createdAt: Date
    _count: AttendanceCountAggregateOutputType | null
    _min: AttendanceMinAggregateOutputType | null
    _max: AttendanceMaxAggregateOutputType | null
  }

  type GetAttendanceGroupByPayload<T extends AttendanceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AttendanceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AttendanceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AttendanceGroupByOutputType[P]>
            : GetScalarType<T[P], AttendanceGroupByOutputType[P]>
        }
      >
    >


  export type AttendanceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    santriId?: boolean
    scheduleId?: boolean
    date?: boolean
    status?: boolean
    notes?: boolean
    recordedBy?: boolean
    createdAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    santri?: boolean | SantriDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["attendance"]>

  export type AttendanceSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    santriId?: boolean
    scheduleId?: boolean
    date?: boolean
    status?: boolean
    notes?: boolean
    recordedBy?: boolean
    createdAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    santri?: boolean | SantriDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["attendance"]>

  export type AttendanceSelectScalar = {
    id?: boolean
    tenantId?: boolean
    santriId?: boolean
    scheduleId?: boolean
    date?: boolean
    status?: boolean
    notes?: boolean
    recordedBy?: boolean
    createdAt?: boolean
  }

  export type AttendanceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    santri?: boolean | SantriDefaultArgs<ExtArgs>
  }
  export type AttendanceIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    santri?: boolean | SantriDefaultArgs<ExtArgs>
  }

  export type $AttendancePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Attendance"
    objects: {
      tenant: Prisma.$TenantPayload<ExtArgs>
      santri: Prisma.$SantriPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      tenantId: string
      santriId: string
      scheduleId: string | null
      date: Date
      status: string
      notes: string | null
      recordedBy: string | null
      createdAt: Date
    }, ExtArgs["result"]["attendance"]>
    composites: {}
  }

  type AttendanceGetPayload<S extends boolean | null | undefined | AttendanceDefaultArgs> = $Result.GetResult<Prisma.$AttendancePayload, S>

  type AttendanceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<AttendanceFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: AttendanceCountAggregateInputType | true
    }

  export interface AttendanceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Attendance'], meta: { name: 'Attendance' } }
    /**
     * Find zero or one Attendance that matches the filter.
     * @param {AttendanceFindUniqueArgs} args - Arguments to find a Attendance
     * @example
     * // Get one Attendance
     * const attendance = await prisma.attendance.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AttendanceFindUniqueArgs>(args: SelectSubset<T, AttendanceFindUniqueArgs<ExtArgs>>): Prisma__AttendanceClient<$Result.GetResult<Prisma.$AttendancePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Attendance that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {AttendanceFindUniqueOrThrowArgs} args - Arguments to find a Attendance
     * @example
     * // Get one Attendance
     * const attendance = await prisma.attendance.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AttendanceFindUniqueOrThrowArgs>(args: SelectSubset<T, AttendanceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AttendanceClient<$Result.GetResult<Prisma.$AttendancePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Attendance that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttendanceFindFirstArgs} args - Arguments to find a Attendance
     * @example
     * // Get one Attendance
     * const attendance = await prisma.attendance.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AttendanceFindFirstArgs>(args?: SelectSubset<T, AttendanceFindFirstArgs<ExtArgs>>): Prisma__AttendanceClient<$Result.GetResult<Prisma.$AttendancePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Attendance that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttendanceFindFirstOrThrowArgs} args - Arguments to find a Attendance
     * @example
     * // Get one Attendance
     * const attendance = await prisma.attendance.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AttendanceFindFirstOrThrowArgs>(args?: SelectSubset<T, AttendanceFindFirstOrThrowArgs<ExtArgs>>): Prisma__AttendanceClient<$Result.GetResult<Prisma.$AttendancePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Attendances that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttendanceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Attendances
     * const attendances = await prisma.attendance.findMany()
     * 
     * // Get first 10 Attendances
     * const attendances = await prisma.attendance.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const attendanceWithIdOnly = await prisma.attendance.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AttendanceFindManyArgs>(args?: SelectSubset<T, AttendanceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AttendancePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Attendance.
     * @param {AttendanceCreateArgs} args - Arguments to create a Attendance.
     * @example
     * // Create one Attendance
     * const Attendance = await prisma.attendance.create({
     *   data: {
     *     // ... data to create a Attendance
     *   }
     * })
     * 
     */
    create<T extends AttendanceCreateArgs>(args: SelectSubset<T, AttendanceCreateArgs<ExtArgs>>): Prisma__AttendanceClient<$Result.GetResult<Prisma.$AttendancePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Attendances.
     * @param {AttendanceCreateManyArgs} args - Arguments to create many Attendances.
     * @example
     * // Create many Attendances
     * const attendance = await prisma.attendance.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AttendanceCreateManyArgs>(args?: SelectSubset<T, AttendanceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Attendances and returns the data saved in the database.
     * @param {AttendanceCreateManyAndReturnArgs} args - Arguments to create many Attendances.
     * @example
     * // Create many Attendances
     * const attendance = await prisma.attendance.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Attendances and only return the `id`
     * const attendanceWithIdOnly = await prisma.attendance.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AttendanceCreateManyAndReturnArgs>(args?: SelectSubset<T, AttendanceCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AttendancePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Attendance.
     * @param {AttendanceDeleteArgs} args - Arguments to delete one Attendance.
     * @example
     * // Delete one Attendance
     * const Attendance = await prisma.attendance.delete({
     *   where: {
     *     // ... filter to delete one Attendance
     *   }
     * })
     * 
     */
    delete<T extends AttendanceDeleteArgs>(args: SelectSubset<T, AttendanceDeleteArgs<ExtArgs>>): Prisma__AttendanceClient<$Result.GetResult<Prisma.$AttendancePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Attendance.
     * @param {AttendanceUpdateArgs} args - Arguments to update one Attendance.
     * @example
     * // Update one Attendance
     * const attendance = await prisma.attendance.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AttendanceUpdateArgs>(args: SelectSubset<T, AttendanceUpdateArgs<ExtArgs>>): Prisma__AttendanceClient<$Result.GetResult<Prisma.$AttendancePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Attendances.
     * @param {AttendanceDeleteManyArgs} args - Arguments to filter Attendances to delete.
     * @example
     * // Delete a few Attendances
     * const { count } = await prisma.attendance.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AttendanceDeleteManyArgs>(args?: SelectSubset<T, AttendanceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Attendances.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttendanceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Attendances
     * const attendance = await prisma.attendance.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AttendanceUpdateManyArgs>(args: SelectSubset<T, AttendanceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Attendance.
     * @param {AttendanceUpsertArgs} args - Arguments to update or create a Attendance.
     * @example
     * // Update or create a Attendance
     * const attendance = await prisma.attendance.upsert({
     *   create: {
     *     // ... data to create a Attendance
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Attendance we want to update
     *   }
     * })
     */
    upsert<T extends AttendanceUpsertArgs>(args: SelectSubset<T, AttendanceUpsertArgs<ExtArgs>>): Prisma__AttendanceClient<$Result.GetResult<Prisma.$AttendancePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Attendances.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttendanceCountArgs} args - Arguments to filter Attendances to count.
     * @example
     * // Count the number of Attendances
     * const count = await prisma.attendance.count({
     *   where: {
     *     // ... the filter for the Attendances we want to count
     *   }
     * })
    **/
    count<T extends AttendanceCountArgs>(
      args?: Subset<T, AttendanceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AttendanceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Attendance.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttendanceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AttendanceAggregateArgs>(args: Subset<T, AttendanceAggregateArgs>): Prisma.PrismaPromise<GetAttendanceAggregateType<T>>

    /**
     * Group by Attendance.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttendanceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AttendanceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AttendanceGroupByArgs['orderBy'] }
        : { orderBy?: AttendanceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AttendanceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAttendanceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Attendance model
   */
  readonly fields: AttendanceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Attendance.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AttendanceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    tenant<T extends TenantDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TenantDefaultArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    santri<T extends SantriDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SantriDefaultArgs<ExtArgs>>): Prisma__SantriClient<$Result.GetResult<Prisma.$SantriPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Attendance model
   */ 
  interface AttendanceFieldRefs {
    readonly id: FieldRef<"Attendance", 'String'>
    readonly tenantId: FieldRef<"Attendance", 'String'>
    readonly santriId: FieldRef<"Attendance", 'String'>
    readonly scheduleId: FieldRef<"Attendance", 'String'>
    readonly date: FieldRef<"Attendance", 'DateTime'>
    readonly status: FieldRef<"Attendance", 'String'>
    readonly notes: FieldRef<"Attendance", 'String'>
    readonly recordedBy: FieldRef<"Attendance", 'String'>
    readonly createdAt: FieldRef<"Attendance", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Attendance findUnique
   */
  export type AttendanceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attendance
     */
    select?: AttendanceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceInclude<ExtArgs> | null
    /**
     * Filter, which Attendance to fetch.
     */
    where: AttendanceWhereUniqueInput
  }

  /**
   * Attendance findUniqueOrThrow
   */
  export type AttendanceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attendance
     */
    select?: AttendanceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceInclude<ExtArgs> | null
    /**
     * Filter, which Attendance to fetch.
     */
    where: AttendanceWhereUniqueInput
  }

  /**
   * Attendance findFirst
   */
  export type AttendanceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attendance
     */
    select?: AttendanceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceInclude<ExtArgs> | null
    /**
     * Filter, which Attendance to fetch.
     */
    where?: AttendanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Attendances to fetch.
     */
    orderBy?: AttendanceOrderByWithRelationInput | AttendanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Attendances.
     */
    cursor?: AttendanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Attendances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Attendances.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Attendances.
     */
    distinct?: AttendanceScalarFieldEnum | AttendanceScalarFieldEnum[]
  }

  /**
   * Attendance findFirstOrThrow
   */
  export type AttendanceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attendance
     */
    select?: AttendanceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceInclude<ExtArgs> | null
    /**
     * Filter, which Attendance to fetch.
     */
    where?: AttendanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Attendances to fetch.
     */
    orderBy?: AttendanceOrderByWithRelationInput | AttendanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Attendances.
     */
    cursor?: AttendanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Attendances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Attendances.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Attendances.
     */
    distinct?: AttendanceScalarFieldEnum | AttendanceScalarFieldEnum[]
  }

  /**
   * Attendance findMany
   */
  export type AttendanceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attendance
     */
    select?: AttendanceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceInclude<ExtArgs> | null
    /**
     * Filter, which Attendances to fetch.
     */
    where?: AttendanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Attendances to fetch.
     */
    orderBy?: AttendanceOrderByWithRelationInput | AttendanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Attendances.
     */
    cursor?: AttendanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Attendances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Attendances.
     */
    skip?: number
    distinct?: AttendanceScalarFieldEnum | AttendanceScalarFieldEnum[]
  }

  /**
   * Attendance create
   */
  export type AttendanceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attendance
     */
    select?: AttendanceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceInclude<ExtArgs> | null
    /**
     * The data needed to create a Attendance.
     */
    data: XOR<AttendanceCreateInput, AttendanceUncheckedCreateInput>
  }

  /**
   * Attendance createMany
   */
  export type AttendanceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Attendances.
     */
    data: AttendanceCreateManyInput | AttendanceCreateManyInput[]
  }

  /**
   * Attendance createManyAndReturn
   */
  export type AttendanceCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attendance
     */
    select?: AttendanceSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Attendances.
     */
    data: AttendanceCreateManyInput | AttendanceCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Attendance update
   */
  export type AttendanceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attendance
     */
    select?: AttendanceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceInclude<ExtArgs> | null
    /**
     * The data needed to update a Attendance.
     */
    data: XOR<AttendanceUpdateInput, AttendanceUncheckedUpdateInput>
    /**
     * Choose, which Attendance to update.
     */
    where: AttendanceWhereUniqueInput
  }

  /**
   * Attendance updateMany
   */
  export type AttendanceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Attendances.
     */
    data: XOR<AttendanceUpdateManyMutationInput, AttendanceUncheckedUpdateManyInput>
    /**
     * Filter which Attendances to update
     */
    where?: AttendanceWhereInput
  }

  /**
   * Attendance upsert
   */
  export type AttendanceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attendance
     */
    select?: AttendanceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceInclude<ExtArgs> | null
    /**
     * The filter to search for the Attendance to update in case it exists.
     */
    where: AttendanceWhereUniqueInput
    /**
     * In case the Attendance found by the `where` argument doesn't exist, create a new Attendance with this data.
     */
    create: XOR<AttendanceCreateInput, AttendanceUncheckedCreateInput>
    /**
     * In case the Attendance was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AttendanceUpdateInput, AttendanceUncheckedUpdateInput>
  }

  /**
   * Attendance delete
   */
  export type AttendanceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attendance
     */
    select?: AttendanceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceInclude<ExtArgs> | null
    /**
     * Filter which Attendance to delete.
     */
    where: AttendanceWhereUniqueInput
  }

  /**
   * Attendance deleteMany
   */
  export type AttendanceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Attendances to delete
     */
    where?: AttendanceWhereInput
  }

  /**
   * Attendance without action
   */
  export type AttendanceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attendance
     */
    select?: AttendanceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceInclude<ExtArgs> | null
  }


  /**
   * Model Grade
   */

  export type AggregateGrade = {
    _count: GradeCountAggregateOutputType | null
    _avg: GradeAvgAggregateOutputType | null
    _sum: GradeSumAggregateOutputType | null
    _min: GradeMinAggregateOutputType | null
    _max: GradeMaxAggregateOutputType | null
  }

  export type GradeAvgAggregateOutputType = {
    score: number | null
  }

  export type GradeSumAggregateOutputType = {
    score: number | null
  }

  export type GradeMinAggregateOutputType = {
    id: string | null
    tenantId: string | null
    santriId: string | null
    subject: string | null
    semester: string | null
    academicYear: string | null
    type: string | null
    score: number | null
    notes: string | null
    createdAt: Date | null
  }

  export type GradeMaxAggregateOutputType = {
    id: string | null
    tenantId: string | null
    santriId: string | null
    subject: string | null
    semester: string | null
    academicYear: string | null
    type: string | null
    score: number | null
    notes: string | null
    createdAt: Date | null
  }

  export type GradeCountAggregateOutputType = {
    id: number
    tenantId: number
    santriId: number
    subject: number
    semester: number
    academicYear: number
    type: number
    score: number
    notes: number
    createdAt: number
    _all: number
  }


  export type GradeAvgAggregateInputType = {
    score?: true
  }

  export type GradeSumAggregateInputType = {
    score?: true
  }

  export type GradeMinAggregateInputType = {
    id?: true
    tenantId?: true
    santriId?: true
    subject?: true
    semester?: true
    academicYear?: true
    type?: true
    score?: true
    notes?: true
    createdAt?: true
  }

  export type GradeMaxAggregateInputType = {
    id?: true
    tenantId?: true
    santriId?: true
    subject?: true
    semester?: true
    academicYear?: true
    type?: true
    score?: true
    notes?: true
    createdAt?: true
  }

  export type GradeCountAggregateInputType = {
    id?: true
    tenantId?: true
    santriId?: true
    subject?: true
    semester?: true
    academicYear?: true
    type?: true
    score?: true
    notes?: true
    createdAt?: true
    _all?: true
  }

  export type GradeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Grade to aggregate.
     */
    where?: GradeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Grades to fetch.
     */
    orderBy?: GradeOrderByWithRelationInput | GradeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: GradeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Grades from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Grades.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Grades
    **/
    _count?: true | GradeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: GradeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: GradeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: GradeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: GradeMaxAggregateInputType
  }

  export type GetGradeAggregateType<T extends GradeAggregateArgs> = {
        [P in keyof T & keyof AggregateGrade]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateGrade[P]>
      : GetScalarType<T[P], AggregateGrade[P]>
  }




  export type GradeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GradeWhereInput
    orderBy?: GradeOrderByWithAggregationInput | GradeOrderByWithAggregationInput[]
    by: GradeScalarFieldEnum[] | GradeScalarFieldEnum
    having?: GradeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: GradeCountAggregateInputType | true
    _avg?: GradeAvgAggregateInputType
    _sum?: GradeSumAggregateInputType
    _min?: GradeMinAggregateInputType
    _max?: GradeMaxAggregateInputType
  }

  export type GradeGroupByOutputType = {
    id: string
    tenantId: string
    santriId: string
    subject: string
    semester: string
    academicYear: string
    type: string
    score: number
    notes: string | null
    createdAt: Date
    _count: GradeCountAggregateOutputType | null
    _avg: GradeAvgAggregateOutputType | null
    _sum: GradeSumAggregateOutputType | null
    _min: GradeMinAggregateOutputType | null
    _max: GradeMaxAggregateOutputType | null
  }

  type GetGradeGroupByPayload<T extends GradeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<GradeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof GradeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], GradeGroupByOutputType[P]>
            : GetScalarType<T[P], GradeGroupByOutputType[P]>
        }
      >
    >


  export type GradeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    santriId?: boolean
    subject?: boolean
    semester?: boolean
    academicYear?: boolean
    type?: boolean
    score?: boolean
    notes?: boolean
    createdAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    santri?: boolean | SantriDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["grade"]>

  export type GradeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    santriId?: boolean
    subject?: boolean
    semester?: boolean
    academicYear?: boolean
    type?: boolean
    score?: boolean
    notes?: boolean
    createdAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    santri?: boolean | SantriDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["grade"]>

  export type GradeSelectScalar = {
    id?: boolean
    tenantId?: boolean
    santriId?: boolean
    subject?: boolean
    semester?: boolean
    academicYear?: boolean
    type?: boolean
    score?: boolean
    notes?: boolean
    createdAt?: boolean
  }

  export type GradeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    santri?: boolean | SantriDefaultArgs<ExtArgs>
  }
  export type GradeIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    santri?: boolean | SantriDefaultArgs<ExtArgs>
  }

  export type $GradePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Grade"
    objects: {
      tenant: Prisma.$TenantPayload<ExtArgs>
      santri: Prisma.$SantriPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      tenantId: string
      santriId: string
      subject: string
      semester: string
      academicYear: string
      type: string
      score: number
      notes: string | null
      createdAt: Date
    }, ExtArgs["result"]["grade"]>
    composites: {}
  }

  type GradeGetPayload<S extends boolean | null | undefined | GradeDefaultArgs> = $Result.GetResult<Prisma.$GradePayload, S>

  type GradeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<GradeFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: GradeCountAggregateInputType | true
    }

  export interface GradeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Grade'], meta: { name: 'Grade' } }
    /**
     * Find zero or one Grade that matches the filter.
     * @param {GradeFindUniqueArgs} args - Arguments to find a Grade
     * @example
     * // Get one Grade
     * const grade = await prisma.grade.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends GradeFindUniqueArgs>(args: SelectSubset<T, GradeFindUniqueArgs<ExtArgs>>): Prisma__GradeClient<$Result.GetResult<Prisma.$GradePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Grade that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {GradeFindUniqueOrThrowArgs} args - Arguments to find a Grade
     * @example
     * // Get one Grade
     * const grade = await prisma.grade.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends GradeFindUniqueOrThrowArgs>(args: SelectSubset<T, GradeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__GradeClient<$Result.GetResult<Prisma.$GradePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Grade that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GradeFindFirstArgs} args - Arguments to find a Grade
     * @example
     * // Get one Grade
     * const grade = await prisma.grade.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends GradeFindFirstArgs>(args?: SelectSubset<T, GradeFindFirstArgs<ExtArgs>>): Prisma__GradeClient<$Result.GetResult<Prisma.$GradePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Grade that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GradeFindFirstOrThrowArgs} args - Arguments to find a Grade
     * @example
     * // Get one Grade
     * const grade = await prisma.grade.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends GradeFindFirstOrThrowArgs>(args?: SelectSubset<T, GradeFindFirstOrThrowArgs<ExtArgs>>): Prisma__GradeClient<$Result.GetResult<Prisma.$GradePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Grades that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GradeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Grades
     * const grades = await prisma.grade.findMany()
     * 
     * // Get first 10 Grades
     * const grades = await prisma.grade.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const gradeWithIdOnly = await prisma.grade.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends GradeFindManyArgs>(args?: SelectSubset<T, GradeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GradePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Grade.
     * @param {GradeCreateArgs} args - Arguments to create a Grade.
     * @example
     * // Create one Grade
     * const Grade = await prisma.grade.create({
     *   data: {
     *     // ... data to create a Grade
     *   }
     * })
     * 
     */
    create<T extends GradeCreateArgs>(args: SelectSubset<T, GradeCreateArgs<ExtArgs>>): Prisma__GradeClient<$Result.GetResult<Prisma.$GradePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Grades.
     * @param {GradeCreateManyArgs} args - Arguments to create many Grades.
     * @example
     * // Create many Grades
     * const grade = await prisma.grade.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends GradeCreateManyArgs>(args?: SelectSubset<T, GradeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Grades and returns the data saved in the database.
     * @param {GradeCreateManyAndReturnArgs} args - Arguments to create many Grades.
     * @example
     * // Create many Grades
     * const grade = await prisma.grade.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Grades and only return the `id`
     * const gradeWithIdOnly = await prisma.grade.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends GradeCreateManyAndReturnArgs>(args?: SelectSubset<T, GradeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GradePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Grade.
     * @param {GradeDeleteArgs} args - Arguments to delete one Grade.
     * @example
     * // Delete one Grade
     * const Grade = await prisma.grade.delete({
     *   where: {
     *     // ... filter to delete one Grade
     *   }
     * })
     * 
     */
    delete<T extends GradeDeleteArgs>(args: SelectSubset<T, GradeDeleteArgs<ExtArgs>>): Prisma__GradeClient<$Result.GetResult<Prisma.$GradePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Grade.
     * @param {GradeUpdateArgs} args - Arguments to update one Grade.
     * @example
     * // Update one Grade
     * const grade = await prisma.grade.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends GradeUpdateArgs>(args: SelectSubset<T, GradeUpdateArgs<ExtArgs>>): Prisma__GradeClient<$Result.GetResult<Prisma.$GradePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Grades.
     * @param {GradeDeleteManyArgs} args - Arguments to filter Grades to delete.
     * @example
     * // Delete a few Grades
     * const { count } = await prisma.grade.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends GradeDeleteManyArgs>(args?: SelectSubset<T, GradeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Grades.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GradeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Grades
     * const grade = await prisma.grade.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends GradeUpdateManyArgs>(args: SelectSubset<T, GradeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Grade.
     * @param {GradeUpsertArgs} args - Arguments to update or create a Grade.
     * @example
     * // Update or create a Grade
     * const grade = await prisma.grade.upsert({
     *   create: {
     *     // ... data to create a Grade
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Grade we want to update
     *   }
     * })
     */
    upsert<T extends GradeUpsertArgs>(args: SelectSubset<T, GradeUpsertArgs<ExtArgs>>): Prisma__GradeClient<$Result.GetResult<Prisma.$GradePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Grades.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GradeCountArgs} args - Arguments to filter Grades to count.
     * @example
     * // Count the number of Grades
     * const count = await prisma.grade.count({
     *   where: {
     *     // ... the filter for the Grades we want to count
     *   }
     * })
    **/
    count<T extends GradeCountArgs>(
      args?: Subset<T, GradeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], GradeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Grade.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GradeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends GradeAggregateArgs>(args: Subset<T, GradeAggregateArgs>): Prisma.PrismaPromise<GetGradeAggregateType<T>>

    /**
     * Group by Grade.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GradeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends GradeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: GradeGroupByArgs['orderBy'] }
        : { orderBy?: GradeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, GradeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetGradeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Grade model
   */
  readonly fields: GradeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Grade.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__GradeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    tenant<T extends TenantDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TenantDefaultArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    santri<T extends SantriDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SantriDefaultArgs<ExtArgs>>): Prisma__SantriClient<$Result.GetResult<Prisma.$SantriPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Grade model
   */ 
  interface GradeFieldRefs {
    readonly id: FieldRef<"Grade", 'String'>
    readonly tenantId: FieldRef<"Grade", 'String'>
    readonly santriId: FieldRef<"Grade", 'String'>
    readonly subject: FieldRef<"Grade", 'String'>
    readonly semester: FieldRef<"Grade", 'String'>
    readonly academicYear: FieldRef<"Grade", 'String'>
    readonly type: FieldRef<"Grade", 'String'>
    readonly score: FieldRef<"Grade", 'Float'>
    readonly notes: FieldRef<"Grade", 'String'>
    readonly createdAt: FieldRef<"Grade", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Grade findUnique
   */
  export type GradeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Grade
     */
    select?: GradeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GradeInclude<ExtArgs> | null
    /**
     * Filter, which Grade to fetch.
     */
    where: GradeWhereUniqueInput
  }

  /**
   * Grade findUniqueOrThrow
   */
  export type GradeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Grade
     */
    select?: GradeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GradeInclude<ExtArgs> | null
    /**
     * Filter, which Grade to fetch.
     */
    where: GradeWhereUniqueInput
  }

  /**
   * Grade findFirst
   */
  export type GradeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Grade
     */
    select?: GradeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GradeInclude<ExtArgs> | null
    /**
     * Filter, which Grade to fetch.
     */
    where?: GradeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Grades to fetch.
     */
    orderBy?: GradeOrderByWithRelationInput | GradeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Grades.
     */
    cursor?: GradeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Grades from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Grades.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Grades.
     */
    distinct?: GradeScalarFieldEnum | GradeScalarFieldEnum[]
  }

  /**
   * Grade findFirstOrThrow
   */
  export type GradeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Grade
     */
    select?: GradeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GradeInclude<ExtArgs> | null
    /**
     * Filter, which Grade to fetch.
     */
    where?: GradeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Grades to fetch.
     */
    orderBy?: GradeOrderByWithRelationInput | GradeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Grades.
     */
    cursor?: GradeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Grades from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Grades.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Grades.
     */
    distinct?: GradeScalarFieldEnum | GradeScalarFieldEnum[]
  }

  /**
   * Grade findMany
   */
  export type GradeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Grade
     */
    select?: GradeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GradeInclude<ExtArgs> | null
    /**
     * Filter, which Grades to fetch.
     */
    where?: GradeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Grades to fetch.
     */
    orderBy?: GradeOrderByWithRelationInput | GradeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Grades.
     */
    cursor?: GradeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Grades from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Grades.
     */
    skip?: number
    distinct?: GradeScalarFieldEnum | GradeScalarFieldEnum[]
  }

  /**
   * Grade create
   */
  export type GradeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Grade
     */
    select?: GradeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GradeInclude<ExtArgs> | null
    /**
     * The data needed to create a Grade.
     */
    data: XOR<GradeCreateInput, GradeUncheckedCreateInput>
  }

  /**
   * Grade createMany
   */
  export type GradeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Grades.
     */
    data: GradeCreateManyInput | GradeCreateManyInput[]
  }

  /**
   * Grade createManyAndReturn
   */
  export type GradeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Grade
     */
    select?: GradeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Grades.
     */
    data: GradeCreateManyInput | GradeCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GradeIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Grade update
   */
  export type GradeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Grade
     */
    select?: GradeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GradeInclude<ExtArgs> | null
    /**
     * The data needed to update a Grade.
     */
    data: XOR<GradeUpdateInput, GradeUncheckedUpdateInput>
    /**
     * Choose, which Grade to update.
     */
    where: GradeWhereUniqueInput
  }

  /**
   * Grade updateMany
   */
  export type GradeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Grades.
     */
    data: XOR<GradeUpdateManyMutationInput, GradeUncheckedUpdateManyInput>
    /**
     * Filter which Grades to update
     */
    where?: GradeWhereInput
  }

  /**
   * Grade upsert
   */
  export type GradeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Grade
     */
    select?: GradeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GradeInclude<ExtArgs> | null
    /**
     * The filter to search for the Grade to update in case it exists.
     */
    where: GradeWhereUniqueInput
    /**
     * In case the Grade found by the `where` argument doesn't exist, create a new Grade with this data.
     */
    create: XOR<GradeCreateInput, GradeUncheckedCreateInput>
    /**
     * In case the Grade was found with the provided `where` argument, update it with this data.
     */
    update: XOR<GradeUpdateInput, GradeUncheckedUpdateInput>
  }

  /**
   * Grade delete
   */
  export type GradeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Grade
     */
    select?: GradeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GradeInclude<ExtArgs> | null
    /**
     * Filter which Grade to delete.
     */
    where: GradeWhereUniqueInput
  }

  /**
   * Grade deleteMany
   */
  export type GradeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Grades to delete
     */
    where?: GradeWhereInput
  }

  /**
   * Grade without action
   */
  export type GradeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Grade
     */
    select?: GradeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GradeInclude<ExtArgs> | null
  }


  /**
   * Model PpdbRegistration
   */

  export type AggregatePpdbRegistration = {
    _count: PpdbRegistrationCountAggregateOutputType | null
    _min: PpdbRegistrationMinAggregateOutputType | null
    _max: PpdbRegistrationMaxAggregateOutputType | null
  }

  export type PpdbRegistrationMinAggregateOutputType = {
    id: string | null
    tenantId: string | null
    registrationNumber: string | null
    fullName: string | null
    gender: string | null
    dob: Date | null
    previousSchool: string | null
    pathway: string | null
    status: string | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PpdbRegistrationMaxAggregateOutputType = {
    id: string | null
    tenantId: string | null
    registrationNumber: string | null
    fullName: string | null
    gender: string | null
    dob: Date | null
    previousSchool: string | null
    pathway: string | null
    status: string | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PpdbRegistrationCountAggregateOutputType = {
    id: number
    tenantId: number
    registrationNumber: number
    fullName: number
    gender: number
    dob: number
    previousSchool: number
    pathway: number
    status: number
    notes: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PpdbRegistrationMinAggregateInputType = {
    id?: true
    tenantId?: true
    registrationNumber?: true
    fullName?: true
    gender?: true
    dob?: true
    previousSchool?: true
    pathway?: true
    status?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PpdbRegistrationMaxAggregateInputType = {
    id?: true
    tenantId?: true
    registrationNumber?: true
    fullName?: true
    gender?: true
    dob?: true
    previousSchool?: true
    pathway?: true
    status?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PpdbRegistrationCountAggregateInputType = {
    id?: true
    tenantId?: true
    registrationNumber?: true
    fullName?: true
    gender?: true
    dob?: true
    previousSchool?: true
    pathway?: true
    status?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PpdbRegistrationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PpdbRegistration to aggregate.
     */
    where?: PpdbRegistrationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PpdbRegistrations to fetch.
     */
    orderBy?: PpdbRegistrationOrderByWithRelationInput | PpdbRegistrationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PpdbRegistrationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PpdbRegistrations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PpdbRegistrations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PpdbRegistrations
    **/
    _count?: true | PpdbRegistrationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PpdbRegistrationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PpdbRegistrationMaxAggregateInputType
  }

  export type GetPpdbRegistrationAggregateType<T extends PpdbRegistrationAggregateArgs> = {
        [P in keyof T & keyof AggregatePpdbRegistration]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePpdbRegistration[P]>
      : GetScalarType<T[P], AggregatePpdbRegistration[P]>
  }




  export type PpdbRegistrationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PpdbRegistrationWhereInput
    orderBy?: PpdbRegistrationOrderByWithAggregationInput | PpdbRegistrationOrderByWithAggregationInput[]
    by: PpdbRegistrationScalarFieldEnum[] | PpdbRegistrationScalarFieldEnum
    having?: PpdbRegistrationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PpdbRegistrationCountAggregateInputType | true
    _min?: PpdbRegistrationMinAggregateInputType
    _max?: PpdbRegistrationMaxAggregateInputType
  }

  export type PpdbRegistrationGroupByOutputType = {
    id: string
    tenantId: string
    registrationNumber: string
    fullName: string
    gender: string
    dob: Date | null
    previousSchool: string | null
    pathway: string
    status: string
    notes: string | null
    createdAt: Date
    updatedAt: Date
    _count: PpdbRegistrationCountAggregateOutputType | null
    _min: PpdbRegistrationMinAggregateOutputType | null
    _max: PpdbRegistrationMaxAggregateOutputType | null
  }

  type GetPpdbRegistrationGroupByPayload<T extends PpdbRegistrationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PpdbRegistrationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PpdbRegistrationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PpdbRegistrationGroupByOutputType[P]>
            : GetScalarType<T[P], PpdbRegistrationGroupByOutputType[P]>
        }
      >
    >


  export type PpdbRegistrationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    registrationNumber?: boolean
    fullName?: boolean
    gender?: boolean
    dob?: boolean
    previousSchool?: boolean
    pathway?: boolean
    status?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    documents?: boolean | PpdbRegistration$documentsArgs<ExtArgs>
    exams?: boolean | PpdbRegistration$examsArgs<ExtArgs>
    _count?: boolean | PpdbRegistrationCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["ppdbRegistration"]>

  export type PpdbRegistrationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    registrationNumber?: boolean
    fullName?: boolean
    gender?: boolean
    dob?: boolean
    previousSchool?: boolean
    pathway?: boolean
    status?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["ppdbRegistration"]>

  export type PpdbRegistrationSelectScalar = {
    id?: boolean
    tenantId?: boolean
    registrationNumber?: boolean
    fullName?: boolean
    gender?: boolean
    dob?: boolean
    previousSchool?: boolean
    pathway?: boolean
    status?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PpdbRegistrationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    documents?: boolean | PpdbRegistration$documentsArgs<ExtArgs>
    exams?: boolean | PpdbRegistration$examsArgs<ExtArgs>
    _count?: boolean | PpdbRegistrationCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type PpdbRegistrationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }

  export type $PpdbRegistrationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PpdbRegistration"
    objects: {
      tenant: Prisma.$TenantPayload<ExtArgs>
      documents: Prisma.$PpdbDocumentPayload<ExtArgs>[]
      exams: Prisma.$PpdbExamPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      tenantId: string
      registrationNumber: string
      fullName: string
      gender: string
      dob: Date | null
      previousSchool: string | null
      pathway: string
      status: string
      notes: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["ppdbRegistration"]>
    composites: {}
  }

  type PpdbRegistrationGetPayload<S extends boolean | null | undefined | PpdbRegistrationDefaultArgs> = $Result.GetResult<Prisma.$PpdbRegistrationPayload, S>

  type PpdbRegistrationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<PpdbRegistrationFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PpdbRegistrationCountAggregateInputType | true
    }

  export interface PpdbRegistrationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PpdbRegistration'], meta: { name: 'PpdbRegistration' } }
    /**
     * Find zero or one PpdbRegistration that matches the filter.
     * @param {PpdbRegistrationFindUniqueArgs} args - Arguments to find a PpdbRegistration
     * @example
     * // Get one PpdbRegistration
     * const ppdbRegistration = await prisma.ppdbRegistration.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PpdbRegistrationFindUniqueArgs>(args: SelectSubset<T, PpdbRegistrationFindUniqueArgs<ExtArgs>>): Prisma__PpdbRegistrationClient<$Result.GetResult<Prisma.$PpdbRegistrationPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one PpdbRegistration that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {PpdbRegistrationFindUniqueOrThrowArgs} args - Arguments to find a PpdbRegistration
     * @example
     * // Get one PpdbRegistration
     * const ppdbRegistration = await prisma.ppdbRegistration.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PpdbRegistrationFindUniqueOrThrowArgs>(args: SelectSubset<T, PpdbRegistrationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PpdbRegistrationClient<$Result.GetResult<Prisma.$PpdbRegistrationPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first PpdbRegistration that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PpdbRegistrationFindFirstArgs} args - Arguments to find a PpdbRegistration
     * @example
     * // Get one PpdbRegistration
     * const ppdbRegistration = await prisma.ppdbRegistration.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PpdbRegistrationFindFirstArgs>(args?: SelectSubset<T, PpdbRegistrationFindFirstArgs<ExtArgs>>): Prisma__PpdbRegistrationClient<$Result.GetResult<Prisma.$PpdbRegistrationPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first PpdbRegistration that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PpdbRegistrationFindFirstOrThrowArgs} args - Arguments to find a PpdbRegistration
     * @example
     * // Get one PpdbRegistration
     * const ppdbRegistration = await prisma.ppdbRegistration.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PpdbRegistrationFindFirstOrThrowArgs>(args?: SelectSubset<T, PpdbRegistrationFindFirstOrThrowArgs<ExtArgs>>): Prisma__PpdbRegistrationClient<$Result.GetResult<Prisma.$PpdbRegistrationPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more PpdbRegistrations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PpdbRegistrationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PpdbRegistrations
     * const ppdbRegistrations = await prisma.ppdbRegistration.findMany()
     * 
     * // Get first 10 PpdbRegistrations
     * const ppdbRegistrations = await prisma.ppdbRegistration.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const ppdbRegistrationWithIdOnly = await prisma.ppdbRegistration.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PpdbRegistrationFindManyArgs>(args?: SelectSubset<T, PpdbRegistrationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PpdbRegistrationPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a PpdbRegistration.
     * @param {PpdbRegistrationCreateArgs} args - Arguments to create a PpdbRegistration.
     * @example
     * // Create one PpdbRegistration
     * const PpdbRegistration = await prisma.ppdbRegistration.create({
     *   data: {
     *     // ... data to create a PpdbRegistration
     *   }
     * })
     * 
     */
    create<T extends PpdbRegistrationCreateArgs>(args: SelectSubset<T, PpdbRegistrationCreateArgs<ExtArgs>>): Prisma__PpdbRegistrationClient<$Result.GetResult<Prisma.$PpdbRegistrationPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many PpdbRegistrations.
     * @param {PpdbRegistrationCreateManyArgs} args - Arguments to create many PpdbRegistrations.
     * @example
     * // Create many PpdbRegistrations
     * const ppdbRegistration = await prisma.ppdbRegistration.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PpdbRegistrationCreateManyArgs>(args?: SelectSubset<T, PpdbRegistrationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PpdbRegistrations and returns the data saved in the database.
     * @param {PpdbRegistrationCreateManyAndReturnArgs} args - Arguments to create many PpdbRegistrations.
     * @example
     * // Create many PpdbRegistrations
     * const ppdbRegistration = await prisma.ppdbRegistration.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PpdbRegistrations and only return the `id`
     * const ppdbRegistrationWithIdOnly = await prisma.ppdbRegistration.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PpdbRegistrationCreateManyAndReturnArgs>(args?: SelectSubset<T, PpdbRegistrationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PpdbRegistrationPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a PpdbRegistration.
     * @param {PpdbRegistrationDeleteArgs} args - Arguments to delete one PpdbRegistration.
     * @example
     * // Delete one PpdbRegistration
     * const PpdbRegistration = await prisma.ppdbRegistration.delete({
     *   where: {
     *     // ... filter to delete one PpdbRegistration
     *   }
     * })
     * 
     */
    delete<T extends PpdbRegistrationDeleteArgs>(args: SelectSubset<T, PpdbRegistrationDeleteArgs<ExtArgs>>): Prisma__PpdbRegistrationClient<$Result.GetResult<Prisma.$PpdbRegistrationPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one PpdbRegistration.
     * @param {PpdbRegistrationUpdateArgs} args - Arguments to update one PpdbRegistration.
     * @example
     * // Update one PpdbRegistration
     * const ppdbRegistration = await prisma.ppdbRegistration.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PpdbRegistrationUpdateArgs>(args: SelectSubset<T, PpdbRegistrationUpdateArgs<ExtArgs>>): Prisma__PpdbRegistrationClient<$Result.GetResult<Prisma.$PpdbRegistrationPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more PpdbRegistrations.
     * @param {PpdbRegistrationDeleteManyArgs} args - Arguments to filter PpdbRegistrations to delete.
     * @example
     * // Delete a few PpdbRegistrations
     * const { count } = await prisma.ppdbRegistration.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PpdbRegistrationDeleteManyArgs>(args?: SelectSubset<T, PpdbRegistrationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PpdbRegistrations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PpdbRegistrationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PpdbRegistrations
     * const ppdbRegistration = await prisma.ppdbRegistration.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PpdbRegistrationUpdateManyArgs>(args: SelectSubset<T, PpdbRegistrationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one PpdbRegistration.
     * @param {PpdbRegistrationUpsertArgs} args - Arguments to update or create a PpdbRegistration.
     * @example
     * // Update or create a PpdbRegistration
     * const ppdbRegistration = await prisma.ppdbRegistration.upsert({
     *   create: {
     *     // ... data to create a PpdbRegistration
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PpdbRegistration we want to update
     *   }
     * })
     */
    upsert<T extends PpdbRegistrationUpsertArgs>(args: SelectSubset<T, PpdbRegistrationUpsertArgs<ExtArgs>>): Prisma__PpdbRegistrationClient<$Result.GetResult<Prisma.$PpdbRegistrationPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of PpdbRegistrations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PpdbRegistrationCountArgs} args - Arguments to filter PpdbRegistrations to count.
     * @example
     * // Count the number of PpdbRegistrations
     * const count = await prisma.ppdbRegistration.count({
     *   where: {
     *     // ... the filter for the PpdbRegistrations we want to count
     *   }
     * })
    **/
    count<T extends PpdbRegistrationCountArgs>(
      args?: Subset<T, PpdbRegistrationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PpdbRegistrationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PpdbRegistration.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PpdbRegistrationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PpdbRegistrationAggregateArgs>(args: Subset<T, PpdbRegistrationAggregateArgs>): Prisma.PrismaPromise<GetPpdbRegistrationAggregateType<T>>

    /**
     * Group by PpdbRegistration.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PpdbRegistrationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PpdbRegistrationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PpdbRegistrationGroupByArgs['orderBy'] }
        : { orderBy?: PpdbRegistrationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PpdbRegistrationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPpdbRegistrationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PpdbRegistration model
   */
  readonly fields: PpdbRegistrationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PpdbRegistration.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PpdbRegistrationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    tenant<T extends TenantDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TenantDefaultArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    documents<T extends PpdbRegistration$documentsArgs<ExtArgs> = {}>(args?: Subset<T, PpdbRegistration$documentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PpdbDocumentPayload<ExtArgs>, T, "findMany"> | Null>
    exams<T extends PpdbRegistration$examsArgs<ExtArgs> = {}>(args?: Subset<T, PpdbRegistration$examsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PpdbExamPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PpdbRegistration model
   */ 
  interface PpdbRegistrationFieldRefs {
    readonly id: FieldRef<"PpdbRegistration", 'String'>
    readonly tenantId: FieldRef<"PpdbRegistration", 'String'>
    readonly registrationNumber: FieldRef<"PpdbRegistration", 'String'>
    readonly fullName: FieldRef<"PpdbRegistration", 'String'>
    readonly gender: FieldRef<"PpdbRegistration", 'String'>
    readonly dob: FieldRef<"PpdbRegistration", 'DateTime'>
    readonly previousSchool: FieldRef<"PpdbRegistration", 'String'>
    readonly pathway: FieldRef<"PpdbRegistration", 'String'>
    readonly status: FieldRef<"PpdbRegistration", 'String'>
    readonly notes: FieldRef<"PpdbRegistration", 'String'>
    readonly createdAt: FieldRef<"PpdbRegistration", 'DateTime'>
    readonly updatedAt: FieldRef<"PpdbRegistration", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PpdbRegistration findUnique
   */
  export type PpdbRegistrationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PpdbRegistration
     */
    select?: PpdbRegistrationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PpdbRegistrationInclude<ExtArgs> | null
    /**
     * Filter, which PpdbRegistration to fetch.
     */
    where: PpdbRegistrationWhereUniqueInput
  }

  /**
   * PpdbRegistration findUniqueOrThrow
   */
  export type PpdbRegistrationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PpdbRegistration
     */
    select?: PpdbRegistrationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PpdbRegistrationInclude<ExtArgs> | null
    /**
     * Filter, which PpdbRegistration to fetch.
     */
    where: PpdbRegistrationWhereUniqueInput
  }

  /**
   * PpdbRegistration findFirst
   */
  export type PpdbRegistrationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PpdbRegistration
     */
    select?: PpdbRegistrationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PpdbRegistrationInclude<ExtArgs> | null
    /**
     * Filter, which PpdbRegistration to fetch.
     */
    where?: PpdbRegistrationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PpdbRegistrations to fetch.
     */
    orderBy?: PpdbRegistrationOrderByWithRelationInput | PpdbRegistrationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PpdbRegistrations.
     */
    cursor?: PpdbRegistrationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PpdbRegistrations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PpdbRegistrations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PpdbRegistrations.
     */
    distinct?: PpdbRegistrationScalarFieldEnum | PpdbRegistrationScalarFieldEnum[]
  }

  /**
   * PpdbRegistration findFirstOrThrow
   */
  export type PpdbRegistrationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PpdbRegistration
     */
    select?: PpdbRegistrationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PpdbRegistrationInclude<ExtArgs> | null
    /**
     * Filter, which PpdbRegistration to fetch.
     */
    where?: PpdbRegistrationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PpdbRegistrations to fetch.
     */
    orderBy?: PpdbRegistrationOrderByWithRelationInput | PpdbRegistrationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PpdbRegistrations.
     */
    cursor?: PpdbRegistrationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PpdbRegistrations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PpdbRegistrations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PpdbRegistrations.
     */
    distinct?: PpdbRegistrationScalarFieldEnum | PpdbRegistrationScalarFieldEnum[]
  }

  /**
   * PpdbRegistration findMany
   */
  export type PpdbRegistrationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PpdbRegistration
     */
    select?: PpdbRegistrationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PpdbRegistrationInclude<ExtArgs> | null
    /**
     * Filter, which PpdbRegistrations to fetch.
     */
    where?: PpdbRegistrationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PpdbRegistrations to fetch.
     */
    orderBy?: PpdbRegistrationOrderByWithRelationInput | PpdbRegistrationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PpdbRegistrations.
     */
    cursor?: PpdbRegistrationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PpdbRegistrations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PpdbRegistrations.
     */
    skip?: number
    distinct?: PpdbRegistrationScalarFieldEnum | PpdbRegistrationScalarFieldEnum[]
  }

  /**
   * PpdbRegistration create
   */
  export type PpdbRegistrationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PpdbRegistration
     */
    select?: PpdbRegistrationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PpdbRegistrationInclude<ExtArgs> | null
    /**
     * The data needed to create a PpdbRegistration.
     */
    data: XOR<PpdbRegistrationCreateInput, PpdbRegistrationUncheckedCreateInput>
  }

  /**
   * PpdbRegistration createMany
   */
  export type PpdbRegistrationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PpdbRegistrations.
     */
    data: PpdbRegistrationCreateManyInput | PpdbRegistrationCreateManyInput[]
  }

  /**
   * PpdbRegistration createManyAndReturn
   */
  export type PpdbRegistrationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PpdbRegistration
     */
    select?: PpdbRegistrationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many PpdbRegistrations.
     */
    data: PpdbRegistrationCreateManyInput | PpdbRegistrationCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PpdbRegistrationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PpdbRegistration update
   */
  export type PpdbRegistrationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PpdbRegistration
     */
    select?: PpdbRegistrationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PpdbRegistrationInclude<ExtArgs> | null
    /**
     * The data needed to update a PpdbRegistration.
     */
    data: XOR<PpdbRegistrationUpdateInput, PpdbRegistrationUncheckedUpdateInput>
    /**
     * Choose, which PpdbRegistration to update.
     */
    where: PpdbRegistrationWhereUniqueInput
  }

  /**
   * PpdbRegistration updateMany
   */
  export type PpdbRegistrationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PpdbRegistrations.
     */
    data: XOR<PpdbRegistrationUpdateManyMutationInput, PpdbRegistrationUncheckedUpdateManyInput>
    /**
     * Filter which PpdbRegistrations to update
     */
    where?: PpdbRegistrationWhereInput
  }

  /**
   * PpdbRegistration upsert
   */
  export type PpdbRegistrationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PpdbRegistration
     */
    select?: PpdbRegistrationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PpdbRegistrationInclude<ExtArgs> | null
    /**
     * The filter to search for the PpdbRegistration to update in case it exists.
     */
    where: PpdbRegistrationWhereUniqueInput
    /**
     * In case the PpdbRegistration found by the `where` argument doesn't exist, create a new PpdbRegistration with this data.
     */
    create: XOR<PpdbRegistrationCreateInput, PpdbRegistrationUncheckedCreateInput>
    /**
     * In case the PpdbRegistration was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PpdbRegistrationUpdateInput, PpdbRegistrationUncheckedUpdateInput>
  }

  /**
   * PpdbRegistration delete
   */
  export type PpdbRegistrationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PpdbRegistration
     */
    select?: PpdbRegistrationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PpdbRegistrationInclude<ExtArgs> | null
    /**
     * Filter which PpdbRegistration to delete.
     */
    where: PpdbRegistrationWhereUniqueInput
  }

  /**
   * PpdbRegistration deleteMany
   */
  export type PpdbRegistrationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PpdbRegistrations to delete
     */
    where?: PpdbRegistrationWhereInput
  }

  /**
   * PpdbRegistration.documents
   */
  export type PpdbRegistration$documentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PpdbDocument
     */
    select?: PpdbDocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PpdbDocumentInclude<ExtArgs> | null
    where?: PpdbDocumentWhereInput
    orderBy?: PpdbDocumentOrderByWithRelationInput | PpdbDocumentOrderByWithRelationInput[]
    cursor?: PpdbDocumentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PpdbDocumentScalarFieldEnum | PpdbDocumentScalarFieldEnum[]
  }

  /**
   * PpdbRegistration.exams
   */
  export type PpdbRegistration$examsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PpdbExam
     */
    select?: PpdbExamSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PpdbExamInclude<ExtArgs> | null
    where?: PpdbExamWhereInput
    orderBy?: PpdbExamOrderByWithRelationInput | PpdbExamOrderByWithRelationInput[]
    cursor?: PpdbExamWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PpdbExamScalarFieldEnum | PpdbExamScalarFieldEnum[]
  }

  /**
   * PpdbRegistration without action
   */
  export type PpdbRegistrationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PpdbRegistration
     */
    select?: PpdbRegistrationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PpdbRegistrationInclude<ExtArgs> | null
  }


  /**
   * Model PpdbDocument
   */

  export type AggregatePpdbDocument = {
    _count: PpdbDocumentCountAggregateOutputType | null
    _min: PpdbDocumentMinAggregateOutputType | null
    _max: PpdbDocumentMaxAggregateOutputType | null
  }

  export type PpdbDocumentMinAggregateOutputType = {
    id: string | null
    tenantId: string | null
    registrationId: string | null
    documentType: string | null
    fileUrl: string | null
    isVerified: boolean | null
    createdAt: Date | null
  }

  export type PpdbDocumentMaxAggregateOutputType = {
    id: string | null
    tenantId: string | null
    registrationId: string | null
    documentType: string | null
    fileUrl: string | null
    isVerified: boolean | null
    createdAt: Date | null
  }

  export type PpdbDocumentCountAggregateOutputType = {
    id: number
    tenantId: number
    registrationId: number
    documentType: number
    fileUrl: number
    isVerified: number
    createdAt: number
    _all: number
  }


  export type PpdbDocumentMinAggregateInputType = {
    id?: true
    tenantId?: true
    registrationId?: true
    documentType?: true
    fileUrl?: true
    isVerified?: true
    createdAt?: true
  }

  export type PpdbDocumentMaxAggregateInputType = {
    id?: true
    tenantId?: true
    registrationId?: true
    documentType?: true
    fileUrl?: true
    isVerified?: true
    createdAt?: true
  }

  export type PpdbDocumentCountAggregateInputType = {
    id?: true
    tenantId?: true
    registrationId?: true
    documentType?: true
    fileUrl?: true
    isVerified?: true
    createdAt?: true
    _all?: true
  }

  export type PpdbDocumentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PpdbDocument to aggregate.
     */
    where?: PpdbDocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PpdbDocuments to fetch.
     */
    orderBy?: PpdbDocumentOrderByWithRelationInput | PpdbDocumentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PpdbDocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PpdbDocuments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PpdbDocuments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PpdbDocuments
    **/
    _count?: true | PpdbDocumentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PpdbDocumentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PpdbDocumentMaxAggregateInputType
  }

  export type GetPpdbDocumentAggregateType<T extends PpdbDocumentAggregateArgs> = {
        [P in keyof T & keyof AggregatePpdbDocument]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePpdbDocument[P]>
      : GetScalarType<T[P], AggregatePpdbDocument[P]>
  }




  export type PpdbDocumentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PpdbDocumentWhereInput
    orderBy?: PpdbDocumentOrderByWithAggregationInput | PpdbDocumentOrderByWithAggregationInput[]
    by: PpdbDocumentScalarFieldEnum[] | PpdbDocumentScalarFieldEnum
    having?: PpdbDocumentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PpdbDocumentCountAggregateInputType | true
    _min?: PpdbDocumentMinAggregateInputType
    _max?: PpdbDocumentMaxAggregateInputType
  }

  export type PpdbDocumentGroupByOutputType = {
    id: string
    tenantId: string
    registrationId: string
    documentType: string
    fileUrl: string
    isVerified: boolean
    createdAt: Date
    _count: PpdbDocumentCountAggregateOutputType | null
    _min: PpdbDocumentMinAggregateOutputType | null
    _max: PpdbDocumentMaxAggregateOutputType | null
  }

  type GetPpdbDocumentGroupByPayload<T extends PpdbDocumentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PpdbDocumentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PpdbDocumentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PpdbDocumentGroupByOutputType[P]>
            : GetScalarType<T[P], PpdbDocumentGroupByOutputType[P]>
        }
      >
    >


  export type PpdbDocumentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    registrationId?: boolean
    documentType?: boolean
    fileUrl?: boolean
    isVerified?: boolean
    createdAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    registration?: boolean | PpdbRegistrationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["ppdbDocument"]>

  export type PpdbDocumentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    registrationId?: boolean
    documentType?: boolean
    fileUrl?: boolean
    isVerified?: boolean
    createdAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    registration?: boolean | PpdbRegistrationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["ppdbDocument"]>

  export type PpdbDocumentSelectScalar = {
    id?: boolean
    tenantId?: boolean
    registrationId?: boolean
    documentType?: boolean
    fileUrl?: boolean
    isVerified?: boolean
    createdAt?: boolean
  }

  export type PpdbDocumentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    registration?: boolean | PpdbRegistrationDefaultArgs<ExtArgs>
  }
  export type PpdbDocumentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    registration?: boolean | PpdbRegistrationDefaultArgs<ExtArgs>
  }

  export type $PpdbDocumentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PpdbDocument"
    objects: {
      tenant: Prisma.$TenantPayload<ExtArgs>
      registration: Prisma.$PpdbRegistrationPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      tenantId: string
      registrationId: string
      documentType: string
      fileUrl: string
      isVerified: boolean
      createdAt: Date
    }, ExtArgs["result"]["ppdbDocument"]>
    composites: {}
  }

  type PpdbDocumentGetPayload<S extends boolean | null | undefined | PpdbDocumentDefaultArgs> = $Result.GetResult<Prisma.$PpdbDocumentPayload, S>

  type PpdbDocumentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<PpdbDocumentFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PpdbDocumentCountAggregateInputType | true
    }

  export interface PpdbDocumentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PpdbDocument'], meta: { name: 'PpdbDocument' } }
    /**
     * Find zero or one PpdbDocument that matches the filter.
     * @param {PpdbDocumentFindUniqueArgs} args - Arguments to find a PpdbDocument
     * @example
     * // Get one PpdbDocument
     * const ppdbDocument = await prisma.ppdbDocument.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PpdbDocumentFindUniqueArgs>(args: SelectSubset<T, PpdbDocumentFindUniqueArgs<ExtArgs>>): Prisma__PpdbDocumentClient<$Result.GetResult<Prisma.$PpdbDocumentPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one PpdbDocument that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {PpdbDocumentFindUniqueOrThrowArgs} args - Arguments to find a PpdbDocument
     * @example
     * // Get one PpdbDocument
     * const ppdbDocument = await prisma.ppdbDocument.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PpdbDocumentFindUniqueOrThrowArgs>(args: SelectSubset<T, PpdbDocumentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PpdbDocumentClient<$Result.GetResult<Prisma.$PpdbDocumentPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first PpdbDocument that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PpdbDocumentFindFirstArgs} args - Arguments to find a PpdbDocument
     * @example
     * // Get one PpdbDocument
     * const ppdbDocument = await prisma.ppdbDocument.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PpdbDocumentFindFirstArgs>(args?: SelectSubset<T, PpdbDocumentFindFirstArgs<ExtArgs>>): Prisma__PpdbDocumentClient<$Result.GetResult<Prisma.$PpdbDocumentPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first PpdbDocument that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PpdbDocumentFindFirstOrThrowArgs} args - Arguments to find a PpdbDocument
     * @example
     * // Get one PpdbDocument
     * const ppdbDocument = await prisma.ppdbDocument.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PpdbDocumentFindFirstOrThrowArgs>(args?: SelectSubset<T, PpdbDocumentFindFirstOrThrowArgs<ExtArgs>>): Prisma__PpdbDocumentClient<$Result.GetResult<Prisma.$PpdbDocumentPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more PpdbDocuments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PpdbDocumentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PpdbDocuments
     * const ppdbDocuments = await prisma.ppdbDocument.findMany()
     * 
     * // Get first 10 PpdbDocuments
     * const ppdbDocuments = await prisma.ppdbDocument.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const ppdbDocumentWithIdOnly = await prisma.ppdbDocument.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PpdbDocumentFindManyArgs>(args?: SelectSubset<T, PpdbDocumentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PpdbDocumentPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a PpdbDocument.
     * @param {PpdbDocumentCreateArgs} args - Arguments to create a PpdbDocument.
     * @example
     * // Create one PpdbDocument
     * const PpdbDocument = await prisma.ppdbDocument.create({
     *   data: {
     *     // ... data to create a PpdbDocument
     *   }
     * })
     * 
     */
    create<T extends PpdbDocumentCreateArgs>(args: SelectSubset<T, PpdbDocumentCreateArgs<ExtArgs>>): Prisma__PpdbDocumentClient<$Result.GetResult<Prisma.$PpdbDocumentPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many PpdbDocuments.
     * @param {PpdbDocumentCreateManyArgs} args - Arguments to create many PpdbDocuments.
     * @example
     * // Create many PpdbDocuments
     * const ppdbDocument = await prisma.ppdbDocument.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PpdbDocumentCreateManyArgs>(args?: SelectSubset<T, PpdbDocumentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PpdbDocuments and returns the data saved in the database.
     * @param {PpdbDocumentCreateManyAndReturnArgs} args - Arguments to create many PpdbDocuments.
     * @example
     * // Create many PpdbDocuments
     * const ppdbDocument = await prisma.ppdbDocument.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PpdbDocuments and only return the `id`
     * const ppdbDocumentWithIdOnly = await prisma.ppdbDocument.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PpdbDocumentCreateManyAndReturnArgs>(args?: SelectSubset<T, PpdbDocumentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PpdbDocumentPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a PpdbDocument.
     * @param {PpdbDocumentDeleteArgs} args - Arguments to delete one PpdbDocument.
     * @example
     * // Delete one PpdbDocument
     * const PpdbDocument = await prisma.ppdbDocument.delete({
     *   where: {
     *     // ... filter to delete one PpdbDocument
     *   }
     * })
     * 
     */
    delete<T extends PpdbDocumentDeleteArgs>(args: SelectSubset<T, PpdbDocumentDeleteArgs<ExtArgs>>): Prisma__PpdbDocumentClient<$Result.GetResult<Prisma.$PpdbDocumentPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one PpdbDocument.
     * @param {PpdbDocumentUpdateArgs} args - Arguments to update one PpdbDocument.
     * @example
     * // Update one PpdbDocument
     * const ppdbDocument = await prisma.ppdbDocument.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PpdbDocumentUpdateArgs>(args: SelectSubset<T, PpdbDocumentUpdateArgs<ExtArgs>>): Prisma__PpdbDocumentClient<$Result.GetResult<Prisma.$PpdbDocumentPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more PpdbDocuments.
     * @param {PpdbDocumentDeleteManyArgs} args - Arguments to filter PpdbDocuments to delete.
     * @example
     * // Delete a few PpdbDocuments
     * const { count } = await prisma.ppdbDocument.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PpdbDocumentDeleteManyArgs>(args?: SelectSubset<T, PpdbDocumentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PpdbDocuments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PpdbDocumentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PpdbDocuments
     * const ppdbDocument = await prisma.ppdbDocument.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PpdbDocumentUpdateManyArgs>(args: SelectSubset<T, PpdbDocumentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one PpdbDocument.
     * @param {PpdbDocumentUpsertArgs} args - Arguments to update or create a PpdbDocument.
     * @example
     * // Update or create a PpdbDocument
     * const ppdbDocument = await prisma.ppdbDocument.upsert({
     *   create: {
     *     // ... data to create a PpdbDocument
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PpdbDocument we want to update
     *   }
     * })
     */
    upsert<T extends PpdbDocumentUpsertArgs>(args: SelectSubset<T, PpdbDocumentUpsertArgs<ExtArgs>>): Prisma__PpdbDocumentClient<$Result.GetResult<Prisma.$PpdbDocumentPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of PpdbDocuments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PpdbDocumentCountArgs} args - Arguments to filter PpdbDocuments to count.
     * @example
     * // Count the number of PpdbDocuments
     * const count = await prisma.ppdbDocument.count({
     *   where: {
     *     // ... the filter for the PpdbDocuments we want to count
     *   }
     * })
    **/
    count<T extends PpdbDocumentCountArgs>(
      args?: Subset<T, PpdbDocumentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PpdbDocumentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PpdbDocument.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PpdbDocumentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PpdbDocumentAggregateArgs>(args: Subset<T, PpdbDocumentAggregateArgs>): Prisma.PrismaPromise<GetPpdbDocumentAggregateType<T>>

    /**
     * Group by PpdbDocument.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PpdbDocumentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PpdbDocumentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PpdbDocumentGroupByArgs['orderBy'] }
        : { orderBy?: PpdbDocumentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PpdbDocumentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPpdbDocumentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PpdbDocument model
   */
  readonly fields: PpdbDocumentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PpdbDocument.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PpdbDocumentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    tenant<T extends TenantDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TenantDefaultArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    registration<T extends PpdbRegistrationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PpdbRegistrationDefaultArgs<ExtArgs>>): Prisma__PpdbRegistrationClient<$Result.GetResult<Prisma.$PpdbRegistrationPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PpdbDocument model
   */ 
  interface PpdbDocumentFieldRefs {
    readonly id: FieldRef<"PpdbDocument", 'String'>
    readonly tenantId: FieldRef<"PpdbDocument", 'String'>
    readonly registrationId: FieldRef<"PpdbDocument", 'String'>
    readonly documentType: FieldRef<"PpdbDocument", 'String'>
    readonly fileUrl: FieldRef<"PpdbDocument", 'String'>
    readonly isVerified: FieldRef<"PpdbDocument", 'Boolean'>
    readonly createdAt: FieldRef<"PpdbDocument", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PpdbDocument findUnique
   */
  export type PpdbDocumentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PpdbDocument
     */
    select?: PpdbDocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PpdbDocumentInclude<ExtArgs> | null
    /**
     * Filter, which PpdbDocument to fetch.
     */
    where: PpdbDocumentWhereUniqueInput
  }

  /**
   * PpdbDocument findUniqueOrThrow
   */
  export type PpdbDocumentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PpdbDocument
     */
    select?: PpdbDocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PpdbDocumentInclude<ExtArgs> | null
    /**
     * Filter, which PpdbDocument to fetch.
     */
    where: PpdbDocumentWhereUniqueInput
  }

  /**
   * PpdbDocument findFirst
   */
  export type PpdbDocumentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PpdbDocument
     */
    select?: PpdbDocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PpdbDocumentInclude<ExtArgs> | null
    /**
     * Filter, which PpdbDocument to fetch.
     */
    where?: PpdbDocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PpdbDocuments to fetch.
     */
    orderBy?: PpdbDocumentOrderByWithRelationInput | PpdbDocumentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PpdbDocuments.
     */
    cursor?: PpdbDocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PpdbDocuments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PpdbDocuments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PpdbDocuments.
     */
    distinct?: PpdbDocumentScalarFieldEnum | PpdbDocumentScalarFieldEnum[]
  }

  /**
   * PpdbDocument findFirstOrThrow
   */
  export type PpdbDocumentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PpdbDocument
     */
    select?: PpdbDocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PpdbDocumentInclude<ExtArgs> | null
    /**
     * Filter, which PpdbDocument to fetch.
     */
    where?: PpdbDocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PpdbDocuments to fetch.
     */
    orderBy?: PpdbDocumentOrderByWithRelationInput | PpdbDocumentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PpdbDocuments.
     */
    cursor?: PpdbDocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PpdbDocuments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PpdbDocuments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PpdbDocuments.
     */
    distinct?: PpdbDocumentScalarFieldEnum | PpdbDocumentScalarFieldEnum[]
  }

  /**
   * PpdbDocument findMany
   */
  export type PpdbDocumentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PpdbDocument
     */
    select?: PpdbDocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PpdbDocumentInclude<ExtArgs> | null
    /**
     * Filter, which PpdbDocuments to fetch.
     */
    where?: PpdbDocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PpdbDocuments to fetch.
     */
    orderBy?: PpdbDocumentOrderByWithRelationInput | PpdbDocumentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PpdbDocuments.
     */
    cursor?: PpdbDocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PpdbDocuments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PpdbDocuments.
     */
    skip?: number
    distinct?: PpdbDocumentScalarFieldEnum | PpdbDocumentScalarFieldEnum[]
  }

  /**
   * PpdbDocument create
   */
  export type PpdbDocumentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PpdbDocument
     */
    select?: PpdbDocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PpdbDocumentInclude<ExtArgs> | null
    /**
     * The data needed to create a PpdbDocument.
     */
    data: XOR<PpdbDocumentCreateInput, PpdbDocumentUncheckedCreateInput>
  }

  /**
   * PpdbDocument createMany
   */
  export type PpdbDocumentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PpdbDocuments.
     */
    data: PpdbDocumentCreateManyInput | PpdbDocumentCreateManyInput[]
  }

  /**
   * PpdbDocument createManyAndReturn
   */
  export type PpdbDocumentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PpdbDocument
     */
    select?: PpdbDocumentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many PpdbDocuments.
     */
    data: PpdbDocumentCreateManyInput | PpdbDocumentCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PpdbDocumentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PpdbDocument update
   */
  export type PpdbDocumentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PpdbDocument
     */
    select?: PpdbDocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PpdbDocumentInclude<ExtArgs> | null
    /**
     * The data needed to update a PpdbDocument.
     */
    data: XOR<PpdbDocumentUpdateInput, PpdbDocumentUncheckedUpdateInput>
    /**
     * Choose, which PpdbDocument to update.
     */
    where: PpdbDocumentWhereUniqueInput
  }

  /**
   * PpdbDocument updateMany
   */
  export type PpdbDocumentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PpdbDocuments.
     */
    data: XOR<PpdbDocumentUpdateManyMutationInput, PpdbDocumentUncheckedUpdateManyInput>
    /**
     * Filter which PpdbDocuments to update
     */
    where?: PpdbDocumentWhereInput
  }

  /**
   * PpdbDocument upsert
   */
  export type PpdbDocumentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PpdbDocument
     */
    select?: PpdbDocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PpdbDocumentInclude<ExtArgs> | null
    /**
     * The filter to search for the PpdbDocument to update in case it exists.
     */
    where: PpdbDocumentWhereUniqueInput
    /**
     * In case the PpdbDocument found by the `where` argument doesn't exist, create a new PpdbDocument with this data.
     */
    create: XOR<PpdbDocumentCreateInput, PpdbDocumentUncheckedCreateInput>
    /**
     * In case the PpdbDocument was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PpdbDocumentUpdateInput, PpdbDocumentUncheckedUpdateInput>
  }

  /**
   * PpdbDocument delete
   */
  export type PpdbDocumentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PpdbDocument
     */
    select?: PpdbDocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PpdbDocumentInclude<ExtArgs> | null
    /**
     * Filter which PpdbDocument to delete.
     */
    where: PpdbDocumentWhereUniqueInput
  }

  /**
   * PpdbDocument deleteMany
   */
  export type PpdbDocumentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PpdbDocuments to delete
     */
    where?: PpdbDocumentWhereInput
  }

  /**
   * PpdbDocument without action
   */
  export type PpdbDocumentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PpdbDocument
     */
    select?: PpdbDocumentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PpdbDocumentInclude<ExtArgs> | null
  }


  /**
   * Model PpdbExam
   */

  export type AggregatePpdbExam = {
    _count: PpdbExamCountAggregateOutputType | null
    _avg: PpdbExamAvgAggregateOutputType | null
    _sum: PpdbExamSumAggregateOutputType | null
    _min: PpdbExamMinAggregateOutputType | null
    _max: PpdbExamMaxAggregateOutputType | null
  }

  export type PpdbExamAvgAggregateOutputType = {
    score: number | null
  }

  export type PpdbExamSumAggregateOutputType = {
    score: number | null
  }

  export type PpdbExamMinAggregateOutputType = {
    id: string | null
    tenantId: string | null
    registrationId: string | null
    examType: string | null
    examDate: Date | null
    score: number | null
    result: string | null
    interviewer: string | null
    createdAt: Date | null
  }

  export type PpdbExamMaxAggregateOutputType = {
    id: string | null
    tenantId: string | null
    registrationId: string | null
    examType: string | null
    examDate: Date | null
    score: number | null
    result: string | null
    interviewer: string | null
    createdAt: Date | null
  }

  export type PpdbExamCountAggregateOutputType = {
    id: number
    tenantId: number
    registrationId: number
    examType: number
    examDate: number
    score: number
    result: number
    interviewer: number
    createdAt: number
    _all: number
  }


  export type PpdbExamAvgAggregateInputType = {
    score?: true
  }

  export type PpdbExamSumAggregateInputType = {
    score?: true
  }

  export type PpdbExamMinAggregateInputType = {
    id?: true
    tenantId?: true
    registrationId?: true
    examType?: true
    examDate?: true
    score?: true
    result?: true
    interviewer?: true
    createdAt?: true
  }

  export type PpdbExamMaxAggregateInputType = {
    id?: true
    tenantId?: true
    registrationId?: true
    examType?: true
    examDate?: true
    score?: true
    result?: true
    interviewer?: true
    createdAt?: true
  }

  export type PpdbExamCountAggregateInputType = {
    id?: true
    tenantId?: true
    registrationId?: true
    examType?: true
    examDate?: true
    score?: true
    result?: true
    interviewer?: true
    createdAt?: true
    _all?: true
  }

  export type PpdbExamAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PpdbExam to aggregate.
     */
    where?: PpdbExamWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PpdbExams to fetch.
     */
    orderBy?: PpdbExamOrderByWithRelationInput | PpdbExamOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PpdbExamWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PpdbExams from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PpdbExams.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PpdbExams
    **/
    _count?: true | PpdbExamCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PpdbExamAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PpdbExamSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PpdbExamMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PpdbExamMaxAggregateInputType
  }

  export type GetPpdbExamAggregateType<T extends PpdbExamAggregateArgs> = {
        [P in keyof T & keyof AggregatePpdbExam]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePpdbExam[P]>
      : GetScalarType<T[P], AggregatePpdbExam[P]>
  }




  export type PpdbExamGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PpdbExamWhereInput
    orderBy?: PpdbExamOrderByWithAggregationInput | PpdbExamOrderByWithAggregationInput[]
    by: PpdbExamScalarFieldEnum[] | PpdbExamScalarFieldEnum
    having?: PpdbExamScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PpdbExamCountAggregateInputType | true
    _avg?: PpdbExamAvgAggregateInputType
    _sum?: PpdbExamSumAggregateInputType
    _min?: PpdbExamMinAggregateInputType
    _max?: PpdbExamMaxAggregateInputType
  }

  export type PpdbExamGroupByOutputType = {
    id: string
    tenantId: string
    registrationId: string
    examType: string
    examDate: Date
    score: number | null
    result: string | null
    interviewer: string | null
    createdAt: Date
    _count: PpdbExamCountAggregateOutputType | null
    _avg: PpdbExamAvgAggregateOutputType | null
    _sum: PpdbExamSumAggregateOutputType | null
    _min: PpdbExamMinAggregateOutputType | null
    _max: PpdbExamMaxAggregateOutputType | null
  }

  type GetPpdbExamGroupByPayload<T extends PpdbExamGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PpdbExamGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PpdbExamGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PpdbExamGroupByOutputType[P]>
            : GetScalarType<T[P], PpdbExamGroupByOutputType[P]>
        }
      >
    >


  export type PpdbExamSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    registrationId?: boolean
    examType?: boolean
    examDate?: boolean
    score?: boolean
    result?: boolean
    interviewer?: boolean
    createdAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    registration?: boolean | PpdbRegistrationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["ppdbExam"]>

  export type PpdbExamSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    registrationId?: boolean
    examType?: boolean
    examDate?: boolean
    score?: boolean
    result?: boolean
    interviewer?: boolean
    createdAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    registration?: boolean | PpdbRegistrationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["ppdbExam"]>

  export type PpdbExamSelectScalar = {
    id?: boolean
    tenantId?: boolean
    registrationId?: boolean
    examType?: boolean
    examDate?: boolean
    score?: boolean
    result?: boolean
    interviewer?: boolean
    createdAt?: boolean
  }

  export type PpdbExamInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    registration?: boolean | PpdbRegistrationDefaultArgs<ExtArgs>
  }
  export type PpdbExamIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    registration?: boolean | PpdbRegistrationDefaultArgs<ExtArgs>
  }

  export type $PpdbExamPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PpdbExam"
    objects: {
      tenant: Prisma.$TenantPayload<ExtArgs>
      registration: Prisma.$PpdbRegistrationPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      tenantId: string
      registrationId: string
      examType: string
      examDate: Date
      score: number | null
      result: string | null
      interviewer: string | null
      createdAt: Date
    }, ExtArgs["result"]["ppdbExam"]>
    composites: {}
  }

  type PpdbExamGetPayload<S extends boolean | null | undefined | PpdbExamDefaultArgs> = $Result.GetResult<Prisma.$PpdbExamPayload, S>

  type PpdbExamCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<PpdbExamFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PpdbExamCountAggregateInputType | true
    }

  export interface PpdbExamDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PpdbExam'], meta: { name: 'PpdbExam' } }
    /**
     * Find zero or one PpdbExam that matches the filter.
     * @param {PpdbExamFindUniqueArgs} args - Arguments to find a PpdbExam
     * @example
     * // Get one PpdbExam
     * const ppdbExam = await prisma.ppdbExam.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PpdbExamFindUniqueArgs>(args: SelectSubset<T, PpdbExamFindUniqueArgs<ExtArgs>>): Prisma__PpdbExamClient<$Result.GetResult<Prisma.$PpdbExamPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one PpdbExam that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {PpdbExamFindUniqueOrThrowArgs} args - Arguments to find a PpdbExam
     * @example
     * // Get one PpdbExam
     * const ppdbExam = await prisma.ppdbExam.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PpdbExamFindUniqueOrThrowArgs>(args: SelectSubset<T, PpdbExamFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PpdbExamClient<$Result.GetResult<Prisma.$PpdbExamPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first PpdbExam that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PpdbExamFindFirstArgs} args - Arguments to find a PpdbExam
     * @example
     * // Get one PpdbExam
     * const ppdbExam = await prisma.ppdbExam.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PpdbExamFindFirstArgs>(args?: SelectSubset<T, PpdbExamFindFirstArgs<ExtArgs>>): Prisma__PpdbExamClient<$Result.GetResult<Prisma.$PpdbExamPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first PpdbExam that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PpdbExamFindFirstOrThrowArgs} args - Arguments to find a PpdbExam
     * @example
     * // Get one PpdbExam
     * const ppdbExam = await prisma.ppdbExam.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PpdbExamFindFirstOrThrowArgs>(args?: SelectSubset<T, PpdbExamFindFirstOrThrowArgs<ExtArgs>>): Prisma__PpdbExamClient<$Result.GetResult<Prisma.$PpdbExamPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more PpdbExams that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PpdbExamFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PpdbExams
     * const ppdbExams = await prisma.ppdbExam.findMany()
     * 
     * // Get first 10 PpdbExams
     * const ppdbExams = await prisma.ppdbExam.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const ppdbExamWithIdOnly = await prisma.ppdbExam.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PpdbExamFindManyArgs>(args?: SelectSubset<T, PpdbExamFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PpdbExamPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a PpdbExam.
     * @param {PpdbExamCreateArgs} args - Arguments to create a PpdbExam.
     * @example
     * // Create one PpdbExam
     * const PpdbExam = await prisma.ppdbExam.create({
     *   data: {
     *     // ... data to create a PpdbExam
     *   }
     * })
     * 
     */
    create<T extends PpdbExamCreateArgs>(args: SelectSubset<T, PpdbExamCreateArgs<ExtArgs>>): Prisma__PpdbExamClient<$Result.GetResult<Prisma.$PpdbExamPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many PpdbExams.
     * @param {PpdbExamCreateManyArgs} args - Arguments to create many PpdbExams.
     * @example
     * // Create many PpdbExams
     * const ppdbExam = await prisma.ppdbExam.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PpdbExamCreateManyArgs>(args?: SelectSubset<T, PpdbExamCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PpdbExams and returns the data saved in the database.
     * @param {PpdbExamCreateManyAndReturnArgs} args - Arguments to create many PpdbExams.
     * @example
     * // Create many PpdbExams
     * const ppdbExam = await prisma.ppdbExam.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PpdbExams and only return the `id`
     * const ppdbExamWithIdOnly = await prisma.ppdbExam.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PpdbExamCreateManyAndReturnArgs>(args?: SelectSubset<T, PpdbExamCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PpdbExamPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a PpdbExam.
     * @param {PpdbExamDeleteArgs} args - Arguments to delete one PpdbExam.
     * @example
     * // Delete one PpdbExam
     * const PpdbExam = await prisma.ppdbExam.delete({
     *   where: {
     *     // ... filter to delete one PpdbExam
     *   }
     * })
     * 
     */
    delete<T extends PpdbExamDeleteArgs>(args: SelectSubset<T, PpdbExamDeleteArgs<ExtArgs>>): Prisma__PpdbExamClient<$Result.GetResult<Prisma.$PpdbExamPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one PpdbExam.
     * @param {PpdbExamUpdateArgs} args - Arguments to update one PpdbExam.
     * @example
     * // Update one PpdbExam
     * const ppdbExam = await prisma.ppdbExam.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PpdbExamUpdateArgs>(args: SelectSubset<T, PpdbExamUpdateArgs<ExtArgs>>): Prisma__PpdbExamClient<$Result.GetResult<Prisma.$PpdbExamPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more PpdbExams.
     * @param {PpdbExamDeleteManyArgs} args - Arguments to filter PpdbExams to delete.
     * @example
     * // Delete a few PpdbExams
     * const { count } = await prisma.ppdbExam.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PpdbExamDeleteManyArgs>(args?: SelectSubset<T, PpdbExamDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PpdbExams.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PpdbExamUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PpdbExams
     * const ppdbExam = await prisma.ppdbExam.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PpdbExamUpdateManyArgs>(args: SelectSubset<T, PpdbExamUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one PpdbExam.
     * @param {PpdbExamUpsertArgs} args - Arguments to update or create a PpdbExam.
     * @example
     * // Update or create a PpdbExam
     * const ppdbExam = await prisma.ppdbExam.upsert({
     *   create: {
     *     // ... data to create a PpdbExam
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PpdbExam we want to update
     *   }
     * })
     */
    upsert<T extends PpdbExamUpsertArgs>(args: SelectSubset<T, PpdbExamUpsertArgs<ExtArgs>>): Prisma__PpdbExamClient<$Result.GetResult<Prisma.$PpdbExamPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of PpdbExams.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PpdbExamCountArgs} args - Arguments to filter PpdbExams to count.
     * @example
     * // Count the number of PpdbExams
     * const count = await prisma.ppdbExam.count({
     *   where: {
     *     // ... the filter for the PpdbExams we want to count
     *   }
     * })
    **/
    count<T extends PpdbExamCountArgs>(
      args?: Subset<T, PpdbExamCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PpdbExamCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PpdbExam.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PpdbExamAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PpdbExamAggregateArgs>(args: Subset<T, PpdbExamAggregateArgs>): Prisma.PrismaPromise<GetPpdbExamAggregateType<T>>

    /**
     * Group by PpdbExam.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PpdbExamGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PpdbExamGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PpdbExamGroupByArgs['orderBy'] }
        : { orderBy?: PpdbExamGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PpdbExamGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPpdbExamGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PpdbExam model
   */
  readonly fields: PpdbExamFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PpdbExam.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PpdbExamClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    tenant<T extends TenantDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TenantDefaultArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    registration<T extends PpdbRegistrationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PpdbRegistrationDefaultArgs<ExtArgs>>): Prisma__PpdbRegistrationClient<$Result.GetResult<Prisma.$PpdbRegistrationPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PpdbExam model
   */ 
  interface PpdbExamFieldRefs {
    readonly id: FieldRef<"PpdbExam", 'String'>
    readonly tenantId: FieldRef<"PpdbExam", 'String'>
    readonly registrationId: FieldRef<"PpdbExam", 'String'>
    readonly examType: FieldRef<"PpdbExam", 'String'>
    readonly examDate: FieldRef<"PpdbExam", 'DateTime'>
    readonly score: FieldRef<"PpdbExam", 'Float'>
    readonly result: FieldRef<"PpdbExam", 'String'>
    readonly interviewer: FieldRef<"PpdbExam", 'String'>
    readonly createdAt: FieldRef<"PpdbExam", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PpdbExam findUnique
   */
  export type PpdbExamFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PpdbExam
     */
    select?: PpdbExamSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PpdbExamInclude<ExtArgs> | null
    /**
     * Filter, which PpdbExam to fetch.
     */
    where: PpdbExamWhereUniqueInput
  }

  /**
   * PpdbExam findUniqueOrThrow
   */
  export type PpdbExamFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PpdbExam
     */
    select?: PpdbExamSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PpdbExamInclude<ExtArgs> | null
    /**
     * Filter, which PpdbExam to fetch.
     */
    where: PpdbExamWhereUniqueInput
  }

  /**
   * PpdbExam findFirst
   */
  export type PpdbExamFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PpdbExam
     */
    select?: PpdbExamSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PpdbExamInclude<ExtArgs> | null
    /**
     * Filter, which PpdbExam to fetch.
     */
    where?: PpdbExamWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PpdbExams to fetch.
     */
    orderBy?: PpdbExamOrderByWithRelationInput | PpdbExamOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PpdbExams.
     */
    cursor?: PpdbExamWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PpdbExams from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PpdbExams.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PpdbExams.
     */
    distinct?: PpdbExamScalarFieldEnum | PpdbExamScalarFieldEnum[]
  }

  /**
   * PpdbExam findFirstOrThrow
   */
  export type PpdbExamFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PpdbExam
     */
    select?: PpdbExamSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PpdbExamInclude<ExtArgs> | null
    /**
     * Filter, which PpdbExam to fetch.
     */
    where?: PpdbExamWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PpdbExams to fetch.
     */
    orderBy?: PpdbExamOrderByWithRelationInput | PpdbExamOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PpdbExams.
     */
    cursor?: PpdbExamWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PpdbExams from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PpdbExams.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PpdbExams.
     */
    distinct?: PpdbExamScalarFieldEnum | PpdbExamScalarFieldEnum[]
  }

  /**
   * PpdbExam findMany
   */
  export type PpdbExamFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PpdbExam
     */
    select?: PpdbExamSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PpdbExamInclude<ExtArgs> | null
    /**
     * Filter, which PpdbExams to fetch.
     */
    where?: PpdbExamWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PpdbExams to fetch.
     */
    orderBy?: PpdbExamOrderByWithRelationInput | PpdbExamOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PpdbExams.
     */
    cursor?: PpdbExamWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PpdbExams from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PpdbExams.
     */
    skip?: number
    distinct?: PpdbExamScalarFieldEnum | PpdbExamScalarFieldEnum[]
  }

  /**
   * PpdbExam create
   */
  export type PpdbExamCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PpdbExam
     */
    select?: PpdbExamSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PpdbExamInclude<ExtArgs> | null
    /**
     * The data needed to create a PpdbExam.
     */
    data: XOR<PpdbExamCreateInput, PpdbExamUncheckedCreateInput>
  }

  /**
   * PpdbExam createMany
   */
  export type PpdbExamCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PpdbExams.
     */
    data: PpdbExamCreateManyInput | PpdbExamCreateManyInput[]
  }

  /**
   * PpdbExam createManyAndReturn
   */
  export type PpdbExamCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PpdbExam
     */
    select?: PpdbExamSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many PpdbExams.
     */
    data: PpdbExamCreateManyInput | PpdbExamCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PpdbExamIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PpdbExam update
   */
  export type PpdbExamUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PpdbExam
     */
    select?: PpdbExamSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PpdbExamInclude<ExtArgs> | null
    /**
     * The data needed to update a PpdbExam.
     */
    data: XOR<PpdbExamUpdateInput, PpdbExamUncheckedUpdateInput>
    /**
     * Choose, which PpdbExam to update.
     */
    where: PpdbExamWhereUniqueInput
  }

  /**
   * PpdbExam updateMany
   */
  export type PpdbExamUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PpdbExams.
     */
    data: XOR<PpdbExamUpdateManyMutationInput, PpdbExamUncheckedUpdateManyInput>
    /**
     * Filter which PpdbExams to update
     */
    where?: PpdbExamWhereInput
  }

  /**
   * PpdbExam upsert
   */
  export type PpdbExamUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PpdbExam
     */
    select?: PpdbExamSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PpdbExamInclude<ExtArgs> | null
    /**
     * The filter to search for the PpdbExam to update in case it exists.
     */
    where: PpdbExamWhereUniqueInput
    /**
     * In case the PpdbExam found by the `where` argument doesn't exist, create a new PpdbExam with this data.
     */
    create: XOR<PpdbExamCreateInput, PpdbExamUncheckedCreateInput>
    /**
     * In case the PpdbExam was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PpdbExamUpdateInput, PpdbExamUncheckedUpdateInput>
  }

  /**
   * PpdbExam delete
   */
  export type PpdbExamDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PpdbExam
     */
    select?: PpdbExamSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PpdbExamInclude<ExtArgs> | null
    /**
     * Filter which PpdbExam to delete.
     */
    where: PpdbExamWhereUniqueInput
  }

  /**
   * PpdbExam deleteMany
   */
  export type PpdbExamDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PpdbExams to delete
     */
    where?: PpdbExamWhereInput
  }

  /**
   * PpdbExam without action
   */
  export type PpdbExamDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PpdbExam
     */
    select?: PpdbExamSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PpdbExamInclude<ExtArgs> | null
  }


  /**
   * Model Item
   */

  export type AggregateItem = {
    _count: ItemCountAggregateOutputType | null
    _avg: ItemAvgAggregateOutputType | null
    _sum: ItemSumAggregateOutputType | null
    _min: ItemMinAggregateOutputType | null
    _max: ItemMaxAggregateOutputType | null
  }

  export type ItemAvgAggregateOutputType = {
    price: number | null
    costPrice: number | null
    stock: number | null
    minStock: number | null
  }

  export type ItemSumAggregateOutputType = {
    price: number | null
    costPrice: number | null
    stock: number | null
    minStock: number | null
  }

  export type ItemMinAggregateOutputType = {
    id: string | null
    tenantId: string | null
    sku: string | null
    name: string | null
    description: string | null
    category: string | null
    price: number | null
    costPrice: number | null
    stock: number | null
    minStock: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ItemMaxAggregateOutputType = {
    id: string | null
    tenantId: string | null
    sku: string | null
    name: string | null
    description: string | null
    category: string | null
    price: number | null
    costPrice: number | null
    stock: number | null
    minStock: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ItemCountAggregateOutputType = {
    id: number
    tenantId: number
    sku: number
    name: number
    description: number
    category: number
    price: number
    costPrice: number
    stock: number
    minStock: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ItemAvgAggregateInputType = {
    price?: true
    costPrice?: true
    stock?: true
    minStock?: true
  }

  export type ItemSumAggregateInputType = {
    price?: true
    costPrice?: true
    stock?: true
    minStock?: true
  }

  export type ItemMinAggregateInputType = {
    id?: true
    tenantId?: true
    sku?: true
    name?: true
    description?: true
    category?: true
    price?: true
    costPrice?: true
    stock?: true
    minStock?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ItemMaxAggregateInputType = {
    id?: true
    tenantId?: true
    sku?: true
    name?: true
    description?: true
    category?: true
    price?: true
    costPrice?: true
    stock?: true
    minStock?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ItemCountAggregateInputType = {
    id?: true
    tenantId?: true
    sku?: true
    name?: true
    description?: true
    category?: true
    price?: true
    costPrice?: true
    stock?: true
    minStock?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ItemAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Item to aggregate.
     */
    where?: ItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Items to fetch.
     */
    orderBy?: ItemOrderByWithRelationInput | ItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Items from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Items.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Items
    **/
    _count?: true | ItemCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ItemAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ItemSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ItemMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ItemMaxAggregateInputType
  }

  export type GetItemAggregateType<T extends ItemAggregateArgs> = {
        [P in keyof T & keyof AggregateItem]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateItem[P]>
      : GetScalarType<T[P], AggregateItem[P]>
  }




  export type ItemGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ItemWhereInput
    orderBy?: ItemOrderByWithAggregationInput | ItemOrderByWithAggregationInput[]
    by: ItemScalarFieldEnum[] | ItemScalarFieldEnum
    having?: ItemScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ItemCountAggregateInputType | true
    _avg?: ItemAvgAggregateInputType
    _sum?: ItemSumAggregateInputType
    _min?: ItemMinAggregateInputType
    _max?: ItemMaxAggregateInputType
  }

  export type ItemGroupByOutputType = {
    id: string
    tenantId: string
    sku: string
    name: string
    description: string | null
    category: string
    price: number
    costPrice: number | null
    stock: number
    minStock: number
    createdAt: Date
    updatedAt: Date
    _count: ItemCountAggregateOutputType | null
    _avg: ItemAvgAggregateOutputType | null
    _sum: ItemSumAggregateOutputType | null
    _min: ItemMinAggregateOutputType | null
    _max: ItemMaxAggregateOutputType | null
  }

  type GetItemGroupByPayload<T extends ItemGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ItemGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ItemGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ItemGroupByOutputType[P]>
            : GetScalarType<T[P], ItemGroupByOutputType[P]>
        }
      >
    >


  export type ItemSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    sku?: boolean
    name?: boolean
    description?: boolean
    category?: boolean
    price?: boolean
    costPrice?: boolean
    stock?: boolean
    minStock?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    transactions?: boolean | Item$transactionsArgs<ExtArgs>
    _count?: boolean | ItemCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["item"]>

  export type ItemSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    sku?: boolean
    name?: boolean
    description?: boolean
    category?: boolean
    price?: boolean
    costPrice?: boolean
    stock?: boolean
    minStock?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["item"]>

  export type ItemSelectScalar = {
    id?: boolean
    tenantId?: boolean
    sku?: boolean
    name?: boolean
    description?: boolean
    category?: boolean
    price?: boolean
    costPrice?: boolean
    stock?: boolean
    minStock?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ItemInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    transactions?: boolean | Item$transactionsArgs<ExtArgs>
    _count?: boolean | ItemCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ItemIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }

  export type $ItemPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Item"
    objects: {
      tenant: Prisma.$TenantPayload<ExtArgs>
      transactions: Prisma.$InventoryTransactionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      tenantId: string
      sku: string
      name: string
      description: string | null
      category: string
      price: number
      costPrice: number | null
      stock: number
      minStock: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["item"]>
    composites: {}
  }

  type ItemGetPayload<S extends boolean | null | undefined | ItemDefaultArgs> = $Result.GetResult<Prisma.$ItemPayload, S>

  type ItemCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ItemFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ItemCountAggregateInputType | true
    }

  export interface ItemDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Item'], meta: { name: 'Item' } }
    /**
     * Find zero or one Item that matches the filter.
     * @param {ItemFindUniqueArgs} args - Arguments to find a Item
     * @example
     * // Get one Item
     * const item = await prisma.item.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ItemFindUniqueArgs>(args: SelectSubset<T, ItemFindUniqueArgs<ExtArgs>>): Prisma__ItemClient<$Result.GetResult<Prisma.$ItemPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Item that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ItemFindUniqueOrThrowArgs} args - Arguments to find a Item
     * @example
     * // Get one Item
     * const item = await prisma.item.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ItemFindUniqueOrThrowArgs>(args: SelectSubset<T, ItemFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ItemClient<$Result.GetResult<Prisma.$ItemPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Item that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemFindFirstArgs} args - Arguments to find a Item
     * @example
     * // Get one Item
     * const item = await prisma.item.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ItemFindFirstArgs>(args?: SelectSubset<T, ItemFindFirstArgs<ExtArgs>>): Prisma__ItemClient<$Result.GetResult<Prisma.$ItemPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Item that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemFindFirstOrThrowArgs} args - Arguments to find a Item
     * @example
     * // Get one Item
     * const item = await prisma.item.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ItemFindFirstOrThrowArgs>(args?: SelectSubset<T, ItemFindFirstOrThrowArgs<ExtArgs>>): Prisma__ItemClient<$Result.GetResult<Prisma.$ItemPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Items that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Items
     * const items = await prisma.item.findMany()
     * 
     * // Get first 10 Items
     * const items = await prisma.item.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const itemWithIdOnly = await prisma.item.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ItemFindManyArgs>(args?: SelectSubset<T, ItemFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ItemPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Item.
     * @param {ItemCreateArgs} args - Arguments to create a Item.
     * @example
     * // Create one Item
     * const Item = await prisma.item.create({
     *   data: {
     *     // ... data to create a Item
     *   }
     * })
     * 
     */
    create<T extends ItemCreateArgs>(args: SelectSubset<T, ItemCreateArgs<ExtArgs>>): Prisma__ItemClient<$Result.GetResult<Prisma.$ItemPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Items.
     * @param {ItemCreateManyArgs} args - Arguments to create many Items.
     * @example
     * // Create many Items
     * const item = await prisma.item.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ItemCreateManyArgs>(args?: SelectSubset<T, ItemCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Items and returns the data saved in the database.
     * @param {ItemCreateManyAndReturnArgs} args - Arguments to create many Items.
     * @example
     * // Create many Items
     * const item = await prisma.item.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Items and only return the `id`
     * const itemWithIdOnly = await prisma.item.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ItemCreateManyAndReturnArgs>(args?: SelectSubset<T, ItemCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ItemPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Item.
     * @param {ItemDeleteArgs} args - Arguments to delete one Item.
     * @example
     * // Delete one Item
     * const Item = await prisma.item.delete({
     *   where: {
     *     // ... filter to delete one Item
     *   }
     * })
     * 
     */
    delete<T extends ItemDeleteArgs>(args: SelectSubset<T, ItemDeleteArgs<ExtArgs>>): Prisma__ItemClient<$Result.GetResult<Prisma.$ItemPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Item.
     * @param {ItemUpdateArgs} args - Arguments to update one Item.
     * @example
     * // Update one Item
     * const item = await prisma.item.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ItemUpdateArgs>(args: SelectSubset<T, ItemUpdateArgs<ExtArgs>>): Prisma__ItemClient<$Result.GetResult<Prisma.$ItemPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Items.
     * @param {ItemDeleteManyArgs} args - Arguments to filter Items to delete.
     * @example
     * // Delete a few Items
     * const { count } = await prisma.item.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ItemDeleteManyArgs>(args?: SelectSubset<T, ItemDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Items.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Items
     * const item = await prisma.item.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ItemUpdateManyArgs>(args: SelectSubset<T, ItemUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Item.
     * @param {ItemUpsertArgs} args - Arguments to update or create a Item.
     * @example
     * // Update or create a Item
     * const item = await prisma.item.upsert({
     *   create: {
     *     // ... data to create a Item
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Item we want to update
     *   }
     * })
     */
    upsert<T extends ItemUpsertArgs>(args: SelectSubset<T, ItemUpsertArgs<ExtArgs>>): Prisma__ItemClient<$Result.GetResult<Prisma.$ItemPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Items.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemCountArgs} args - Arguments to filter Items to count.
     * @example
     * // Count the number of Items
     * const count = await prisma.item.count({
     *   where: {
     *     // ... the filter for the Items we want to count
     *   }
     * })
    **/
    count<T extends ItemCountArgs>(
      args?: Subset<T, ItemCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ItemCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Item.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ItemAggregateArgs>(args: Subset<T, ItemAggregateArgs>): Prisma.PrismaPromise<GetItemAggregateType<T>>

    /**
     * Group by Item.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ItemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ItemGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ItemGroupByArgs['orderBy'] }
        : { orderBy?: ItemGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ItemGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetItemGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Item model
   */
  readonly fields: ItemFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Item.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ItemClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    tenant<T extends TenantDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TenantDefaultArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    transactions<T extends Item$transactionsArgs<ExtArgs> = {}>(args?: Subset<T, Item$transactionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InventoryTransactionPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Item model
   */ 
  interface ItemFieldRefs {
    readonly id: FieldRef<"Item", 'String'>
    readonly tenantId: FieldRef<"Item", 'String'>
    readonly sku: FieldRef<"Item", 'String'>
    readonly name: FieldRef<"Item", 'String'>
    readonly description: FieldRef<"Item", 'String'>
    readonly category: FieldRef<"Item", 'String'>
    readonly price: FieldRef<"Item", 'Float'>
    readonly costPrice: FieldRef<"Item", 'Float'>
    readonly stock: FieldRef<"Item", 'Int'>
    readonly minStock: FieldRef<"Item", 'Int'>
    readonly createdAt: FieldRef<"Item", 'DateTime'>
    readonly updatedAt: FieldRef<"Item", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Item findUnique
   */
  export type ItemFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Item
     */
    select?: ItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemInclude<ExtArgs> | null
    /**
     * Filter, which Item to fetch.
     */
    where: ItemWhereUniqueInput
  }

  /**
   * Item findUniqueOrThrow
   */
  export type ItemFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Item
     */
    select?: ItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemInclude<ExtArgs> | null
    /**
     * Filter, which Item to fetch.
     */
    where: ItemWhereUniqueInput
  }

  /**
   * Item findFirst
   */
  export type ItemFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Item
     */
    select?: ItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemInclude<ExtArgs> | null
    /**
     * Filter, which Item to fetch.
     */
    where?: ItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Items to fetch.
     */
    orderBy?: ItemOrderByWithRelationInput | ItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Items.
     */
    cursor?: ItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Items from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Items.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Items.
     */
    distinct?: ItemScalarFieldEnum | ItemScalarFieldEnum[]
  }

  /**
   * Item findFirstOrThrow
   */
  export type ItemFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Item
     */
    select?: ItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemInclude<ExtArgs> | null
    /**
     * Filter, which Item to fetch.
     */
    where?: ItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Items to fetch.
     */
    orderBy?: ItemOrderByWithRelationInput | ItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Items.
     */
    cursor?: ItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Items from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Items.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Items.
     */
    distinct?: ItemScalarFieldEnum | ItemScalarFieldEnum[]
  }

  /**
   * Item findMany
   */
  export type ItemFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Item
     */
    select?: ItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemInclude<ExtArgs> | null
    /**
     * Filter, which Items to fetch.
     */
    where?: ItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Items to fetch.
     */
    orderBy?: ItemOrderByWithRelationInput | ItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Items.
     */
    cursor?: ItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Items from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Items.
     */
    skip?: number
    distinct?: ItemScalarFieldEnum | ItemScalarFieldEnum[]
  }

  /**
   * Item create
   */
  export type ItemCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Item
     */
    select?: ItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemInclude<ExtArgs> | null
    /**
     * The data needed to create a Item.
     */
    data: XOR<ItemCreateInput, ItemUncheckedCreateInput>
  }

  /**
   * Item createMany
   */
  export type ItemCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Items.
     */
    data: ItemCreateManyInput | ItemCreateManyInput[]
  }

  /**
   * Item createManyAndReturn
   */
  export type ItemCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Item
     */
    select?: ItemSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Items.
     */
    data: ItemCreateManyInput | ItemCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Item update
   */
  export type ItemUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Item
     */
    select?: ItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemInclude<ExtArgs> | null
    /**
     * The data needed to update a Item.
     */
    data: XOR<ItemUpdateInput, ItemUncheckedUpdateInput>
    /**
     * Choose, which Item to update.
     */
    where: ItemWhereUniqueInput
  }

  /**
   * Item updateMany
   */
  export type ItemUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Items.
     */
    data: XOR<ItemUpdateManyMutationInput, ItemUncheckedUpdateManyInput>
    /**
     * Filter which Items to update
     */
    where?: ItemWhereInput
  }

  /**
   * Item upsert
   */
  export type ItemUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Item
     */
    select?: ItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemInclude<ExtArgs> | null
    /**
     * The filter to search for the Item to update in case it exists.
     */
    where: ItemWhereUniqueInput
    /**
     * In case the Item found by the `where` argument doesn't exist, create a new Item with this data.
     */
    create: XOR<ItemCreateInput, ItemUncheckedCreateInput>
    /**
     * In case the Item was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ItemUpdateInput, ItemUncheckedUpdateInput>
  }

  /**
   * Item delete
   */
  export type ItemDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Item
     */
    select?: ItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemInclude<ExtArgs> | null
    /**
     * Filter which Item to delete.
     */
    where: ItemWhereUniqueInput
  }

  /**
   * Item deleteMany
   */
  export type ItemDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Items to delete
     */
    where?: ItemWhereInput
  }

  /**
   * Item.transactions
   */
  export type Item$transactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryTransaction
     */
    select?: InventoryTransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryTransactionInclude<ExtArgs> | null
    where?: InventoryTransactionWhereInput
    orderBy?: InventoryTransactionOrderByWithRelationInput | InventoryTransactionOrderByWithRelationInput[]
    cursor?: InventoryTransactionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InventoryTransactionScalarFieldEnum | InventoryTransactionScalarFieldEnum[]
  }

  /**
   * Item without action
   */
  export type ItemDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Item
     */
    select?: ItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ItemInclude<ExtArgs> | null
  }


  /**
   * Model InventoryTransaction
   */

  export type AggregateInventoryTransaction = {
    _count: InventoryTransactionCountAggregateOutputType | null
    _avg: InventoryTransactionAvgAggregateOutputType | null
    _sum: InventoryTransactionSumAggregateOutputType | null
    _min: InventoryTransactionMinAggregateOutputType | null
    _max: InventoryTransactionMaxAggregateOutputType | null
  }

  export type InventoryTransactionAvgAggregateOutputType = {
    quantity: number | null
  }

  export type InventoryTransactionSumAggregateOutputType = {
    quantity: number | null
  }

  export type InventoryTransactionMinAggregateOutputType = {
    id: string | null
    tenantId: string | null
    itemId: string | null
    type: string | null
    quantity: number | null
    reference: string | null
    notes: string | null
    handledBy: string | null
    date: Date | null
  }

  export type InventoryTransactionMaxAggregateOutputType = {
    id: string | null
    tenantId: string | null
    itemId: string | null
    type: string | null
    quantity: number | null
    reference: string | null
    notes: string | null
    handledBy: string | null
    date: Date | null
  }

  export type InventoryTransactionCountAggregateOutputType = {
    id: number
    tenantId: number
    itemId: number
    type: number
    quantity: number
    reference: number
    notes: number
    handledBy: number
    date: number
    _all: number
  }


  export type InventoryTransactionAvgAggregateInputType = {
    quantity?: true
  }

  export type InventoryTransactionSumAggregateInputType = {
    quantity?: true
  }

  export type InventoryTransactionMinAggregateInputType = {
    id?: true
    tenantId?: true
    itemId?: true
    type?: true
    quantity?: true
    reference?: true
    notes?: true
    handledBy?: true
    date?: true
  }

  export type InventoryTransactionMaxAggregateInputType = {
    id?: true
    tenantId?: true
    itemId?: true
    type?: true
    quantity?: true
    reference?: true
    notes?: true
    handledBy?: true
    date?: true
  }

  export type InventoryTransactionCountAggregateInputType = {
    id?: true
    tenantId?: true
    itemId?: true
    type?: true
    quantity?: true
    reference?: true
    notes?: true
    handledBy?: true
    date?: true
    _all?: true
  }

  export type InventoryTransactionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which InventoryTransaction to aggregate.
     */
    where?: InventoryTransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InventoryTransactions to fetch.
     */
    orderBy?: InventoryTransactionOrderByWithRelationInput | InventoryTransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: InventoryTransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InventoryTransactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InventoryTransactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned InventoryTransactions
    **/
    _count?: true | InventoryTransactionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: InventoryTransactionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: InventoryTransactionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InventoryTransactionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InventoryTransactionMaxAggregateInputType
  }

  export type GetInventoryTransactionAggregateType<T extends InventoryTransactionAggregateArgs> = {
        [P in keyof T & keyof AggregateInventoryTransaction]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInventoryTransaction[P]>
      : GetScalarType<T[P], AggregateInventoryTransaction[P]>
  }




  export type InventoryTransactionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InventoryTransactionWhereInput
    orderBy?: InventoryTransactionOrderByWithAggregationInput | InventoryTransactionOrderByWithAggregationInput[]
    by: InventoryTransactionScalarFieldEnum[] | InventoryTransactionScalarFieldEnum
    having?: InventoryTransactionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InventoryTransactionCountAggregateInputType | true
    _avg?: InventoryTransactionAvgAggregateInputType
    _sum?: InventoryTransactionSumAggregateInputType
    _min?: InventoryTransactionMinAggregateInputType
    _max?: InventoryTransactionMaxAggregateInputType
  }

  export type InventoryTransactionGroupByOutputType = {
    id: string
    tenantId: string
    itemId: string
    type: string
    quantity: number
    reference: string | null
    notes: string | null
    handledBy: string | null
    date: Date
    _count: InventoryTransactionCountAggregateOutputType | null
    _avg: InventoryTransactionAvgAggregateOutputType | null
    _sum: InventoryTransactionSumAggregateOutputType | null
    _min: InventoryTransactionMinAggregateOutputType | null
    _max: InventoryTransactionMaxAggregateOutputType | null
  }

  type GetInventoryTransactionGroupByPayload<T extends InventoryTransactionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<InventoryTransactionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InventoryTransactionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InventoryTransactionGroupByOutputType[P]>
            : GetScalarType<T[P], InventoryTransactionGroupByOutputType[P]>
        }
      >
    >


  export type InventoryTransactionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    itemId?: boolean
    type?: boolean
    quantity?: boolean
    reference?: boolean
    notes?: boolean
    handledBy?: boolean
    date?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    item?: boolean | ItemDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["inventoryTransaction"]>

  export type InventoryTransactionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    itemId?: boolean
    type?: boolean
    quantity?: boolean
    reference?: boolean
    notes?: boolean
    handledBy?: boolean
    date?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    item?: boolean | ItemDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["inventoryTransaction"]>

  export type InventoryTransactionSelectScalar = {
    id?: boolean
    tenantId?: boolean
    itemId?: boolean
    type?: boolean
    quantity?: boolean
    reference?: boolean
    notes?: boolean
    handledBy?: boolean
    date?: boolean
  }

  export type InventoryTransactionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    item?: boolean | ItemDefaultArgs<ExtArgs>
  }
  export type InventoryTransactionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    item?: boolean | ItemDefaultArgs<ExtArgs>
  }

  export type $InventoryTransactionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "InventoryTransaction"
    objects: {
      tenant: Prisma.$TenantPayload<ExtArgs>
      item: Prisma.$ItemPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      tenantId: string
      itemId: string
      type: string
      quantity: number
      reference: string | null
      notes: string | null
      handledBy: string | null
      date: Date
    }, ExtArgs["result"]["inventoryTransaction"]>
    composites: {}
  }

  type InventoryTransactionGetPayload<S extends boolean | null | undefined | InventoryTransactionDefaultArgs> = $Result.GetResult<Prisma.$InventoryTransactionPayload, S>

  type InventoryTransactionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<InventoryTransactionFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: InventoryTransactionCountAggregateInputType | true
    }

  export interface InventoryTransactionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['InventoryTransaction'], meta: { name: 'InventoryTransaction' } }
    /**
     * Find zero or one InventoryTransaction that matches the filter.
     * @param {InventoryTransactionFindUniqueArgs} args - Arguments to find a InventoryTransaction
     * @example
     * // Get one InventoryTransaction
     * const inventoryTransaction = await prisma.inventoryTransaction.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends InventoryTransactionFindUniqueArgs>(args: SelectSubset<T, InventoryTransactionFindUniqueArgs<ExtArgs>>): Prisma__InventoryTransactionClient<$Result.GetResult<Prisma.$InventoryTransactionPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one InventoryTransaction that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {InventoryTransactionFindUniqueOrThrowArgs} args - Arguments to find a InventoryTransaction
     * @example
     * // Get one InventoryTransaction
     * const inventoryTransaction = await prisma.inventoryTransaction.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends InventoryTransactionFindUniqueOrThrowArgs>(args: SelectSubset<T, InventoryTransactionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__InventoryTransactionClient<$Result.GetResult<Prisma.$InventoryTransactionPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first InventoryTransaction that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryTransactionFindFirstArgs} args - Arguments to find a InventoryTransaction
     * @example
     * // Get one InventoryTransaction
     * const inventoryTransaction = await prisma.inventoryTransaction.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends InventoryTransactionFindFirstArgs>(args?: SelectSubset<T, InventoryTransactionFindFirstArgs<ExtArgs>>): Prisma__InventoryTransactionClient<$Result.GetResult<Prisma.$InventoryTransactionPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first InventoryTransaction that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryTransactionFindFirstOrThrowArgs} args - Arguments to find a InventoryTransaction
     * @example
     * // Get one InventoryTransaction
     * const inventoryTransaction = await prisma.inventoryTransaction.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends InventoryTransactionFindFirstOrThrowArgs>(args?: SelectSubset<T, InventoryTransactionFindFirstOrThrowArgs<ExtArgs>>): Prisma__InventoryTransactionClient<$Result.GetResult<Prisma.$InventoryTransactionPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more InventoryTransactions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryTransactionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all InventoryTransactions
     * const inventoryTransactions = await prisma.inventoryTransaction.findMany()
     * 
     * // Get first 10 InventoryTransactions
     * const inventoryTransactions = await prisma.inventoryTransaction.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const inventoryTransactionWithIdOnly = await prisma.inventoryTransaction.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends InventoryTransactionFindManyArgs>(args?: SelectSubset<T, InventoryTransactionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InventoryTransactionPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a InventoryTransaction.
     * @param {InventoryTransactionCreateArgs} args - Arguments to create a InventoryTransaction.
     * @example
     * // Create one InventoryTransaction
     * const InventoryTransaction = await prisma.inventoryTransaction.create({
     *   data: {
     *     // ... data to create a InventoryTransaction
     *   }
     * })
     * 
     */
    create<T extends InventoryTransactionCreateArgs>(args: SelectSubset<T, InventoryTransactionCreateArgs<ExtArgs>>): Prisma__InventoryTransactionClient<$Result.GetResult<Prisma.$InventoryTransactionPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many InventoryTransactions.
     * @param {InventoryTransactionCreateManyArgs} args - Arguments to create many InventoryTransactions.
     * @example
     * // Create many InventoryTransactions
     * const inventoryTransaction = await prisma.inventoryTransaction.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends InventoryTransactionCreateManyArgs>(args?: SelectSubset<T, InventoryTransactionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many InventoryTransactions and returns the data saved in the database.
     * @param {InventoryTransactionCreateManyAndReturnArgs} args - Arguments to create many InventoryTransactions.
     * @example
     * // Create many InventoryTransactions
     * const inventoryTransaction = await prisma.inventoryTransaction.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many InventoryTransactions and only return the `id`
     * const inventoryTransactionWithIdOnly = await prisma.inventoryTransaction.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends InventoryTransactionCreateManyAndReturnArgs>(args?: SelectSubset<T, InventoryTransactionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InventoryTransactionPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a InventoryTransaction.
     * @param {InventoryTransactionDeleteArgs} args - Arguments to delete one InventoryTransaction.
     * @example
     * // Delete one InventoryTransaction
     * const InventoryTransaction = await prisma.inventoryTransaction.delete({
     *   where: {
     *     // ... filter to delete one InventoryTransaction
     *   }
     * })
     * 
     */
    delete<T extends InventoryTransactionDeleteArgs>(args: SelectSubset<T, InventoryTransactionDeleteArgs<ExtArgs>>): Prisma__InventoryTransactionClient<$Result.GetResult<Prisma.$InventoryTransactionPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one InventoryTransaction.
     * @param {InventoryTransactionUpdateArgs} args - Arguments to update one InventoryTransaction.
     * @example
     * // Update one InventoryTransaction
     * const inventoryTransaction = await prisma.inventoryTransaction.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends InventoryTransactionUpdateArgs>(args: SelectSubset<T, InventoryTransactionUpdateArgs<ExtArgs>>): Prisma__InventoryTransactionClient<$Result.GetResult<Prisma.$InventoryTransactionPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more InventoryTransactions.
     * @param {InventoryTransactionDeleteManyArgs} args - Arguments to filter InventoryTransactions to delete.
     * @example
     * // Delete a few InventoryTransactions
     * const { count } = await prisma.inventoryTransaction.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends InventoryTransactionDeleteManyArgs>(args?: SelectSubset<T, InventoryTransactionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more InventoryTransactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryTransactionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many InventoryTransactions
     * const inventoryTransaction = await prisma.inventoryTransaction.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends InventoryTransactionUpdateManyArgs>(args: SelectSubset<T, InventoryTransactionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one InventoryTransaction.
     * @param {InventoryTransactionUpsertArgs} args - Arguments to update or create a InventoryTransaction.
     * @example
     * // Update or create a InventoryTransaction
     * const inventoryTransaction = await prisma.inventoryTransaction.upsert({
     *   create: {
     *     // ... data to create a InventoryTransaction
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the InventoryTransaction we want to update
     *   }
     * })
     */
    upsert<T extends InventoryTransactionUpsertArgs>(args: SelectSubset<T, InventoryTransactionUpsertArgs<ExtArgs>>): Prisma__InventoryTransactionClient<$Result.GetResult<Prisma.$InventoryTransactionPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of InventoryTransactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryTransactionCountArgs} args - Arguments to filter InventoryTransactions to count.
     * @example
     * // Count the number of InventoryTransactions
     * const count = await prisma.inventoryTransaction.count({
     *   where: {
     *     // ... the filter for the InventoryTransactions we want to count
     *   }
     * })
    **/
    count<T extends InventoryTransactionCountArgs>(
      args?: Subset<T, InventoryTransactionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InventoryTransactionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a InventoryTransaction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryTransactionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InventoryTransactionAggregateArgs>(args: Subset<T, InventoryTransactionAggregateArgs>): Prisma.PrismaPromise<GetInventoryTransactionAggregateType<T>>

    /**
     * Group by InventoryTransaction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryTransactionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends InventoryTransactionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: InventoryTransactionGroupByArgs['orderBy'] }
        : { orderBy?: InventoryTransactionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, InventoryTransactionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInventoryTransactionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the InventoryTransaction model
   */
  readonly fields: InventoryTransactionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for InventoryTransaction.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__InventoryTransactionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    tenant<T extends TenantDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TenantDefaultArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    item<T extends ItemDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ItemDefaultArgs<ExtArgs>>): Prisma__ItemClient<$Result.GetResult<Prisma.$ItemPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the InventoryTransaction model
   */ 
  interface InventoryTransactionFieldRefs {
    readonly id: FieldRef<"InventoryTransaction", 'String'>
    readonly tenantId: FieldRef<"InventoryTransaction", 'String'>
    readonly itemId: FieldRef<"InventoryTransaction", 'String'>
    readonly type: FieldRef<"InventoryTransaction", 'String'>
    readonly quantity: FieldRef<"InventoryTransaction", 'Int'>
    readonly reference: FieldRef<"InventoryTransaction", 'String'>
    readonly notes: FieldRef<"InventoryTransaction", 'String'>
    readonly handledBy: FieldRef<"InventoryTransaction", 'String'>
    readonly date: FieldRef<"InventoryTransaction", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * InventoryTransaction findUnique
   */
  export type InventoryTransactionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryTransaction
     */
    select?: InventoryTransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryTransactionInclude<ExtArgs> | null
    /**
     * Filter, which InventoryTransaction to fetch.
     */
    where: InventoryTransactionWhereUniqueInput
  }

  /**
   * InventoryTransaction findUniqueOrThrow
   */
  export type InventoryTransactionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryTransaction
     */
    select?: InventoryTransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryTransactionInclude<ExtArgs> | null
    /**
     * Filter, which InventoryTransaction to fetch.
     */
    where: InventoryTransactionWhereUniqueInput
  }

  /**
   * InventoryTransaction findFirst
   */
  export type InventoryTransactionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryTransaction
     */
    select?: InventoryTransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryTransactionInclude<ExtArgs> | null
    /**
     * Filter, which InventoryTransaction to fetch.
     */
    where?: InventoryTransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InventoryTransactions to fetch.
     */
    orderBy?: InventoryTransactionOrderByWithRelationInput | InventoryTransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for InventoryTransactions.
     */
    cursor?: InventoryTransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InventoryTransactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InventoryTransactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of InventoryTransactions.
     */
    distinct?: InventoryTransactionScalarFieldEnum | InventoryTransactionScalarFieldEnum[]
  }

  /**
   * InventoryTransaction findFirstOrThrow
   */
  export type InventoryTransactionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryTransaction
     */
    select?: InventoryTransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryTransactionInclude<ExtArgs> | null
    /**
     * Filter, which InventoryTransaction to fetch.
     */
    where?: InventoryTransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InventoryTransactions to fetch.
     */
    orderBy?: InventoryTransactionOrderByWithRelationInput | InventoryTransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for InventoryTransactions.
     */
    cursor?: InventoryTransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InventoryTransactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InventoryTransactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of InventoryTransactions.
     */
    distinct?: InventoryTransactionScalarFieldEnum | InventoryTransactionScalarFieldEnum[]
  }

  /**
   * InventoryTransaction findMany
   */
  export type InventoryTransactionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryTransaction
     */
    select?: InventoryTransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryTransactionInclude<ExtArgs> | null
    /**
     * Filter, which InventoryTransactions to fetch.
     */
    where?: InventoryTransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InventoryTransactions to fetch.
     */
    orderBy?: InventoryTransactionOrderByWithRelationInput | InventoryTransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing InventoryTransactions.
     */
    cursor?: InventoryTransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InventoryTransactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InventoryTransactions.
     */
    skip?: number
    distinct?: InventoryTransactionScalarFieldEnum | InventoryTransactionScalarFieldEnum[]
  }

  /**
   * InventoryTransaction create
   */
  export type InventoryTransactionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryTransaction
     */
    select?: InventoryTransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryTransactionInclude<ExtArgs> | null
    /**
     * The data needed to create a InventoryTransaction.
     */
    data: XOR<InventoryTransactionCreateInput, InventoryTransactionUncheckedCreateInput>
  }

  /**
   * InventoryTransaction createMany
   */
  export type InventoryTransactionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many InventoryTransactions.
     */
    data: InventoryTransactionCreateManyInput | InventoryTransactionCreateManyInput[]
  }

  /**
   * InventoryTransaction createManyAndReturn
   */
  export type InventoryTransactionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryTransaction
     */
    select?: InventoryTransactionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many InventoryTransactions.
     */
    data: InventoryTransactionCreateManyInput | InventoryTransactionCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryTransactionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * InventoryTransaction update
   */
  export type InventoryTransactionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryTransaction
     */
    select?: InventoryTransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryTransactionInclude<ExtArgs> | null
    /**
     * The data needed to update a InventoryTransaction.
     */
    data: XOR<InventoryTransactionUpdateInput, InventoryTransactionUncheckedUpdateInput>
    /**
     * Choose, which InventoryTransaction to update.
     */
    where: InventoryTransactionWhereUniqueInput
  }

  /**
   * InventoryTransaction updateMany
   */
  export type InventoryTransactionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update InventoryTransactions.
     */
    data: XOR<InventoryTransactionUpdateManyMutationInput, InventoryTransactionUncheckedUpdateManyInput>
    /**
     * Filter which InventoryTransactions to update
     */
    where?: InventoryTransactionWhereInput
  }

  /**
   * InventoryTransaction upsert
   */
  export type InventoryTransactionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryTransaction
     */
    select?: InventoryTransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryTransactionInclude<ExtArgs> | null
    /**
     * The filter to search for the InventoryTransaction to update in case it exists.
     */
    where: InventoryTransactionWhereUniqueInput
    /**
     * In case the InventoryTransaction found by the `where` argument doesn't exist, create a new InventoryTransaction with this data.
     */
    create: XOR<InventoryTransactionCreateInput, InventoryTransactionUncheckedCreateInput>
    /**
     * In case the InventoryTransaction was found with the provided `where` argument, update it with this data.
     */
    update: XOR<InventoryTransactionUpdateInput, InventoryTransactionUncheckedUpdateInput>
  }

  /**
   * InventoryTransaction delete
   */
  export type InventoryTransactionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryTransaction
     */
    select?: InventoryTransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryTransactionInclude<ExtArgs> | null
    /**
     * Filter which InventoryTransaction to delete.
     */
    where: InventoryTransactionWhereUniqueInput
  }

  /**
   * InventoryTransaction deleteMany
   */
  export type InventoryTransactionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which InventoryTransactions to delete
     */
    where?: InventoryTransactionWhereInput
  }

  /**
   * InventoryTransaction without action
   */
  export type InventoryTransactionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryTransaction
     */
    select?: InventoryTransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryTransactionInclude<ExtArgs> | null
  }


  /**
   * Model Supplier
   */

  export type AggregateSupplier = {
    _count: SupplierCountAggregateOutputType | null
    _min: SupplierMinAggregateOutputType | null
    _max: SupplierMaxAggregateOutputType | null
  }

  export type SupplierMinAggregateOutputType = {
    id: string | null
    tenantId: string | null
    name: string | null
    contact: string | null
    address: string | null
    email: string | null
    createdAt: Date | null
  }

  export type SupplierMaxAggregateOutputType = {
    id: string | null
    tenantId: string | null
    name: string | null
    contact: string | null
    address: string | null
    email: string | null
    createdAt: Date | null
  }

  export type SupplierCountAggregateOutputType = {
    id: number
    tenantId: number
    name: number
    contact: number
    address: number
    email: number
    createdAt: number
    _all: number
  }


  export type SupplierMinAggregateInputType = {
    id?: true
    tenantId?: true
    name?: true
    contact?: true
    address?: true
    email?: true
    createdAt?: true
  }

  export type SupplierMaxAggregateInputType = {
    id?: true
    tenantId?: true
    name?: true
    contact?: true
    address?: true
    email?: true
    createdAt?: true
  }

  export type SupplierCountAggregateInputType = {
    id?: true
    tenantId?: true
    name?: true
    contact?: true
    address?: true
    email?: true
    createdAt?: true
    _all?: true
  }

  export type SupplierAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Supplier to aggregate.
     */
    where?: SupplierWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Suppliers to fetch.
     */
    orderBy?: SupplierOrderByWithRelationInput | SupplierOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SupplierWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Suppliers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Suppliers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Suppliers
    **/
    _count?: true | SupplierCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SupplierMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SupplierMaxAggregateInputType
  }

  export type GetSupplierAggregateType<T extends SupplierAggregateArgs> = {
        [P in keyof T & keyof AggregateSupplier]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSupplier[P]>
      : GetScalarType<T[P], AggregateSupplier[P]>
  }




  export type SupplierGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SupplierWhereInput
    orderBy?: SupplierOrderByWithAggregationInput | SupplierOrderByWithAggregationInput[]
    by: SupplierScalarFieldEnum[] | SupplierScalarFieldEnum
    having?: SupplierScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SupplierCountAggregateInputType | true
    _min?: SupplierMinAggregateInputType
    _max?: SupplierMaxAggregateInputType
  }

  export type SupplierGroupByOutputType = {
    id: string
    tenantId: string
    name: string
    contact: string | null
    address: string | null
    email: string | null
    createdAt: Date
    _count: SupplierCountAggregateOutputType | null
    _min: SupplierMinAggregateOutputType | null
    _max: SupplierMaxAggregateOutputType | null
  }

  type GetSupplierGroupByPayload<T extends SupplierGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SupplierGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SupplierGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SupplierGroupByOutputType[P]>
            : GetScalarType<T[P], SupplierGroupByOutputType[P]>
        }
      >
    >


  export type SupplierSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    name?: boolean
    contact?: boolean
    address?: boolean
    email?: boolean
    createdAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    purchaseOrders?: boolean | Supplier$purchaseOrdersArgs<ExtArgs>
    _count?: boolean | SupplierCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["supplier"]>

  export type SupplierSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    name?: boolean
    contact?: boolean
    address?: boolean
    email?: boolean
    createdAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["supplier"]>

  export type SupplierSelectScalar = {
    id?: boolean
    tenantId?: boolean
    name?: boolean
    contact?: boolean
    address?: boolean
    email?: boolean
    createdAt?: boolean
  }

  export type SupplierInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    purchaseOrders?: boolean | Supplier$purchaseOrdersArgs<ExtArgs>
    _count?: boolean | SupplierCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type SupplierIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }

  export type $SupplierPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Supplier"
    objects: {
      tenant: Prisma.$TenantPayload<ExtArgs>
      purchaseOrders: Prisma.$PurchaseOrderPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      tenantId: string
      name: string
      contact: string | null
      address: string | null
      email: string | null
      createdAt: Date
    }, ExtArgs["result"]["supplier"]>
    composites: {}
  }

  type SupplierGetPayload<S extends boolean | null | undefined | SupplierDefaultArgs> = $Result.GetResult<Prisma.$SupplierPayload, S>

  type SupplierCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<SupplierFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: SupplierCountAggregateInputType | true
    }

  export interface SupplierDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Supplier'], meta: { name: 'Supplier' } }
    /**
     * Find zero or one Supplier that matches the filter.
     * @param {SupplierFindUniqueArgs} args - Arguments to find a Supplier
     * @example
     * // Get one Supplier
     * const supplier = await prisma.supplier.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SupplierFindUniqueArgs>(args: SelectSubset<T, SupplierFindUniqueArgs<ExtArgs>>): Prisma__SupplierClient<$Result.GetResult<Prisma.$SupplierPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Supplier that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {SupplierFindUniqueOrThrowArgs} args - Arguments to find a Supplier
     * @example
     * // Get one Supplier
     * const supplier = await prisma.supplier.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SupplierFindUniqueOrThrowArgs>(args: SelectSubset<T, SupplierFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SupplierClient<$Result.GetResult<Prisma.$SupplierPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Supplier that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupplierFindFirstArgs} args - Arguments to find a Supplier
     * @example
     * // Get one Supplier
     * const supplier = await prisma.supplier.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SupplierFindFirstArgs>(args?: SelectSubset<T, SupplierFindFirstArgs<ExtArgs>>): Prisma__SupplierClient<$Result.GetResult<Prisma.$SupplierPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Supplier that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupplierFindFirstOrThrowArgs} args - Arguments to find a Supplier
     * @example
     * // Get one Supplier
     * const supplier = await prisma.supplier.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SupplierFindFirstOrThrowArgs>(args?: SelectSubset<T, SupplierFindFirstOrThrowArgs<ExtArgs>>): Prisma__SupplierClient<$Result.GetResult<Prisma.$SupplierPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Suppliers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupplierFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Suppliers
     * const suppliers = await prisma.supplier.findMany()
     * 
     * // Get first 10 Suppliers
     * const suppliers = await prisma.supplier.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const supplierWithIdOnly = await prisma.supplier.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SupplierFindManyArgs>(args?: SelectSubset<T, SupplierFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SupplierPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Supplier.
     * @param {SupplierCreateArgs} args - Arguments to create a Supplier.
     * @example
     * // Create one Supplier
     * const Supplier = await prisma.supplier.create({
     *   data: {
     *     // ... data to create a Supplier
     *   }
     * })
     * 
     */
    create<T extends SupplierCreateArgs>(args: SelectSubset<T, SupplierCreateArgs<ExtArgs>>): Prisma__SupplierClient<$Result.GetResult<Prisma.$SupplierPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Suppliers.
     * @param {SupplierCreateManyArgs} args - Arguments to create many Suppliers.
     * @example
     * // Create many Suppliers
     * const supplier = await prisma.supplier.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SupplierCreateManyArgs>(args?: SelectSubset<T, SupplierCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Suppliers and returns the data saved in the database.
     * @param {SupplierCreateManyAndReturnArgs} args - Arguments to create many Suppliers.
     * @example
     * // Create many Suppliers
     * const supplier = await prisma.supplier.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Suppliers and only return the `id`
     * const supplierWithIdOnly = await prisma.supplier.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SupplierCreateManyAndReturnArgs>(args?: SelectSubset<T, SupplierCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SupplierPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Supplier.
     * @param {SupplierDeleteArgs} args - Arguments to delete one Supplier.
     * @example
     * // Delete one Supplier
     * const Supplier = await prisma.supplier.delete({
     *   where: {
     *     // ... filter to delete one Supplier
     *   }
     * })
     * 
     */
    delete<T extends SupplierDeleteArgs>(args: SelectSubset<T, SupplierDeleteArgs<ExtArgs>>): Prisma__SupplierClient<$Result.GetResult<Prisma.$SupplierPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Supplier.
     * @param {SupplierUpdateArgs} args - Arguments to update one Supplier.
     * @example
     * // Update one Supplier
     * const supplier = await prisma.supplier.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SupplierUpdateArgs>(args: SelectSubset<T, SupplierUpdateArgs<ExtArgs>>): Prisma__SupplierClient<$Result.GetResult<Prisma.$SupplierPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Suppliers.
     * @param {SupplierDeleteManyArgs} args - Arguments to filter Suppliers to delete.
     * @example
     * // Delete a few Suppliers
     * const { count } = await prisma.supplier.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SupplierDeleteManyArgs>(args?: SelectSubset<T, SupplierDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Suppliers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupplierUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Suppliers
     * const supplier = await prisma.supplier.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SupplierUpdateManyArgs>(args: SelectSubset<T, SupplierUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Supplier.
     * @param {SupplierUpsertArgs} args - Arguments to update or create a Supplier.
     * @example
     * // Update or create a Supplier
     * const supplier = await prisma.supplier.upsert({
     *   create: {
     *     // ... data to create a Supplier
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Supplier we want to update
     *   }
     * })
     */
    upsert<T extends SupplierUpsertArgs>(args: SelectSubset<T, SupplierUpsertArgs<ExtArgs>>): Prisma__SupplierClient<$Result.GetResult<Prisma.$SupplierPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Suppliers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupplierCountArgs} args - Arguments to filter Suppliers to count.
     * @example
     * // Count the number of Suppliers
     * const count = await prisma.supplier.count({
     *   where: {
     *     // ... the filter for the Suppliers we want to count
     *   }
     * })
    **/
    count<T extends SupplierCountArgs>(
      args?: Subset<T, SupplierCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SupplierCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Supplier.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupplierAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SupplierAggregateArgs>(args: Subset<T, SupplierAggregateArgs>): Prisma.PrismaPromise<GetSupplierAggregateType<T>>

    /**
     * Group by Supplier.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupplierGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SupplierGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SupplierGroupByArgs['orderBy'] }
        : { orderBy?: SupplierGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SupplierGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSupplierGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Supplier model
   */
  readonly fields: SupplierFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Supplier.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SupplierClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    tenant<T extends TenantDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TenantDefaultArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    purchaseOrders<T extends Supplier$purchaseOrdersArgs<ExtArgs> = {}>(args?: Subset<T, Supplier$purchaseOrdersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PurchaseOrderPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Supplier model
   */ 
  interface SupplierFieldRefs {
    readonly id: FieldRef<"Supplier", 'String'>
    readonly tenantId: FieldRef<"Supplier", 'String'>
    readonly name: FieldRef<"Supplier", 'String'>
    readonly contact: FieldRef<"Supplier", 'String'>
    readonly address: FieldRef<"Supplier", 'String'>
    readonly email: FieldRef<"Supplier", 'String'>
    readonly createdAt: FieldRef<"Supplier", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Supplier findUnique
   */
  export type SupplierFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Supplier
     */
    select?: SupplierSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierInclude<ExtArgs> | null
    /**
     * Filter, which Supplier to fetch.
     */
    where: SupplierWhereUniqueInput
  }

  /**
   * Supplier findUniqueOrThrow
   */
  export type SupplierFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Supplier
     */
    select?: SupplierSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierInclude<ExtArgs> | null
    /**
     * Filter, which Supplier to fetch.
     */
    where: SupplierWhereUniqueInput
  }

  /**
   * Supplier findFirst
   */
  export type SupplierFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Supplier
     */
    select?: SupplierSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierInclude<ExtArgs> | null
    /**
     * Filter, which Supplier to fetch.
     */
    where?: SupplierWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Suppliers to fetch.
     */
    orderBy?: SupplierOrderByWithRelationInput | SupplierOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Suppliers.
     */
    cursor?: SupplierWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Suppliers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Suppliers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Suppliers.
     */
    distinct?: SupplierScalarFieldEnum | SupplierScalarFieldEnum[]
  }

  /**
   * Supplier findFirstOrThrow
   */
  export type SupplierFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Supplier
     */
    select?: SupplierSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierInclude<ExtArgs> | null
    /**
     * Filter, which Supplier to fetch.
     */
    where?: SupplierWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Suppliers to fetch.
     */
    orderBy?: SupplierOrderByWithRelationInput | SupplierOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Suppliers.
     */
    cursor?: SupplierWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Suppliers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Suppliers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Suppliers.
     */
    distinct?: SupplierScalarFieldEnum | SupplierScalarFieldEnum[]
  }

  /**
   * Supplier findMany
   */
  export type SupplierFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Supplier
     */
    select?: SupplierSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierInclude<ExtArgs> | null
    /**
     * Filter, which Suppliers to fetch.
     */
    where?: SupplierWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Suppliers to fetch.
     */
    orderBy?: SupplierOrderByWithRelationInput | SupplierOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Suppliers.
     */
    cursor?: SupplierWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Suppliers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Suppliers.
     */
    skip?: number
    distinct?: SupplierScalarFieldEnum | SupplierScalarFieldEnum[]
  }

  /**
   * Supplier create
   */
  export type SupplierCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Supplier
     */
    select?: SupplierSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierInclude<ExtArgs> | null
    /**
     * The data needed to create a Supplier.
     */
    data: XOR<SupplierCreateInput, SupplierUncheckedCreateInput>
  }

  /**
   * Supplier createMany
   */
  export type SupplierCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Suppliers.
     */
    data: SupplierCreateManyInput | SupplierCreateManyInput[]
  }

  /**
   * Supplier createManyAndReturn
   */
  export type SupplierCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Supplier
     */
    select?: SupplierSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Suppliers.
     */
    data: SupplierCreateManyInput | SupplierCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Supplier update
   */
  export type SupplierUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Supplier
     */
    select?: SupplierSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierInclude<ExtArgs> | null
    /**
     * The data needed to update a Supplier.
     */
    data: XOR<SupplierUpdateInput, SupplierUncheckedUpdateInput>
    /**
     * Choose, which Supplier to update.
     */
    where: SupplierWhereUniqueInput
  }

  /**
   * Supplier updateMany
   */
  export type SupplierUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Suppliers.
     */
    data: XOR<SupplierUpdateManyMutationInput, SupplierUncheckedUpdateManyInput>
    /**
     * Filter which Suppliers to update
     */
    where?: SupplierWhereInput
  }

  /**
   * Supplier upsert
   */
  export type SupplierUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Supplier
     */
    select?: SupplierSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierInclude<ExtArgs> | null
    /**
     * The filter to search for the Supplier to update in case it exists.
     */
    where: SupplierWhereUniqueInput
    /**
     * In case the Supplier found by the `where` argument doesn't exist, create a new Supplier with this data.
     */
    create: XOR<SupplierCreateInput, SupplierUncheckedCreateInput>
    /**
     * In case the Supplier was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SupplierUpdateInput, SupplierUncheckedUpdateInput>
  }

  /**
   * Supplier delete
   */
  export type SupplierDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Supplier
     */
    select?: SupplierSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierInclude<ExtArgs> | null
    /**
     * Filter which Supplier to delete.
     */
    where: SupplierWhereUniqueInput
  }

  /**
   * Supplier deleteMany
   */
  export type SupplierDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Suppliers to delete
     */
    where?: SupplierWhereInput
  }

  /**
   * Supplier.purchaseOrders
   */
  export type Supplier$purchaseOrdersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseOrder
     */
    select?: PurchaseOrderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseOrderInclude<ExtArgs> | null
    where?: PurchaseOrderWhereInput
    orderBy?: PurchaseOrderOrderByWithRelationInput | PurchaseOrderOrderByWithRelationInput[]
    cursor?: PurchaseOrderWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PurchaseOrderScalarFieldEnum | PurchaseOrderScalarFieldEnum[]
  }

  /**
   * Supplier without action
   */
  export type SupplierDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Supplier
     */
    select?: SupplierSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupplierInclude<ExtArgs> | null
  }


  /**
   * Model PurchaseOrder
   */

  export type AggregatePurchaseOrder = {
    _count: PurchaseOrderCountAggregateOutputType | null
    _avg: PurchaseOrderAvgAggregateOutputType | null
    _sum: PurchaseOrderSumAggregateOutputType | null
    _min: PurchaseOrderMinAggregateOutputType | null
    _max: PurchaseOrderMaxAggregateOutputType | null
  }

  export type PurchaseOrderAvgAggregateOutputType = {
    totalCost: number | null
  }

  export type PurchaseOrderSumAggregateOutputType = {
    totalCost: number | null
  }

  export type PurchaseOrderMinAggregateOutputType = {
    id: string | null
    tenantId: string | null
    supplierId: string | null
    poNumber: string | null
    totalCost: number | null
    status: string | null
    orderDate: Date | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PurchaseOrderMaxAggregateOutputType = {
    id: string | null
    tenantId: string | null
    supplierId: string | null
    poNumber: string | null
    totalCost: number | null
    status: string | null
    orderDate: Date | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PurchaseOrderCountAggregateOutputType = {
    id: number
    tenantId: number
    supplierId: number
    poNumber: number
    totalCost: number
    status: number
    orderDate: number
    notes: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PurchaseOrderAvgAggregateInputType = {
    totalCost?: true
  }

  export type PurchaseOrderSumAggregateInputType = {
    totalCost?: true
  }

  export type PurchaseOrderMinAggregateInputType = {
    id?: true
    tenantId?: true
    supplierId?: true
    poNumber?: true
    totalCost?: true
    status?: true
    orderDate?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PurchaseOrderMaxAggregateInputType = {
    id?: true
    tenantId?: true
    supplierId?: true
    poNumber?: true
    totalCost?: true
    status?: true
    orderDate?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PurchaseOrderCountAggregateInputType = {
    id?: true
    tenantId?: true
    supplierId?: true
    poNumber?: true
    totalCost?: true
    status?: true
    orderDate?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PurchaseOrderAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PurchaseOrder to aggregate.
     */
    where?: PurchaseOrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PurchaseOrders to fetch.
     */
    orderBy?: PurchaseOrderOrderByWithRelationInput | PurchaseOrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PurchaseOrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PurchaseOrders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PurchaseOrders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PurchaseOrders
    **/
    _count?: true | PurchaseOrderCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PurchaseOrderAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PurchaseOrderSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PurchaseOrderMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PurchaseOrderMaxAggregateInputType
  }

  export type GetPurchaseOrderAggregateType<T extends PurchaseOrderAggregateArgs> = {
        [P in keyof T & keyof AggregatePurchaseOrder]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePurchaseOrder[P]>
      : GetScalarType<T[P], AggregatePurchaseOrder[P]>
  }




  export type PurchaseOrderGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PurchaseOrderWhereInput
    orderBy?: PurchaseOrderOrderByWithAggregationInput | PurchaseOrderOrderByWithAggregationInput[]
    by: PurchaseOrderScalarFieldEnum[] | PurchaseOrderScalarFieldEnum
    having?: PurchaseOrderScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PurchaseOrderCountAggregateInputType | true
    _avg?: PurchaseOrderAvgAggregateInputType
    _sum?: PurchaseOrderSumAggregateInputType
    _min?: PurchaseOrderMinAggregateInputType
    _max?: PurchaseOrderMaxAggregateInputType
  }

  export type PurchaseOrderGroupByOutputType = {
    id: string
    tenantId: string
    supplierId: string
    poNumber: string
    totalCost: number
    status: string
    orderDate: Date
    notes: string | null
    createdAt: Date
    updatedAt: Date
    _count: PurchaseOrderCountAggregateOutputType | null
    _avg: PurchaseOrderAvgAggregateOutputType | null
    _sum: PurchaseOrderSumAggregateOutputType | null
    _min: PurchaseOrderMinAggregateOutputType | null
    _max: PurchaseOrderMaxAggregateOutputType | null
  }

  type GetPurchaseOrderGroupByPayload<T extends PurchaseOrderGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PurchaseOrderGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PurchaseOrderGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PurchaseOrderGroupByOutputType[P]>
            : GetScalarType<T[P], PurchaseOrderGroupByOutputType[P]>
        }
      >
    >


  export type PurchaseOrderSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    supplierId?: boolean
    poNumber?: boolean
    totalCost?: boolean
    status?: boolean
    orderDate?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    supplier?: boolean | SupplierDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["purchaseOrder"]>

  export type PurchaseOrderSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    supplierId?: boolean
    poNumber?: boolean
    totalCost?: boolean
    status?: boolean
    orderDate?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    supplier?: boolean | SupplierDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["purchaseOrder"]>

  export type PurchaseOrderSelectScalar = {
    id?: boolean
    tenantId?: boolean
    supplierId?: boolean
    poNumber?: boolean
    totalCost?: boolean
    status?: boolean
    orderDate?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PurchaseOrderInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    supplier?: boolean | SupplierDefaultArgs<ExtArgs>
  }
  export type PurchaseOrderIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    supplier?: boolean | SupplierDefaultArgs<ExtArgs>
  }

  export type $PurchaseOrderPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PurchaseOrder"
    objects: {
      tenant: Prisma.$TenantPayload<ExtArgs>
      supplier: Prisma.$SupplierPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      tenantId: string
      supplierId: string
      poNumber: string
      totalCost: number
      status: string
      orderDate: Date
      notes: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["purchaseOrder"]>
    composites: {}
  }

  type PurchaseOrderGetPayload<S extends boolean | null | undefined | PurchaseOrderDefaultArgs> = $Result.GetResult<Prisma.$PurchaseOrderPayload, S>

  type PurchaseOrderCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<PurchaseOrderFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PurchaseOrderCountAggregateInputType | true
    }

  export interface PurchaseOrderDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PurchaseOrder'], meta: { name: 'PurchaseOrder' } }
    /**
     * Find zero or one PurchaseOrder that matches the filter.
     * @param {PurchaseOrderFindUniqueArgs} args - Arguments to find a PurchaseOrder
     * @example
     * // Get one PurchaseOrder
     * const purchaseOrder = await prisma.purchaseOrder.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PurchaseOrderFindUniqueArgs>(args: SelectSubset<T, PurchaseOrderFindUniqueArgs<ExtArgs>>): Prisma__PurchaseOrderClient<$Result.GetResult<Prisma.$PurchaseOrderPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one PurchaseOrder that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {PurchaseOrderFindUniqueOrThrowArgs} args - Arguments to find a PurchaseOrder
     * @example
     * // Get one PurchaseOrder
     * const purchaseOrder = await prisma.purchaseOrder.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PurchaseOrderFindUniqueOrThrowArgs>(args: SelectSubset<T, PurchaseOrderFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PurchaseOrderClient<$Result.GetResult<Prisma.$PurchaseOrderPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first PurchaseOrder that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseOrderFindFirstArgs} args - Arguments to find a PurchaseOrder
     * @example
     * // Get one PurchaseOrder
     * const purchaseOrder = await prisma.purchaseOrder.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PurchaseOrderFindFirstArgs>(args?: SelectSubset<T, PurchaseOrderFindFirstArgs<ExtArgs>>): Prisma__PurchaseOrderClient<$Result.GetResult<Prisma.$PurchaseOrderPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first PurchaseOrder that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseOrderFindFirstOrThrowArgs} args - Arguments to find a PurchaseOrder
     * @example
     * // Get one PurchaseOrder
     * const purchaseOrder = await prisma.purchaseOrder.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PurchaseOrderFindFirstOrThrowArgs>(args?: SelectSubset<T, PurchaseOrderFindFirstOrThrowArgs<ExtArgs>>): Prisma__PurchaseOrderClient<$Result.GetResult<Prisma.$PurchaseOrderPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more PurchaseOrders that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseOrderFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PurchaseOrders
     * const purchaseOrders = await prisma.purchaseOrder.findMany()
     * 
     * // Get first 10 PurchaseOrders
     * const purchaseOrders = await prisma.purchaseOrder.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const purchaseOrderWithIdOnly = await prisma.purchaseOrder.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PurchaseOrderFindManyArgs>(args?: SelectSubset<T, PurchaseOrderFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PurchaseOrderPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a PurchaseOrder.
     * @param {PurchaseOrderCreateArgs} args - Arguments to create a PurchaseOrder.
     * @example
     * // Create one PurchaseOrder
     * const PurchaseOrder = await prisma.purchaseOrder.create({
     *   data: {
     *     // ... data to create a PurchaseOrder
     *   }
     * })
     * 
     */
    create<T extends PurchaseOrderCreateArgs>(args: SelectSubset<T, PurchaseOrderCreateArgs<ExtArgs>>): Prisma__PurchaseOrderClient<$Result.GetResult<Prisma.$PurchaseOrderPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many PurchaseOrders.
     * @param {PurchaseOrderCreateManyArgs} args - Arguments to create many PurchaseOrders.
     * @example
     * // Create many PurchaseOrders
     * const purchaseOrder = await prisma.purchaseOrder.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PurchaseOrderCreateManyArgs>(args?: SelectSubset<T, PurchaseOrderCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PurchaseOrders and returns the data saved in the database.
     * @param {PurchaseOrderCreateManyAndReturnArgs} args - Arguments to create many PurchaseOrders.
     * @example
     * // Create many PurchaseOrders
     * const purchaseOrder = await prisma.purchaseOrder.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PurchaseOrders and only return the `id`
     * const purchaseOrderWithIdOnly = await prisma.purchaseOrder.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PurchaseOrderCreateManyAndReturnArgs>(args?: SelectSubset<T, PurchaseOrderCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PurchaseOrderPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a PurchaseOrder.
     * @param {PurchaseOrderDeleteArgs} args - Arguments to delete one PurchaseOrder.
     * @example
     * // Delete one PurchaseOrder
     * const PurchaseOrder = await prisma.purchaseOrder.delete({
     *   where: {
     *     // ... filter to delete one PurchaseOrder
     *   }
     * })
     * 
     */
    delete<T extends PurchaseOrderDeleteArgs>(args: SelectSubset<T, PurchaseOrderDeleteArgs<ExtArgs>>): Prisma__PurchaseOrderClient<$Result.GetResult<Prisma.$PurchaseOrderPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one PurchaseOrder.
     * @param {PurchaseOrderUpdateArgs} args - Arguments to update one PurchaseOrder.
     * @example
     * // Update one PurchaseOrder
     * const purchaseOrder = await prisma.purchaseOrder.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PurchaseOrderUpdateArgs>(args: SelectSubset<T, PurchaseOrderUpdateArgs<ExtArgs>>): Prisma__PurchaseOrderClient<$Result.GetResult<Prisma.$PurchaseOrderPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more PurchaseOrders.
     * @param {PurchaseOrderDeleteManyArgs} args - Arguments to filter PurchaseOrders to delete.
     * @example
     * // Delete a few PurchaseOrders
     * const { count } = await prisma.purchaseOrder.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PurchaseOrderDeleteManyArgs>(args?: SelectSubset<T, PurchaseOrderDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PurchaseOrders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseOrderUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PurchaseOrders
     * const purchaseOrder = await prisma.purchaseOrder.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PurchaseOrderUpdateManyArgs>(args: SelectSubset<T, PurchaseOrderUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one PurchaseOrder.
     * @param {PurchaseOrderUpsertArgs} args - Arguments to update or create a PurchaseOrder.
     * @example
     * // Update or create a PurchaseOrder
     * const purchaseOrder = await prisma.purchaseOrder.upsert({
     *   create: {
     *     // ... data to create a PurchaseOrder
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PurchaseOrder we want to update
     *   }
     * })
     */
    upsert<T extends PurchaseOrderUpsertArgs>(args: SelectSubset<T, PurchaseOrderUpsertArgs<ExtArgs>>): Prisma__PurchaseOrderClient<$Result.GetResult<Prisma.$PurchaseOrderPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of PurchaseOrders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseOrderCountArgs} args - Arguments to filter PurchaseOrders to count.
     * @example
     * // Count the number of PurchaseOrders
     * const count = await prisma.purchaseOrder.count({
     *   where: {
     *     // ... the filter for the PurchaseOrders we want to count
     *   }
     * })
    **/
    count<T extends PurchaseOrderCountArgs>(
      args?: Subset<T, PurchaseOrderCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PurchaseOrderCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PurchaseOrder.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseOrderAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PurchaseOrderAggregateArgs>(args: Subset<T, PurchaseOrderAggregateArgs>): Prisma.PrismaPromise<GetPurchaseOrderAggregateType<T>>

    /**
     * Group by PurchaseOrder.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseOrderGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PurchaseOrderGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PurchaseOrderGroupByArgs['orderBy'] }
        : { orderBy?: PurchaseOrderGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PurchaseOrderGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPurchaseOrderGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PurchaseOrder model
   */
  readonly fields: PurchaseOrderFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PurchaseOrder.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PurchaseOrderClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    tenant<T extends TenantDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TenantDefaultArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    supplier<T extends SupplierDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SupplierDefaultArgs<ExtArgs>>): Prisma__SupplierClient<$Result.GetResult<Prisma.$SupplierPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PurchaseOrder model
   */ 
  interface PurchaseOrderFieldRefs {
    readonly id: FieldRef<"PurchaseOrder", 'String'>
    readonly tenantId: FieldRef<"PurchaseOrder", 'String'>
    readonly supplierId: FieldRef<"PurchaseOrder", 'String'>
    readonly poNumber: FieldRef<"PurchaseOrder", 'String'>
    readonly totalCost: FieldRef<"PurchaseOrder", 'Float'>
    readonly status: FieldRef<"PurchaseOrder", 'String'>
    readonly orderDate: FieldRef<"PurchaseOrder", 'DateTime'>
    readonly notes: FieldRef<"PurchaseOrder", 'String'>
    readonly createdAt: FieldRef<"PurchaseOrder", 'DateTime'>
    readonly updatedAt: FieldRef<"PurchaseOrder", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PurchaseOrder findUnique
   */
  export type PurchaseOrderFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseOrder
     */
    select?: PurchaseOrderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseOrderInclude<ExtArgs> | null
    /**
     * Filter, which PurchaseOrder to fetch.
     */
    where: PurchaseOrderWhereUniqueInput
  }

  /**
   * PurchaseOrder findUniqueOrThrow
   */
  export type PurchaseOrderFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseOrder
     */
    select?: PurchaseOrderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseOrderInclude<ExtArgs> | null
    /**
     * Filter, which PurchaseOrder to fetch.
     */
    where: PurchaseOrderWhereUniqueInput
  }

  /**
   * PurchaseOrder findFirst
   */
  export type PurchaseOrderFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseOrder
     */
    select?: PurchaseOrderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseOrderInclude<ExtArgs> | null
    /**
     * Filter, which PurchaseOrder to fetch.
     */
    where?: PurchaseOrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PurchaseOrders to fetch.
     */
    orderBy?: PurchaseOrderOrderByWithRelationInput | PurchaseOrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PurchaseOrders.
     */
    cursor?: PurchaseOrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PurchaseOrders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PurchaseOrders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PurchaseOrders.
     */
    distinct?: PurchaseOrderScalarFieldEnum | PurchaseOrderScalarFieldEnum[]
  }

  /**
   * PurchaseOrder findFirstOrThrow
   */
  export type PurchaseOrderFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseOrder
     */
    select?: PurchaseOrderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseOrderInclude<ExtArgs> | null
    /**
     * Filter, which PurchaseOrder to fetch.
     */
    where?: PurchaseOrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PurchaseOrders to fetch.
     */
    orderBy?: PurchaseOrderOrderByWithRelationInput | PurchaseOrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PurchaseOrders.
     */
    cursor?: PurchaseOrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PurchaseOrders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PurchaseOrders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PurchaseOrders.
     */
    distinct?: PurchaseOrderScalarFieldEnum | PurchaseOrderScalarFieldEnum[]
  }

  /**
   * PurchaseOrder findMany
   */
  export type PurchaseOrderFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseOrder
     */
    select?: PurchaseOrderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseOrderInclude<ExtArgs> | null
    /**
     * Filter, which PurchaseOrders to fetch.
     */
    where?: PurchaseOrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PurchaseOrders to fetch.
     */
    orderBy?: PurchaseOrderOrderByWithRelationInput | PurchaseOrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PurchaseOrders.
     */
    cursor?: PurchaseOrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PurchaseOrders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PurchaseOrders.
     */
    skip?: number
    distinct?: PurchaseOrderScalarFieldEnum | PurchaseOrderScalarFieldEnum[]
  }

  /**
   * PurchaseOrder create
   */
  export type PurchaseOrderCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseOrder
     */
    select?: PurchaseOrderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseOrderInclude<ExtArgs> | null
    /**
     * The data needed to create a PurchaseOrder.
     */
    data: XOR<PurchaseOrderCreateInput, PurchaseOrderUncheckedCreateInput>
  }

  /**
   * PurchaseOrder createMany
   */
  export type PurchaseOrderCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PurchaseOrders.
     */
    data: PurchaseOrderCreateManyInput | PurchaseOrderCreateManyInput[]
  }

  /**
   * PurchaseOrder createManyAndReturn
   */
  export type PurchaseOrderCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseOrder
     */
    select?: PurchaseOrderSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many PurchaseOrders.
     */
    data: PurchaseOrderCreateManyInput | PurchaseOrderCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseOrderIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PurchaseOrder update
   */
  export type PurchaseOrderUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseOrder
     */
    select?: PurchaseOrderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseOrderInclude<ExtArgs> | null
    /**
     * The data needed to update a PurchaseOrder.
     */
    data: XOR<PurchaseOrderUpdateInput, PurchaseOrderUncheckedUpdateInput>
    /**
     * Choose, which PurchaseOrder to update.
     */
    where: PurchaseOrderWhereUniqueInput
  }

  /**
   * PurchaseOrder updateMany
   */
  export type PurchaseOrderUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PurchaseOrders.
     */
    data: XOR<PurchaseOrderUpdateManyMutationInput, PurchaseOrderUncheckedUpdateManyInput>
    /**
     * Filter which PurchaseOrders to update
     */
    where?: PurchaseOrderWhereInput
  }

  /**
   * PurchaseOrder upsert
   */
  export type PurchaseOrderUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseOrder
     */
    select?: PurchaseOrderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseOrderInclude<ExtArgs> | null
    /**
     * The filter to search for the PurchaseOrder to update in case it exists.
     */
    where: PurchaseOrderWhereUniqueInput
    /**
     * In case the PurchaseOrder found by the `where` argument doesn't exist, create a new PurchaseOrder with this data.
     */
    create: XOR<PurchaseOrderCreateInput, PurchaseOrderUncheckedCreateInput>
    /**
     * In case the PurchaseOrder was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PurchaseOrderUpdateInput, PurchaseOrderUncheckedUpdateInput>
  }

  /**
   * PurchaseOrder delete
   */
  export type PurchaseOrderDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseOrder
     */
    select?: PurchaseOrderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseOrderInclude<ExtArgs> | null
    /**
     * Filter which PurchaseOrder to delete.
     */
    where: PurchaseOrderWhereUniqueInput
  }

  /**
   * PurchaseOrder deleteMany
   */
  export type PurchaseOrderDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PurchaseOrders to delete
     */
    where?: PurchaseOrderWhereInput
  }

  /**
   * PurchaseOrder without action
   */
  export type PurchaseOrderDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseOrder
     */
    select?: PurchaseOrderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseOrderInclude<ExtArgs> | null
  }


  /**
   * Model Building
   */

  export type AggregateBuilding = {
    _count: BuildingCountAggregateOutputType | null
    _avg: BuildingAvgAggregateOutputType | null
    _sum: BuildingSumAggregateOutputType | null
    _min: BuildingMinAggregateOutputType | null
    _max: BuildingMaxAggregateOutputType | null
  }

  export type BuildingAvgAggregateOutputType = {
    capacity: number | null
  }

  export type BuildingSumAggregateOutputType = {
    capacity: number | null
  }

  export type BuildingMinAggregateOutputType = {
    id: string | null
    tenantId: string | null
    name: string | null
    description: string | null
    gender: string | null
    capacity: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BuildingMaxAggregateOutputType = {
    id: string | null
    tenantId: string | null
    name: string | null
    description: string | null
    gender: string | null
    capacity: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BuildingCountAggregateOutputType = {
    id: number
    tenantId: number
    name: number
    description: number
    gender: number
    capacity: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type BuildingAvgAggregateInputType = {
    capacity?: true
  }

  export type BuildingSumAggregateInputType = {
    capacity?: true
  }

  export type BuildingMinAggregateInputType = {
    id?: true
    tenantId?: true
    name?: true
    description?: true
    gender?: true
    capacity?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BuildingMaxAggregateInputType = {
    id?: true
    tenantId?: true
    name?: true
    description?: true
    gender?: true
    capacity?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BuildingCountAggregateInputType = {
    id?: true
    tenantId?: true
    name?: true
    description?: true
    gender?: true
    capacity?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type BuildingAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Building to aggregate.
     */
    where?: BuildingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Buildings to fetch.
     */
    orderBy?: BuildingOrderByWithRelationInput | BuildingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BuildingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Buildings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Buildings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Buildings
    **/
    _count?: true | BuildingCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BuildingAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BuildingSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BuildingMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BuildingMaxAggregateInputType
  }

  export type GetBuildingAggregateType<T extends BuildingAggregateArgs> = {
        [P in keyof T & keyof AggregateBuilding]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBuilding[P]>
      : GetScalarType<T[P], AggregateBuilding[P]>
  }




  export type BuildingGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BuildingWhereInput
    orderBy?: BuildingOrderByWithAggregationInput | BuildingOrderByWithAggregationInput[]
    by: BuildingScalarFieldEnum[] | BuildingScalarFieldEnum
    having?: BuildingScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BuildingCountAggregateInputType | true
    _avg?: BuildingAvgAggregateInputType
    _sum?: BuildingSumAggregateInputType
    _min?: BuildingMinAggregateInputType
    _max?: BuildingMaxAggregateInputType
  }

  export type BuildingGroupByOutputType = {
    id: string
    tenantId: string
    name: string
    description: string | null
    gender: string
    capacity: number
    createdAt: Date
    updatedAt: Date
    _count: BuildingCountAggregateOutputType | null
    _avg: BuildingAvgAggregateOutputType | null
    _sum: BuildingSumAggregateOutputType | null
    _min: BuildingMinAggregateOutputType | null
    _max: BuildingMaxAggregateOutputType | null
  }

  type GetBuildingGroupByPayload<T extends BuildingGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BuildingGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BuildingGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BuildingGroupByOutputType[P]>
            : GetScalarType<T[P], BuildingGroupByOutputType[P]>
        }
      >
    >


  export type BuildingSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    name?: boolean
    description?: boolean
    gender?: boolean
    capacity?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    rooms?: boolean | Building$roomsArgs<ExtArgs>
    _count?: boolean | BuildingCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["building"]>

  export type BuildingSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    name?: boolean
    description?: boolean
    gender?: boolean
    capacity?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["building"]>

  export type BuildingSelectScalar = {
    id?: boolean
    tenantId?: boolean
    name?: boolean
    description?: boolean
    gender?: boolean
    capacity?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type BuildingInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    rooms?: boolean | Building$roomsArgs<ExtArgs>
    _count?: boolean | BuildingCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type BuildingIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }

  export type $BuildingPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Building"
    objects: {
      tenant: Prisma.$TenantPayload<ExtArgs>
      rooms: Prisma.$RoomPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      tenantId: string
      name: string
      description: string | null
      gender: string
      capacity: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["building"]>
    composites: {}
  }

  type BuildingGetPayload<S extends boolean | null | undefined | BuildingDefaultArgs> = $Result.GetResult<Prisma.$BuildingPayload, S>

  type BuildingCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<BuildingFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: BuildingCountAggregateInputType | true
    }

  export interface BuildingDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Building'], meta: { name: 'Building' } }
    /**
     * Find zero or one Building that matches the filter.
     * @param {BuildingFindUniqueArgs} args - Arguments to find a Building
     * @example
     * // Get one Building
     * const building = await prisma.building.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BuildingFindUniqueArgs>(args: SelectSubset<T, BuildingFindUniqueArgs<ExtArgs>>): Prisma__BuildingClient<$Result.GetResult<Prisma.$BuildingPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Building that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {BuildingFindUniqueOrThrowArgs} args - Arguments to find a Building
     * @example
     * // Get one Building
     * const building = await prisma.building.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BuildingFindUniqueOrThrowArgs>(args: SelectSubset<T, BuildingFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BuildingClient<$Result.GetResult<Prisma.$BuildingPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Building that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BuildingFindFirstArgs} args - Arguments to find a Building
     * @example
     * // Get one Building
     * const building = await prisma.building.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BuildingFindFirstArgs>(args?: SelectSubset<T, BuildingFindFirstArgs<ExtArgs>>): Prisma__BuildingClient<$Result.GetResult<Prisma.$BuildingPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Building that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BuildingFindFirstOrThrowArgs} args - Arguments to find a Building
     * @example
     * // Get one Building
     * const building = await prisma.building.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BuildingFindFirstOrThrowArgs>(args?: SelectSubset<T, BuildingFindFirstOrThrowArgs<ExtArgs>>): Prisma__BuildingClient<$Result.GetResult<Prisma.$BuildingPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Buildings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BuildingFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Buildings
     * const buildings = await prisma.building.findMany()
     * 
     * // Get first 10 Buildings
     * const buildings = await prisma.building.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const buildingWithIdOnly = await prisma.building.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BuildingFindManyArgs>(args?: SelectSubset<T, BuildingFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BuildingPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Building.
     * @param {BuildingCreateArgs} args - Arguments to create a Building.
     * @example
     * // Create one Building
     * const Building = await prisma.building.create({
     *   data: {
     *     // ... data to create a Building
     *   }
     * })
     * 
     */
    create<T extends BuildingCreateArgs>(args: SelectSubset<T, BuildingCreateArgs<ExtArgs>>): Prisma__BuildingClient<$Result.GetResult<Prisma.$BuildingPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Buildings.
     * @param {BuildingCreateManyArgs} args - Arguments to create many Buildings.
     * @example
     * // Create many Buildings
     * const building = await prisma.building.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BuildingCreateManyArgs>(args?: SelectSubset<T, BuildingCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Buildings and returns the data saved in the database.
     * @param {BuildingCreateManyAndReturnArgs} args - Arguments to create many Buildings.
     * @example
     * // Create many Buildings
     * const building = await prisma.building.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Buildings and only return the `id`
     * const buildingWithIdOnly = await prisma.building.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BuildingCreateManyAndReturnArgs>(args?: SelectSubset<T, BuildingCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BuildingPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Building.
     * @param {BuildingDeleteArgs} args - Arguments to delete one Building.
     * @example
     * // Delete one Building
     * const Building = await prisma.building.delete({
     *   where: {
     *     // ... filter to delete one Building
     *   }
     * })
     * 
     */
    delete<T extends BuildingDeleteArgs>(args: SelectSubset<T, BuildingDeleteArgs<ExtArgs>>): Prisma__BuildingClient<$Result.GetResult<Prisma.$BuildingPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Building.
     * @param {BuildingUpdateArgs} args - Arguments to update one Building.
     * @example
     * // Update one Building
     * const building = await prisma.building.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BuildingUpdateArgs>(args: SelectSubset<T, BuildingUpdateArgs<ExtArgs>>): Prisma__BuildingClient<$Result.GetResult<Prisma.$BuildingPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Buildings.
     * @param {BuildingDeleteManyArgs} args - Arguments to filter Buildings to delete.
     * @example
     * // Delete a few Buildings
     * const { count } = await prisma.building.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BuildingDeleteManyArgs>(args?: SelectSubset<T, BuildingDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Buildings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BuildingUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Buildings
     * const building = await prisma.building.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BuildingUpdateManyArgs>(args: SelectSubset<T, BuildingUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Building.
     * @param {BuildingUpsertArgs} args - Arguments to update or create a Building.
     * @example
     * // Update or create a Building
     * const building = await prisma.building.upsert({
     *   create: {
     *     // ... data to create a Building
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Building we want to update
     *   }
     * })
     */
    upsert<T extends BuildingUpsertArgs>(args: SelectSubset<T, BuildingUpsertArgs<ExtArgs>>): Prisma__BuildingClient<$Result.GetResult<Prisma.$BuildingPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Buildings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BuildingCountArgs} args - Arguments to filter Buildings to count.
     * @example
     * // Count the number of Buildings
     * const count = await prisma.building.count({
     *   where: {
     *     // ... the filter for the Buildings we want to count
     *   }
     * })
    **/
    count<T extends BuildingCountArgs>(
      args?: Subset<T, BuildingCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BuildingCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Building.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BuildingAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BuildingAggregateArgs>(args: Subset<T, BuildingAggregateArgs>): Prisma.PrismaPromise<GetBuildingAggregateType<T>>

    /**
     * Group by Building.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BuildingGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BuildingGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BuildingGroupByArgs['orderBy'] }
        : { orderBy?: BuildingGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BuildingGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBuildingGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Building model
   */
  readonly fields: BuildingFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Building.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BuildingClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    tenant<T extends TenantDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TenantDefaultArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    rooms<T extends Building$roomsArgs<ExtArgs> = {}>(args?: Subset<T, Building$roomsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RoomPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Building model
   */ 
  interface BuildingFieldRefs {
    readonly id: FieldRef<"Building", 'String'>
    readonly tenantId: FieldRef<"Building", 'String'>
    readonly name: FieldRef<"Building", 'String'>
    readonly description: FieldRef<"Building", 'String'>
    readonly gender: FieldRef<"Building", 'String'>
    readonly capacity: FieldRef<"Building", 'Int'>
    readonly createdAt: FieldRef<"Building", 'DateTime'>
    readonly updatedAt: FieldRef<"Building", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Building findUnique
   */
  export type BuildingFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Building
     */
    select?: BuildingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BuildingInclude<ExtArgs> | null
    /**
     * Filter, which Building to fetch.
     */
    where: BuildingWhereUniqueInput
  }

  /**
   * Building findUniqueOrThrow
   */
  export type BuildingFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Building
     */
    select?: BuildingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BuildingInclude<ExtArgs> | null
    /**
     * Filter, which Building to fetch.
     */
    where: BuildingWhereUniqueInput
  }

  /**
   * Building findFirst
   */
  export type BuildingFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Building
     */
    select?: BuildingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BuildingInclude<ExtArgs> | null
    /**
     * Filter, which Building to fetch.
     */
    where?: BuildingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Buildings to fetch.
     */
    orderBy?: BuildingOrderByWithRelationInput | BuildingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Buildings.
     */
    cursor?: BuildingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Buildings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Buildings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Buildings.
     */
    distinct?: BuildingScalarFieldEnum | BuildingScalarFieldEnum[]
  }

  /**
   * Building findFirstOrThrow
   */
  export type BuildingFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Building
     */
    select?: BuildingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BuildingInclude<ExtArgs> | null
    /**
     * Filter, which Building to fetch.
     */
    where?: BuildingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Buildings to fetch.
     */
    orderBy?: BuildingOrderByWithRelationInput | BuildingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Buildings.
     */
    cursor?: BuildingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Buildings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Buildings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Buildings.
     */
    distinct?: BuildingScalarFieldEnum | BuildingScalarFieldEnum[]
  }

  /**
   * Building findMany
   */
  export type BuildingFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Building
     */
    select?: BuildingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BuildingInclude<ExtArgs> | null
    /**
     * Filter, which Buildings to fetch.
     */
    where?: BuildingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Buildings to fetch.
     */
    orderBy?: BuildingOrderByWithRelationInput | BuildingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Buildings.
     */
    cursor?: BuildingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Buildings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Buildings.
     */
    skip?: number
    distinct?: BuildingScalarFieldEnum | BuildingScalarFieldEnum[]
  }

  /**
   * Building create
   */
  export type BuildingCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Building
     */
    select?: BuildingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BuildingInclude<ExtArgs> | null
    /**
     * The data needed to create a Building.
     */
    data: XOR<BuildingCreateInput, BuildingUncheckedCreateInput>
  }

  /**
   * Building createMany
   */
  export type BuildingCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Buildings.
     */
    data: BuildingCreateManyInput | BuildingCreateManyInput[]
  }

  /**
   * Building createManyAndReturn
   */
  export type BuildingCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Building
     */
    select?: BuildingSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Buildings.
     */
    data: BuildingCreateManyInput | BuildingCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BuildingIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Building update
   */
  export type BuildingUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Building
     */
    select?: BuildingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BuildingInclude<ExtArgs> | null
    /**
     * The data needed to update a Building.
     */
    data: XOR<BuildingUpdateInput, BuildingUncheckedUpdateInput>
    /**
     * Choose, which Building to update.
     */
    where: BuildingWhereUniqueInput
  }

  /**
   * Building updateMany
   */
  export type BuildingUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Buildings.
     */
    data: XOR<BuildingUpdateManyMutationInput, BuildingUncheckedUpdateManyInput>
    /**
     * Filter which Buildings to update
     */
    where?: BuildingWhereInput
  }

  /**
   * Building upsert
   */
  export type BuildingUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Building
     */
    select?: BuildingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BuildingInclude<ExtArgs> | null
    /**
     * The filter to search for the Building to update in case it exists.
     */
    where: BuildingWhereUniqueInput
    /**
     * In case the Building found by the `where` argument doesn't exist, create a new Building with this data.
     */
    create: XOR<BuildingCreateInput, BuildingUncheckedCreateInput>
    /**
     * In case the Building was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BuildingUpdateInput, BuildingUncheckedUpdateInput>
  }

  /**
   * Building delete
   */
  export type BuildingDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Building
     */
    select?: BuildingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BuildingInclude<ExtArgs> | null
    /**
     * Filter which Building to delete.
     */
    where: BuildingWhereUniqueInput
  }

  /**
   * Building deleteMany
   */
  export type BuildingDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Buildings to delete
     */
    where?: BuildingWhereInput
  }

  /**
   * Building.rooms
   */
  export type Building$roomsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Room
     */
    select?: RoomSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoomInclude<ExtArgs> | null
    where?: RoomWhereInput
    orderBy?: RoomOrderByWithRelationInput | RoomOrderByWithRelationInput[]
    cursor?: RoomWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RoomScalarFieldEnum | RoomScalarFieldEnum[]
  }

  /**
   * Building without action
   */
  export type BuildingDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Building
     */
    select?: BuildingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BuildingInclude<ExtArgs> | null
  }


  /**
   * Model Room
   */

  export type AggregateRoom = {
    _count: RoomCountAggregateOutputType | null
    _avg: RoomAvgAggregateOutputType | null
    _sum: RoomSumAggregateOutputType | null
    _min: RoomMinAggregateOutputType | null
    _max: RoomMaxAggregateOutputType | null
  }

  export type RoomAvgAggregateOutputType = {
    capacity: number | null
  }

  export type RoomSumAggregateOutputType = {
    capacity: number | null
  }

  export type RoomMinAggregateOutputType = {
    id: string | null
    tenantId: string | null
    buildingId: string | null
    name: string | null
    capacity: number | null
    picName: string | null
    createdAt: Date | null
  }

  export type RoomMaxAggregateOutputType = {
    id: string | null
    tenantId: string | null
    buildingId: string | null
    name: string | null
    capacity: number | null
    picName: string | null
    createdAt: Date | null
  }

  export type RoomCountAggregateOutputType = {
    id: number
    tenantId: number
    buildingId: number
    name: number
    capacity: number
    picName: number
    createdAt: number
    _all: number
  }


  export type RoomAvgAggregateInputType = {
    capacity?: true
  }

  export type RoomSumAggregateInputType = {
    capacity?: true
  }

  export type RoomMinAggregateInputType = {
    id?: true
    tenantId?: true
    buildingId?: true
    name?: true
    capacity?: true
    picName?: true
    createdAt?: true
  }

  export type RoomMaxAggregateInputType = {
    id?: true
    tenantId?: true
    buildingId?: true
    name?: true
    capacity?: true
    picName?: true
    createdAt?: true
  }

  export type RoomCountAggregateInputType = {
    id?: true
    tenantId?: true
    buildingId?: true
    name?: true
    capacity?: true
    picName?: true
    createdAt?: true
    _all?: true
  }

  export type RoomAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Room to aggregate.
     */
    where?: RoomWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Rooms to fetch.
     */
    orderBy?: RoomOrderByWithRelationInput | RoomOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RoomWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Rooms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Rooms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Rooms
    **/
    _count?: true | RoomCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RoomAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RoomSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RoomMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RoomMaxAggregateInputType
  }

  export type GetRoomAggregateType<T extends RoomAggregateArgs> = {
        [P in keyof T & keyof AggregateRoom]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRoom[P]>
      : GetScalarType<T[P], AggregateRoom[P]>
  }




  export type RoomGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RoomWhereInput
    orderBy?: RoomOrderByWithAggregationInput | RoomOrderByWithAggregationInput[]
    by: RoomScalarFieldEnum[] | RoomScalarFieldEnum
    having?: RoomScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RoomCountAggregateInputType | true
    _avg?: RoomAvgAggregateInputType
    _sum?: RoomSumAggregateInputType
    _min?: RoomMinAggregateInputType
    _max?: RoomMaxAggregateInputType
  }

  export type RoomGroupByOutputType = {
    id: string
    tenantId: string
    buildingId: string
    name: string
    capacity: number
    picName: string | null
    createdAt: Date
    _count: RoomCountAggregateOutputType | null
    _avg: RoomAvgAggregateOutputType | null
    _sum: RoomSumAggregateOutputType | null
    _min: RoomMinAggregateOutputType | null
    _max: RoomMaxAggregateOutputType | null
  }

  type GetRoomGroupByPayload<T extends RoomGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RoomGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RoomGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RoomGroupByOutputType[P]>
            : GetScalarType<T[P], RoomGroupByOutputType[P]>
        }
      >
    >


  export type RoomSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    buildingId?: boolean
    name?: boolean
    capacity?: boolean
    picName?: boolean
    createdAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    building?: boolean | BuildingDefaultArgs<ExtArgs>
    assignments?: boolean | Room$assignmentsArgs<ExtArgs>
    tickets?: boolean | Room$ticketsArgs<ExtArgs>
    _count?: boolean | RoomCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["room"]>

  export type RoomSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    buildingId?: boolean
    name?: boolean
    capacity?: boolean
    picName?: boolean
    createdAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    building?: boolean | BuildingDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["room"]>

  export type RoomSelectScalar = {
    id?: boolean
    tenantId?: boolean
    buildingId?: boolean
    name?: boolean
    capacity?: boolean
    picName?: boolean
    createdAt?: boolean
  }

  export type RoomInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    building?: boolean | BuildingDefaultArgs<ExtArgs>
    assignments?: boolean | Room$assignmentsArgs<ExtArgs>
    tickets?: boolean | Room$ticketsArgs<ExtArgs>
    _count?: boolean | RoomCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type RoomIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    building?: boolean | BuildingDefaultArgs<ExtArgs>
  }

  export type $RoomPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Room"
    objects: {
      tenant: Prisma.$TenantPayload<ExtArgs>
      building: Prisma.$BuildingPayload<ExtArgs>
      assignments: Prisma.$RoomAssignmentPayload<ExtArgs>[]
      tickets: Prisma.$MaintenanceTicketPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      tenantId: string
      buildingId: string
      name: string
      capacity: number
      picName: string | null
      createdAt: Date
    }, ExtArgs["result"]["room"]>
    composites: {}
  }

  type RoomGetPayload<S extends boolean | null | undefined | RoomDefaultArgs> = $Result.GetResult<Prisma.$RoomPayload, S>

  type RoomCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<RoomFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: RoomCountAggregateInputType | true
    }

  export interface RoomDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Room'], meta: { name: 'Room' } }
    /**
     * Find zero or one Room that matches the filter.
     * @param {RoomFindUniqueArgs} args - Arguments to find a Room
     * @example
     * // Get one Room
     * const room = await prisma.room.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RoomFindUniqueArgs>(args: SelectSubset<T, RoomFindUniqueArgs<ExtArgs>>): Prisma__RoomClient<$Result.GetResult<Prisma.$RoomPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Room that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {RoomFindUniqueOrThrowArgs} args - Arguments to find a Room
     * @example
     * // Get one Room
     * const room = await prisma.room.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RoomFindUniqueOrThrowArgs>(args: SelectSubset<T, RoomFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RoomClient<$Result.GetResult<Prisma.$RoomPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Room that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoomFindFirstArgs} args - Arguments to find a Room
     * @example
     * // Get one Room
     * const room = await prisma.room.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RoomFindFirstArgs>(args?: SelectSubset<T, RoomFindFirstArgs<ExtArgs>>): Prisma__RoomClient<$Result.GetResult<Prisma.$RoomPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Room that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoomFindFirstOrThrowArgs} args - Arguments to find a Room
     * @example
     * // Get one Room
     * const room = await prisma.room.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RoomFindFirstOrThrowArgs>(args?: SelectSubset<T, RoomFindFirstOrThrowArgs<ExtArgs>>): Prisma__RoomClient<$Result.GetResult<Prisma.$RoomPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Rooms that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoomFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Rooms
     * const rooms = await prisma.room.findMany()
     * 
     * // Get first 10 Rooms
     * const rooms = await prisma.room.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const roomWithIdOnly = await prisma.room.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RoomFindManyArgs>(args?: SelectSubset<T, RoomFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RoomPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Room.
     * @param {RoomCreateArgs} args - Arguments to create a Room.
     * @example
     * // Create one Room
     * const Room = await prisma.room.create({
     *   data: {
     *     // ... data to create a Room
     *   }
     * })
     * 
     */
    create<T extends RoomCreateArgs>(args: SelectSubset<T, RoomCreateArgs<ExtArgs>>): Prisma__RoomClient<$Result.GetResult<Prisma.$RoomPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Rooms.
     * @param {RoomCreateManyArgs} args - Arguments to create many Rooms.
     * @example
     * // Create many Rooms
     * const room = await prisma.room.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RoomCreateManyArgs>(args?: SelectSubset<T, RoomCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Rooms and returns the data saved in the database.
     * @param {RoomCreateManyAndReturnArgs} args - Arguments to create many Rooms.
     * @example
     * // Create many Rooms
     * const room = await prisma.room.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Rooms and only return the `id`
     * const roomWithIdOnly = await prisma.room.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RoomCreateManyAndReturnArgs>(args?: SelectSubset<T, RoomCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RoomPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Room.
     * @param {RoomDeleteArgs} args - Arguments to delete one Room.
     * @example
     * // Delete one Room
     * const Room = await prisma.room.delete({
     *   where: {
     *     // ... filter to delete one Room
     *   }
     * })
     * 
     */
    delete<T extends RoomDeleteArgs>(args: SelectSubset<T, RoomDeleteArgs<ExtArgs>>): Prisma__RoomClient<$Result.GetResult<Prisma.$RoomPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Room.
     * @param {RoomUpdateArgs} args - Arguments to update one Room.
     * @example
     * // Update one Room
     * const room = await prisma.room.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RoomUpdateArgs>(args: SelectSubset<T, RoomUpdateArgs<ExtArgs>>): Prisma__RoomClient<$Result.GetResult<Prisma.$RoomPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Rooms.
     * @param {RoomDeleteManyArgs} args - Arguments to filter Rooms to delete.
     * @example
     * // Delete a few Rooms
     * const { count } = await prisma.room.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RoomDeleteManyArgs>(args?: SelectSubset<T, RoomDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Rooms.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoomUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Rooms
     * const room = await prisma.room.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RoomUpdateManyArgs>(args: SelectSubset<T, RoomUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Room.
     * @param {RoomUpsertArgs} args - Arguments to update or create a Room.
     * @example
     * // Update or create a Room
     * const room = await prisma.room.upsert({
     *   create: {
     *     // ... data to create a Room
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Room we want to update
     *   }
     * })
     */
    upsert<T extends RoomUpsertArgs>(args: SelectSubset<T, RoomUpsertArgs<ExtArgs>>): Prisma__RoomClient<$Result.GetResult<Prisma.$RoomPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Rooms.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoomCountArgs} args - Arguments to filter Rooms to count.
     * @example
     * // Count the number of Rooms
     * const count = await prisma.room.count({
     *   where: {
     *     // ... the filter for the Rooms we want to count
     *   }
     * })
    **/
    count<T extends RoomCountArgs>(
      args?: Subset<T, RoomCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RoomCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Room.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoomAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RoomAggregateArgs>(args: Subset<T, RoomAggregateArgs>): Prisma.PrismaPromise<GetRoomAggregateType<T>>

    /**
     * Group by Room.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoomGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RoomGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RoomGroupByArgs['orderBy'] }
        : { orderBy?: RoomGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RoomGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRoomGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Room model
   */
  readonly fields: RoomFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Room.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RoomClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    tenant<T extends TenantDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TenantDefaultArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    building<T extends BuildingDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BuildingDefaultArgs<ExtArgs>>): Prisma__BuildingClient<$Result.GetResult<Prisma.$BuildingPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    assignments<T extends Room$assignmentsArgs<ExtArgs> = {}>(args?: Subset<T, Room$assignmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RoomAssignmentPayload<ExtArgs>, T, "findMany"> | Null>
    tickets<T extends Room$ticketsArgs<ExtArgs> = {}>(args?: Subset<T, Room$ticketsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MaintenanceTicketPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Room model
   */ 
  interface RoomFieldRefs {
    readonly id: FieldRef<"Room", 'String'>
    readonly tenantId: FieldRef<"Room", 'String'>
    readonly buildingId: FieldRef<"Room", 'String'>
    readonly name: FieldRef<"Room", 'String'>
    readonly capacity: FieldRef<"Room", 'Int'>
    readonly picName: FieldRef<"Room", 'String'>
    readonly createdAt: FieldRef<"Room", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Room findUnique
   */
  export type RoomFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Room
     */
    select?: RoomSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoomInclude<ExtArgs> | null
    /**
     * Filter, which Room to fetch.
     */
    where: RoomWhereUniqueInput
  }

  /**
   * Room findUniqueOrThrow
   */
  export type RoomFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Room
     */
    select?: RoomSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoomInclude<ExtArgs> | null
    /**
     * Filter, which Room to fetch.
     */
    where: RoomWhereUniqueInput
  }

  /**
   * Room findFirst
   */
  export type RoomFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Room
     */
    select?: RoomSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoomInclude<ExtArgs> | null
    /**
     * Filter, which Room to fetch.
     */
    where?: RoomWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Rooms to fetch.
     */
    orderBy?: RoomOrderByWithRelationInput | RoomOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Rooms.
     */
    cursor?: RoomWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Rooms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Rooms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Rooms.
     */
    distinct?: RoomScalarFieldEnum | RoomScalarFieldEnum[]
  }

  /**
   * Room findFirstOrThrow
   */
  export type RoomFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Room
     */
    select?: RoomSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoomInclude<ExtArgs> | null
    /**
     * Filter, which Room to fetch.
     */
    where?: RoomWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Rooms to fetch.
     */
    orderBy?: RoomOrderByWithRelationInput | RoomOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Rooms.
     */
    cursor?: RoomWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Rooms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Rooms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Rooms.
     */
    distinct?: RoomScalarFieldEnum | RoomScalarFieldEnum[]
  }

  /**
   * Room findMany
   */
  export type RoomFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Room
     */
    select?: RoomSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoomInclude<ExtArgs> | null
    /**
     * Filter, which Rooms to fetch.
     */
    where?: RoomWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Rooms to fetch.
     */
    orderBy?: RoomOrderByWithRelationInput | RoomOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Rooms.
     */
    cursor?: RoomWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Rooms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Rooms.
     */
    skip?: number
    distinct?: RoomScalarFieldEnum | RoomScalarFieldEnum[]
  }

  /**
   * Room create
   */
  export type RoomCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Room
     */
    select?: RoomSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoomInclude<ExtArgs> | null
    /**
     * The data needed to create a Room.
     */
    data: XOR<RoomCreateInput, RoomUncheckedCreateInput>
  }

  /**
   * Room createMany
   */
  export type RoomCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Rooms.
     */
    data: RoomCreateManyInput | RoomCreateManyInput[]
  }

  /**
   * Room createManyAndReturn
   */
  export type RoomCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Room
     */
    select?: RoomSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Rooms.
     */
    data: RoomCreateManyInput | RoomCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoomIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Room update
   */
  export type RoomUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Room
     */
    select?: RoomSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoomInclude<ExtArgs> | null
    /**
     * The data needed to update a Room.
     */
    data: XOR<RoomUpdateInput, RoomUncheckedUpdateInput>
    /**
     * Choose, which Room to update.
     */
    where: RoomWhereUniqueInput
  }

  /**
   * Room updateMany
   */
  export type RoomUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Rooms.
     */
    data: XOR<RoomUpdateManyMutationInput, RoomUncheckedUpdateManyInput>
    /**
     * Filter which Rooms to update
     */
    where?: RoomWhereInput
  }

  /**
   * Room upsert
   */
  export type RoomUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Room
     */
    select?: RoomSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoomInclude<ExtArgs> | null
    /**
     * The filter to search for the Room to update in case it exists.
     */
    where: RoomWhereUniqueInput
    /**
     * In case the Room found by the `where` argument doesn't exist, create a new Room with this data.
     */
    create: XOR<RoomCreateInput, RoomUncheckedCreateInput>
    /**
     * In case the Room was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RoomUpdateInput, RoomUncheckedUpdateInput>
  }

  /**
   * Room delete
   */
  export type RoomDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Room
     */
    select?: RoomSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoomInclude<ExtArgs> | null
    /**
     * Filter which Room to delete.
     */
    where: RoomWhereUniqueInput
  }

  /**
   * Room deleteMany
   */
  export type RoomDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Rooms to delete
     */
    where?: RoomWhereInput
  }

  /**
   * Room.assignments
   */
  export type Room$assignmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoomAssignment
     */
    select?: RoomAssignmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoomAssignmentInclude<ExtArgs> | null
    where?: RoomAssignmentWhereInput
    orderBy?: RoomAssignmentOrderByWithRelationInput | RoomAssignmentOrderByWithRelationInput[]
    cursor?: RoomAssignmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RoomAssignmentScalarFieldEnum | RoomAssignmentScalarFieldEnum[]
  }

  /**
   * Room.tickets
   */
  export type Room$ticketsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaintenanceTicket
     */
    select?: MaintenanceTicketSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaintenanceTicketInclude<ExtArgs> | null
    where?: MaintenanceTicketWhereInput
    orderBy?: MaintenanceTicketOrderByWithRelationInput | MaintenanceTicketOrderByWithRelationInput[]
    cursor?: MaintenanceTicketWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MaintenanceTicketScalarFieldEnum | MaintenanceTicketScalarFieldEnum[]
  }

  /**
   * Room without action
   */
  export type RoomDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Room
     */
    select?: RoomSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoomInclude<ExtArgs> | null
  }


  /**
   * Model RoomAssignment
   */

  export type AggregateRoomAssignment = {
    _count: RoomAssignmentCountAggregateOutputType | null
    _min: RoomAssignmentMinAggregateOutputType | null
    _max: RoomAssignmentMaxAggregateOutputType | null
  }

  export type RoomAssignmentMinAggregateOutputType = {
    id: string | null
    tenantId: string | null
    roomId: string | null
    santriId: string | null
    startDate: Date | null
    endDate: Date | null
    status: string | null
  }

  export type RoomAssignmentMaxAggregateOutputType = {
    id: string | null
    tenantId: string | null
    roomId: string | null
    santriId: string | null
    startDate: Date | null
    endDate: Date | null
    status: string | null
  }

  export type RoomAssignmentCountAggregateOutputType = {
    id: number
    tenantId: number
    roomId: number
    santriId: number
    startDate: number
    endDate: number
    status: number
    _all: number
  }


  export type RoomAssignmentMinAggregateInputType = {
    id?: true
    tenantId?: true
    roomId?: true
    santriId?: true
    startDate?: true
    endDate?: true
    status?: true
  }

  export type RoomAssignmentMaxAggregateInputType = {
    id?: true
    tenantId?: true
    roomId?: true
    santriId?: true
    startDate?: true
    endDate?: true
    status?: true
  }

  export type RoomAssignmentCountAggregateInputType = {
    id?: true
    tenantId?: true
    roomId?: true
    santriId?: true
    startDate?: true
    endDate?: true
    status?: true
    _all?: true
  }

  export type RoomAssignmentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RoomAssignment to aggregate.
     */
    where?: RoomAssignmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RoomAssignments to fetch.
     */
    orderBy?: RoomAssignmentOrderByWithRelationInput | RoomAssignmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RoomAssignmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RoomAssignments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RoomAssignments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RoomAssignments
    **/
    _count?: true | RoomAssignmentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RoomAssignmentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RoomAssignmentMaxAggregateInputType
  }

  export type GetRoomAssignmentAggregateType<T extends RoomAssignmentAggregateArgs> = {
        [P in keyof T & keyof AggregateRoomAssignment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRoomAssignment[P]>
      : GetScalarType<T[P], AggregateRoomAssignment[P]>
  }




  export type RoomAssignmentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RoomAssignmentWhereInput
    orderBy?: RoomAssignmentOrderByWithAggregationInput | RoomAssignmentOrderByWithAggregationInput[]
    by: RoomAssignmentScalarFieldEnum[] | RoomAssignmentScalarFieldEnum
    having?: RoomAssignmentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RoomAssignmentCountAggregateInputType | true
    _min?: RoomAssignmentMinAggregateInputType
    _max?: RoomAssignmentMaxAggregateInputType
  }

  export type RoomAssignmentGroupByOutputType = {
    id: string
    tenantId: string
    roomId: string
    santriId: string
    startDate: Date
    endDate: Date | null
    status: string
    _count: RoomAssignmentCountAggregateOutputType | null
    _min: RoomAssignmentMinAggregateOutputType | null
    _max: RoomAssignmentMaxAggregateOutputType | null
  }

  type GetRoomAssignmentGroupByPayload<T extends RoomAssignmentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RoomAssignmentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RoomAssignmentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RoomAssignmentGroupByOutputType[P]>
            : GetScalarType<T[P], RoomAssignmentGroupByOutputType[P]>
        }
      >
    >


  export type RoomAssignmentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    roomId?: boolean
    santriId?: boolean
    startDate?: boolean
    endDate?: boolean
    status?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    room?: boolean | RoomDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["roomAssignment"]>

  export type RoomAssignmentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    roomId?: boolean
    santriId?: boolean
    startDate?: boolean
    endDate?: boolean
    status?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    room?: boolean | RoomDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["roomAssignment"]>

  export type RoomAssignmentSelectScalar = {
    id?: boolean
    tenantId?: boolean
    roomId?: boolean
    santriId?: boolean
    startDate?: boolean
    endDate?: boolean
    status?: boolean
  }

  export type RoomAssignmentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    room?: boolean | RoomDefaultArgs<ExtArgs>
  }
  export type RoomAssignmentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    room?: boolean | RoomDefaultArgs<ExtArgs>
  }

  export type $RoomAssignmentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "RoomAssignment"
    objects: {
      tenant: Prisma.$TenantPayload<ExtArgs>
      room: Prisma.$RoomPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      tenantId: string
      roomId: string
      santriId: string
      startDate: Date
      endDate: Date | null
      status: string
    }, ExtArgs["result"]["roomAssignment"]>
    composites: {}
  }

  type RoomAssignmentGetPayload<S extends boolean | null | undefined | RoomAssignmentDefaultArgs> = $Result.GetResult<Prisma.$RoomAssignmentPayload, S>

  type RoomAssignmentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<RoomAssignmentFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: RoomAssignmentCountAggregateInputType | true
    }

  export interface RoomAssignmentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['RoomAssignment'], meta: { name: 'RoomAssignment' } }
    /**
     * Find zero or one RoomAssignment that matches the filter.
     * @param {RoomAssignmentFindUniqueArgs} args - Arguments to find a RoomAssignment
     * @example
     * // Get one RoomAssignment
     * const roomAssignment = await prisma.roomAssignment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RoomAssignmentFindUniqueArgs>(args: SelectSubset<T, RoomAssignmentFindUniqueArgs<ExtArgs>>): Prisma__RoomAssignmentClient<$Result.GetResult<Prisma.$RoomAssignmentPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one RoomAssignment that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {RoomAssignmentFindUniqueOrThrowArgs} args - Arguments to find a RoomAssignment
     * @example
     * // Get one RoomAssignment
     * const roomAssignment = await prisma.roomAssignment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RoomAssignmentFindUniqueOrThrowArgs>(args: SelectSubset<T, RoomAssignmentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RoomAssignmentClient<$Result.GetResult<Prisma.$RoomAssignmentPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first RoomAssignment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoomAssignmentFindFirstArgs} args - Arguments to find a RoomAssignment
     * @example
     * // Get one RoomAssignment
     * const roomAssignment = await prisma.roomAssignment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RoomAssignmentFindFirstArgs>(args?: SelectSubset<T, RoomAssignmentFindFirstArgs<ExtArgs>>): Prisma__RoomAssignmentClient<$Result.GetResult<Prisma.$RoomAssignmentPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first RoomAssignment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoomAssignmentFindFirstOrThrowArgs} args - Arguments to find a RoomAssignment
     * @example
     * // Get one RoomAssignment
     * const roomAssignment = await prisma.roomAssignment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RoomAssignmentFindFirstOrThrowArgs>(args?: SelectSubset<T, RoomAssignmentFindFirstOrThrowArgs<ExtArgs>>): Prisma__RoomAssignmentClient<$Result.GetResult<Prisma.$RoomAssignmentPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more RoomAssignments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoomAssignmentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RoomAssignments
     * const roomAssignments = await prisma.roomAssignment.findMany()
     * 
     * // Get first 10 RoomAssignments
     * const roomAssignments = await prisma.roomAssignment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const roomAssignmentWithIdOnly = await prisma.roomAssignment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RoomAssignmentFindManyArgs>(args?: SelectSubset<T, RoomAssignmentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RoomAssignmentPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a RoomAssignment.
     * @param {RoomAssignmentCreateArgs} args - Arguments to create a RoomAssignment.
     * @example
     * // Create one RoomAssignment
     * const RoomAssignment = await prisma.roomAssignment.create({
     *   data: {
     *     // ... data to create a RoomAssignment
     *   }
     * })
     * 
     */
    create<T extends RoomAssignmentCreateArgs>(args: SelectSubset<T, RoomAssignmentCreateArgs<ExtArgs>>): Prisma__RoomAssignmentClient<$Result.GetResult<Prisma.$RoomAssignmentPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many RoomAssignments.
     * @param {RoomAssignmentCreateManyArgs} args - Arguments to create many RoomAssignments.
     * @example
     * // Create many RoomAssignments
     * const roomAssignment = await prisma.roomAssignment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RoomAssignmentCreateManyArgs>(args?: SelectSubset<T, RoomAssignmentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many RoomAssignments and returns the data saved in the database.
     * @param {RoomAssignmentCreateManyAndReturnArgs} args - Arguments to create many RoomAssignments.
     * @example
     * // Create many RoomAssignments
     * const roomAssignment = await prisma.roomAssignment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many RoomAssignments and only return the `id`
     * const roomAssignmentWithIdOnly = await prisma.roomAssignment.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RoomAssignmentCreateManyAndReturnArgs>(args?: SelectSubset<T, RoomAssignmentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RoomAssignmentPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a RoomAssignment.
     * @param {RoomAssignmentDeleteArgs} args - Arguments to delete one RoomAssignment.
     * @example
     * // Delete one RoomAssignment
     * const RoomAssignment = await prisma.roomAssignment.delete({
     *   where: {
     *     // ... filter to delete one RoomAssignment
     *   }
     * })
     * 
     */
    delete<T extends RoomAssignmentDeleteArgs>(args: SelectSubset<T, RoomAssignmentDeleteArgs<ExtArgs>>): Prisma__RoomAssignmentClient<$Result.GetResult<Prisma.$RoomAssignmentPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one RoomAssignment.
     * @param {RoomAssignmentUpdateArgs} args - Arguments to update one RoomAssignment.
     * @example
     * // Update one RoomAssignment
     * const roomAssignment = await prisma.roomAssignment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RoomAssignmentUpdateArgs>(args: SelectSubset<T, RoomAssignmentUpdateArgs<ExtArgs>>): Prisma__RoomAssignmentClient<$Result.GetResult<Prisma.$RoomAssignmentPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more RoomAssignments.
     * @param {RoomAssignmentDeleteManyArgs} args - Arguments to filter RoomAssignments to delete.
     * @example
     * // Delete a few RoomAssignments
     * const { count } = await prisma.roomAssignment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RoomAssignmentDeleteManyArgs>(args?: SelectSubset<T, RoomAssignmentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RoomAssignments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoomAssignmentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RoomAssignments
     * const roomAssignment = await prisma.roomAssignment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RoomAssignmentUpdateManyArgs>(args: SelectSubset<T, RoomAssignmentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one RoomAssignment.
     * @param {RoomAssignmentUpsertArgs} args - Arguments to update or create a RoomAssignment.
     * @example
     * // Update or create a RoomAssignment
     * const roomAssignment = await prisma.roomAssignment.upsert({
     *   create: {
     *     // ... data to create a RoomAssignment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RoomAssignment we want to update
     *   }
     * })
     */
    upsert<T extends RoomAssignmentUpsertArgs>(args: SelectSubset<T, RoomAssignmentUpsertArgs<ExtArgs>>): Prisma__RoomAssignmentClient<$Result.GetResult<Prisma.$RoomAssignmentPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of RoomAssignments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoomAssignmentCountArgs} args - Arguments to filter RoomAssignments to count.
     * @example
     * // Count the number of RoomAssignments
     * const count = await prisma.roomAssignment.count({
     *   where: {
     *     // ... the filter for the RoomAssignments we want to count
     *   }
     * })
    **/
    count<T extends RoomAssignmentCountArgs>(
      args?: Subset<T, RoomAssignmentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RoomAssignmentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RoomAssignment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoomAssignmentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RoomAssignmentAggregateArgs>(args: Subset<T, RoomAssignmentAggregateArgs>): Prisma.PrismaPromise<GetRoomAssignmentAggregateType<T>>

    /**
     * Group by RoomAssignment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoomAssignmentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RoomAssignmentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RoomAssignmentGroupByArgs['orderBy'] }
        : { orderBy?: RoomAssignmentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RoomAssignmentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRoomAssignmentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the RoomAssignment model
   */
  readonly fields: RoomAssignmentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RoomAssignment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RoomAssignmentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    tenant<T extends TenantDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TenantDefaultArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    room<T extends RoomDefaultArgs<ExtArgs> = {}>(args?: Subset<T, RoomDefaultArgs<ExtArgs>>): Prisma__RoomClient<$Result.GetResult<Prisma.$RoomPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the RoomAssignment model
   */ 
  interface RoomAssignmentFieldRefs {
    readonly id: FieldRef<"RoomAssignment", 'String'>
    readonly tenantId: FieldRef<"RoomAssignment", 'String'>
    readonly roomId: FieldRef<"RoomAssignment", 'String'>
    readonly santriId: FieldRef<"RoomAssignment", 'String'>
    readonly startDate: FieldRef<"RoomAssignment", 'DateTime'>
    readonly endDate: FieldRef<"RoomAssignment", 'DateTime'>
    readonly status: FieldRef<"RoomAssignment", 'String'>
  }
    

  // Custom InputTypes
  /**
   * RoomAssignment findUnique
   */
  export type RoomAssignmentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoomAssignment
     */
    select?: RoomAssignmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoomAssignmentInclude<ExtArgs> | null
    /**
     * Filter, which RoomAssignment to fetch.
     */
    where: RoomAssignmentWhereUniqueInput
  }

  /**
   * RoomAssignment findUniqueOrThrow
   */
  export type RoomAssignmentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoomAssignment
     */
    select?: RoomAssignmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoomAssignmentInclude<ExtArgs> | null
    /**
     * Filter, which RoomAssignment to fetch.
     */
    where: RoomAssignmentWhereUniqueInput
  }

  /**
   * RoomAssignment findFirst
   */
  export type RoomAssignmentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoomAssignment
     */
    select?: RoomAssignmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoomAssignmentInclude<ExtArgs> | null
    /**
     * Filter, which RoomAssignment to fetch.
     */
    where?: RoomAssignmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RoomAssignments to fetch.
     */
    orderBy?: RoomAssignmentOrderByWithRelationInput | RoomAssignmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RoomAssignments.
     */
    cursor?: RoomAssignmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RoomAssignments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RoomAssignments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RoomAssignments.
     */
    distinct?: RoomAssignmentScalarFieldEnum | RoomAssignmentScalarFieldEnum[]
  }

  /**
   * RoomAssignment findFirstOrThrow
   */
  export type RoomAssignmentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoomAssignment
     */
    select?: RoomAssignmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoomAssignmentInclude<ExtArgs> | null
    /**
     * Filter, which RoomAssignment to fetch.
     */
    where?: RoomAssignmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RoomAssignments to fetch.
     */
    orderBy?: RoomAssignmentOrderByWithRelationInput | RoomAssignmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RoomAssignments.
     */
    cursor?: RoomAssignmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RoomAssignments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RoomAssignments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RoomAssignments.
     */
    distinct?: RoomAssignmentScalarFieldEnum | RoomAssignmentScalarFieldEnum[]
  }

  /**
   * RoomAssignment findMany
   */
  export type RoomAssignmentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoomAssignment
     */
    select?: RoomAssignmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoomAssignmentInclude<ExtArgs> | null
    /**
     * Filter, which RoomAssignments to fetch.
     */
    where?: RoomAssignmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RoomAssignments to fetch.
     */
    orderBy?: RoomAssignmentOrderByWithRelationInput | RoomAssignmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RoomAssignments.
     */
    cursor?: RoomAssignmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RoomAssignments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RoomAssignments.
     */
    skip?: number
    distinct?: RoomAssignmentScalarFieldEnum | RoomAssignmentScalarFieldEnum[]
  }

  /**
   * RoomAssignment create
   */
  export type RoomAssignmentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoomAssignment
     */
    select?: RoomAssignmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoomAssignmentInclude<ExtArgs> | null
    /**
     * The data needed to create a RoomAssignment.
     */
    data: XOR<RoomAssignmentCreateInput, RoomAssignmentUncheckedCreateInput>
  }

  /**
   * RoomAssignment createMany
   */
  export type RoomAssignmentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many RoomAssignments.
     */
    data: RoomAssignmentCreateManyInput | RoomAssignmentCreateManyInput[]
  }

  /**
   * RoomAssignment createManyAndReturn
   */
  export type RoomAssignmentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoomAssignment
     */
    select?: RoomAssignmentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many RoomAssignments.
     */
    data: RoomAssignmentCreateManyInput | RoomAssignmentCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoomAssignmentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * RoomAssignment update
   */
  export type RoomAssignmentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoomAssignment
     */
    select?: RoomAssignmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoomAssignmentInclude<ExtArgs> | null
    /**
     * The data needed to update a RoomAssignment.
     */
    data: XOR<RoomAssignmentUpdateInput, RoomAssignmentUncheckedUpdateInput>
    /**
     * Choose, which RoomAssignment to update.
     */
    where: RoomAssignmentWhereUniqueInput
  }

  /**
   * RoomAssignment updateMany
   */
  export type RoomAssignmentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update RoomAssignments.
     */
    data: XOR<RoomAssignmentUpdateManyMutationInput, RoomAssignmentUncheckedUpdateManyInput>
    /**
     * Filter which RoomAssignments to update
     */
    where?: RoomAssignmentWhereInput
  }

  /**
   * RoomAssignment upsert
   */
  export type RoomAssignmentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoomAssignment
     */
    select?: RoomAssignmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoomAssignmentInclude<ExtArgs> | null
    /**
     * The filter to search for the RoomAssignment to update in case it exists.
     */
    where: RoomAssignmentWhereUniqueInput
    /**
     * In case the RoomAssignment found by the `where` argument doesn't exist, create a new RoomAssignment with this data.
     */
    create: XOR<RoomAssignmentCreateInput, RoomAssignmentUncheckedCreateInput>
    /**
     * In case the RoomAssignment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RoomAssignmentUpdateInput, RoomAssignmentUncheckedUpdateInput>
  }

  /**
   * RoomAssignment delete
   */
  export type RoomAssignmentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoomAssignment
     */
    select?: RoomAssignmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoomAssignmentInclude<ExtArgs> | null
    /**
     * Filter which RoomAssignment to delete.
     */
    where: RoomAssignmentWhereUniqueInput
  }

  /**
   * RoomAssignment deleteMany
   */
  export type RoomAssignmentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RoomAssignments to delete
     */
    where?: RoomAssignmentWhereInput
  }

  /**
   * RoomAssignment without action
   */
  export type RoomAssignmentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoomAssignment
     */
    select?: RoomAssignmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoomAssignmentInclude<ExtArgs> | null
  }


  /**
   * Model MaintenanceTicket
   */

  export type AggregateMaintenanceTicket = {
    _count: MaintenanceTicketCountAggregateOutputType | null
    _min: MaintenanceTicketMinAggregateOutputType | null
    _max: MaintenanceTicketMaxAggregateOutputType | null
  }

  export type MaintenanceTicketMinAggregateOutputType = {
    id: string | null
    tenantId: string | null
    roomId: string | null
    title: string | null
    description: string | null
    priority: string | null
    status: string | null
    reportedBy: string | null
    resolvedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MaintenanceTicketMaxAggregateOutputType = {
    id: string | null
    tenantId: string | null
    roomId: string | null
    title: string | null
    description: string | null
    priority: string | null
    status: string | null
    reportedBy: string | null
    resolvedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MaintenanceTicketCountAggregateOutputType = {
    id: number
    tenantId: number
    roomId: number
    title: number
    description: number
    priority: number
    status: number
    reportedBy: number
    resolvedAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type MaintenanceTicketMinAggregateInputType = {
    id?: true
    tenantId?: true
    roomId?: true
    title?: true
    description?: true
    priority?: true
    status?: true
    reportedBy?: true
    resolvedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MaintenanceTicketMaxAggregateInputType = {
    id?: true
    tenantId?: true
    roomId?: true
    title?: true
    description?: true
    priority?: true
    status?: true
    reportedBy?: true
    resolvedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MaintenanceTicketCountAggregateInputType = {
    id?: true
    tenantId?: true
    roomId?: true
    title?: true
    description?: true
    priority?: true
    status?: true
    reportedBy?: true
    resolvedAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type MaintenanceTicketAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MaintenanceTicket to aggregate.
     */
    where?: MaintenanceTicketWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MaintenanceTickets to fetch.
     */
    orderBy?: MaintenanceTicketOrderByWithRelationInput | MaintenanceTicketOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MaintenanceTicketWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MaintenanceTickets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MaintenanceTickets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MaintenanceTickets
    **/
    _count?: true | MaintenanceTicketCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MaintenanceTicketMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MaintenanceTicketMaxAggregateInputType
  }

  export type GetMaintenanceTicketAggregateType<T extends MaintenanceTicketAggregateArgs> = {
        [P in keyof T & keyof AggregateMaintenanceTicket]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMaintenanceTicket[P]>
      : GetScalarType<T[P], AggregateMaintenanceTicket[P]>
  }




  export type MaintenanceTicketGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MaintenanceTicketWhereInput
    orderBy?: MaintenanceTicketOrderByWithAggregationInput | MaintenanceTicketOrderByWithAggregationInput[]
    by: MaintenanceTicketScalarFieldEnum[] | MaintenanceTicketScalarFieldEnum
    having?: MaintenanceTicketScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MaintenanceTicketCountAggregateInputType | true
    _min?: MaintenanceTicketMinAggregateInputType
    _max?: MaintenanceTicketMaxAggregateInputType
  }

  export type MaintenanceTicketGroupByOutputType = {
    id: string
    tenantId: string
    roomId: string
    title: string
    description: string
    priority: string
    status: string
    reportedBy: string
    resolvedAt: Date | null
    createdAt: Date
    updatedAt: Date
    _count: MaintenanceTicketCountAggregateOutputType | null
    _min: MaintenanceTicketMinAggregateOutputType | null
    _max: MaintenanceTicketMaxAggregateOutputType | null
  }

  type GetMaintenanceTicketGroupByPayload<T extends MaintenanceTicketGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MaintenanceTicketGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MaintenanceTicketGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MaintenanceTicketGroupByOutputType[P]>
            : GetScalarType<T[P], MaintenanceTicketGroupByOutputType[P]>
        }
      >
    >


  export type MaintenanceTicketSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    roomId?: boolean
    title?: boolean
    description?: boolean
    priority?: boolean
    status?: boolean
    reportedBy?: boolean
    resolvedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    room?: boolean | RoomDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["maintenanceTicket"]>

  export type MaintenanceTicketSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    roomId?: boolean
    title?: boolean
    description?: boolean
    priority?: boolean
    status?: boolean
    reportedBy?: boolean
    resolvedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    room?: boolean | RoomDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["maintenanceTicket"]>

  export type MaintenanceTicketSelectScalar = {
    id?: boolean
    tenantId?: boolean
    roomId?: boolean
    title?: boolean
    description?: boolean
    priority?: boolean
    status?: boolean
    reportedBy?: boolean
    resolvedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type MaintenanceTicketInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    room?: boolean | RoomDefaultArgs<ExtArgs>
  }
  export type MaintenanceTicketIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    room?: boolean | RoomDefaultArgs<ExtArgs>
  }

  export type $MaintenanceTicketPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "MaintenanceTicket"
    objects: {
      tenant: Prisma.$TenantPayload<ExtArgs>
      room: Prisma.$RoomPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      tenantId: string
      roomId: string
      title: string
      description: string
      priority: string
      status: string
      reportedBy: string
      resolvedAt: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["maintenanceTicket"]>
    composites: {}
  }

  type MaintenanceTicketGetPayload<S extends boolean | null | undefined | MaintenanceTicketDefaultArgs> = $Result.GetResult<Prisma.$MaintenanceTicketPayload, S>

  type MaintenanceTicketCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<MaintenanceTicketFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: MaintenanceTicketCountAggregateInputType | true
    }

  export interface MaintenanceTicketDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MaintenanceTicket'], meta: { name: 'MaintenanceTicket' } }
    /**
     * Find zero or one MaintenanceTicket that matches the filter.
     * @param {MaintenanceTicketFindUniqueArgs} args - Arguments to find a MaintenanceTicket
     * @example
     * // Get one MaintenanceTicket
     * const maintenanceTicket = await prisma.maintenanceTicket.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MaintenanceTicketFindUniqueArgs>(args: SelectSubset<T, MaintenanceTicketFindUniqueArgs<ExtArgs>>): Prisma__MaintenanceTicketClient<$Result.GetResult<Prisma.$MaintenanceTicketPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one MaintenanceTicket that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {MaintenanceTicketFindUniqueOrThrowArgs} args - Arguments to find a MaintenanceTicket
     * @example
     * // Get one MaintenanceTicket
     * const maintenanceTicket = await prisma.maintenanceTicket.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MaintenanceTicketFindUniqueOrThrowArgs>(args: SelectSubset<T, MaintenanceTicketFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MaintenanceTicketClient<$Result.GetResult<Prisma.$MaintenanceTicketPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first MaintenanceTicket that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaintenanceTicketFindFirstArgs} args - Arguments to find a MaintenanceTicket
     * @example
     * // Get one MaintenanceTicket
     * const maintenanceTicket = await prisma.maintenanceTicket.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MaintenanceTicketFindFirstArgs>(args?: SelectSubset<T, MaintenanceTicketFindFirstArgs<ExtArgs>>): Prisma__MaintenanceTicketClient<$Result.GetResult<Prisma.$MaintenanceTicketPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first MaintenanceTicket that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaintenanceTicketFindFirstOrThrowArgs} args - Arguments to find a MaintenanceTicket
     * @example
     * // Get one MaintenanceTicket
     * const maintenanceTicket = await prisma.maintenanceTicket.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MaintenanceTicketFindFirstOrThrowArgs>(args?: SelectSubset<T, MaintenanceTicketFindFirstOrThrowArgs<ExtArgs>>): Prisma__MaintenanceTicketClient<$Result.GetResult<Prisma.$MaintenanceTicketPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more MaintenanceTickets that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaintenanceTicketFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MaintenanceTickets
     * const maintenanceTickets = await prisma.maintenanceTicket.findMany()
     * 
     * // Get first 10 MaintenanceTickets
     * const maintenanceTickets = await prisma.maintenanceTicket.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const maintenanceTicketWithIdOnly = await prisma.maintenanceTicket.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MaintenanceTicketFindManyArgs>(args?: SelectSubset<T, MaintenanceTicketFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MaintenanceTicketPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a MaintenanceTicket.
     * @param {MaintenanceTicketCreateArgs} args - Arguments to create a MaintenanceTicket.
     * @example
     * // Create one MaintenanceTicket
     * const MaintenanceTicket = await prisma.maintenanceTicket.create({
     *   data: {
     *     // ... data to create a MaintenanceTicket
     *   }
     * })
     * 
     */
    create<T extends MaintenanceTicketCreateArgs>(args: SelectSubset<T, MaintenanceTicketCreateArgs<ExtArgs>>): Prisma__MaintenanceTicketClient<$Result.GetResult<Prisma.$MaintenanceTicketPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many MaintenanceTickets.
     * @param {MaintenanceTicketCreateManyArgs} args - Arguments to create many MaintenanceTickets.
     * @example
     * // Create many MaintenanceTickets
     * const maintenanceTicket = await prisma.maintenanceTicket.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MaintenanceTicketCreateManyArgs>(args?: SelectSubset<T, MaintenanceTicketCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many MaintenanceTickets and returns the data saved in the database.
     * @param {MaintenanceTicketCreateManyAndReturnArgs} args - Arguments to create many MaintenanceTickets.
     * @example
     * // Create many MaintenanceTickets
     * const maintenanceTicket = await prisma.maintenanceTicket.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many MaintenanceTickets and only return the `id`
     * const maintenanceTicketWithIdOnly = await prisma.maintenanceTicket.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MaintenanceTicketCreateManyAndReturnArgs>(args?: SelectSubset<T, MaintenanceTicketCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MaintenanceTicketPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a MaintenanceTicket.
     * @param {MaintenanceTicketDeleteArgs} args - Arguments to delete one MaintenanceTicket.
     * @example
     * // Delete one MaintenanceTicket
     * const MaintenanceTicket = await prisma.maintenanceTicket.delete({
     *   where: {
     *     // ... filter to delete one MaintenanceTicket
     *   }
     * })
     * 
     */
    delete<T extends MaintenanceTicketDeleteArgs>(args: SelectSubset<T, MaintenanceTicketDeleteArgs<ExtArgs>>): Prisma__MaintenanceTicketClient<$Result.GetResult<Prisma.$MaintenanceTicketPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one MaintenanceTicket.
     * @param {MaintenanceTicketUpdateArgs} args - Arguments to update one MaintenanceTicket.
     * @example
     * // Update one MaintenanceTicket
     * const maintenanceTicket = await prisma.maintenanceTicket.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MaintenanceTicketUpdateArgs>(args: SelectSubset<T, MaintenanceTicketUpdateArgs<ExtArgs>>): Prisma__MaintenanceTicketClient<$Result.GetResult<Prisma.$MaintenanceTicketPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more MaintenanceTickets.
     * @param {MaintenanceTicketDeleteManyArgs} args - Arguments to filter MaintenanceTickets to delete.
     * @example
     * // Delete a few MaintenanceTickets
     * const { count } = await prisma.maintenanceTicket.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MaintenanceTicketDeleteManyArgs>(args?: SelectSubset<T, MaintenanceTicketDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MaintenanceTickets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaintenanceTicketUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MaintenanceTickets
     * const maintenanceTicket = await prisma.maintenanceTicket.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MaintenanceTicketUpdateManyArgs>(args: SelectSubset<T, MaintenanceTicketUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one MaintenanceTicket.
     * @param {MaintenanceTicketUpsertArgs} args - Arguments to update or create a MaintenanceTicket.
     * @example
     * // Update or create a MaintenanceTicket
     * const maintenanceTicket = await prisma.maintenanceTicket.upsert({
     *   create: {
     *     // ... data to create a MaintenanceTicket
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MaintenanceTicket we want to update
     *   }
     * })
     */
    upsert<T extends MaintenanceTicketUpsertArgs>(args: SelectSubset<T, MaintenanceTicketUpsertArgs<ExtArgs>>): Prisma__MaintenanceTicketClient<$Result.GetResult<Prisma.$MaintenanceTicketPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of MaintenanceTickets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaintenanceTicketCountArgs} args - Arguments to filter MaintenanceTickets to count.
     * @example
     * // Count the number of MaintenanceTickets
     * const count = await prisma.maintenanceTicket.count({
     *   where: {
     *     // ... the filter for the MaintenanceTickets we want to count
     *   }
     * })
    **/
    count<T extends MaintenanceTicketCountArgs>(
      args?: Subset<T, MaintenanceTicketCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MaintenanceTicketCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MaintenanceTicket.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaintenanceTicketAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MaintenanceTicketAggregateArgs>(args: Subset<T, MaintenanceTicketAggregateArgs>): Prisma.PrismaPromise<GetMaintenanceTicketAggregateType<T>>

    /**
     * Group by MaintenanceTicket.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaintenanceTicketGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MaintenanceTicketGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MaintenanceTicketGroupByArgs['orderBy'] }
        : { orderBy?: MaintenanceTicketGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MaintenanceTicketGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMaintenanceTicketGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MaintenanceTicket model
   */
  readonly fields: MaintenanceTicketFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MaintenanceTicket.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MaintenanceTicketClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    tenant<T extends TenantDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TenantDefaultArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    room<T extends RoomDefaultArgs<ExtArgs> = {}>(args?: Subset<T, RoomDefaultArgs<ExtArgs>>): Prisma__RoomClient<$Result.GetResult<Prisma.$RoomPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the MaintenanceTicket model
   */ 
  interface MaintenanceTicketFieldRefs {
    readonly id: FieldRef<"MaintenanceTicket", 'String'>
    readonly tenantId: FieldRef<"MaintenanceTicket", 'String'>
    readonly roomId: FieldRef<"MaintenanceTicket", 'String'>
    readonly title: FieldRef<"MaintenanceTicket", 'String'>
    readonly description: FieldRef<"MaintenanceTicket", 'String'>
    readonly priority: FieldRef<"MaintenanceTicket", 'String'>
    readonly status: FieldRef<"MaintenanceTicket", 'String'>
    readonly reportedBy: FieldRef<"MaintenanceTicket", 'String'>
    readonly resolvedAt: FieldRef<"MaintenanceTicket", 'DateTime'>
    readonly createdAt: FieldRef<"MaintenanceTicket", 'DateTime'>
    readonly updatedAt: FieldRef<"MaintenanceTicket", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * MaintenanceTicket findUnique
   */
  export type MaintenanceTicketFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaintenanceTicket
     */
    select?: MaintenanceTicketSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaintenanceTicketInclude<ExtArgs> | null
    /**
     * Filter, which MaintenanceTicket to fetch.
     */
    where: MaintenanceTicketWhereUniqueInput
  }

  /**
   * MaintenanceTicket findUniqueOrThrow
   */
  export type MaintenanceTicketFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaintenanceTicket
     */
    select?: MaintenanceTicketSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaintenanceTicketInclude<ExtArgs> | null
    /**
     * Filter, which MaintenanceTicket to fetch.
     */
    where: MaintenanceTicketWhereUniqueInput
  }

  /**
   * MaintenanceTicket findFirst
   */
  export type MaintenanceTicketFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaintenanceTicket
     */
    select?: MaintenanceTicketSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaintenanceTicketInclude<ExtArgs> | null
    /**
     * Filter, which MaintenanceTicket to fetch.
     */
    where?: MaintenanceTicketWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MaintenanceTickets to fetch.
     */
    orderBy?: MaintenanceTicketOrderByWithRelationInput | MaintenanceTicketOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MaintenanceTickets.
     */
    cursor?: MaintenanceTicketWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MaintenanceTickets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MaintenanceTickets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MaintenanceTickets.
     */
    distinct?: MaintenanceTicketScalarFieldEnum | MaintenanceTicketScalarFieldEnum[]
  }

  /**
   * MaintenanceTicket findFirstOrThrow
   */
  export type MaintenanceTicketFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaintenanceTicket
     */
    select?: MaintenanceTicketSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaintenanceTicketInclude<ExtArgs> | null
    /**
     * Filter, which MaintenanceTicket to fetch.
     */
    where?: MaintenanceTicketWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MaintenanceTickets to fetch.
     */
    orderBy?: MaintenanceTicketOrderByWithRelationInput | MaintenanceTicketOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MaintenanceTickets.
     */
    cursor?: MaintenanceTicketWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MaintenanceTickets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MaintenanceTickets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MaintenanceTickets.
     */
    distinct?: MaintenanceTicketScalarFieldEnum | MaintenanceTicketScalarFieldEnum[]
  }

  /**
   * MaintenanceTicket findMany
   */
  export type MaintenanceTicketFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaintenanceTicket
     */
    select?: MaintenanceTicketSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaintenanceTicketInclude<ExtArgs> | null
    /**
     * Filter, which MaintenanceTickets to fetch.
     */
    where?: MaintenanceTicketWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MaintenanceTickets to fetch.
     */
    orderBy?: MaintenanceTicketOrderByWithRelationInput | MaintenanceTicketOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MaintenanceTickets.
     */
    cursor?: MaintenanceTicketWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MaintenanceTickets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MaintenanceTickets.
     */
    skip?: number
    distinct?: MaintenanceTicketScalarFieldEnum | MaintenanceTicketScalarFieldEnum[]
  }

  /**
   * MaintenanceTicket create
   */
  export type MaintenanceTicketCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaintenanceTicket
     */
    select?: MaintenanceTicketSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaintenanceTicketInclude<ExtArgs> | null
    /**
     * The data needed to create a MaintenanceTicket.
     */
    data: XOR<MaintenanceTicketCreateInput, MaintenanceTicketUncheckedCreateInput>
  }

  /**
   * MaintenanceTicket createMany
   */
  export type MaintenanceTicketCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MaintenanceTickets.
     */
    data: MaintenanceTicketCreateManyInput | MaintenanceTicketCreateManyInput[]
  }

  /**
   * MaintenanceTicket createManyAndReturn
   */
  export type MaintenanceTicketCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaintenanceTicket
     */
    select?: MaintenanceTicketSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many MaintenanceTickets.
     */
    data: MaintenanceTicketCreateManyInput | MaintenanceTicketCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaintenanceTicketIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * MaintenanceTicket update
   */
  export type MaintenanceTicketUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaintenanceTicket
     */
    select?: MaintenanceTicketSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaintenanceTicketInclude<ExtArgs> | null
    /**
     * The data needed to update a MaintenanceTicket.
     */
    data: XOR<MaintenanceTicketUpdateInput, MaintenanceTicketUncheckedUpdateInput>
    /**
     * Choose, which MaintenanceTicket to update.
     */
    where: MaintenanceTicketWhereUniqueInput
  }

  /**
   * MaintenanceTicket updateMany
   */
  export type MaintenanceTicketUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MaintenanceTickets.
     */
    data: XOR<MaintenanceTicketUpdateManyMutationInput, MaintenanceTicketUncheckedUpdateManyInput>
    /**
     * Filter which MaintenanceTickets to update
     */
    where?: MaintenanceTicketWhereInput
  }

  /**
   * MaintenanceTicket upsert
   */
  export type MaintenanceTicketUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaintenanceTicket
     */
    select?: MaintenanceTicketSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaintenanceTicketInclude<ExtArgs> | null
    /**
     * The filter to search for the MaintenanceTicket to update in case it exists.
     */
    where: MaintenanceTicketWhereUniqueInput
    /**
     * In case the MaintenanceTicket found by the `where` argument doesn't exist, create a new MaintenanceTicket with this data.
     */
    create: XOR<MaintenanceTicketCreateInput, MaintenanceTicketUncheckedCreateInput>
    /**
     * In case the MaintenanceTicket was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MaintenanceTicketUpdateInput, MaintenanceTicketUncheckedUpdateInput>
  }

  /**
   * MaintenanceTicket delete
   */
  export type MaintenanceTicketDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaintenanceTicket
     */
    select?: MaintenanceTicketSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaintenanceTicketInclude<ExtArgs> | null
    /**
     * Filter which MaintenanceTicket to delete.
     */
    where: MaintenanceTicketWhereUniqueInput
  }

  /**
   * MaintenanceTicket deleteMany
   */
  export type MaintenanceTicketDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MaintenanceTickets to delete
     */
    where?: MaintenanceTicketWhereInput
  }

  /**
   * MaintenanceTicket without action
   */
  export type MaintenanceTicketDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaintenanceTicket
     */
    select?: MaintenanceTicketSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaintenanceTicketInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const TenantScalarFieldEnum: {
    id: 'id',
    name: 'name',
    address: 'address',
    phone: 'phone',
    adminUserId: 'adminUserId',
    timezone: 'timezone',
    plan: 'plan',
    billingContact: 'billingContact',
    status: 'status',
    settings: 'settings',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type TenantScalarFieldEnum = (typeof TenantScalarFieldEnum)[keyof typeof TenantScalarFieldEnum]


  export const UserScalarFieldEnum: {
    id: 'id',
    tenantId: 'tenantId',
    email: 'email',
    passwordHash: 'passwordHash',
    role: 'role',
    name: 'name',
    phone: 'phone',
    isActive: 'isActive',
    lastLogin: 'lastLogin',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const RefreshTokenScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    token: 'token',
    expiresAt: 'expiresAt',
    revoked: 'revoked',
    createdAt: 'createdAt'
  };

  export type RefreshTokenScalarFieldEnum = (typeof RefreshTokenScalarFieldEnum)[keyof typeof RefreshTokenScalarFieldEnum]


  export const SantriScalarFieldEnum: {
    id: 'id',
    tenantId: 'tenantId',
    nisn: 'nisn',
    name: 'name',
    gender: 'gender',
    dob: 'dob',
    kelas: 'kelas',
    room: 'room',
    contact: 'contact',
    address: 'address',
    photo: 'photo',
    status: 'status',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SantriScalarFieldEnum = (typeof SantriScalarFieldEnum)[keyof typeof SantriScalarFieldEnum]


  export const WaliScalarFieldEnum: {
    id: 'id',
    tenantId: 'tenantId',
    name: 'name',
    relation: 'relation',
    phone: 'phone',
    email: 'email',
    address: 'address',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type WaliScalarFieldEnum = (typeof WaliScalarFieldEnum)[keyof typeof WaliScalarFieldEnum]


  export const SantriWaliScalarFieldEnum: {
    santriId: 'santriId',
    waliId: 'waliId',
    isPrimary: 'isPrimary'
  };

  export type SantriWaliScalarFieldEnum = (typeof SantriWaliScalarFieldEnum)[keyof typeof SantriWaliScalarFieldEnum]


  export const IzinScalarFieldEnum: {
    id: 'id',
    tenantId: 'tenantId',
    santriId: 'santriId',
    type: 'type',
    reason: 'reason',
    startAt: 'startAt',
    endAt: 'endAt',
    status: 'status',
    requestedBy: 'requestedBy',
    approvedBy: 'approvedBy',
    approvedAt: 'approvedAt',
    qrCodeData: 'qrCodeData',
    checkoutAt: 'checkoutAt',
    checkoutBy: 'checkoutBy',
    checkinAt: 'checkinAt',
    checkinBy: 'checkinBy',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type IzinScalarFieldEnum = (typeof IzinScalarFieldEnum)[keyof typeof IzinScalarFieldEnum]


  export const CatatanHarianScalarFieldEnum: {
    id: 'id',
    tenantId: 'tenantId',
    santriId: 'santriId',
    authorId: 'authorId',
    date: 'date',
    content: 'content',
    category: 'category',
    attachments: 'attachments',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CatatanHarianScalarFieldEnum = (typeof CatatanHarianScalarFieldEnum)[keyof typeof CatatanHarianScalarFieldEnum]


  export const PengumumanScalarFieldEnum: {
    id: 'id',
    tenantId: 'tenantId',
    title: 'title',
    content: 'content',
    audience: 'audience',
    pinnedUntil: 'pinnedUntil',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PengumumanScalarFieldEnum = (typeof PengumumanScalarFieldEnum)[keyof typeof PengumumanScalarFieldEnum]


  export const InvoiceScalarFieldEnum: {
    id: 'id',
    tenantId: 'tenantId',
    santriId: 'santriId',
    amountDue: 'amountDue',
    dueDate: 'dueDate',
    status: 'status',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type InvoiceScalarFieldEnum = (typeof InvoiceScalarFieldEnum)[keyof typeof InvoiceScalarFieldEnum]


  export const InvoiceLineScalarFieldEnum: {
    id: 'id',
    invoiceId: 'invoiceId',
    description: 'description',
    amount: 'amount',
    type: 'type'
  };

  export type InvoiceLineScalarFieldEnum = (typeof InvoiceLineScalarFieldEnum)[keyof typeof InvoiceLineScalarFieldEnum]


  export const PaymentScalarFieldEnum: {
    id: 'id',
    invoiceId: 'invoiceId',
    method: 'method',
    amount: 'amount',
    status: 'status',
    transactionRef: 'transactionRef',
    paidAt: 'paidAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PaymentScalarFieldEnum = (typeof PaymentScalarFieldEnum)[keyof typeof PaymentScalarFieldEnum]


  export const PelanggaranScalarFieldEnum: {
    id: 'id',
    tenantId: 'tenantId',
    santriId: 'santriId',
    recordedBy: 'recordedBy',
    category: 'category',
    severity: 'severity',
    points: 'points',
    description: 'description',
    date: 'date',
    resolved: 'resolved',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PelanggaranScalarFieldEnum = (typeof PelanggaranScalarFieldEnum)[keyof typeof PelanggaranScalarFieldEnum]


  export const PembinaanScalarFieldEnum: {
    id: 'id',
    tenantId: 'tenantId',
    santriId: 'santriId',
    plan: 'plan',
    targetDate: 'targetDate',
    status: 'status',
    assignedTo: 'assignedTo',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PembinaanScalarFieldEnum = (typeof PembinaanScalarFieldEnum)[keyof typeof PembinaanScalarFieldEnum]


  export const KunjunganScalarFieldEnum: {
    id: 'id',
    tenantId: 'tenantId',
    santriId: 'santriId',
    scheduledAt: 'scheduledAt',
    slot: 'slot',
    visitorLimit: 'visitorLimit',
    status: 'status',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type KunjunganScalarFieldEnum = (typeof KunjunganScalarFieldEnum)[keyof typeof KunjunganScalarFieldEnum]


  export const TamuScalarFieldEnum: {
    id: 'id',
    kunjunganId: 'kunjunganId',
    name: 'name',
    phone: 'phone',
    idNumber: 'idNumber',
    checkinAt: 'checkinAt',
    createdAt: 'createdAt'
  };

  export type TamuScalarFieldEnum = (typeof TamuScalarFieldEnum)[keyof typeof TamuScalarFieldEnum]


  export const HealthRecordScalarFieldEnum: {
    id: 'id',
    tenantId: 'tenantId',
    santriId: 'santriId',
    recordedBy: 'recordedBy',
    symptoms: 'symptoms',
    diagnosis: 'diagnosis',
    actionTaken: 'actionTaken',
    referred: 'referred',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type HealthRecordScalarFieldEnum = (typeof HealthRecordScalarFieldEnum)[keyof typeof HealthRecordScalarFieldEnum]


  export const MedicationScalarFieldEnum: {
    id: 'id',
    santriId: 'santriId',
    medicineName: 'medicineName',
    dose: 'dose',
    schedule: 'schedule',
    givenBy: 'givenBy',
    givenAt: 'givenAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type MedicationScalarFieldEnum = (typeof MedicationScalarFieldEnum)[keyof typeof MedicationScalarFieldEnum]


  export const AuditLogScalarFieldEnum: {
    id: 'id',
    tenantId: 'tenantId',
    userId: 'userId',
    action: 'action',
    entity: 'entity',
    entityId: 'entityId',
    oldValue: 'oldValue',
    newValue: 'newValue',
    ip: 'ip',
    createdAt: 'createdAt'
  };

  export type AuditLogScalarFieldEnum = (typeof AuditLogScalarFieldEnum)[keyof typeof AuditLogScalarFieldEnum]


  export const NotificationScalarFieldEnum: {
    id: 'id',
    tenantId: 'tenantId',
    userId: 'userId',
    type: 'type',
    title: 'title',
    body: 'body',
    read: 'read',
    createdAt: 'createdAt'
  };

  export type NotificationScalarFieldEnum = (typeof NotificationScalarFieldEnum)[keyof typeof NotificationScalarFieldEnum]


  export const WebhookEventScalarFieldEnum: {
    id: 'id',
    tenantId: 'tenantId',
    eventType: 'eventType',
    payload: 'payload',
    status: 'status',
    error: 'error',
    createdAt: 'createdAt',
    processedAt: 'processedAt'
  };

  export type WebhookEventScalarFieldEnum = (typeof WebhookEventScalarFieldEnum)[keyof typeof WebhookEventScalarFieldEnum]


  export const TahfidzScalarFieldEnum: {
    id: 'id',
    tenantId: 'tenantId',
    santriId: 'santriId',
    surah: 'surah',
    ayat: 'ayat',
    type: 'type',
    grade: 'grade',
    notes: 'notes',
    recordedBy: 'recordedBy',
    date: 'date',
    createdAt: 'createdAt'
  };

  export type TahfidzScalarFieldEnum = (typeof TahfidzScalarFieldEnum)[keyof typeof TahfidzScalarFieldEnum]


  export const MutabaahScalarFieldEnum: {
    id: 'id',
    tenantId: 'tenantId',
    santriId: 'santriId',
    date: 'date',
    sholatWajib: 'sholatWajib',
    tahajud: 'tahajud',
    dhuha: 'dhuha',
    puasaSunnah: 'puasaSunnah',
    bacaQuran: 'bacaQuran',
    notes: 'notes',
    recordedBy: 'recordedBy',
    createdAt: 'createdAt'
  };

  export type MutabaahScalarFieldEnum = (typeof MutabaahScalarFieldEnum)[keyof typeof MutabaahScalarFieldEnum]


  export const WalletScalarFieldEnum: {
    id: 'id',
    tenantId: 'tenantId',
    santriId: 'santriId',
    balance: 'balance',
    pin: 'pin',
    isActive: 'isActive',
    updatedAt: 'updatedAt'
  };

  export type WalletScalarFieldEnum = (typeof WalletScalarFieldEnum)[keyof typeof WalletScalarFieldEnum]


  export const WalletTransactionScalarFieldEnum: {
    id: 'id',
    walletId: 'walletId',
    amount: 'amount',
    type: 'type',
    method: 'method',
    description: 'description',
    reference: 'reference',
    status: 'status',
    handledBy: 'handledBy',
    createdAt: 'createdAt'
  };

  export type WalletTransactionScalarFieldEnum = (typeof WalletTransactionScalarFieldEnum)[keyof typeof WalletTransactionScalarFieldEnum]


  export const EmployeeScalarFieldEnum: {
    id: 'id',
    tenantId: 'tenantId',
    userId: 'userId',
    nip: 'nip',
    name: 'name',
    position: 'position',
    phone: 'phone',
    address: 'address',
    joinDate: 'joinDate',
    status: 'status',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type EmployeeScalarFieldEnum = (typeof EmployeeScalarFieldEnum)[keyof typeof EmployeeScalarFieldEnum]


  export const PayrollScalarFieldEnum: {
    id: 'id',
    tenantId: 'tenantId',
    employeeId: 'employeeId',
    month: 'month',
    year: 'year',
    baseSalary: 'baseSalary',
    allowances: 'allowances',
    deductions: 'deductions',
    netAmount: 'netAmount',
    status: 'status',
    paidAt: 'paidAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PayrollScalarFieldEnum = (typeof PayrollScalarFieldEnum)[keyof typeof PayrollScalarFieldEnum]


  export const AcademicScheduleScalarFieldEnum: {
    id: 'id',
    tenantId: 'tenantId',
    subject: 'subject',
    teacherId: 'teacherId',
    kelas: 'kelas',
    dayOfWeek: 'dayOfWeek',
    startTime: 'startTime',
    endTime: 'endTime',
    room: 'room',
    createdAt: 'createdAt'
  };

  export type AcademicScheduleScalarFieldEnum = (typeof AcademicScheduleScalarFieldEnum)[keyof typeof AcademicScheduleScalarFieldEnum]


  export const AttendanceScalarFieldEnum: {
    id: 'id',
    tenantId: 'tenantId',
    santriId: 'santriId',
    scheduleId: 'scheduleId',
    date: 'date',
    status: 'status',
    notes: 'notes',
    recordedBy: 'recordedBy',
    createdAt: 'createdAt'
  };

  export type AttendanceScalarFieldEnum = (typeof AttendanceScalarFieldEnum)[keyof typeof AttendanceScalarFieldEnum]


  export const GradeScalarFieldEnum: {
    id: 'id',
    tenantId: 'tenantId',
    santriId: 'santriId',
    subject: 'subject',
    semester: 'semester',
    academicYear: 'academicYear',
    type: 'type',
    score: 'score',
    notes: 'notes',
    createdAt: 'createdAt'
  };

  export type GradeScalarFieldEnum = (typeof GradeScalarFieldEnum)[keyof typeof GradeScalarFieldEnum]


  export const PpdbRegistrationScalarFieldEnum: {
    id: 'id',
    tenantId: 'tenantId',
    registrationNumber: 'registrationNumber',
    fullName: 'fullName',
    gender: 'gender',
    dob: 'dob',
    previousSchool: 'previousSchool',
    pathway: 'pathway',
    status: 'status',
    notes: 'notes',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PpdbRegistrationScalarFieldEnum = (typeof PpdbRegistrationScalarFieldEnum)[keyof typeof PpdbRegistrationScalarFieldEnum]


  export const PpdbDocumentScalarFieldEnum: {
    id: 'id',
    tenantId: 'tenantId',
    registrationId: 'registrationId',
    documentType: 'documentType',
    fileUrl: 'fileUrl',
    isVerified: 'isVerified',
    createdAt: 'createdAt'
  };

  export type PpdbDocumentScalarFieldEnum = (typeof PpdbDocumentScalarFieldEnum)[keyof typeof PpdbDocumentScalarFieldEnum]


  export const PpdbExamScalarFieldEnum: {
    id: 'id',
    tenantId: 'tenantId',
    registrationId: 'registrationId',
    examType: 'examType',
    examDate: 'examDate',
    score: 'score',
    result: 'result',
    interviewer: 'interviewer',
    createdAt: 'createdAt'
  };

  export type PpdbExamScalarFieldEnum = (typeof PpdbExamScalarFieldEnum)[keyof typeof PpdbExamScalarFieldEnum]


  export const ItemScalarFieldEnum: {
    id: 'id',
    tenantId: 'tenantId',
    sku: 'sku',
    name: 'name',
    description: 'description',
    category: 'category',
    price: 'price',
    costPrice: 'costPrice',
    stock: 'stock',
    minStock: 'minStock',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ItemScalarFieldEnum = (typeof ItemScalarFieldEnum)[keyof typeof ItemScalarFieldEnum]


  export const InventoryTransactionScalarFieldEnum: {
    id: 'id',
    tenantId: 'tenantId',
    itemId: 'itemId',
    type: 'type',
    quantity: 'quantity',
    reference: 'reference',
    notes: 'notes',
    handledBy: 'handledBy',
    date: 'date'
  };

  export type InventoryTransactionScalarFieldEnum = (typeof InventoryTransactionScalarFieldEnum)[keyof typeof InventoryTransactionScalarFieldEnum]


  export const SupplierScalarFieldEnum: {
    id: 'id',
    tenantId: 'tenantId',
    name: 'name',
    contact: 'contact',
    address: 'address',
    email: 'email',
    createdAt: 'createdAt'
  };

  export type SupplierScalarFieldEnum = (typeof SupplierScalarFieldEnum)[keyof typeof SupplierScalarFieldEnum]


  export const PurchaseOrderScalarFieldEnum: {
    id: 'id',
    tenantId: 'tenantId',
    supplierId: 'supplierId',
    poNumber: 'poNumber',
    totalCost: 'totalCost',
    status: 'status',
    orderDate: 'orderDate',
    notes: 'notes',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PurchaseOrderScalarFieldEnum = (typeof PurchaseOrderScalarFieldEnum)[keyof typeof PurchaseOrderScalarFieldEnum]


  export const BuildingScalarFieldEnum: {
    id: 'id',
    tenantId: 'tenantId',
    name: 'name',
    description: 'description',
    gender: 'gender',
    capacity: 'capacity',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type BuildingScalarFieldEnum = (typeof BuildingScalarFieldEnum)[keyof typeof BuildingScalarFieldEnum]


  export const RoomScalarFieldEnum: {
    id: 'id',
    tenantId: 'tenantId',
    buildingId: 'buildingId',
    name: 'name',
    capacity: 'capacity',
    picName: 'picName',
    createdAt: 'createdAt'
  };

  export type RoomScalarFieldEnum = (typeof RoomScalarFieldEnum)[keyof typeof RoomScalarFieldEnum]


  export const RoomAssignmentScalarFieldEnum: {
    id: 'id',
    tenantId: 'tenantId',
    roomId: 'roomId',
    santriId: 'santriId',
    startDate: 'startDate',
    endDate: 'endDate',
    status: 'status'
  };

  export type RoomAssignmentScalarFieldEnum = (typeof RoomAssignmentScalarFieldEnum)[keyof typeof RoomAssignmentScalarFieldEnum]


  export const MaintenanceTicketScalarFieldEnum: {
    id: 'id',
    tenantId: 'tenantId',
    roomId: 'roomId',
    title: 'title',
    description: 'description',
    priority: 'priority',
    status: 'status',
    reportedBy: 'reportedBy',
    resolvedAt: 'resolvedAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type MaintenanceTicketScalarFieldEnum = (typeof MaintenanceTicketScalarFieldEnum)[keyof typeof MaintenanceTicketScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references 
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    
  /**
   * Deep Input Types
   */


  export type TenantWhereInput = {
    AND?: TenantWhereInput | TenantWhereInput[]
    OR?: TenantWhereInput[]
    NOT?: TenantWhereInput | TenantWhereInput[]
    id?: StringFilter<"Tenant"> | string
    name?: StringFilter<"Tenant"> | string
    address?: StringNullableFilter<"Tenant"> | string | null
    phone?: StringNullableFilter<"Tenant"> | string | null
    adminUserId?: StringNullableFilter<"Tenant"> | string | null
    timezone?: StringFilter<"Tenant"> | string
    plan?: StringFilter<"Tenant"> | string
    billingContact?: StringNullableFilter<"Tenant"> | string | null
    status?: StringFilter<"Tenant"> | string
    settings?: StringNullableFilter<"Tenant"> | string | null
    createdAt?: DateTimeFilter<"Tenant"> | Date | string
    updatedAt?: DateTimeFilter<"Tenant"> | Date | string
    users?: UserListRelationFilter
    santri?: SantriListRelationFilter
    wali?: WaliListRelationFilter
    izin?: IzinListRelationFilter
    catatanHarian?: CatatanHarianListRelationFilter
    pengumuman?: PengumumanListRelationFilter
    invoices?: InvoiceListRelationFilter
    pelanggaran?: PelanggaranListRelationFilter
    pembinaan?: PembinaanListRelationFilter
    kunjungan?: KunjunganListRelationFilter
    healthRecords?: HealthRecordListRelationFilter
    auditLogs?: AuditLogListRelationFilter
    notifications?: NotificationListRelationFilter
    webhookEvents?: WebhookEventListRelationFilter
    tahfidz?: TahfidzListRelationFilter
    mutabaah?: MutabaahListRelationFilter
    wallets?: WalletListRelationFilter
    employees?: EmployeeListRelationFilter
    payrolls?: PayrollListRelationFilter
    academicScheds?: AcademicScheduleListRelationFilter
    attendances?: AttendanceListRelationFilter
    grades?: GradeListRelationFilter
    ppdbRegistrations?: PpdbRegistrationListRelationFilter
    ppdbDocuments?: PpdbDocumentListRelationFilter
    ppdbExams?: PpdbExamListRelationFilter
    inventoryItems?: ItemListRelationFilter
    inventoryTransactions?: InventoryTransactionListRelationFilter
    suppliers?: SupplierListRelationFilter
    purchaseOrders?: PurchaseOrderListRelationFilter
    buildings?: BuildingListRelationFilter
    rooms?: RoomListRelationFilter
    roomAssignments?: RoomAssignmentListRelationFilter
    maintenanceTickets?: MaintenanceTicketListRelationFilter
  }

  export type TenantOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    address?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    adminUserId?: SortOrderInput | SortOrder
    timezone?: SortOrder
    plan?: SortOrder
    billingContact?: SortOrderInput | SortOrder
    status?: SortOrder
    settings?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    users?: UserOrderByRelationAggregateInput
    santri?: SantriOrderByRelationAggregateInput
    wali?: WaliOrderByRelationAggregateInput
    izin?: IzinOrderByRelationAggregateInput
    catatanHarian?: CatatanHarianOrderByRelationAggregateInput
    pengumuman?: PengumumanOrderByRelationAggregateInput
    invoices?: InvoiceOrderByRelationAggregateInput
    pelanggaran?: PelanggaranOrderByRelationAggregateInput
    pembinaan?: PembinaanOrderByRelationAggregateInput
    kunjungan?: KunjunganOrderByRelationAggregateInput
    healthRecords?: HealthRecordOrderByRelationAggregateInput
    auditLogs?: AuditLogOrderByRelationAggregateInput
    notifications?: NotificationOrderByRelationAggregateInput
    webhookEvents?: WebhookEventOrderByRelationAggregateInput
    tahfidz?: TahfidzOrderByRelationAggregateInput
    mutabaah?: MutabaahOrderByRelationAggregateInput
    wallets?: WalletOrderByRelationAggregateInput
    employees?: EmployeeOrderByRelationAggregateInput
    payrolls?: PayrollOrderByRelationAggregateInput
    academicScheds?: AcademicScheduleOrderByRelationAggregateInput
    attendances?: AttendanceOrderByRelationAggregateInput
    grades?: GradeOrderByRelationAggregateInput
    ppdbRegistrations?: PpdbRegistrationOrderByRelationAggregateInput
    ppdbDocuments?: PpdbDocumentOrderByRelationAggregateInput
    ppdbExams?: PpdbExamOrderByRelationAggregateInput
    inventoryItems?: ItemOrderByRelationAggregateInput
    inventoryTransactions?: InventoryTransactionOrderByRelationAggregateInput
    suppliers?: SupplierOrderByRelationAggregateInput
    purchaseOrders?: PurchaseOrderOrderByRelationAggregateInput
    buildings?: BuildingOrderByRelationAggregateInput
    rooms?: RoomOrderByRelationAggregateInput
    roomAssignments?: RoomAssignmentOrderByRelationAggregateInput
    maintenanceTickets?: MaintenanceTicketOrderByRelationAggregateInput
  }

  export type TenantWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: TenantWhereInput | TenantWhereInput[]
    OR?: TenantWhereInput[]
    NOT?: TenantWhereInput | TenantWhereInput[]
    name?: StringFilter<"Tenant"> | string
    address?: StringNullableFilter<"Tenant"> | string | null
    phone?: StringNullableFilter<"Tenant"> | string | null
    adminUserId?: StringNullableFilter<"Tenant"> | string | null
    timezone?: StringFilter<"Tenant"> | string
    plan?: StringFilter<"Tenant"> | string
    billingContact?: StringNullableFilter<"Tenant"> | string | null
    status?: StringFilter<"Tenant"> | string
    settings?: StringNullableFilter<"Tenant"> | string | null
    createdAt?: DateTimeFilter<"Tenant"> | Date | string
    updatedAt?: DateTimeFilter<"Tenant"> | Date | string
    users?: UserListRelationFilter
    santri?: SantriListRelationFilter
    wali?: WaliListRelationFilter
    izin?: IzinListRelationFilter
    catatanHarian?: CatatanHarianListRelationFilter
    pengumuman?: PengumumanListRelationFilter
    invoices?: InvoiceListRelationFilter
    pelanggaran?: PelanggaranListRelationFilter
    pembinaan?: PembinaanListRelationFilter
    kunjungan?: KunjunganListRelationFilter
    healthRecords?: HealthRecordListRelationFilter
    auditLogs?: AuditLogListRelationFilter
    notifications?: NotificationListRelationFilter
    webhookEvents?: WebhookEventListRelationFilter
    tahfidz?: TahfidzListRelationFilter
    mutabaah?: MutabaahListRelationFilter
    wallets?: WalletListRelationFilter
    employees?: EmployeeListRelationFilter
    payrolls?: PayrollListRelationFilter
    academicScheds?: AcademicScheduleListRelationFilter
    attendances?: AttendanceListRelationFilter
    grades?: GradeListRelationFilter
    ppdbRegistrations?: PpdbRegistrationListRelationFilter
    ppdbDocuments?: PpdbDocumentListRelationFilter
    ppdbExams?: PpdbExamListRelationFilter
    inventoryItems?: ItemListRelationFilter
    inventoryTransactions?: InventoryTransactionListRelationFilter
    suppliers?: SupplierListRelationFilter
    purchaseOrders?: PurchaseOrderListRelationFilter
    buildings?: BuildingListRelationFilter
    rooms?: RoomListRelationFilter
    roomAssignments?: RoomAssignmentListRelationFilter
    maintenanceTickets?: MaintenanceTicketListRelationFilter
  }, "id">

  export type TenantOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    address?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    adminUserId?: SortOrderInput | SortOrder
    timezone?: SortOrder
    plan?: SortOrder
    billingContact?: SortOrderInput | SortOrder
    status?: SortOrder
    settings?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: TenantCountOrderByAggregateInput
    _max?: TenantMaxOrderByAggregateInput
    _min?: TenantMinOrderByAggregateInput
  }

  export type TenantScalarWhereWithAggregatesInput = {
    AND?: TenantScalarWhereWithAggregatesInput | TenantScalarWhereWithAggregatesInput[]
    OR?: TenantScalarWhereWithAggregatesInput[]
    NOT?: TenantScalarWhereWithAggregatesInput | TenantScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Tenant"> | string
    name?: StringWithAggregatesFilter<"Tenant"> | string
    address?: StringNullableWithAggregatesFilter<"Tenant"> | string | null
    phone?: StringNullableWithAggregatesFilter<"Tenant"> | string | null
    adminUserId?: StringNullableWithAggregatesFilter<"Tenant"> | string | null
    timezone?: StringWithAggregatesFilter<"Tenant"> | string
    plan?: StringWithAggregatesFilter<"Tenant"> | string
    billingContact?: StringNullableWithAggregatesFilter<"Tenant"> | string | null
    status?: StringWithAggregatesFilter<"Tenant"> | string
    settings?: StringNullableWithAggregatesFilter<"Tenant"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Tenant"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Tenant"> | Date | string
  }

  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: StringFilter<"User"> | string
    tenantId?: StringNullableFilter<"User"> | string | null
    email?: StringFilter<"User"> | string
    passwordHash?: StringFilter<"User"> | string
    role?: StringFilter<"User"> | string
    name?: StringFilter<"User"> | string
    phone?: StringNullableFilter<"User"> | string | null
    isActive?: BoolFilter<"User"> | boolean
    lastLogin?: DateTimeNullableFilter<"User"> | Date | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    tenant?: XOR<TenantNullableRelationFilter, TenantWhereInput> | null
    refreshTokens?: RefreshTokenListRelationFilter
    auditLogs?: AuditLogListRelationFilter
    notifications?: NotificationListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    tenantId?: SortOrderInput | SortOrder
    email?: SortOrder
    passwordHash?: SortOrder
    role?: SortOrder
    name?: SortOrder
    phone?: SortOrderInput | SortOrder
    isActive?: SortOrder
    lastLogin?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    tenant?: TenantOrderByWithRelationInput
    refreshTokens?: RefreshTokenOrderByRelationAggregateInput
    auditLogs?: AuditLogOrderByRelationAggregateInput
    notifications?: NotificationOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    tenantId?: StringNullableFilter<"User"> | string | null
    passwordHash?: StringFilter<"User"> | string
    role?: StringFilter<"User"> | string
    name?: StringFilter<"User"> | string
    phone?: StringNullableFilter<"User"> | string | null
    isActive?: BoolFilter<"User"> | boolean
    lastLogin?: DateTimeNullableFilter<"User"> | Date | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    tenant?: XOR<TenantNullableRelationFilter, TenantWhereInput> | null
    refreshTokens?: RefreshTokenListRelationFilter
    auditLogs?: AuditLogListRelationFilter
    notifications?: NotificationListRelationFilter
  }, "id" | "email">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    tenantId?: SortOrderInput | SortOrder
    email?: SortOrder
    passwordHash?: SortOrder
    role?: SortOrder
    name?: SortOrder
    phone?: SortOrderInput | SortOrder
    isActive?: SortOrder
    lastLogin?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"User"> | string
    tenantId?: StringNullableWithAggregatesFilter<"User"> | string | null
    email?: StringWithAggregatesFilter<"User"> | string
    passwordHash?: StringWithAggregatesFilter<"User"> | string
    role?: StringWithAggregatesFilter<"User"> | string
    name?: StringWithAggregatesFilter<"User"> | string
    phone?: StringNullableWithAggregatesFilter<"User"> | string | null
    isActive?: BoolWithAggregatesFilter<"User"> | boolean
    lastLogin?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
  }

  export type RefreshTokenWhereInput = {
    AND?: RefreshTokenWhereInput | RefreshTokenWhereInput[]
    OR?: RefreshTokenWhereInput[]
    NOT?: RefreshTokenWhereInput | RefreshTokenWhereInput[]
    id?: StringFilter<"RefreshToken"> | string
    userId?: StringFilter<"RefreshToken"> | string
    token?: StringFilter<"RefreshToken"> | string
    expiresAt?: DateTimeFilter<"RefreshToken"> | Date | string
    revoked?: BoolFilter<"RefreshToken"> | boolean
    createdAt?: DateTimeFilter<"RefreshToken"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type RefreshTokenOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    token?: SortOrder
    expiresAt?: SortOrder
    revoked?: SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type RefreshTokenWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    token?: string
    AND?: RefreshTokenWhereInput | RefreshTokenWhereInput[]
    OR?: RefreshTokenWhereInput[]
    NOT?: RefreshTokenWhereInput | RefreshTokenWhereInput[]
    userId?: StringFilter<"RefreshToken"> | string
    expiresAt?: DateTimeFilter<"RefreshToken"> | Date | string
    revoked?: BoolFilter<"RefreshToken"> | boolean
    createdAt?: DateTimeFilter<"RefreshToken"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id" | "token">

  export type RefreshTokenOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    token?: SortOrder
    expiresAt?: SortOrder
    revoked?: SortOrder
    createdAt?: SortOrder
    _count?: RefreshTokenCountOrderByAggregateInput
    _max?: RefreshTokenMaxOrderByAggregateInput
    _min?: RefreshTokenMinOrderByAggregateInput
  }

  export type RefreshTokenScalarWhereWithAggregatesInput = {
    AND?: RefreshTokenScalarWhereWithAggregatesInput | RefreshTokenScalarWhereWithAggregatesInput[]
    OR?: RefreshTokenScalarWhereWithAggregatesInput[]
    NOT?: RefreshTokenScalarWhereWithAggregatesInput | RefreshTokenScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"RefreshToken"> | string
    userId?: StringWithAggregatesFilter<"RefreshToken"> | string
    token?: StringWithAggregatesFilter<"RefreshToken"> | string
    expiresAt?: DateTimeWithAggregatesFilter<"RefreshToken"> | Date | string
    revoked?: BoolWithAggregatesFilter<"RefreshToken"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"RefreshToken"> | Date | string
  }

  export type SantriWhereInput = {
    AND?: SantriWhereInput | SantriWhereInput[]
    OR?: SantriWhereInput[]
    NOT?: SantriWhereInput | SantriWhereInput[]
    id?: StringFilter<"Santri"> | string
    tenantId?: StringFilter<"Santri"> | string
    nisn?: StringNullableFilter<"Santri"> | string | null
    name?: StringFilter<"Santri"> | string
    gender?: StringFilter<"Santri"> | string
    dob?: DateTimeNullableFilter<"Santri"> | Date | string | null
    kelas?: StringNullableFilter<"Santri"> | string | null
    room?: StringNullableFilter<"Santri"> | string | null
    contact?: StringNullableFilter<"Santri"> | string | null
    address?: StringNullableFilter<"Santri"> | string | null
    photo?: StringNullableFilter<"Santri"> | string | null
    status?: StringFilter<"Santri"> | string
    createdAt?: DateTimeFilter<"Santri"> | Date | string
    updatedAt?: DateTimeFilter<"Santri"> | Date | string
    tenant?: XOR<TenantRelationFilter, TenantWhereInput>
    walis?: SantriWaliListRelationFilter
    izin?: IzinListRelationFilter
    catatanHarian?: CatatanHarianListRelationFilter
    invoices?: InvoiceListRelationFilter
    pelanggaran?: PelanggaranListRelationFilter
    pembinaan?: PembinaanListRelationFilter
    kunjungan?: KunjunganListRelationFilter
    healthRecords?: HealthRecordListRelationFilter
    medications?: MedicationListRelationFilter
    tahfidz?: TahfidzListRelationFilter
    mutabaah?: MutabaahListRelationFilter
    wallet?: XOR<WalletNullableRelationFilter, WalletWhereInput> | null
    attendances?: AttendanceListRelationFilter
    grades?: GradeListRelationFilter
  }

  export type SantriOrderByWithRelationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    nisn?: SortOrderInput | SortOrder
    name?: SortOrder
    gender?: SortOrder
    dob?: SortOrderInput | SortOrder
    kelas?: SortOrderInput | SortOrder
    room?: SortOrderInput | SortOrder
    contact?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    photo?: SortOrderInput | SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    tenant?: TenantOrderByWithRelationInput
    walis?: SantriWaliOrderByRelationAggregateInput
    izin?: IzinOrderByRelationAggregateInput
    catatanHarian?: CatatanHarianOrderByRelationAggregateInput
    invoices?: InvoiceOrderByRelationAggregateInput
    pelanggaran?: PelanggaranOrderByRelationAggregateInput
    pembinaan?: PembinaanOrderByRelationAggregateInput
    kunjungan?: KunjunganOrderByRelationAggregateInput
    healthRecords?: HealthRecordOrderByRelationAggregateInput
    medications?: MedicationOrderByRelationAggregateInput
    tahfidz?: TahfidzOrderByRelationAggregateInput
    mutabaah?: MutabaahOrderByRelationAggregateInput
    wallet?: WalletOrderByWithRelationInput
    attendances?: AttendanceOrderByRelationAggregateInput
    grades?: GradeOrderByRelationAggregateInput
  }

  export type SantriWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: SantriWhereInput | SantriWhereInput[]
    OR?: SantriWhereInput[]
    NOT?: SantriWhereInput | SantriWhereInput[]
    tenantId?: StringFilter<"Santri"> | string
    nisn?: StringNullableFilter<"Santri"> | string | null
    name?: StringFilter<"Santri"> | string
    gender?: StringFilter<"Santri"> | string
    dob?: DateTimeNullableFilter<"Santri"> | Date | string | null
    kelas?: StringNullableFilter<"Santri"> | string | null
    room?: StringNullableFilter<"Santri"> | string | null
    contact?: StringNullableFilter<"Santri"> | string | null
    address?: StringNullableFilter<"Santri"> | string | null
    photo?: StringNullableFilter<"Santri"> | string | null
    status?: StringFilter<"Santri"> | string
    createdAt?: DateTimeFilter<"Santri"> | Date | string
    updatedAt?: DateTimeFilter<"Santri"> | Date | string
    tenant?: XOR<TenantRelationFilter, TenantWhereInput>
    walis?: SantriWaliListRelationFilter
    izin?: IzinListRelationFilter
    catatanHarian?: CatatanHarianListRelationFilter
    invoices?: InvoiceListRelationFilter
    pelanggaran?: PelanggaranListRelationFilter
    pembinaan?: PembinaanListRelationFilter
    kunjungan?: KunjunganListRelationFilter
    healthRecords?: HealthRecordListRelationFilter
    medications?: MedicationListRelationFilter
    tahfidz?: TahfidzListRelationFilter
    mutabaah?: MutabaahListRelationFilter
    wallet?: XOR<WalletNullableRelationFilter, WalletWhereInput> | null
    attendances?: AttendanceListRelationFilter
    grades?: GradeListRelationFilter
  }, "id">

  export type SantriOrderByWithAggregationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    nisn?: SortOrderInput | SortOrder
    name?: SortOrder
    gender?: SortOrder
    dob?: SortOrderInput | SortOrder
    kelas?: SortOrderInput | SortOrder
    room?: SortOrderInput | SortOrder
    contact?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    photo?: SortOrderInput | SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: SantriCountOrderByAggregateInput
    _max?: SantriMaxOrderByAggregateInput
    _min?: SantriMinOrderByAggregateInput
  }

  export type SantriScalarWhereWithAggregatesInput = {
    AND?: SantriScalarWhereWithAggregatesInput | SantriScalarWhereWithAggregatesInput[]
    OR?: SantriScalarWhereWithAggregatesInput[]
    NOT?: SantriScalarWhereWithAggregatesInput | SantriScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Santri"> | string
    tenantId?: StringWithAggregatesFilter<"Santri"> | string
    nisn?: StringNullableWithAggregatesFilter<"Santri"> | string | null
    name?: StringWithAggregatesFilter<"Santri"> | string
    gender?: StringWithAggregatesFilter<"Santri"> | string
    dob?: DateTimeNullableWithAggregatesFilter<"Santri"> | Date | string | null
    kelas?: StringNullableWithAggregatesFilter<"Santri"> | string | null
    room?: StringNullableWithAggregatesFilter<"Santri"> | string | null
    contact?: StringNullableWithAggregatesFilter<"Santri"> | string | null
    address?: StringNullableWithAggregatesFilter<"Santri"> | string | null
    photo?: StringNullableWithAggregatesFilter<"Santri"> | string | null
    status?: StringWithAggregatesFilter<"Santri"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Santri"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Santri"> | Date | string
  }

  export type WaliWhereInput = {
    AND?: WaliWhereInput | WaliWhereInput[]
    OR?: WaliWhereInput[]
    NOT?: WaliWhereInput | WaliWhereInput[]
    id?: StringFilter<"Wali"> | string
    tenantId?: StringFilter<"Wali"> | string
    name?: StringFilter<"Wali"> | string
    relation?: StringFilter<"Wali"> | string
    phone?: StringFilter<"Wali"> | string
    email?: StringNullableFilter<"Wali"> | string | null
    address?: StringNullableFilter<"Wali"> | string | null
    createdAt?: DateTimeFilter<"Wali"> | Date | string
    updatedAt?: DateTimeFilter<"Wali"> | Date | string
    tenant?: XOR<TenantRelationFilter, TenantWhereInput>
    santris?: SantriWaliListRelationFilter
  }

  export type WaliOrderByWithRelationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    name?: SortOrder
    relation?: SortOrder
    phone?: SortOrder
    email?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    tenant?: TenantOrderByWithRelationInput
    santris?: SantriWaliOrderByRelationAggregateInput
  }

  export type WaliWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: WaliWhereInput | WaliWhereInput[]
    OR?: WaliWhereInput[]
    NOT?: WaliWhereInput | WaliWhereInput[]
    tenantId?: StringFilter<"Wali"> | string
    name?: StringFilter<"Wali"> | string
    relation?: StringFilter<"Wali"> | string
    phone?: StringFilter<"Wali"> | string
    email?: StringNullableFilter<"Wali"> | string | null
    address?: StringNullableFilter<"Wali"> | string | null
    createdAt?: DateTimeFilter<"Wali"> | Date | string
    updatedAt?: DateTimeFilter<"Wali"> | Date | string
    tenant?: XOR<TenantRelationFilter, TenantWhereInput>
    santris?: SantriWaliListRelationFilter
  }, "id">

  export type WaliOrderByWithAggregationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    name?: SortOrder
    relation?: SortOrder
    phone?: SortOrder
    email?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: WaliCountOrderByAggregateInput
    _max?: WaliMaxOrderByAggregateInput
    _min?: WaliMinOrderByAggregateInput
  }

  export type WaliScalarWhereWithAggregatesInput = {
    AND?: WaliScalarWhereWithAggregatesInput | WaliScalarWhereWithAggregatesInput[]
    OR?: WaliScalarWhereWithAggregatesInput[]
    NOT?: WaliScalarWhereWithAggregatesInput | WaliScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Wali"> | string
    tenantId?: StringWithAggregatesFilter<"Wali"> | string
    name?: StringWithAggregatesFilter<"Wali"> | string
    relation?: StringWithAggregatesFilter<"Wali"> | string
    phone?: StringWithAggregatesFilter<"Wali"> | string
    email?: StringNullableWithAggregatesFilter<"Wali"> | string | null
    address?: StringNullableWithAggregatesFilter<"Wali"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Wali"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Wali"> | Date | string
  }

  export type SantriWaliWhereInput = {
    AND?: SantriWaliWhereInput | SantriWaliWhereInput[]
    OR?: SantriWaliWhereInput[]
    NOT?: SantriWaliWhereInput | SantriWaliWhereInput[]
    santriId?: StringFilter<"SantriWali"> | string
    waliId?: StringFilter<"SantriWali"> | string
    isPrimary?: BoolFilter<"SantriWali"> | boolean
    santri?: XOR<SantriRelationFilter, SantriWhereInput>
    wali?: XOR<WaliRelationFilter, WaliWhereInput>
  }

  export type SantriWaliOrderByWithRelationInput = {
    santriId?: SortOrder
    waliId?: SortOrder
    isPrimary?: SortOrder
    santri?: SantriOrderByWithRelationInput
    wali?: WaliOrderByWithRelationInput
  }

  export type SantriWaliWhereUniqueInput = Prisma.AtLeast<{
    santriId_waliId?: SantriWaliSantriIdWaliIdCompoundUniqueInput
    AND?: SantriWaliWhereInput | SantriWaliWhereInput[]
    OR?: SantriWaliWhereInput[]
    NOT?: SantriWaliWhereInput | SantriWaliWhereInput[]
    santriId?: StringFilter<"SantriWali"> | string
    waliId?: StringFilter<"SantriWali"> | string
    isPrimary?: BoolFilter<"SantriWali"> | boolean
    santri?: XOR<SantriRelationFilter, SantriWhereInput>
    wali?: XOR<WaliRelationFilter, WaliWhereInput>
  }, "santriId_waliId">

  export type SantriWaliOrderByWithAggregationInput = {
    santriId?: SortOrder
    waliId?: SortOrder
    isPrimary?: SortOrder
    _count?: SantriWaliCountOrderByAggregateInput
    _max?: SantriWaliMaxOrderByAggregateInput
    _min?: SantriWaliMinOrderByAggregateInput
  }

  export type SantriWaliScalarWhereWithAggregatesInput = {
    AND?: SantriWaliScalarWhereWithAggregatesInput | SantriWaliScalarWhereWithAggregatesInput[]
    OR?: SantriWaliScalarWhereWithAggregatesInput[]
    NOT?: SantriWaliScalarWhereWithAggregatesInput | SantriWaliScalarWhereWithAggregatesInput[]
    santriId?: StringWithAggregatesFilter<"SantriWali"> | string
    waliId?: StringWithAggregatesFilter<"SantriWali"> | string
    isPrimary?: BoolWithAggregatesFilter<"SantriWali"> | boolean
  }

  export type IzinWhereInput = {
    AND?: IzinWhereInput | IzinWhereInput[]
    OR?: IzinWhereInput[]
    NOT?: IzinWhereInput | IzinWhereInput[]
    id?: StringFilter<"Izin"> | string
    tenantId?: StringFilter<"Izin"> | string
    santriId?: StringFilter<"Izin"> | string
    type?: StringFilter<"Izin"> | string
    reason?: StringFilter<"Izin"> | string
    startAt?: DateTimeFilter<"Izin"> | Date | string
    endAt?: DateTimeFilter<"Izin"> | Date | string
    status?: StringFilter<"Izin"> | string
    requestedBy?: StringFilter<"Izin"> | string
    approvedBy?: StringNullableFilter<"Izin"> | string | null
    approvedAt?: DateTimeNullableFilter<"Izin"> | Date | string | null
    qrCodeData?: StringNullableFilter<"Izin"> | string | null
    checkoutAt?: DateTimeNullableFilter<"Izin"> | Date | string | null
    checkoutBy?: StringNullableFilter<"Izin"> | string | null
    checkinAt?: DateTimeNullableFilter<"Izin"> | Date | string | null
    checkinBy?: StringNullableFilter<"Izin"> | string | null
    createdAt?: DateTimeFilter<"Izin"> | Date | string
    updatedAt?: DateTimeFilter<"Izin"> | Date | string
    tenant?: XOR<TenantRelationFilter, TenantWhereInput>
    santri?: XOR<SantriRelationFilter, SantriWhereInput>
  }

  export type IzinOrderByWithRelationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    santriId?: SortOrder
    type?: SortOrder
    reason?: SortOrder
    startAt?: SortOrder
    endAt?: SortOrder
    status?: SortOrder
    requestedBy?: SortOrder
    approvedBy?: SortOrderInput | SortOrder
    approvedAt?: SortOrderInput | SortOrder
    qrCodeData?: SortOrderInput | SortOrder
    checkoutAt?: SortOrderInput | SortOrder
    checkoutBy?: SortOrderInput | SortOrder
    checkinAt?: SortOrderInput | SortOrder
    checkinBy?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    tenant?: TenantOrderByWithRelationInput
    santri?: SantriOrderByWithRelationInput
  }

  export type IzinWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    qrCodeData?: string
    AND?: IzinWhereInput | IzinWhereInput[]
    OR?: IzinWhereInput[]
    NOT?: IzinWhereInput | IzinWhereInput[]
    tenantId?: StringFilter<"Izin"> | string
    santriId?: StringFilter<"Izin"> | string
    type?: StringFilter<"Izin"> | string
    reason?: StringFilter<"Izin"> | string
    startAt?: DateTimeFilter<"Izin"> | Date | string
    endAt?: DateTimeFilter<"Izin"> | Date | string
    status?: StringFilter<"Izin"> | string
    requestedBy?: StringFilter<"Izin"> | string
    approvedBy?: StringNullableFilter<"Izin"> | string | null
    approvedAt?: DateTimeNullableFilter<"Izin"> | Date | string | null
    checkoutAt?: DateTimeNullableFilter<"Izin"> | Date | string | null
    checkoutBy?: StringNullableFilter<"Izin"> | string | null
    checkinAt?: DateTimeNullableFilter<"Izin"> | Date | string | null
    checkinBy?: StringNullableFilter<"Izin"> | string | null
    createdAt?: DateTimeFilter<"Izin"> | Date | string
    updatedAt?: DateTimeFilter<"Izin"> | Date | string
    tenant?: XOR<TenantRelationFilter, TenantWhereInput>
    santri?: XOR<SantriRelationFilter, SantriWhereInput>
  }, "id" | "qrCodeData">

  export type IzinOrderByWithAggregationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    santriId?: SortOrder
    type?: SortOrder
    reason?: SortOrder
    startAt?: SortOrder
    endAt?: SortOrder
    status?: SortOrder
    requestedBy?: SortOrder
    approvedBy?: SortOrderInput | SortOrder
    approvedAt?: SortOrderInput | SortOrder
    qrCodeData?: SortOrderInput | SortOrder
    checkoutAt?: SortOrderInput | SortOrder
    checkoutBy?: SortOrderInput | SortOrder
    checkinAt?: SortOrderInput | SortOrder
    checkinBy?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: IzinCountOrderByAggregateInput
    _max?: IzinMaxOrderByAggregateInput
    _min?: IzinMinOrderByAggregateInput
  }

  export type IzinScalarWhereWithAggregatesInput = {
    AND?: IzinScalarWhereWithAggregatesInput | IzinScalarWhereWithAggregatesInput[]
    OR?: IzinScalarWhereWithAggregatesInput[]
    NOT?: IzinScalarWhereWithAggregatesInput | IzinScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Izin"> | string
    tenantId?: StringWithAggregatesFilter<"Izin"> | string
    santriId?: StringWithAggregatesFilter<"Izin"> | string
    type?: StringWithAggregatesFilter<"Izin"> | string
    reason?: StringWithAggregatesFilter<"Izin"> | string
    startAt?: DateTimeWithAggregatesFilter<"Izin"> | Date | string
    endAt?: DateTimeWithAggregatesFilter<"Izin"> | Date | string
    status?: StringWithAggregatesFilter<"Izin"> | string
    requestedBy?: StringWithAggregatesFilter<"Izin"> | string
    approvedBy?: StringNullableWithAggregatesFilter<"Izin"> | string | null
    approvedAt?: DateTimeNullableWithAggregatesFilter<"Izin"> | Date | string | null
    qrCodeData?: StringNullableWithAggregatesFilter<"Izin"> | string | null
    checkoutAt?: DateTimeNullableWithAggregatesFilter<"Izin"> | Date | string | null
    checkoutBy?: StringNullableWithAggregatesFilter<"Izin"> | string | null
    checkinAt?: DateTimeNullableWithAggregatesFilter<"Izin"> | Date | string | null
    checkinBy?: StringNullableWithAggregatesFilter<"Izin"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Izin"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Izin"> | Date | string
  }

  export type CatatanHarianWhereInput = {
    AND?: CatatanHarianWhereInput | CatatanHarianWhereInput[]
    OR?: CatatanHarianWhereInput[]
    NOT?: CatatanHarianWhereInput | CatatanHarianWhereInput[]
    id?: StringFilter<"CatatanHarian"> | string
    tenantId?: StringFilter<"CatatanHarian"> | string
    santriId?: StringFilter<"CatatanHarian"> | string
    authorId?: StringFilter<"CatatanHarian"> | string
    date?: DateTimeFilter<"CatatanHarian"> | Date | string
    content?: StringFilter<"CatatanHarian"> | string
    category?: StringFilter<"CatatanHarian"> | string
    attachments?: StringNullableFilter<"CatatanHarian"> | string | null
    createdAt?: DateTimeFilter<"CatatanHarian"> | Date | string
    updatedAt?: DateTimeFilter<"CatatanHarian"> | Date | string
    tenant?: XOR<TenantRelationFilter, TenantWhereInput>
    santri?: XOR<SantriRelationFilter, SantriWhereInput>
  }

  export type CatatanHarianOrderByWithRelationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    santriId?: SortOrder
    authorId?: SortOrder
    date?: SortOrder
    content?: SortOrder
    category?: SortOrder
    attachments?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    tenant?: TenantOrderByWithRelationInput
    santri?: SantriOrderByWithRelationInput
  }

  export type CatatanHarianWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CatatanHarianWhereInput | CatatanHarianWhereInput[]
    OR?: CatatanHarianWhereInput[]
    NOT?: CatatanHarianWhereInput | CatatanHarianWhereInput[]
    tenantId?: StringFilter<"CatatanHarian"> | string
    santriId?: StringFilter<"CatatanHarian"> | string
    authorId?: StringFilter<"CatatanHarian"> | string
    date?: DateTimeFilter<"CatatanHarian"> | Date | string
    content?: StringFilter<"CatatanHarian"> | string
    category?: StringFilter<"CatatanHarian"> | string
    attachments?: StringNullableFilter<"CatatanHarian"> | string | null
    createdAt?: DateTimeFilter<"CatatanHarian"> | Date | string
    updatedAt?: DateTimeFilter<"CatatanHarian"> | Date | string
    tenant?: XOR<TenantRelationFilter, TenantWhereInput>
    santri?: XOR<SantriRelationFilter, SantriWhereInput>
  }, "id">

  export type CatatanHarianOrderByWithAggregationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    santriId?: SortOrder
    authorId?: SortOrder
    date?: SortOrder
    content?: SortOrder
    category?: SortOrder
    attachments?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CatatanHarianCountOrderByAggregateInput
    _max?: CatatanHarianMaxOrderByAggregateInput
    _min?: CatatanHarianMinOrderByAggregateInput
  }

  export type CatatanHarianScalarWhereWithAggregatesInput = {
    AND?: CatatanHarianScalarWhereWithAggregatesInput | CatatanHarianScalarWhereWithAggregatesInput[]
    OR?: CatatanHarianScalarWhereWithAggregatesInput[]
    NOT?: CatatanHarianScalarWhereWithAggregatesInput | CatatanHarianScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CatatanHarian"> | string
    tenantId?: StringWithAggregatesFilter<"CatatanHarian"> | string
    santriId?: StringWithAggregatesFilter<"CatatanHarian"> | string
    authorId?: StringWithAggregatesFilter<"CatatanHarian"> | string
    date?: DateTimeWithAggregatesFilter<"CatatanHarian"> | Date | string
    content?: StringWithAggregatesFilter<"CatatanHarian"> | string
    category?: StringWithAggregatesFilter<"CatatanHarian"> | string
    attachments?: StringNullableWithAggregatesFilter<"CatatanHarian"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"CatatanHarian"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"CatatanHarian"> | Date | string
  }

  export type PengumumanWhereInput = {
    AND?: PengumumanWhereInput | PengumumanWhereInput[]
    OR?: PengumumanWhereInput[]
    NOT?: PengumumanWhereInput | PengumumanWhereInput[]
    id?: StringFilter<"Pengumuman"> | string
    tenantId?: StringFilter<"Pengumuman"> | string
    title?: StringFilter<"Pengumuman"> | string
    content?: StringFilter<"Pengumuman"> | string
    audience?: StringFilter<"Pengumuman"> | string
    pinnedUntil?: DateTimeNullableFilter<"Pengumuman"> | Date | string | null
    createdAt?: DateTimeFilter<"Pengumuman"> | Date | string
    updatedAt?: DateTimeFilter<"Pengumuman"> | Date | string
    tenant?: XOR<TenantRelationFilter, TenantWhereInput>
  }

  export type PengumumanOrderByWithRelationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    title?: SortOrder
    content?: SortOrder
    audience?: SortOrder
    pinnedUntil?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    tenant?: TenantOrderByWithRelationInput
  }

  export type PengumumanWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PengumumanWhereInput | PengumumanWhereInput[]
    OR?: PengumumanWhereInput[]
    NOT?: PengumumanWhereInput | PengumumanWhereInput[]
    tenantId?: StringFilter<"Pengumuman"> | string
    title?: StringFilter<"Pengumuman"> | string
    content?: StringFilter<"Pengumuman"> | string
    audience?: StringFilter<"Pengumuman"> | string
    pinnedUntil?: DateTimeNullableFilter<"Pengumuman"> | Date | string | null
    createdAt?: DateTimeFilter<"Pengumuman"> | Date | string
    updatedAt?: DateTimeFilter<"Pengumuman"> | Date | string
    tenant?: XOR<TenantRelationFilter, TenantWhereInput>
  }, "id">

  export type PengumumanOrderByWithAggregationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    title?: SortOrder
    content?: SortOrder
    audience?: SortOrder
    pinnedUntil?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PengumumanCountOrderByAggregateInput
    _max?: PengumumanMaxOrderByAggregateInput
    _min?: PengumumanMinOrderByAggregateInput
  }

  export type PengumumanScalarWhereWithAggregatesInput = {
    AND?: PengumumanScalarWhereWithAggregatesInput | PengumumanScalarWhereWithAggregatesInput[]
    OR?: PengumumanScalarWhereWithAggregatesInput[]
    NOT?: PengumumanScalarWhereWithAggregatesInput | PengumumanScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Pengumuman"> | string
    tenantId?: StringWithAggregatesFilter<"Pengumuman"> | string
    title?: StringWithAggregatesFilter<"Pengumuman"> | string
    content?: StringWithAggregatesFilter<"Pengumuman"> | string
    audience?: StringWithAggregatesFilter<"Pengumuman"> | string
    pinnedUntil?: DateTimeNullableWithAggregatesFilter<"Pengumuman"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Pengumuman"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Pengumuman"> | Date | string
  }

  export type InvoiceWhereInput = {
    AND?: InvoiceWhereInput | InvoiceWhereInput[]
    OR?: InvoiceWhereInput[]
    NOT?: InvoiceWhereInput | InvoiceWhereInput[]
    id?: StringFilter<"Invoice"> | string
    tenantId?: StringFilter<"Invoice"> | string
    santriId?: StringFilter<"Invoice"> | string
    amountDue?: FloatFilter<"Invoice"> | number
    dueDate?: DateTimeFilter<"Invoice"> | Date | string
    status?: StringFilter<"Invoice"> | string
    createdAt?: DateTimeFilter<"Invoice"> | Date | string
    updatedAt?: DateTimeFilter<"Invoice"> | Date | string
    tenant?: XOR<TenantRelationFilter, TenantWhereInput>
    santri?: XOR<SantriRelationFilter, SantriWhereInput>
    lines?: InvoiceLineListRelationFilter
    payments?: PaymentListRelationFilter
  }

  export type InvoiceOrderByWithRelationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    santriId?: SortOrder
    amountDue?: SortOrder
    dueDate?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    tenant?: TenantOrderByWithRelationInput
    santri?: SantriOrderByWithRelationInput
    lines?: InvoiceLineOrderByRelationAggregateInput
    payments?: PaymentOrderByRelationAggregateInput
  }

  export type InvoiceWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: InvoiceWhereInput | InvoiceWhereInput[]
    OR?: InvoiceWhereInput[]
    NOT?: InvoiceWhereInput | InvoiceWhereInput[]
    tenantId?: StringFilter<"Invoice"> | string
    santriId?: StringFilter<"Invoice"> | string
    amountDue?: FloatFilter<"Invoice"> | number
    dueDate?: DateTimeFilter<"Invoice"> | Date | string
    status?: StringFilter<"Invoice"> | string
    createdAt?: DateTimeFilter<"Invoice"> | Date | string
    updatedAt?: DateTimeFilter<"Invoice"> | Date | string
    tenant?: XOR<TenantRelationFilter, TenantWhereInput>
    santri?: XOR<SantriRelationFilter, SantriWhereInput>
    lines?: InvoiceLineListRelationFilter
    payments?: PaymentListRelationFilter
  }, "id">

  export type InvoiceOrderByWithAggregationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    santriId?: SortOrder
    amountDue?: SortOrder
    dueDate?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: InvoiceCountOrderByAggregateInput
    _avg?: InvoiceAvgOrderByAggregateInput
    _max?: InvoiceMaxOrderByAggregateInput
    _min?: InvoiceMinOrderByAggregateInput
    _sum?: InvoiceSumOrderByAggregateInput
  }

  export type InvoiceScalarWhereWithAggregatesInput = {
    AND?: InvoiceScalarWhereWithAggregatesInput | InvoiceScalarWhereWithAggregatesInput[]
    OR?: InvoiceScalarWhereWithAggregatesInput[]
    NOT?: InvoiceScalarWhereWithAggregatesInput | InvoiceScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Invoice"> | string
    tenantId?: StringWithAggregatesFilter<"Invoice"> | string
    santriId?: StringWithAggregatesFilter<"Invoice"> | string
    amountDue?: FloatWithAggregatesFilter<"Invoice"> | number
    dueDate?: DateTimeWithAggregatesFilter<"Invoice"> | Date | string
    status?: StringWithAggregatesFilter<"Invoice"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Invoice"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Invoice"> | Date | string
  }

  export type InvoiceLineWhereInput = {
    AND?: InvoiceLineWhereInput | InvoiceLineWhereInput[]
    OR?: InvoiceLineWhereInput[]
    NOT?: InvoiceLineWhereInput | InvoiceLineWhereInput[]
    id?: StringFilter<"InvoiceLine"> | string
    invoiceId?: StringFilter<"InvoiceLine"> | string
    description?: StringFilter<"InvoiceLine"> | string
    amount?: FloatFilter<"InvoiceLine"> | number
    type?: StringFilter<"InvoiceLine"> | string
    invoice?: XOR<InvoiceRelationFilter, InvoiceWhereInput>
  }

  export type InvoiceLineOrderByWithRelationInput = {
    id?: SortOrder
    invoiceId?: SortOrder
    description?: SortOrder
    amount?: SortOrder
    type?: SortOrder
    invoice?: InvoiceOrderByWithRelationInput
  }

  export type InvoiceLineWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: InvoiceLineWhereInput | InvoiceLineWhereInput[]
    OR?: InvoiceLineWhereInput[]
    NOT?: InvoiceLineWhereInput | InvoiceLineWhereInput[]
    invoiceId?: StringFilter<"InvoiceLine"> | string
    description?: StringFilter<"InvoiceLine"> | string
    amount?: FloatFilter<"InvoiceLine"> | number
    type?: StringFilter<"InvoiceLine"> | string
    invoice?: XOR<InvoiceRelationFilter, InvoiceWhereInput>
  }, "id">

  export type InvoiceLineOrderByWithAggregationInput = {
    id?: SortOrder
    invoiceId?: SortOrder
    description?: SortOrder
    amount?: SortOrder
    type?: SortOrder
    _count?: InvoiceLineCountOrderByAggregateInput
    _avg?: InvoiceLineAvgOrderByAggregateInput
    _max?: InvoiceLineMaxOrderByAggregateInput
    _min?: InvoiceLineMinOrderByAggregateInput
    _sum?: InvoiceLineSumOrderByAggregateInput
  }

  export type InvoiceLineScalarWhereWithAggregatesInput = {
    AND?: InvoiceLineScalarWhereWithAggregatesInput | InvoiceLineScalarWhereWithAggregatesInput[]
    OR?: InvoiceLineScalarWhereWithAggregatesInput[]
    NOT?: InvoiceLineScalarWhereWithAggregatesInput | InvoiceLineScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"InvoiceLine"> | string
    invoiceId?: StringWithAggregatesFilter<"InvoiceLine"> | string
    description?: StringWithAggregatesFilter<"InvoiceLine"> | string
    amount?: FloatWithAggregatesFilter<"InvoiceLine"> | number
    type?: StringWithAggregatesFilter<"InvoiceLine"> | string
  }

  export type PaymentWhereInput = {
    AND?: PaymentWhereInput | PaymentWhereInput[]
    OR?: PaymentWhereInput[]
    NOT?: PaymentWhereInput | PaymentWhereInput[]
    id?: StringFilter<"Payment"> | string
    invoiceId?: StringFilter<"Payment"> | string
    method?: StringFilter<"Payment"> | string
    amount?: FloatFilter<"Payment"> | number
    status?: StringFilter<"Payment"> | string
    transactionRef?: StringNullableFilter<"Payment"> | string | null
    paidAt?: DateTimeNullableFilter<"Payment"> | Date | string | null
    createdAt?: DateTimeFilter<"Payment"> | Date | string
    updatedAt?: DateTimeFilter<"Payment"> | Date | string
    invoice?: XOR<InvoiceRelationFilter, InvoiceWhereInput>
  }

  export type PaymentOrderByWithRelationInput = {
    id?: SortOrder
    invoiceId?: SortOrder
    method?: SortOrder
    amount?: SortOrder
    status?: SortOrder
    transactionRef?: SortOrderInput | SortOrder
    paidAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    invoice?: InvoiceOrderByWithRelationInput
  }

  export type PaymentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PaymentWhereInput | PaymentWhereInput[]
    OR?: PaymentWhereInput[]
    NOT?: PaymentWhereInput | PaymentWhereInput[]
    invoiceId?: StringFilter<"Payment"> | string
    method?: StringFilter<"Payment"> | string
    amount?: FloatFilter<"Payment"> | number
    status?: StringFilter<"Payment"> | string
    transactionRef?: StringNullableFilter<"Payment"> | string | null
    paidAt?: DateTimeNullableFilter<"Payment"> | Date | string | null
    createdAt?: DateTimeFilter<"Payment"> | Date | string
    updatedAt?: DateTimeFilter<"Payment"> | Date | string
    invoice?: XOR<InvoiceRelationFilter, InvoiceWhereInput>
  }, "id">

  export type PaymentOrderByWithAggregationInput = {
    id?: SortOrder
    invoiceId?: SortOrder
    method?: SortOrder
    amount?: SortOrder
    status?: SortOrder
    transactionRef?: SortOrderInput | SortOrder
    paidAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PaymentCountOrderByAggregateInput
    _avg?: PaymentAvgOrderByAggregateInput
    _max?: PaymentMaxOrderByAggregateInput
    _min?: PaymentMinOrderByAggregateInput
    _sum?: PaymentSumOrderByAggregateInput
  }

  export type PaymentScalarWhereWithAggregatesInput = {
    AND?: PaymentScalarWhereWithAggregatesInput | PaymentScalarWhereWithAggregatesInput[]
    OR?: PaymentScalarWhereWithAggregatesInput[]
    NOT?: PaymentScalarWhereWithAggregatesInput | PaymentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Payment"> | string
    invoiceId?: StringWithAggregatesFilter<"Payment"> | string
    method?: StringWithAggregatesFilter<"Payment"> | string
    amount?: FloatWithAggregatesFilter<"Payment"> | number
    status?: StringWithAggregatesFilter<"Payment"> | string
    transactionRef?: StringNullableWithAggregatesFilter<"Payment"> | string | null
    paidAt?: DateTimeNullableWithAggregatesFilter<"Payment"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Payment"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Payment"> | Date | string
  }

  export type PelanggaranWhereInput = {
    AND?: PelanggaranWhereInput | PelanggaranWhereInput[]
    OR?: PelanggaranWhereInput[]
    NOT?: PelanggaranWhereInput | PelanggaranWhereInput[]
    id?: StringFilter<"Pelanggaran"> | string
    tenantId?: StringFilter<"Pelanggaran"> | string
    santriId?: StringFilter<"Pelanggaran"> | string
    recordedBy?: StringFilter<"Pelanggaran"> | string
    category?: StringFilter<"Pelanggaran"> | string
    severity?: IntFilter<"Pelanggaran"> | number
    points?: IntFilter<"Pelanggaran"> | number
    description?: StringFilter<"Pelanggaran"> | string
    date?: DateTimeFilter<"Pelanggaran"> | Date | string
    resolved?: BoolFilter<"Pelanggaran"> | boolean
    createdAt?: DateTimeFilter<"Pelanggaran"> | Date | string
    updatedAt?: DateTimeFilter<"Pelanggaran"> | Date | string
    tenant?: XOR<TenantRelationFilter, TenantWhereInput>
    santri?: XOR<SantriRelationFilter, SantriWhereInput>
  }

  export type PelanggaranOrderByWithRelationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    santriId?: SortOrder
    recordedBy?: SortOrder
    category?: SortOrder
    severity?: SortOrder
    points?: SortOrder
    description?: SortOrder
    date?: SortOrder
    resolved?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    tenant?: TenantOrderByWithRelationInput
    santri?: SantriOrderByWithRelationInput
  }

  export type PelanggaranWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PelanggaranWhereInput | PelanggaranWhereInput[]
    OR?: PelanggaranWhereInput[]
    NOT?: PelanggaranWhereInput | PelanggaranWhereInput[]
    tenantId?: StringFilter<"Pelanggaran"> | string
    santriId?: StringFilter<"Pelanggaran"> | string
    recordedBy?: StringFilter<"Pelanggaran"> | string
    category?: StringFilter<"Pelanggaran"> | string
    severity?: IntFilter<"Pelanggaran"> | number
    points?: IntFilter<"Pelanggaran"> | number
    description?: StringFilter<"Pelanggaran"> | string
    date?: DateTimeFilter<"Pelanggaran"> | Date | string
    resolved?: BoolFilter<"Pelanggaran"> | boolean
    createdAt?: DateTimeFilter<"Pelanggaran"> | Date | string
    updatedAt?: DateTimeFilter<"Pelanggaran"> | Date | string
    tenant?: XOR<TenantRelationFilter, TenantWhereInput>
    santri?: XOR<SantriRelationFilter, SantriWhereInput>
  }, "id">

  export type PelanggaranOrderByWithAggregationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    santriId?: SortOrder
    recordedBy?: SortOrder
    category?: SortOrder
    severity?: SortOrder
    points?: SortOrder
    description?: SortOrder
    date?: SortOrder
    resolved?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PelanggaranCountOrderByAggregateInput
    _avg?: PelanggaranAvgOrderByAggregateInput
    _max?: PelanggaranMaxOrderByAggregateInput
    _min?: PelanggaranMinOrderByAggregateInput
    _sum?: PelanggaranSumOrderByAggregateInput
  }

  export type PelanggaranScalarWhereWithAggregatesInput = {
    AND?: PelanggaranScalarWhereWithAggregatesInput | PelanggaranScalarWhereWithAggregatesInput[]
    OR?: PelanggaranScalarWhereWithAggregatesInput[]
    NOT?: PelanggaranScalarWhereWithAggregatesInput | PelanggaranScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Pelanggaran"> | string
    tenantId?: StringWithAggregatesFilter<"Pelanggaran"> | string
    santriId?: StringWithAggregatesFilter<"Pelanggaran"> | string
    recordedBy?: StringWithAggregatesFilter<"Pelanggaran"> | string
    category?: StringWithAggregatesFilter<"Pelanggaran"> | string
    severity?: IntWithAggregatesFilter<"Pelanggaran"> | number
    points?: IntWithAggregatesFilter<"Pelanggaran"> | number
    description?: StringWithAggregatesFilter<"Pelanggaran"> | string
    date?: DateTimeWithAggregatesFilter<"Pelanggaran"> | Date | string
    resolved?: BoolWithAggregatesFilter<"Pelanggaran"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Pelanggaran"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Pelanggaran"> | Date | string
  }

  export type PembinaanWhereInput = {
    AND?: PembinaanWhereInput | PembinaanWhereInput[]
    OR?: PembinaanWhereInput[]
    NOT?: PembinaanWhereInput | PembinaanWhereInput[]
    id?: StringFilter<"Pembinaan"> | string
    tenantId?: StringFilter<"Pembinaan"> | string
    santriId?: StringFilter<"Pembinaan"> | string
    plan?: StringFilter<"Pembinaan"> | string
    targetDate?: DateTimeFilter<"Pembinaan"> | Date | string
    status?: StringFilter<"Pembinaan"> | string
    assignedTo?: StringFilter<"Pembinaan"> | string
    createdAt?: DateTimeFilter<"Pembinaan"> | Date | string
    updatedAt?: DateTimeFilter<"Pembinaan"> | Date | string
    tenant?: XOR<TenantRelationFilter, TenantWhereInput>
    santri?: XOR<SantriRelationFilter, SantriWhereInput>
  }

  export type PembinaanOrderByWithRelationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    santriId?: SortOrder
    plan?: SortOrder
    targetDate?: SortOrder
    status?: SortOrder
    assignedTo?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    tenant?: TenantOrderByWithRelationInput
    santri?: SantriOrderByWithRelationInput
  }

  export type PembinaanWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PembinaanWhereInput | PembinaanWhereInput[]
    OR?: PembinaanWhereInput[]
    NOT?: PembinaanWhereInput | PembinaanWhereInput[]
    tenantId?: StringFilter<"Pembinaan"> | string
    santriId?: StringFilter<"Pembinaan"> | string
    plan?: StringFilter<"Pembinaan"> | string
    targetDate?: DateTimeFilter<"Pembinaan"> | Date | string
    status?: StringFilter<"Pembinaan"> | string
    assignedTo?: StringFilter<"Pembinaan"> | string
    createdAt?: DateTimeFilter<"Pembinaan"> | Date | string
    updatedAt?: DateTimeFilter<"Pembinaan"> | Date | string
    tenant?: XOR<TenantRelationFilter, TenantWhereInput>
    santri?: XOR<SantriRelationFilter, SantriWhereInput>
  }, "id">

  export type PembinaanOrderByWithAggregationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    santriId?: SortOrder
    plan?: SortOrder
    targetDate?: SortOrder
    status?: SortOrder
    assignedTo?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PembinaanCountOrderByAggregateInput
    _max?: PembinaanMaxOrderByAggregateInput
    _min?: PembinaanMinOrderByAggregateInput
  }

  export type PembinaanScalarWhereWithAggregatesInput = {
    AND?: PembinaanScalarWhereWithAggregatesInput | PembinaanScalarWhereWithAggregatesInput[]
    OR?: PembinaanScalarWhereWithAggregatesInput[]
    NOT?: PembinaanScalarWhereWithAggregatesInput | PembinaanScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Pembinaan"> | string
    tenantId?: StringWithAggregatesFilter<"Pembinaan"> | string
    santriId?: StringWithAggregatesFilter<"Pembinaan"> | string
    plan?: StringWithAggregatesFilter<"Pembinaan"> | string
    targetDate?: DateTimeWithAggregatesFilter<"Pembinaan"> | Date | string
    status?: StringWithAggregatesFilter<"Pembinaan"> | string
    assignedTo?: StringWithAggregatesFilter<"Pembinaan"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Pembinaan"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Pembinaan"> | Date | string
  }

  export type KunjunganWhereInput = {
    AND?: KunjunganWhereInput | KunjunganWhereInput[]
    OR?: KunjunganWhereInput[]
    NOT?: KunjunganWhereInput | KunjunganWhereInput[]
    id?: StringFilter<"Kunjungan"> | string
    tenantId?: StringFilter<"Kunjungan"> | string
    santriId?: StringFilter<"Kunjungan"> | string
    scheduledAt?: DateTimeFilter<"Kunjungan"> | Date | string
    slot?: StringFilter<"Kunjungan"> | string
    visitorLimit?: IntFilter<"Kunjungan"> | number
    status?: StringFilter<"Kunjungan"> | string
    createdAt?: DateTimeFilter<"Kunjungan"> | Date | string
    updatedAt?: DateTimeFilter<"Kunjungan"> | Date | string
    tenant?: XOR<TenantRelationFilter, TenantWhereInput>
    santri?: XOR<SantriRelationFilter, SantriWhereInput>
    tamu?: TamuListRelationFilter
  }

  export type KunjunganOrderByWithRelationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    santriId?: SortOrder
    scheduledAt?: SortOrder
    slot?: SortOrder
    visitorLimit?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    tenant?: TenantOrderByWithRelationInput
    santri?: SantriOrderByWithRelationInput
    tamu?: TamuOrderByRelationAggregateInput
  }

  export type KunjunganWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: KunjunganWhereInput | KunjunganWhereInput[]
    OR?: KunjunganWhereInput[]
    NOT?: KunjunganWhereInput | KunjunganWhereInput[]
    tenantId?: StringFilter<"Kunjungan"> | string
    santriId?: StringFilter<"Kunjungan"> | string
    scheduledAt?: DateTimeFilter<"Kunjungan"> | Date | string
    slot?: StringFilter<"Kunjungan"> | string
    visitorLimit?: IntFilter<"Kunjungan"> | number
    status?: StringFilter<"Kunjungan"> | string
    createdAt?: DateTimeFilter<"Kunjungan"> | Date | string
    updatedAt?: DateTimeFilter<"Kunjungan"> | Date | string
    tenant?: XOR<TenantRelationFilter, TenantWhereInput>
    santri?: XOR<SantriRelationFilter, SantriWhereInput>
    tamu?: TamuListRelationFilter
  }, "id">

  export type KunjunganOrderByWithAggregationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    santriId?: SortOrder
    scheduledAt?: SortOrder
    slot?: SortOrder
    visitorLimit?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: KunjunganCountOrderByAggregateInput
    _avg?: KunjunganAvgOrderByAggregateInput
    _max?: KunjunganMaxOrderByAggregateInput
    _min?: KunjunganMinOrderByAggregateInput
    _sum?: KunjunganSumOrderByAggregateInput
  }

  export type KunjunganScalarWhereWithAggregatesInput = {
    AND?: KunjunganScalarWhereWithAggregatesInput | KunjunganScalarWhereWithAggregatesInput[]
    OR?: KunjunganScalarWhereWithAggregatesInput[]
    NOT?: KunjunganScalarWhereWithAggregatesInput | KunjunganScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Kunjungan"> | string
    tenantId?: StringWithAggregatesFilter<"Kunjungan"> | string
    santriId?: StringWithAggregatesFilter<"Kunjungan"> | string
    scheduledAt?: DateTimeWithAggregatesFilter<"Kunjungan"> | Date | string
    slot?: StringWithAggregatesFilter<"Kunjungan"> | string
    visitorLimit?: IntWithAggregatesFilter<"Kunjungan"> | number
    status?: StringWithAggregatesFilter<"Kunjungan"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Kunjungan"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Kunjungan"> | Date | string
  }

  export type TamuWhereInput = {
    AND?: TamuWhereInput | TamuWhereInput[]
    OR?: TamuWhereInput[]
    NOT?: TamuWhereInput | TamuWhereInput[]
    id?: StringFilter<"Tamu"> | string
    kunjunganId?: StringFilter<"Tamu"> | string
    name?: StringFilter<"Tamu"> | string
    phone?: StringNullableFilter<"Tamu"> | string | null
    idNumber?: StringNullableFilter<"Tamu"> | string | null
    checkinAt?: DateTimeNullableFilter<"Tamu"> | Date | string | null
    createdAt?: DateTimeFilter<"Tamu"> | Date | string
    kunjungan?: XOR<KunjunganRelationFilter, KunjunganWhereInput>
  }

  export type TamuOrderByWithRelationInput = {
    id?: SortOrder
    kunjunganId?: SortOrder
    name?: SortOrder
    phone?: SortOrderInput | SortOrder
    idNumber?: SortOrderInput | SortOrder
    checkinAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    kunjungan?: KunjunganOrderByWithRelationInput
  }

  export type TamuWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: TamuWhereInput | TamuWhereInput[]
    OR?: TamuWhereInput[]
    NOT?: TamuWhereInput | TamuWhereInput[]
    kunjunganId?: StringFilter<"Tamu"> | string
    name?: StringFilter<"Tamu"> | string
    phone?: StringNullableFilter<"Tamu"> | string | null
    idNumber?: StringNullableFilter<"Tamu"> | string | null
    checkinAt?: DateTimeNullableFilter<"Tamu"> | Date | string | null
    createdAt?: DateTimeFilter<"Tamu"> | Date | string
    kunjungan?: XOR<KunjunganRelationFilter, KunjunganWhereInput>
  }, "id">

  export type TamuOrderByWithAggregationInput = {
    id?: SortOrder
    kunjunganId?: SortOrder
    name?: SortOrder
    phone?: SortOrderInput | SortOrder
    idNumber?: SortOrderInput | SortOrder
    checkinAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: TamuCountOrderByAggregateInput
    _max?: TamuMaxOrderByAggregateInput
    _min?: TamuMinOrderByAggregateInput
  }

  export type TamuScalarWhereWithAggregatesInput = {
    AND?: TamuScalarWhereWithAggregatesInput | TamuScalarWhereWithAggregatesInput[]
    OR?: TamuScalarWhereWithAggregatesInput[]
    NOT?: TamuScalarWhereWithAggregatesInput | TamuScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Tamu"> | string
    kunjunganId?: StringWithAggregatesFilter<"Tamu"> | string
    name?: StringWithAggregatesFilter<"Tamu"> | string
    phone?: StringNullableWithAggregatesFilter<"Tamu"> | string | null
    idNumber?: StringNullableWithAggregatesFilter<"Tamu"> | string | null
    checkinAt?: DateTimeNullableWithAggregatesFilter<"Tamu"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Tamu"> | Date | string
  }

  export type HealthRecordWhereInput = {
    AND?: HealthRecordWhereInput | HealthRecordWhereInput[]
    OR?: HealthRecordWhereInput[]
    NOT?: HealthRecordWhereInput | HealthRecordWhereInput[]
    id?: StringFilter<"HealthRecord"> | string
    tenantId?: StringFilter<"HealthRecord"> | string
    santriId?: StringFilter<"HealthRecord"> | string
    recordedBy?: StringFilter<"HealthRecord"> | string
    symptoms?: StringFilter<"HealthRecord"> | string
    diagnosis?: StringNullableFilter<"HealthRecord"> | string | null
    actionTaken?: StringNullableFilter<"HealthRecord"> | string | null
    referred?: BoolFilter<"HealthRecord"> | boolean
    createdAt?: DateTimeFilter<"HealthRecord"> | Date | string
    updatedAt?: DateTimeFilter<"HealthRecord"> | Date | string
    tenant?: XOR<TenantRelationFilter, TenantWhereInput>
    santri?: XOR<SantriRelationFilter, SantriWhereInput>
  }

  export type HealthRecordOrderByWithRelationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    santriId?: SortOrder
    recordedBy?: SortOrder
    symptoms?: SortOrder
    diagnosis?: SortOrderInput | SortOrder
    actionTaken?: SortOrderInput | SortOrder
    referred?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    tenant?: TenantOrderByWithRelationInput
    santri?: SantriOrderByWithRelationInput
  }

  export type HealthRecordWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: HealthRecordWhereInput | HealthRecordWhereInput[]
    OR?: HealthRecordWhereInput[]
    NOT?: HealthRecordWhereInput | HealthRecordWhereInput[]
    tenantId?: StringFilter<"HealthRecord"> | string
    santriId?: StringFilter<"HealthRecord"> | string
    recordedBy?: StringFilter<"HealthRecord"> | string
    symptoms?: StringFilter<"HealthRecord"> | string
    diagnosis?: StringNullableFilter<"HealthRecord"> | string | null
    actionTaken?: StringNullableFilter<"HealthRecord"> | string | null
    referred?: BoolFilter<"HealthRecord"> | boolean
    createdAt?: DateTimeFilter<"HealthRecord"> | Date | string
    updatedAt?: DateTimeFilter<"HealthRecord"> | Date | string
    tenant?: XOR<TenantRelationFilter, TenantWhereInput>
    santri?: XOR<SantriRelationFilter, SantriWhereInput>
  }, "id">

  export type HealthRecordOrderByWithAggregationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    santriId?: SortOrder
    recordedBy?: SortOrder
    symptoms?: SortOrder
    diagnosis?: SortOrderInput | SortOrder
    actionTaken?: SortOrderInput | SortOrder
    referred?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: HealthRecordCountOrderByAggregateInput
    _max?: HealthRecordMaxOrderByAggregateInput
    _min?: HealthRecordMinOrderByAggregateInput
  }

  export type HealthRecordScalarWhereWithAggregatesInput = {
    AND?: HealthRecordScalarWhereWithAggregatesInput | HealthRecordScalarWhereWithAggregatesInput[]
    OR?: HealthRecordScalarWhereWithAggregatesInput[]
    NOT?: HealthRecordScalarWhereWithAggregatesInput | HealthRecordScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"HealthRecord"> | string
    tenantId?: StringWithAggregatesFilter<"HealthRecord"> | string
    santriId?: StringWithAggregatesFilter<"HealthRecord"> | string
    recordedBy?: StringWithAggregatesFilter<"HealthRecord"> | string
    symptoms?: StringWithAggregatesFilter<"HealthRecord"> | string
    diagnosis?: StringNullableWithAggregatesFilter<"HealthRecord"> | string | null
    actionTaken?: StringNullableWithAggregatesFilter<"HealthRecord"> | string | null
    referred?: BoolWithAggregatesFilter<"HealthRecord"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"HealthRecord"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"HealthRecord"> | Date | string
  }

  export type MedicationWhereInput = {
    AND?: MedicationWhereInput | MedicationWhereInput[]
    OR?: MedicationWhereInput[]
    NOT?: MedicationWhereInput | MedicationWhereInput[]
    id?: StringFilter<"Medication"> | string
    santriId?: StringFilter<"Medication"> | string
    medicineName?: StringFilter<"Medication"> | string
    dose?: StringFilter<"Medication"> | string
    schedule?: StringFilter<"Medication"> | string
    givenBy?: StringNullableFilter<"Medication"> | string | null
    givenAt?: DateTimeNullableFilter<"Medication"> | Date | string | null
    createdAt?: DateTimeFilter<"Medication"> | Date | string
    updatedAt?: DateTimeFilter<"Medication"> | Date | string
    santri?: XOR<SantriRelationFilter, SantriWhereInput>
  }

  export type MedicationOrderByWithRelationInput = {
    id?: SortOrder
    santriId?: SortOrder
    medicineName?: SortOrder
    dose?: SortOrder
    schedule?: SortOrder
    givenBy?: SortOrderInput | SortOrder
    givenAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    santri?: SantriOrderByWithRelationInput
  }

  export type MedicationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: MedicationWhereInput | MedicationWhereInput[]
    OR?: MedicationWhereInput[]
    NOT?: MedicationWhereInput | MedicationWhereInput[]
    santriId?: StringFilter<"Medication"> | string
    medicineName?: StringFilter<"Medication"> | string
    dose?: StringFilter<"Medication"> | string
    schedule?: StringFilter<"Medication"> | string
    givenBy?: StringNullableFilter<"Medication"> | string | null
    givenAt?: DateTimeNullableFilter<"Medication"> | Date | string | null
    createdAt?: DateTimeFilter<"Medication"> | Date | string
    updatedAt?: DateTimeFilter<"Medication"> | Date | string
    santri?: XOR<SantriRelationFilter, SantriWhereInput>
  }, "id">

  export type MedicationOrderByWithAggregationInput = {
    id?: SortOrder
    santriId?: SortOrder
    medicineName?: SortOrder
    dose?: SortOrder
    schedule?: SortOrder
    givenBy?: SortOrderInput | SortOrder
    givenAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: MedicationCountOrderByAggregateInput
    _max?: MedicationMaxOrderByAggregateInput
    _min?: MedicationMinOrderByAggregateInput
  }

  export type MedicationScalarWhereWithAggregatesInput = {
    AND?: MedicationScalarWhereWithAggregatesInput | MedicationScalarWhereWithAggregatesInput[]
    OR?: MedicationScalarWhereWithAggregatesInput[]
    NOT?: MedicationScalarWhereWithAggregatesInput | MedicationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Medication"> | string
    santriId?: StringWithAggregatesFilter<"Medication"> | string
    medicineName?: StringWithAggregatesFilter<"Medication"> | string
    dose?: StringWithAggregatesFilter<"Medication"> | string
    schedule?: StringWithAggregatesFilter<"Medication"> | string
    givenBy?: StringNullableWithAggregatesFilter<"Medication"> | string | null
    givenAt?: DateTimeNullableWithAggregatesFilter<"Medication"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Medication"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Medication"> | Date | string
  }

  export type AuditLogWhereInput = {
    AND?: AuditLogWhereInput | AuditLogWhereInput[]
    OR?: AuditLogWhereInput[]
    NOT?: AuditLogWhereInput | AuditLogWhereInput[]
    id?: StringFilter<"AuditLog"> | string
    tenantId?: StringNullableFilter<"AuditLog"> | string | null
    userId?: StringNullableFilter<"AuditLog"> | string | null
    action?: StringFilter<"AuditLog"> | string
    entity?: StringFilter<"AuditLog"> | string
    entityId?: StringFilter<"AuditLog"> | string
    oldValue?: StringNullableFilter<"AuditLog"> | string | null
    newValue?: StringNullableFilter<"AuditLog"> | string | null
    ip?: StringNullableFilter<"AuditLog"> | string | null
    createdAt?: DateTimeFilter<"AuditLog"> | Date | string
    tenant?: XOR<TenantNullableRelationFilter, TenantWhereInput> | null
    user?: XOR<UserNullableRelationFilter, UserWhereInput> | null
  }

  export type AuditLogOrderByWithRelationInput = {
    id?: SortOrder
    tenantId?: SortOrderInput | SortOrder
    userId?: SortOrderInput | SortOrder
    action?: SortOrder
    entity?: SortOrder
    entityId?: SortOrder
    oldValue?: SortOrderInput | SortOrder
    newValue?: SortOrderInput | SortOrder
    ip?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    tenant?: TenantOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type AuditLogWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AuditLogWhereInput | AuditLogWhereInput[]
    OR?: AuditLogWhereInput[]
    NOT?: AuditLogWhereInput | AuditLogWhereInput[]
    tenantId?: StringNullableFilter<"AuditLog"> | string | null
    userId?: StringNullableFilter<"AuditLog"> | string | null
    action?: StringFilter<"AuditLog"> | string
    entity?: StringFilter<"AuditLog"> | string
    entityId?: StringFilter<"AuditLog"> | string
    oldValue?: StringNullableFilter<"AuditLog"> | string | null
    newValue?: StringNullableFilter<"AuditLog"> | string | null
    ip?: StringNullableFilter<"AuditLog"> | string | null
    createdAt?: DateTimeFilter<"AuditLog"> | Date | string
    tenant?: XOR<TenantNullableRelationFilter, TenantWhereInput> | null
    user?: XOR<UserNullableRelationFilter, UserWhereInput> | null
  }, "id">

  export type AuditLogOrderByWithAggregationInput = {
    id?: SortOrder
    tenantId?: SortOrderInput | SortOrder
    userId?: SortOrderInput | SortOrder
    action?: SortOrder
    entity?: SortOrder
    entityId?: SortOrder
    oldValue?: SortOrderInput | SortOrder
    newValue?: SortOrderInput | SortOrder
    ip?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: AuditLogCountOrderByAggregateInput
    _max?: AuditLogMaxOrderByAggregateInput
    _min?: AuditLogMinOrderByAggregateInput
  }

  export type AuditLogScalarWhereWithAggregatesInput = {
    AND?: AuditLogScalarWhereWithAggregatesInput | AuditLogScalarWhereWithAggregatesInput[]
    OR?: AuditLogScalarWhereWithAggregatesInput[]
    NOT?: AuditLogScalarWhereWithAggregatesInput | AuditLogScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AuditLog"> | string
    tenantId?: StringNullableWithAggregatesFilter<"AuditLog"> | string | null
    userId?: StringNullableWithAggregatesFilter<"AuditLog"> | string | null
    action?: StringWithAggregatesFilter<"AuditLog"> | string
    entity?: StringWithAggregatesFilter<"AuditLog"> | string
    entityId?: StringWithAggregatesFilter<"AuditLog"> | string
    oldValue?: StringNullableWithAggregatesFilter<"AuditLog"> | string | null
    newValue?: StringNullableWithAggregatesFilter<"AuditLog"> | string | null
    ip?: StringNullableWithAggregatesFilter<"AuditLog"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"AuditLog"> | Date | string
  }

  export type NotificationWhereInput = {
    AND?: NotificationWhereInput | NotificationWhereInput[]
    OR?: NotificationWhereInput[]
    NOT?: NotificationWhereInput | NotificationWhereInput[]
    id?: StringFilter<"Notification"> | string
    tenantId?: StringFilter<"Notification"> | string
    userId?: StringFilter<"Notification"> | string
    type?: StringFilter<"Notification"> | string
    title?: StringFilter<"Notification"> | string
    body?: StringFilter<"Notification"> | string
    read?: BoolFilter<"Notification"> | boolean
    createdAt?: DateTimeFilter<"Notification"> | Date | string
    tenant?: XOR<TenantRelationFilter, TenantWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type NotificationOrderByWithRelationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    title?: SortOrder
    body?: SortOrder
    read?: SortOrder
    createdAt?: SortOrder
    tenant?: TenantOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type NotificationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: NotificationWhereInput | NotificationWhereInput[]
    OR?: NotificationWhereInput[]
    NOT?: NotificationWhereInput | NotificationWhereInput[]
    tenantId?: StringFilter<"Notification"> | string
    userId?: StringFilter<"Notification"> | string
    type?: StringFilter<"Notification"> | string
    title?: StringFilter<"Notification"> | string
    body?: StringFilter<"Notification"> | string
    read?: BoolFilter<"Notification"> | boolean
    createdAt?: DateTimeFilter<"Notification"> | Date | string
    tenant?: XOR<TenantRelationFilter, TenantWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id">

  export type NotificationOrderByWithAggregationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    title?: SortOrder
    body?: SortOrder
    read?: SortOrder
    createdAt?: SortOrder
    _count?: NotificationCountOrderByAggregateInput
    _max?: NotificationMaxOrderByAggregateInput
    _min?: NotificationMinOrderByAggregateInput
  }

  export type NotificationScalarWhereWithAggregatesInput = {
    AND?: NotificationScalarWhereWithAggregatesInput | NotificationScalarWhereWithAggregatesInput[]
    OR?: NotificationScalarWhereWithAggregatesInput[]
    NOT?: NotificationScalarWhereWithAggregatesInput | NotificationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Notification"> | string
    tenantId?: StringWithAggregatesFilter<"Notification"> | string
    userId?: StringWithAggregatesFilter<"Notification"> | string
    type?: StringWithAggregatesFilter<"Notification"> | string
    title?: StringWithAggregatesFilter<"Notification"> | string
    body?: StringWithAggregatesFilter<"Notification"> | string
    read?: BoolWithAggregatesFilter<"Notification"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Notification"> | Date | string
  }

  export type WebhookEventWhereInput = {
    AND?: WebhookEventWhereInput | WebhookEventWhereInput[]
    OR?: WebhookEventWhereInput[]
    NOT?: WebhookEventWhereInput | WebhookEventWhereInput[]
    id?: StringFilter<"WebhookEvent"> | string
    tenantId?: StringNullableFilter<"WebhookEvent"> | string | null
    eventType?: StringFilter<"WebhookEvent"> | string
    payload?: StringFilter<"WebhookEvent"> | string
    status?: StringFilter<"WebhookEvent"> | string
    error?: StringNullableFilter<"WebhookEvent"> | string | null
    createdAt?: DateTimeFilter<"WebhookEvent"> | Date | string
    processedAt?: DateTimeNullableFilter<"WebhookEvent"> | Date | string | null
    tenant?: XOR<TenantNullableRelationFilter, TenantWhereInput> | null
  }

  export type WebhookEventOrderByWithRelationInput = {
    id?: SortOrder
    tenantId?: SortOrderInput | SortOrder
    eventType?: SortOrder
    payload?: SortOrder
    status?: SortOrder
    error?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    processedAt?: SortOrderInput | SortOrder
    tenant?: TenantOrderByWithRelationInput
  }

  export type WebhookEventWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: WebhookEventWhereInput | WebhookEventWhereInput[]
    OR?: WebhookEventWhereInput[]
    NOT?: WebhookEventWhereInput | WebhookEventWhereInput[]
    tenantId?: StringNullableFilter<"WebhookEvent"> | string | null
    eventType?: StringFilter<"WebhookEvent"> | string
    payload?: StringFilter<"WebhookEvent"> | string
    status?: StringFilter<"WebhookEvent"> | string
    error?: StringNullableFilter<"WebhookEvent"> | string | null
    createdAt?: DateTimeFilter<"WebhookEvent"> | Date | string
    processedAt?: DateTimeNullableFilter<"WebhookEvent"> | Date | string | null
    tenant?: XOR<TenantNullableRelationFilter, TenantWhereInput> | null
  }, "id">

  export type WebhookEventOrderByWithAggregationInput = {
    id?: SortOrder
    tenantId?: SortOrderInput | SortOrder
    eventType?: SortOrder
    payload?: SortOrder
    status?: SortOrder
    error?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    processedAt?: SortOrderInput | SortOrder
    _count?: WebhookEventCountOrderByAggregateInput
    _max?: WebhookEventMaxOrderByAggregateInput
    _min?: WebhookEventMinOrderByAggregateInput
  }

  export type WebhookEventScalarWhereWithAggregatesInput = {
    AND?: WebhookEventScalarWhereWithAggregatesInput | WebhookEventScalarWhereWithAggregatesInput[]
    OR?: WebhookEventScalarWhereWithAggregatesInput[]
    NOT?: WebhookEventScalarWhereWithAggregatesInput | WebhookEventScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"WebhookEvent"> | string
    tenantId?: StringNullableWithAggregatesFilter<"WebhookEvent"> | string | null
    eventType?: StringWithAggregatesFilter<"WebhookEvent"> | string
    payload?: StringWithAggregatesFilter<"WebhookEvent"> | string
    status?: StringWithAggregatesFilter<"WebhookEvent"> | string
    error?: StringNullableWithAggregatesFilter<"WebhookEvent"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"WebhookEvent"> | Date | string
    processedAt?: DateTimeNullableWithAggregatesFilter<"WebhookEvent"> | Date | string | null
  }

  export type TahfidzWhereInput = {
    AND?: TahfidzWhereInput | TahfidzWhereInput[]
    OR?: TahfidzWhereInput[]
    NOT?: TahfidzWhereInput | TahfidzWhereInput[]
    id?: StringFilter<"Tahfidz"> | string
    tenantId?: StringFilter<"Tahfidz"> | string
    santriId?: StringFilter<"Tahfidz"> | string
    surah?: StringFilter<"Tahfidz"> | string
    ayat?: StringNullableFilter<"Tahfidz"> | string | null
    type?: StringFilter<"Tahfidz"> | string
    grade?: StringNullableFilter<"Tahfidz"> | string | null
    notes?: StringNullableFilter<"Tahfidz"> | string | null
    recordedBy?: StringFilter<"Tahfidz"> | string
    date?: DateTimeFilter<"Tahfidz"> | Date | string
    createdAt?: DateTimeFilter<"Tahfidz"> | Date | string
    tenant?: XOR<TenantRelationFilter, TenantWhereInput>
    santri?: XOR<SantriRelationFilter, SantriWhereInput>
  }

  export type TahfidzOrderByWithRelationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    santriId?: SortOrder
    surah?: SortOrder
    ayat?: SortOrderInput | SortOrder
    type?: SortOrder
    grade?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    recordedBy?: SortOrder
    date?: SortOrder
    createdAt?: SortOrder
    tenant?: TenantOrderByWithRelationInput
    santri?: SantriOrderByWithRelationInput
  }

  export type TahfidzWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: TahfidzWhereInput | TahfidzWhereInput[]
    OR?: TahfidzWhereInput[]
    NOT?: TahfidzWhereInput | TahfidzWhereInput[]
    tenantId?: StringFilter<"Tahfidz"> | string
    santriId?: StringFilter<"Tahfidz"> | string
    surah?: StringFilter<"Tahfidz"> | string
    ayat?: StringNullableFilter<"Tahfidz"> | string | null
    type?: StringFilter<"Tahfidz"> | string
    grade?: StringNullableFilter<"Tahfidz"> | string | null
    notes?: StringNullableFilter<"Tahfidz"> | string | null
    recordedBy?: StringFilter<"Tahfidz"> | string
    date?: DateTimeFilter<"Tahfidz"> | Date | string
    createdAt?: DateTimeFilter<"Tahfidz"> | Date | string
    tenant?: XOR<TenantRelationFilter, TenantWhereInput>
    santri?: XOR<SantriRelationFilter, SantriWhereInput>
  }, "id">

  export type TahfidzOrderByWithAggregationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    santriId?: SortOrder
    surah?: SortOrder
    ayat?: SortOrderInput | SortOrder
    type?: SortOrder
    grade?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    recordedBy?: SortOrder
    date?: SortOrder
    createdAt?: SortOrder
    _count?: TahfidzCountOrderByAggregateInput
    _max?: TahfidzMaxOrderByAggregateInput
    _min?: TahfidzMinOrderByAggregateInput
  }

  export type TahfidzScalarWhereWithAggregatesInput = {
    AND?: TahfidzScalarWhereWithAggregatesInput | TahfidzScalarWhereWithAggregatesInput[]
    OR?: TahfidzScalarWhereWithAggregatesInput[]
    NOT?: TahfidzScalarWhereWithAggregatesInput | TahfidzScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Tahfidz"> | string
    tenantId?: StringWithAggregatesFilter<"Tahfidz"> | string
    santriId?: StringWithAggregatesFilter<"Tahfidz"> | string
    surah?: StringWithAggregatesFilter<"Tahfidz"> | string
    ayat?: StringNullableWithAggregatesFilter<"Tahfidz"> | string | null
    type?: StringWithAggregatesFilter<"Tahfidz"> | string
    grade?: StringNullableWithAggregatesFilter<"Tahfidz"> | string | null
    notes?: StringNullableWithAggregatesFilter<"Tahfidz"> | string | null
    recordedBy?: StringWithAggregatesFilter<"Tahfidz"> | string
    date?: DateTimeWithAggregatesFilter<"Tahfidz"> | Date | string
    createdAt?: DateTimeWithAggregatesFilter<"Tahfidz"> | Date | string
  }

  export type MutabaahWhereInput = {
    AND?: MutabaahWhereInput | MutabaahWhereInput[]
    OR?: MutabaahWhereInput[]
    NOT?: MutabaahWhereInput | MutabaahWhereInput[]
    id?: StringFilter<"Mutabaah"> | string
    tenantId?: StringFilter<"Mutabaah"> | string
    santriId?: StringFilter<"Mutabaah"> | string
    date?: DateTimeFilter<"Mutabaah"> | Date | string
    sholatWajib?: BoolFilter<"Mutabaah"> | boolean
    tahajud?: BoolFilter<"Mutabaah"> | boolean
    dhuha?: BoolFilter<"Mutabaah"> | boolean
    puasaSunnah?: BoolFilter<"Mutabaah"> | boolean
    bacaQuran?: BoolFilter<"Mutabaah"> | boolean
    notes?: StringNullableFilter<"Mutabaah"> | string | null
    recordedBy?: StringNullableFilter<"Mutabaah"> | string | null
    createdAt?: DateTimeFilter<"Mutabaah"> | Date | string
    tenant?: XOR<TenantRelationFilter, TenantWhereInput>
    santri?: XOR<SantriRelationFilter, SantriWhereInput>
  }

  export type MutabaahOrderByWithRelationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    santriId?: SortOrder
    date?: SortOrder
    sholatWajib?: SortOrder
    tahajud?: SortOrder
    dhuha?: SortOrder
    puasaSunnah?: SortOrder
    bacaQuran?: SortOrder
    notes?: SortOrderInput | SortOrder
    recordedBy?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    tenant?: TenantOrderByWithRelationInput
    santri?: SantriOrderByWithRelationInput
  }

  export type MutabaahWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: MutabaahWhereInput | MutabaahWhereInput[]
    OR?: MutabaahWhereInput[]
    NOT?: MutabaahWhereInput | MutabaahWhereInput[]
    tenantId?: StringFilter<"Mutabaah"> | string
    santriId?: StringFilter<"Mutabaah"> | string
    date?: DateTimeFilter<"Mutabaah"> | Date | string
    sholatWajib?: BoolFilter<"Mutabaah"> | boolean
    tahajud?: BoolFilter<"Mutabaah"> | boolean
    dhuha?: BoolFilter<"Mutabaah"> | boolean
    puasaSunnah?: BoolFilter<"Mutabaah"> | boolean
    bacaQuran?: BoolFilter<"Mutabaah"> | boolean
    notes?: StringNullableFilter<"Mutabaah"> | string | null
    recordedBy?: StringNullableFilter<"Mutabaah"> | string | null
    createdAt?: DateTimeFilter<"Mutabaah"> | Date | string
    tenant?: XOR<TenantRelationFilter, TenantWhereInput>
    santri?: XOR<SantriRelationFilter, SantriWhereInput>
  }, "id">

  export type MutabaahOrderByWithAggregationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    santriId?: SortOrder
    date?: SortOrder
    sholatWajib?: SortOrder
    tahajud?: SortOrder
    dhuha?: SortOrder
    puasaSunnah?: SortOrder
    bacaQuran?: SortOrder
    notes?: SortOrderInput | SortOrder
    recordedBy?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: MutabaahCountOrderByAggregateInput
    _max?: MutabaahMaxOrderByAggregateInput
    _min?: MutabaahMinOrderByAggregateInput
  }

  export type MutabaahScalarWhereWithAggregatesInput = {
    AND?: MutabaahScalarWhereWithAggregatesInput | MutabaahScalarWhereWithAggregatesInput[]
    OR?: MutabaahScalarWhereWithAggregatesInput[]
    NOT?: MutabaahScalarWhereWithAggregatesInput | MutabaahScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Mutabaah"> | string
    tenantId?: StringWithAggregatesFilter<"Mutabaah"> | string
    santriId?: StringWithAggregatesFilter<"Mutabaah"> | string
    date?: DateTimeWithAggregatesFilter<"Mutabaah"> | Date | string
    sholatWajib?: BoolWithAggregatesFilter<"Mutabaah"> | boolean
    tahajud?: BoolWithAggregatesFilter<"Mutabaah"> | boolean
    dhuha?: BoolWithAggregatesFilter<"Mutabaah"> | boolean
    puasaSunnah?: BoolWithAggregatesFilter<"Mutabaah"> | boolean
    bacaQuran?: BoolWithAggregatesFilter<"Mutabaah"> | boolean
    notes?: StringNullableWithAggregatesFilter<"Mutabaah"> | string | null
    recordedBy?: StringNullableWithAggregatesFilter<"Mutabaah"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Mutabaah"> | Date | string
  }

  export type WalletWhereInput = {
    AND?: WalletWhereInput | WalletWhereInput[]
    OR?: WalletWhereInput[]
    NOT?: WalletWhereInput | WalletWhereInput[]
    id?: StringFilter<"Wallet"> | string
    tenantId?: StringFilter<"Wallet"> | string
    santriId?: StringFilter<"Wallet"> | string
    balance?: FloatFilter<"Wallet"> | number
    pin?: StringNullableFilter<"Wallet"> | string | null
    isActive?: BoolFilter<"Wallet"> | boolean
    updatedAt?: DateTimeFilter<"Wallet"> | Date | string
    tenant?: XOR<TenantRelationFilter, TenantWhereInput>
    santri?: XOR<SantriRelationFilter, SantriWhereInput>
    transactions?: WalletTransactionListRelationFilter
  }

  export type WalletOrderByWithRelationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    santriId?: SortOrder
    balance?: SortOrder
    pin?: SortOrderInput | SortOrder
    isActive?: SortOrder
    updatedAt?: SortOrder
    tenant?: TenantOrderByWithRelationInput
    santri?: SantriOrderByWithRelationInput
    transactions?: WalletTransactionOrderByRelationAggregateInput
  }

  export type WalletWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    santriId?: string
    AND?: WalletWhereInput | WalletWhereInput[]
    OR?: WalletWhereInput[]
    NOT?: WalletWhereInput | WalletWhereInput[]
    tenantId?: StringFilter<"Wallet"> | string
    balance?: FloatFilter<"Wallet"> | number
    pin?: StringNullableFilter<"Wallet"> | string | null
    isActive?: BoolFilter<"Wallet"> | boolean
    updatedAt?: DateTimeFilter<"Wallet"> | Date | string
    tenant?: XOR<TenantRelationFilter, TenantWhereInput>
    santri?: XOR<SantriRelationFilter, SantriWhereInput>
    transactions?: WalletTransactionListRelationFilter
  }, "id" | "santriId">

  export type WalletOrderByWithAggregationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    santriId?: SortOrder
    balance?: SortOrder
    pin?: SortOrderInput | SortOrder
    isActive?: SortOrder
    updatedAt?: SortOrder
    _count?: WalletCountOrderByAggregateInput
    _avg?: WalletAvgOrderByAggregateInput
    _max?: WalletMaxOrderByAggregateInput
    _min?: WalletMinOrderByAggregateInput
    _sum?: WalletSumOrderByAggregateInput
  }

  export type WalletScalarWhereWithAggregatesInput = {
    AND?: WalletScalarWhereWithAggregatesInput | WalletScalarWhereWithAggregatesInput[]
    OR?: WalletScalarWhereWithAggregatesInput[]
    NOT?: WalletScalarWhereWithAggregatesInput | WalletScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Wallet"> | string
    tenantId?: StringWithAggregatesFilter<"Wallet"> | string
    santriId?: StringWithAggregatesFilter<"Wallet"> | string
    balance?: FloatWithAggregatesFilter<"Wallet"> | number
    pin?: StringNullableWithAggregatesFilter<"Wallet"> | string | null
    isActive?: BoolWithAggregatesFilter<"Wallet"> | boolean
    updatedAt?: DateTimeWithAggregatesFilter<"Wallet"> | Date | string
  }

  export type WalletTransactionWhereInput = {
    AND?: WalletTransactionWhereInput | WalletTransactionWhereInput[]
    OR?: WalletTransactionWhereInput[]
    NOT?: WalletTransactionWhereInput | WalletTransactionWhereInput[]
    id?: StringFilter<"WalletTransaction"> | string
    walletId?: StringFilter<"WalletTransaction"> | string
    amount?: FloatFilter<"WalletTransaction"> | number
    type?: StringFilter<"WalletTransaction"> | string
    method?: StringFilter<"WalletTransaction"> | string
    description?: StringNullableFilter<"WalletTransaction"> | string | null
    reference?: StringNullableFilter<"WalletTransaction"> | string | null
    status?: StringFilter<"WalletTransaction"> | string
    handledBy?: StringNullableFilter<"WalletTransaction"> | string | null
    createdAt?: DateTimeFilter<"WalletTransaction"> | Date | string
    wallet?: XOR<WalletRelationFilter, WalletWhereInput>
  }

  export type WalletTransactionOrderByWithRelationInput = {
    id?: SortOrder
    walletId?: SortOrder
    amount?: SortOrder
    type?: SortOrder
    method?: SortOrder
    description?: SortOrderInput | SortOrder
    reference?: SortOrderInput | SortOrder
    status?: SortOrder
    handledBy?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    wallet?: WalletOrderByWithRelationInput
  }

  export type WalletTransactionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: WalletTransactionWhereInput | WalletTransactionWhereInput[]
    OR?: WalletTransactionWhereInput[]
    NOT?: WalletTransactionWhereInput | WalletTransactionWhereInput[]
    walletId?: StringFilter<"WalletTransaction"> | string
    amount?: FloatFilter<"WalletTransaction"> | number
    type?: StringFilter<"WalletTransaction"> | string
    method?: StringFilter<"WalletTransaction"> | string
    description?: StringNullableFilter<"WalletTransaction"> | string | null
    reference?: StringNullableFilter<"WalletTransaction"> | string | null
    status?: StringFilter<"WalletTransaction"> | string
    handledBy?: StringNullableFilter<"WalletTransaction"> | string | null
    createdAt?: DateTimeFilter<"WalletTransaction"> | Date | string
    wallet?: XOR<WalletRelationFilter, WalletWhereInput>
  }, "id">

  export type WalletTransactionOrderByWithAggregationInput = {
    id?: SortOrder
    walletId?: SortOrder
    amount?: SortOrder
    type?: SortOrder
    method?: SortOrder
    description?: SortOrderInput | SortOrder
    reference?: SortOrderInput | SortOrder
    status?: SortOrder
    handledBy?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: WalletTransactionCountOrderByAggregateInput
    _avg?: WalletTransactionAvgOrderByAggregateInput
    _max?: WalletTransactionMaxOrderByAggregateInput
    _min?: WalletTransactionMinOrderByAggregateInput
    _sum?: WalletTransactionSumOrderByAggregateInput
  }

  export type WalletTransactionScalarWhereWithAggregatesInput = {
    AND?: WalletTransactionScalarWhereWithAggregatesInput | WalletTransactionScalarWhereWithAggregatesInput[]
    OR?: WalletTransactionScalarWhereWithAggregatesInput[]
    NOT?: WalletTransactionScalarWhereWithAggregatesInput | WalletTransactionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"WalletTransaction"> | string
    walletId?: StringWithAggregatesFilter<"WalletTransaction"> | string
    amount?: FloatWithAggregatesFilter<"WalletTransaction"> | number
    type?: StringWithAggregatesFilter<"WalletTransaction"> | string
    method?: StringWithAggregatesFilter<"WalletTransaction"> | string
    description?: StringNullableWithAggregatesFilter<"WalletTransaction"> | string | null
    reference?: StringNullableWithAggregatesFilter<"WalletTransaction"> | string | null
    status?: StringWithAggregatesFilter<"WalletTransaction"> | string
    handledBy?: StringNullableWithAggregatesFilter<"WalletTransaction"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"WalletTransaction"> | Date | string
  }

  export type EmployeeWhereInput = {
    AND?: EmployeeWhereInput | EmployeeWhereInput[]
    OR?: EmployeeWhereInput[]
    NOT?: EmployeeWhereInput | EmployeeWhereInput[]
    id?: StringFilter<"Employee"> | string
    tenantId?: StringFilter<"Employee"> | string
    userId?: StringNullableFilter<"Employee"> | string | null
    nip?: StringNullableFilter<"Employee"> | string | null
    name?: StringFilter<"Employee"> | string
    position?: StringFilter<"Employee"> | string
    phone?: StringNullableFilter<"Employee"> | string | null
    address?: StringNullableFilter<"Employee"> | string | null
    joinDate?: DateTimeNullableFilter<"Employee"> | Date | string | null
    status?: StringFilter<"Employee"> | string
    createdAt?: DateTimeFilter<"Employee"> | Date | string
    updatedAt?: DateTimeFilter<"Employee"> | Date | string
    tenant?: XOR<TenantRelationFilter, TenantWhereInput>
    payrolls?: PayrollListRelationFilter
  }

  export type EmployeeOrderByWithRelationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    userId?: SortOrderInput | SortOrder
    nip?: SortOrderInput | SortOrder
    name?: SortOrder
    position?: SortOrder
    phone?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    joinDate?: SortOrderInput | SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    tenant?: TenantOrderByWithRelationInput
    payrolls?: PayrollOrderByRelationAggregateInput
  }

  export type EmployeeWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId?: string
    AND?: EmployeeWhereInput | EmployeeWhereInput[]
    OR?: EmployeeWhereInput[]
    NOT?: EmployeeWhereInput | EmployeeWhereInput[]
    tenantId?: StringFilter<"Employee"> | string
    nip?: StringNullableFilter<"Employee"> | string | null
    name?: StringFilter<"Employee"> | string
    position?: StringFilter<"Employee"> | string
    phone?: StringNullableFilter<"Employee"> | string | null
    address?: StringNullableFilter<"Employee"> | string | null
    joinDate?: DateTimeNullableFilter<"Employee"> | Date | string | null
    status?: StringFilter<"Employee"> | string
    createdAt?: DateTimeFilter<"Employee"> | Date | string
    updatedAt?: DateTimeFilter<"Employee"> | Date | string
    tenant?: XOR<TenantRelationFilter, TenantWhereInput>
    payrolls?: PayrollListRelationFilter
  }, "id" | "userId">

  export type EmployeeOrderByWithAggregationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    userId?: SortOrderInput | SortOrder
    nip?: SortOrderInput | SortOrder
    name?: SortOrder
    position?: SortOrder
    phone?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    joinDate?: SortOrderInput | SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: EmployeeCountOrderByAggregateInput
    _max?: EmployeeMaxOrderByAggregateInput
    _min?: EmployeeMinOrderByAggregateInput
  }

  export type EmployeeScalarWhereWithAggregatesInput = {
    AND?: EmployeeScalarWhereWithAggregatesInput | EmployeeScalarWhereWithAggregatesInput[]
    OR?: EmployeeScalarWhereWithAggregatesInput[]
    NOT?: EmployeeScalarWhereWithAggregatesInput | EmployeeScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Employee"> | string
    tenantId?: StringWithAggregatesFilter<"Employee"> | string
    userId?: StringNullableWithAggregatesFilter<"Employee"> | string | null
    nip?: StringNullableWithAggregatesFilter<"Employee"> | string | null
    name?: StringWithAggregatesFilter<"Employee"> | string
    position?: StringWithAggregatesFilter<"Employee"> | string
    phone?: StringNullableWithAggregatesFilter<"Employee"> | string | null
    address?: StringNullableWithAggregatesFilter<"Employee"> | string | null
    joinDate?: DateTimeNullableWithAggregatesFilter<"Employee"> | Date | string | null
    status?: StringWithAggregatesFilter<"Employee"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Employee"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Employee"> | Date | string
  }

  export type PayrollWhereInput = {
    AND?: PayrollWhereInput | PayrollWhereInput[]
    OR?: PayrollWhereInput[]
    NOT?: PayrollWhereInput | PayrollWhereInput[]
    id?: StringFilter<"Payroll"> | string
    tenantId?: StringFilter<"Payroll"> | string
    employeeId?: StringFilter<"Payroll"> | string
    month?: IntFilter<"Payroll"> | number
    year?: IntFilter<"Payroll"> | number
    baseSalary?: FloatFilter<"Payroll"> | number
    allowances?: FloatFilter<"Payroll"> | number
    deductions?: FloatFilter<"Payroll"> | number
    netAmount?: FloatFilter<"Payroll"> | number
    status?: StringFilter<"Payroll"> | string
    paidAt?: DateTimeNullableFilter<"Payroll"> | Date | string | null
    createdAt?: DateTimeFilter<"Payroll"> | Date | string
    updatedAt?: DateTimeFilter<"Payroll"> | Date | string
    tenant?: XOR<TenantRelationFilter, TenantWhereInput>
    employee?: XOR<EmployeeRelationFilter, EmployeeWhereInput>
  }

  export type PayrollOrderByWithRelationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    employeeId?: SortOrder
    month?: SortOrder
    year?: SortOrder
    baseSalary?: SortOrder
    allowances?: SortOrder
    deductions?: SortOrder
    netAmount?: SortOrder
    status?: SortOrder
    paidAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    tenant?: TenantOrderByWithRelationInput
    employee?: EmployeeOrderByWithRelationInput
  }

  export type PayrollWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PayrollWhereInput | PayrollWhereInput[]
    OR?: PayrollWhereInput[]
    NOT?: PayrollWhereInput | PayrollWhereInput[]
    tenantId?: StringFilter<"Payroll"> | string
    employeeId?: StringFilter<"Payroll"> | string
    month?: IntFilter<"Payroll"> | number
    year?: IntFilter<"Payroll"> | number
    baseSalary?: FloatFilter<"Payroll"> | number
    allowances?: FloatFilter<"Payroll"> | number
    deductions?: FloatFilter<"Payroll"> | number
    netAmount?: FloatFilter<"Payroll"> | number
    status?: StringFilter<"Payroll"> | string
    paidAt?: DateTimeNullableFilter<"Payroll"> | Date | string | null
    createdAt?: DateTimeFilter<"Payroll"> | Date | string
    updatedAt?: DateTimeFilter<"Payroll"> | Date | string
    tenant?: XOR<TenantRelationFilter, TenantWhereInput>
    employee?: XOR<EmployeeRelationFilter, EmployeeWhereInput>
  }, "id">

  export type PayrollOrderByWithAggregationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    employeeId?: SortOrder
    month?: SortOrder
    year?: SortOrder
    baseSalary?: SortOrder
    allowances?: SortOrder
    deductions?: SortOrder
    netAmount?: SortOrder
    status?: SortOrder
    paidAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PayrollCountOrderByAggregateInput
    _avg?: PayrollAvgOrderByAggregateInput
    _max?: PayrollMaxOrderByAggregateInput
    _min?: PayrollMinOrderByAggregateInput
    _sum?: PayrollSumOrderByAggregateInput
  }

  export type PayrollScalarWhereWithAggregatesInput = {
    AND?: PayrollScalarWhereWithAggregatesInput | PayrollScalarWhereWithAggregatesInput[]
    OR?: PayrollScalarWhereWithAggregatesInput[]
    NOT?: PayrollScalarWhereWithAggregatesInput | PayrollScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Payroll"> | string
    tenantId?: StringWithAggregatesFilter<"Payroll"> | string
    employeeId?: StringWithAggregatesFilter<"Payroll"> | string
    month?: IntWithAggregatesFilter<"Payroll"> | number
    year?: IntWithAggregatesFilter<"Payroll"> | number
    baseSalary?: FloatWithAggregatesFilter<"Payroll"> | number
    allowances?: FloatWithAggregatesFilter<"Payroll"> | number
    deductions?: FloatWithAggregatesFilter<"Payroll"> | number
    netAmount?: FloatWithAggregatesFilter<"Payroll"> | number
    status?: StringWithAggregatesFilter<"Payroll"> | string
    paidAt?: DateTimeNullableWithAggregatesFilter<"Payroll"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Payroll"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Payroll"> | Date | string
  }

  export type AcademicScheduleWhereInput = {
    AND?: AcademicScheduleWhereInput | AcademicScheduleWhereInput[]
    OR?: AcademicScheduleWhereInput[]
    NOT?: AcademicScheduleWhereInput | AcademicScheduleWhereInput[]
    id?: StringFilter<"AcademicSchedule"> | string
    tenantId?: StringFilter<"AcademicSchedule"> | string
    subject?: StringFilter<"AcademicSchedule"> | string
    teacherId?: StringFilter<"AcademicSchedule"> | string
    kelas?: StringFilter<"AcademicSchedule"> | string
    dayOfWeek?: IntFilter<"AcademicSchedule"> | number
    startTime?: StringFilter<"AcademicSchedule"> | string
    endTime?: StringFilter<"AcademicSchedule"> | string
    room?: StringNullableFilter<"AcademicSchedule"> | string | null
    createdAt?: DateTimeFilter<"AcademicSchedule"> | Date | string
    tenant?: XOR<TenantRelationFilter, TenantWhereInput>
  }

  export type AcademicScheduleOrderByWithRelationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    subject?: SortOrder
    teacherId?: SortOrder
    kelas?: SortOrder
    dayOfWeek?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    room?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    tenant?: TenantOrderByWithRelationInput
  }

  export type AcademicScheduleWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AcademicScheduleWhereInput | AcademicScheduleWhereInput[]
    OR?: AcademicScheduleWhereInput[]
    NOT?: AcademicScheduleWhereInput | AcademicScheduleWhereInput[]
    tenantId?: StringFilter<"AcademicSchedule"> | string
    subject?: StringFilter<"AcademicSchedule"> | string
    teacherId?: StringFilter<"AcademicSchedule"> | string
    kelas?: StringFilter<"AcademicSchedule"> | string
    dayOfWeek?: IntFilter<"AcademicSchedule"> | number
    startTime?: StringFilter<"AcademicSchedule"> | string
    endTime?: StringFilter<"AcademicSchedule"> | string
    room?: StringNullableFilter<"AcademicSchedule"> | string | null
    createdAt?: DateTimeFilter<"AcademicSchedule"> | Date | string
    tenant?: XOR<TenantRelationFilter, TenantWhereInput>
  }, "id">

  export type AcademicScheduleOrderByWithAggregationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    subject?: SortOrder
    teacherId?: SortOrder
    kelas?: SortOrder
    dayOfWeek?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    room?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: AcademicScheduleCountOrderByAggregateInput
    _avg?: AcademicScheduleAvgOrderByAggregateInput
    _max?: AcademicScheduleMaxOrderByAggregateInput
    _min?: AcademicScheduleMinOrderByAggregateInput
    _sum?: AcademicScheduleSumOrderByAggregateInput
  }

  export type AcademicScheduleScalarWhereWithAggregatesInput = {
    AND?: AcademicScheduleScalarWhereWithAggregatesInput | AcademicScheduleScalarWhereWithAggregatesInput[]
    OR?: AcademicScheduleScalarWhereWithAggregatesInput[]
    NOT?: AcademicScheduleScalarWhereWithAggregatesInput | AcademicScheduleScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AcademicSchedule"> | string
    tenantId?: StringWithAggregatesFilter<"AcademicSchedule"> | string
    subject?: StringWithAggregatesFilter<"AcademicSchedule"> | string
    teacherId?: StringWithAggregatesFilter<"AcademicSchedule"> | string
    kelas?: StringWithAggregatesFilter<"AcademicSchedule"> | string
    dayOfWeek?: IntWithAggregatesFilter<"AcademicSchedule"> | number
    startTime?: StringWithAggregatesFilter<"AcademicSchedule"> | string
    endTime?: StringWithAggregatesFilter<"AcademicSchedule"> | string
    room?: StringNullableWithAggregatesFilter<"AcademicSchedule"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"AcademicSchedule"> | Date | string
  }

  export type AttendanceWhereInput = {
    AND?: AttendanceWhereInput | AttendanceWhereInput[]
    OR?: AttendanceWhereInput[]
    NOT?: AttendanceWhereInput | AttendanceWhereInput[]
    id?: StringFilter<"Attendance"> | string
    tenantId?: StringFilter<"Attendance"> | string
    santriId?: StringFilter<"Attendance"> | string
    scheduleId?: StringNullableFilter<"Attendance"> | string | null
    date?: DateTimeFilter<"Attendance"> | Date | string
    status?: StringFilter<"Attendance"> | string
    notes?: StringNullableFilter<"Attendance"> | string | null
    recordedBy?: StringNullableFilter<"Attendance"> | string | null
    createdAt?: DateTimeFilter<"Attendance"> | Date | string
    tenant?: XOR<TenantRelationFilter, TenantWhereInput>
    santri?: XOR<SantriRelationFilter, SantriWhereInput>
  }

  export type AttendanceOrderByWithRelationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    santriId?: SortOrder
    scheduleId?: SortOrderInput | SortOrder
    date?: SortOrder
    status?: SortOrder
    notes?: SortOrderInput | SortOrder
    recordedBy?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    tenant?: TenantOrderByWithRelationInput
    santri?: SantriOrderByWithRelationInput
  }

  export type AttendanceWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AttendanceWhereInput | AttendanceWhereInput[]
    OR?: AttendanceWhereInput[]
    NOT?: AttendanceWhereInput | AttendanceWhereInput[]
    tenantId?: StringFilter<"Attendance"> | string
    santriId?: StringFilter<"Attendance"> | string
    scheduleId?: StringNullableFilter<"Attendance"> | string | null
    date?: DateTimeFilter<"Attendance"> | Date | string
    status?: StringFilter<"Attendance"> | string
    notes?: StringNullableFilter<"Attendance"> | string | null
    recordedBy?: StringNullableFilter<"Attendance"> | string | null
    createdAt?: DateTimeFilter<"Attendance"> | Date | string
    tenant?: XOR<TenantRelationFilter, TenantWhereInput>
    santri?: XOR<SantriRelationFilter, SantriWhereInput>
  }, "id">

  export type AttendanceOrderByWithAggregationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    santriId?: SortOrder
    scheduleId?: SortOrderInput | SortOrder
    date?: SortOrder
    status?: SortOrder
    notes?: SortOrderInput | SortOrder
    recordedBy?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: AttendanceCountOrderByAggregateInput
    _max?: AttendanceMaxOrderByAggregateInput
    _min?: AttendanceMinOrderByAggregateInput
  }

  export type AttendanceScalarWhereWithAggregatesInput = {
    AND?: AttendanceScalarWhereWithAggregatesInput | AttendanceScalarWhereWithAggregatesInput[]
    OR?: AttendanceScalarWhereWithAggregatesInput[]
    NOT?: AttendanceScalarWhereWithAggregatesInput | AttendanceScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Attendance"> | string
    tenantId?: StringWithAggregatesFilter<"Attendance"> | string
    santriId?: StringWithAggregatesFilter<"Attendance"> | string
    scheduleId?: StringNullableWithAggregatesFilter<"Attendance"> | string | null
    date?: DateTimeWithAggregatesFilter<"Attendance"> | Date | string
    status?: StringWithAggregatesFilter<"Attendance"> | string
    notes?: StringNullableWithAggregatesFilter<"Attendance"> | string | null
    recordedBy?: StringNullableWithAggregatesFilter<"Attendance"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Attendance"> | Date | string
  }

  export type GradeWhereInput = {
    AND?: GradeWhereInput | GradeWhereInput[]
    OR?: GradeWhereInput[]
    NOT?: GradeWhereInput | GradeWhereInput[]
    id?: StringFilter<"Grade"> | string
    tenantId?: StringFilter<"Grade"> | string
    santriId?: StringFilter<"Grade"> | string
    subject?: StringFilter<"Grade"> | string
    semester?: StringFilter<"Grade"> | string
    academicYear?: StringFilter<"Grade"> | string
    type?: StringFilter<"Grade"> | string
    score?: FloatFilter<"Grade"> | number
    notes?: StringNullableFilter<"Grade"> | string | null
    createdAt?: DateTimeFilter<"Grade"> | Date | string
    tenant?: XOR<TenantRelationFilter, TenantWhereInput>
    santri?: XOR<SantriRelationFilter, SantriWhereInput>
  }

  export type GradeOrderByWithRelationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    santriId?: SortOrder
    subject?: SortOrder
    semester?: SortOrder
    academicYear?: SortOrder
    type?: SortOrder
    score?: SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    tenant?: TenantOrderByWithRelationInput
    santri?: SantriOrderByWithRelationInput
  }

  export type GradeWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: GradeWhereInput | GradeWhereInput[]
    OR?: GradeWhereInput[]
    NOT?: GradeWhereInput | GradeWhereInput[]
    tenantId?: StringFilter<"Grade"> | string
    santriId?: StringFilter<"Grade"> | string
    subject?: StringFilter<"Grade"> | string
    semester?: StringFilter<"Grade"> | string
    academicYear?: StringFilter<"Grade"> | string
    type?: StringFilter<"Grade"> | string
    score?: FloatFilter<"Grade"> | number
    notes?: StringNullableFilter<"Grade"> | string | null
    createdAt?: DateTimeFilter<"Grade"> | Date | string
    tenant?: XOR<TenantRelationFilter, TenantWhereInput>
    santri?: XOR<SantriRelationFilter, SantriWhereInput>
  }, "id">

  export type GradeOrderByWithAggregationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    santriId?: SortOrder
    subject?: SortOrder
    semester?: SortOrder
    academicYear?: SortOrder
    type?: SortOrder
    score?: SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: GradeCountOrderByAggregateInput
    _avg?: GradeAvgOrderByAggregateInput
    _max?: GradeMaxOrderByAggregateInput
    _min?: GradeMinOrderByAggregateInput
    _sum?: GradeSumOrderByAggregateInput
  }

  export type GradeScalarWhereWithAggregatesInput = {
    AND?: GradeScalarWhereWithAggregatesInput | GradeScalarWhereWithAggregatesInput[]
    OR?: GradeScalarWhereWithAggregatesInput[]
    NOT?: GradeScalarWhereWithAggregatesInput | GradeScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Grade"> | string
    tenantId?: StringWithAggregatesFilter<"Grade"> | string
    santriId?: StringWithAggregatesFilter<"Grade"> | string
    subject?: StringWithAggregatesFilter<"Grade"> | string
    semester?: StringWithAggregatesFilter<"Grade"> | string
    academicYear?: StringWithAggregatesFilter<"Grade"> | string
    type?: StringWithAggregatesFilter<"Grade"> | string
    score?: FloatWithAggregatesFilter<"Grade"> | number
    notes?: StringNullableWithAggregatesFilter<"Grade"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Grade"> | Date | string
  }

  export type PpdbRegistrationWhereInput = {
    AND?: PpdbRegistrationWhereInput | PpdbRegistrationWhereInput[]
    OR?: PpdbRegistrationWhereInput[]
    NOT?: PpdbRegistrationWhereInput | PpdbRegistrationWhereInput[]
    id?: StringFilter<"PpdbRegistration"> | string
    tenantId?: StringFilter<"PpdbRegistration"> | string
    registrationNumber?: StringFilter<"PpdbRegistration"> | string
    fullName?: StringFilter<"PpdbRegistration"> | string
    gender?: StringFilter<"PpdbRegistration"> | string
    dob?: DateTimeNullableFilter<"PpdbRegistration"> | Date | string | null
    previousSchool?: StringNullableFilter<"PpdbRegistration"> | string | null
    pathway?: StringFilter<"PpdbRegistration"> | string
    status?: StringFilter<"PpdbRegistration"> | string
    notes?: StringNullableFilter<"PpdbRegistration"> | string | null
    createdAt?: DateTimeFilter<"PpdbRegistration"> | Date | string
    updatedAt?: DateTimeFilter<"PpdbRegistration"> | Date | string
    tenant?: XOR<TenantRelationFilter, TenantWhereInput>
    documents?: PpdbDocumentListRelationFilter
    exams?: PpdbExamListRelationFilter
  }

  export type PpdbRegistrationOrderByWithRelationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    registrationNumber?: SortOrder
    fullName?: SortOrder
    gender?: SortOrder
    dob?: SortOrderInput | SortOrder
    previousSchool?: SortOrderInput | SortOrder
    pathway?: SortOrder
    status?: SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    tenant?: TenantOrderByWithRelationInput
    documents?: PpdbDocumentOrderByRelationAggregateInput
    exams?: PpdbExamOrderByRelationAggregateInput
  }

  export type PpdbRegistrationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    registrationNumber?: string
    AND?: PpdbRegistrationWhereInput | PpdbRegistrationWhereInput[]
    OR?: PpdbRegistrationWhereInput[]
    NOT?: PpdbRegistrationWhereInput | PpdbRegistrationWhereInput[]
    tenantId?: StringFilter<"PpdbRegistration"> | string
    fullName?: StringFilter<"PpdbRegistration"> | string
    gender?: StringFilter<"PpdbRegistration"> | string
    dob?: DateTimeNullableFilter<"PpdbRegistration"> | Date | string | null
    previousSchool?: StringNullableFilter<"PpdbRegistration"> | string | null
    pathway?: StringFilter<"PpdbRegistration"> | string
    status?: StringFilter<"PpdbRegistration"> | string
    notes?: StringNullableFilter<"PpdbRegistration"> | string | null
    createdAt?: DateTimeFilter<"PpdbRegistration"> | Date | string
    updatedAt?: DateTimeFilter<"PpdbRegistration"> | Date | string
    tenant?: XOR<TenantRelationFilter, TenantWhereInput>
    documents?: PpdbDocumentListRelationFilter
    exams?: PpdbExamListRelationFilter
  }, "id" | "registrationNumber">

  export type PpdbRegistrationOrderByWithAggregationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    registrationNumber?: SortOrder
    fullName?: SortOrder
    gender?: SortOrder
    dob?: SortOrderInput | SortOrder
    previousSchool?: SortOrderInput | SortOrder
    pathway?: SortOrder
    status?: SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PpdbRegistrationCountOrderByAggregateInput
    _max?: PpdbRegistrationMaxOrderByAggregateInput
    _min?: PpdbRegistrationMinOrderByAggregateInput
  }

  export type PpdbRegistrationScalarWhereWithAggregatesInput = {
    AND?: PpdbRegistrationScalarWhereWithAggregatesInput | PpdbRegistrationScalarWhereWithAggregatesInput[]
    OR?: PpdbRegistrationScalarWhereWithAggregatesInput[]
    NOT?: PpdbRegistrationScalarWhereWithAggregatesInput | PpdbRegistrationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PpdbRegistration"> | string
    tenantId?: StringWithAggregatesFilter<"PpdbRegistration"> | string
    registrationNumber?: StringWithAggregatesFilter<"PpdbRegistration"> | string
    fullName?: StringWithAggregatesFilter<"PpdbRegistration"> | string
    gender?: StringWithAggregatesFilter<"PpdbRegistration"> | string
    dob?: DateTimeNullableWithAggregatesFilter<"PpdbRegistration"> | Date | string | null
    previousSchool?: StringNullableWithAggregatesFilter<"PpdbRegistration"> | string | null
    pathway?: StringWithAggregatesFilter<"PpdbRegistration"> | string
    status?: StringWithAggregatesFilter<"PpdbRegistration"> | string
    notes?: StringNullableWithAggregatesFilter<"PpdbRegistration"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"PpdbRegistration"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"PpdbRegistration"> | Date | string
  }

  export type PpdbDocumentWhereInput = {
    AND?: PpdbDocumentWhereInput | PpdbDocumentWhereInput[]
    OR?: PpdbDocumentWhereInput[]
    NOT?: PpdbDocumentWhereInput | PpdbDocumentWhereInput[]
    id?: StringFilter<"PpdbDocument"> | string
    tenantId?: StringFilter<"PpdbDocument"> | string
    registrationId?: StringFilter<"PpdbDocument"> | string
    documentType?: StringFilter<"PpdbDocument"> | string
    fileUrl?: StringFilter<"PpdbDocument"> | string
    isVerified?: BoolFilter<"PpdbDocument"> | boolean
    createdAt?: DateTimeFilter<"PpdbDocument"> | Date | string
    tenant?: XOR<TenantRelationFilter, TenantWhereInput>
    registration?: XOR<PpdbRegistrationRelationFilter, PpdbRegistrationWhereInput>
  }

  export type PpdbDocumentOrderByWithRelationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    registrationId?: SortOrder
    documentType?: SortOrder
    fileUrl?: SortOrder
    isVerified?: SortOrder
    createdAt?: SortOrder
    tenant?: TenantOrderByWithRelationInput
    registration?: PpdbRegistrationOrderByWithRelationInput
  }

  export type PpdbDocumentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PpdbDocumentWhereInput | PpdbDocumentWhereInput[]
    OR?: PpdbDocumentWhereInput[]
    NOT?: PpdbDocumentWhereInput | PpdbDocumentWhereInput[]
    tenantId?: StringFilter<"PpdbDocument"> | string
    registrationId?: StringFilter<"PpdbDocument"> | string
    documentType?: StringFilter<"PpdbDocument"> | string
    fileUrl?: StringFilter<"PpdbDocument"> | string
    isVerified?: BoolFilter<"PpdbDocument"> | boolean
    createdAt?: DateTimeFilter<"PpdbDocument"> | Date | string
    tenant?: XOR<TenantRelationFilter, TenantWhereInput>
    registration?: XOR<PpdbRegistrationRelationFilter, PpdbRegistrationWhereInput>
  }, "id">

  export type PpdbDocumentOrderByWithAggregationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    registrationId?: SortOrder
    documentType?: SortOrder
    fileUrl?: SortOrder
    isVerified?: SortOrder
    createdAt?: SortOrder
    _count?: PpdbDocumentCountOrderByAggregateInput
    _max?: PpdbDocumentMaxOrderByAggregateInput
    _min?: PpdbDocumentMinOrderByAggregateInput
  }

  export type PpdbDocumentScalarWhereWithAggregatesInput = {
    AND?: PpdbDocumentScalarWhereWithAggregatesInput | PpdbDocumentScalarWhereWithAggregatesInput[]
    OR?: PpdbDocumentScalarWhereWithAggregatesInput[]
    NOT?: PpdbDocumentScalarWhereWithAggregatesInput | PpdbDocumentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PpdbDocument"> | string
    tenantId?: StringWithAggregatesFilter<"PpdbDocument"> | string
    registrationId?: StringWithAggregatesFilter<"PpdbDocument"> | string
    documentType?: StringWithAggregatesFilter<"PpdbDocument"> | string
    fileUrl?: StringWithAggregatesFilter<"PpdbDocument"> | string
    isVerified?: BoolWithAggregatesFilter<"PpdbDocument"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"PpdbDocument"> | Date | string
  }

  export type PpdbExamWhereInput = {
    AND?: PpdbExamWhereInput | PpdbExamWhereInput[]
    OR?: PpdbExamWhereInput[]
    NOT?: PpdbExamWhereInput | PpdbExamWhereInput[]
    id?: StringFilter<"PpdbExam"> | string
    tenantId?: StringFilter<"PpdbExam"> | string
    registrationId?: StringFilter<"PpdbExam"> | string
    examType?: StringFilter<"PpdbExam"> | string
    examDate?: DateTimeFilter<"PpdbExam"> | Date | string
    score?: FloatNullableFilter<"PpdbExam"> | number | null
    result?: StringNullableFilter<"PpdbExam"> | string | null
    interviewer?: StringNullableFilter<"PpdbExam"> | string | null
    createdAt?: DateTimeFilter<"PpdbExam"> | Date | string
    tenant?: XOR<TenantRelationFilter, TenantWhereInput>
    registration?: XOR<PpdbRegistrationRelationFilter, PpdbRegistrationWhereInput>
  }

  export type PpdbExamOrderByWithRelationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    registrationId?: SortOrder
    examType?: SortOrder
    examDate?: SortOrder
    score?: SortOrderInput | SortOrder
    result?: SortOrderInput | SortOrder
    interviewer?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    tenant?: TenantOrderByWithRelationInput
    registration?: PpdbRegistrationOrderByWithRelationInput
  }

  export type PpdbExamWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PpdbExamWhereInput | PpdbExamWhereInput[]
    OR?: PpdbExamWhereInput[]
    NOT?: PpdbExamWhereInput | PpdbExamWhereInput[]
    tenantId?: StringFilter<"PpdbExam"> | string
    registrationId?: StringFilter<"PpdbExam"> | string
    examType?: StringFilter<"PpdbExam"> | string
    examDate?: DateTimeFilter<"PpdbExam"> | Date | string
    score?: FloatNullableFilter<"PpdbExam"> | number | null
    result?: StringNullableFilter<"PpdbExam"> | string | null
    interviewer?: StringNullableFilter<"PpdbExam"> | string | null
    createdAt?: DateTimeFilter<"PpdbExam"> | Date | string
    tenant?: XOR<TenantRelationFilter, TenantWhereInput>
    registration?: XOR<PpdbRegistrationRelationFilter, PpdbRegistrationWhereInput>
  }, "id">

  export type PpdbExamOrderByWithAggregationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    registrationId?: SortOrder
    examType?: SortOrder
    examDate?: SortOrder
    score?: SortOrderInput | SortOrder
    result?: SortOrderInput | SortOrder
    interviewer?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: PpdbExamCountOrderByAggregateInput
    _avg?: PpdbExamAvgOrderByAggregateInput
    _max?: PpdbExamMaxOrderByAggregateInput
    _min?: PpdbExamMinOrderByAggregateInput
    _sum?: PpdbExamSumOrderByAggregateInput
  }

  export type PpdbExamScalarWhereWithAggregatesInput = {
    AND?: PpdbExamScalarWhereWithAggregatesInput | PpdbExamScalarWhereWithAggregatesInput[]
    OR?: PpdbExamScalarWhereWithAggregatesInput[]
    NOT?: PpdbExamScalarWhereWithAggregatesInput | PpdbExamScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PpdbExam"> | string
    tenantId?: StringWithAggregatesFilter<"PpdbExam"> | string
    registrationId?: StringWithAggregatesFilter<"PpdbExam"> | string
    examType?: StringWithAggregatesFilter<"PpdbExam"> | string
    examDate?: DateTimeWithAggregatesFilter<"PpdbExam"> | Date | string
    score?: FloatNullableWithAggregatesFilter<"PpdbExam"> | number | null
    result?: StringNullableWithAggregatesFilter<"PpdbExam"> | string | null
    interviewer?: StringNullableWithAggregatesFilter<"PpdbExam"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"PpdbExam"> | Date | string
  }

  export type ItemWhereInput = {
    AND?: ItemWhereInput | ItemWhereInput[]
    OR?: ItemWhereInput[]
    NOT?: ItemWhereInput | ItemWhereInput[]
    id?: StringFilter<"Item"> | string
    tenantId?: StringFilter<"Item"> | string
    sku?: StringFilter<"Item"> | string
    name?: StringFilter<"Item"> | string
    description?: StringNullableFilter<"Item"> | string | null
    category?: StringFilter<"Item"> | string
    price?: FloatFilter<"Item"> | number
    costPrice?: FloatNullableFilter<"Item"> | number | null
    stock?: IntFilter<"Item"> | number
    minStock?: IntFilter<"Item"> | number
    createdAt?: DateTimeFilter<"Item"> | Date | string
    updatedAt?: DateTimeFilter<"Item"> | Date | string
    tenant?: XOR<TenantRelationFilter, TenantWhereInput>
    transactions?: InventoryTransactionListRelationFilter
  }

  export type ItemOrderByWithRelationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    sku?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    category?: SortOrder
    price?: SortOrder
    costPrice?: SortOrderInput | SortOrder
    stock?: SortOrder
    minStock?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    tenant?: TenantOrderByWithRelationInput
    transactions?: InventoryTransactionOrderByRelationAggregateInput
  }

  export type ItemWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    sku?: string
    AND?: ItemWhereInput | ItemWhereInput[]
    OR?: ItemWhereInput[]
    NOT?: ItemWhereInput | ItemWhereInput[]
    tenantId?: StringFilter<"Item"> | string
    name?: StringFilter<"Item"> | string
    description?: StringNullableFilter<"Item"> | string | null
    category?: StringFilter<"Item"> | string
    price?: FloatFilter<"Item"> | number
    costPrice?: FloatNullableFilter<"Item"> | number | null
    stock?: IntFilter<"Item"> | number
    minStock?: IntFilter<"Item"> | number
    createdAt?: DateTimeFilter<"Item"> | Date | string
    updatedAt?: DateTimeFilter<"Item"> | Date | string
    tenant?: XOR<TenantRelationFilter, TenantWhereInput>
    transactions?: InventoryTransactionListRelationFilter
  }, "id" | "sku">

  export type ItemOrderByWithAggregationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    sku?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    category?: SortOrder
    price?: SortOrder
    costPrice?: SortOrderInput | SortOrder
    stock?: SortOrder
    minStock?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ItemCountOrderByAggregateInput
    _avg?: ItemAvgOrderByAggregateInput
    _max?: ItemMaxOrderByAggregateInput
    _min?: ItemMinOrderByAggregateInput
    _sum?: ItemSumOrderByAggregateInput
  }

  export type ItemScalarWhereWithAggregatesInput = {
    AND?: ItemScalarWhereWithAggregatesInput | ItemScalarWhereWithAggregatesInput[]
    OR?: ItemScalarWhereWithAggregatesInput[]
    NOT?: ItemScalarWhereWithAggregatesInput | ItemScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Item"> | string
    tenantId?: StringWithAggregatesFilter<"Item"> | string
    sku?: StringWithAggregatesFilter<"Item"> | string
    name?: StringWithAggregatesFilter<"Item"> | string
    description?: StringNullableWithAggregatesFilter<"Item"> | string | null
    category?: StringWithAggregatesFilter<"Item"> | string
    price?: FloatWithAggregatesFilter<"Item"> | number
    costPrice?: FloatNullableWithAggregatesFilter<"Item"> | number | null
    stock?: IntWithAggregatesFilter<"Item"> | number
    minStock?: IntWithAggregatesFilter<"Item"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Item"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Item"> | Date | string
  }

  export type InventoryTransactionWhereInput = {
    AND?: InventoryTransactionWhereInput | InventoryTransactionWhereInput[]
    OR?: InventoryTransactionWhereInput[]
    NOT?: InventoryTransactionWhereInput | InventoryTransactionWhereInput[]
    id?: StringFilter<"InventoryTransaction"> | string
    tenantId?: StringFilter<"InventoryTransaction"> | string
    itemId?: StringFilter<"InventoryTransaction"> | string
    type?: StringFilter<"InventoryTransaction"> | string
    quantity?: IntFilter<"InventoryTransaction"> | number
    reference?: StringNullableFilter<"InventoryTransaction"> | string | null
    notes?: StringNullableFilter<"InventoryTransaction"> | string | null
    handledBy?: StringNullableFilter<"InventoryTransaction"> | string | null
    date?: DateTimeFilter<"InventoryTransaction"> | Date | string
    tenant?: XOR<TenantRelationFilter, TenantWhereInput>
    item?: XOR<ItemRelationFilter, ItemWhereInput>
  }

  export type InventoryTransactionOrderByWithRelationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    itemId?: SortOrder
    type?: SortOrder
    quantity?: SortOrder
    reference?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    handledBy?: SortOrderInput | SortOrder
    date?: SortOrder
    tenant?: TenantOrderByWithRelationInput
    item?: ItemOrderByWithRelationInput
  }

  export type InventoryTransactionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: InventoryTransactionWhereInput | InventoryTransactionWhereInput[]
    OR?: InventoryTransactionWhereInput[]
    NOT?: InventoryTransactionWhereInput | InventoryTransactionWhereInput[]
    tenantId?: StringFilter<"InventoryTransaction"> | string
    itemId?: StringFilter<"InventoryTransaction"> | string
    type?: StringFilter<"InventoryTransaction"> | string
    quantity?: IntFilter<"InventoryTransaction"> | number
    reference?: StringNullableFilter<"InventoryTransaction"> | string | null
    notes?: StringNullableFilter<"InventoryTransaction"> | string | null
    handledBy?: StringNullableFilter<"InventoryTransaction"> | string | null
    date?: DateTimeFilter<"InventoryTransaction"> | Date | string
    tenant?: XOR<TenantRelationFilter, TenantWhereInput>
    item?: XOR<ItemRelationFilter, ItemWhereInput>
  }, "id">

  export type InventoryTransactionOrderByWithAggregationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    itemId?: SortOrder
    type?: SortOrder
    quantity?: SortOrder
    reference?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    handledBy?: SortOrderInput | SortOrder
    date?: SortOrder
    _count?: InventoryTransactionCountOrderByAggregateInput
    _avg?: InventoryTransactionAvgOrderByAggregateInput
    _max?: InventoryTransactionMaxOrderByAggregateInput
    _min?: InventoryTransactionMinOrderByAggregateInput
    _sum?: InventoryTransactionSumOrderByAggregateInput
  }

  export type InventoryTransactionScalarWhereWithAggregatesInput = {
    AND?: InventoryTransactionScalarWhereWithAggregatesInput | InventoryTransactionScalarWhereWithAggregatesInput[]
    OR?: InventoryTransactionScalarWhereWithAggregatesInput[]
    NOT?: InventoryTransactionScalarWhereWithAggregatesInput | InventoryTransactionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"InventoryTransaction"> | string
    tenantId?: StringWithAggregatesFilter<"InventoryTransaction"> | string
    itemId?: StringWithAggregatesFilter<"InventoryTransaction"> | string
    type?: StringWithAggregatesFilter<"InventoryTransaction"> | string
    quantity?: IntWithAggregatesFilter<"InventoryTransaction"> | number
    reference?: StringNullableWithAggregatesFilter<"InventoryTransaction"> | string | null
    notes?: StringNullableWithAggregatesFilter<"InventoryTransaction"> | string | null
    handledBy?: StringNullableWithAggregatesFilter<"InventoryTransaction"> | string | null
    date?: DateTimeWithAggregatesFilter<"InventoryTransaction"> | Date | string
  }

  export type SupplierWhereInput = {
    AND?: SupplierWhereInput | SupplierWhereInput[]
    OR?: SupplierWhereInput[]
    NOT?: SupplierWhereInput | SupplierWhereInput[]
    id?: StringFilter<"Supplier"> | string
    tenantId?: StringFilter<"Supplier"> | string
    name?: StringFilter<"Supplier"> | string
    contact?: StringNullableFilter<"Supplier"> | string | null
    address?: StringNullableFilter<"Supplier"> | string | null
    email?: StringNullableFilter<"Supplier"> | string | null
    createdAt?: DateTimeFilter<"Supplier"> | Date | string
    tenant?: XOR<TenantRelationFilter, TenantWhereInput>
    purchaseOrders?: PurchaseOrderListRelationFilter
  }

  export type SupplierOrderByWithRelationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    name?: SortOrder
    contact?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    tenant?: TenantOrderByWithRelationInput
    purchaseOrders?: PurchaseOrderOrderByRelationAggregateInput
  }

  export type SupplierWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: SupplierWhereInput | SupplierWhereInput[]
    OR?: SupplierWhereInput[]
    NOT?: SupplierWhereInput | SupplierWhereInput[]
    tenantId?: StringFilter<"Supplier"> | string
    name?: StringFilter<"Supplier"> | string
    contact?: StringNullableFilter<"Supplier"> | string | null
    address?: StringNullableFilter<"Supplier"> | string | null
    email?: StringNullableFilter<"Supplier"> | string | null
    createdAt?: DateTimeFilter<"Supplier"> | Date | string
    tenant?: XOR<TenantRelationFilter, TenantWhereInput>
    purchaseOrders?: PurchaseOrderListRelationFilter
  }, "id">

  export type SupplierOrderByWithAggregationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    name?: SortOrder
    contact?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: SupplierCountOrderByAggregateInput
    _max?: SupplierMaxOrderByAggregateInput
    _min?: SupplierMinOrderByAggregateInput
  }

  export type SupplierScalarWhereWithAggregatesInput = {
    AND?: SupplierScalarWhereWithAggregatesInput | SupplierScalarWhereWithAggregatesInput[]
    OR?: SupplierScalarWhereWithAggregatesInput[]
    NOT?: SupplierScalarWhereWithAggregatesInput | SupplierScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Supplier"> | string
    tenantId?: StringWithAggregatesFilter<"Supplier"> | string
    name?: StringWithAggregatesFilter<"Supplier"> | string
    contact?: StringNullableWithAggregatesFilter<"Supplier"> | string | null
    address?: StringNullableWithAggregatesFilter<"Supplier"> | string | null
    email?: StringNullableWithAggregatesFilter<"Supplier"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Supplier"> | Date | string
  }

  export type PurchaseOrderWhereInput = {
    AND?: PurchaseOrderWhereInput | PurchaseOrderWhereInput[]
    OR?: PurchaseOrderWhereInput[]
    NOT?: PurchaseOrderWhereInput | PurchaseOrderWhereInput[]
    id?: StringFilter<"PurchaseOrder"> | string
    tenantId?: StringFilter<"PurchaseOrder"> | string
    supplierId?: StringFilter<"PurchaseOrder"> | string
    poNumber?: StringFilter<"PurchaseOrder"> | string
    totalCost?: FloatFilter<"PurchaseOrder"> | number
    status?: StringFilter<"PurchaseOrder"> | string
    orderDate?: DateTimeFilter<"PurchaseOrder"> | Date | string
    notes?: StringNullableFilter<"PurchaseOrder"> | string | null
    createdAt?: DateTimeFilter<"PurchaseOrder"> | Date | string
    updatedAt?: DateTimeFilter<"PurchaseOrder"> | Date | string
    tenant?: XOR<TenantRelationFilter, TenantWhereInput>
    supplier?: XOR<SupplierRelationFilter, SupplierWhereInput>
  }

  export type PurchaseOrderOrderByWithRelationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    supplierId?: SortOrder
    poNumber?: SortOrder
    totalCost?: SortOrder
    status?: SortOrder
    orderDate?: SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    tenant?: TenantOrderByWithRelationInput
    supplier?: SupplierOrderByWithRelationInput
  }

  export type PurchaseOrderWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    poNumber?: string
    AND?: PurchaseOrderWhereInput | PurchaseOrderWhereInput[]
    OR?: PurchaseOrderWhereInput[]
    NOT?: PurchaseOrderWhereInput | PurchaseOrderWhereInput[]
    tenantId?: StringFilter<"PurchaseOrder"> | string
    supplierId?: StringFilter<"PurchaseOrder"> | string
    totalCost?: FloatFilter<"PurchaseOrder"> | number
    status?: StringFilter<"PurchaseOrder"> | string
    orderDate?: DateTimeFilter<"PurchaseOrder"> | Date | string
    notes?: StringNullableFilter<"PurchaseOrder"> | string | null
    createdAt?: DateTimeFilter<"PurchaseOrder"> | Date | string
    updatedAt?: DateTimeFilter<"PurchaseOrder"> | Date | string
    tenant?: XOR<TenantRelationFilter, TenantWhereInput>
    supplier?: XOR<SupplierRelationFilter, SupplierWhereInput>
  }, "id" | "poNumber">

  export type PurchaseOrderOrderByWithAggregationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    supplierId?: SortOrder
    poNumber?: SortOrder
    totalCost?: SortOrder
    status?: SortOrder
    orderDate?: SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PurchaseOrderCountOrderByAggregateInput
    _avg?: PurchaseOrderAvgOrderByAggregateInput
    _max?: PurchaseOrderMaxOrderByAggregateInput
    _min?: PurchaseOrderMinOrderByAggregateInput
    _sum?: PurchaseOrderSumOrderByAggregateInput
  }

  export type PurchaseOrderScalarWhereWithAggregatesInput = {
    AND?: PurchaseOrderScalarWhereWithAggregatesInput | PurchaseOrderScalarWhereWithAggregatesInput[]
    OR?: PurchaseOrderScalarWhereWithAggregatesInput[]
    NOT?: PurchaseOrderScalarWhereWithAggregatesInput | PurchaseOrderScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PurchaseOrder"> | string
    tenantId?: StringWithAggregatesFilter<"PurchaseOrder"> | string
    supplierId?: StringWithAggregatesFilter<"PurchaseOrder"> | string
    poNumber?: StringWithAggregatesFilter<"PurchaseOrder"> | string
    totalCost?: FloatWithAggregatesFilter<"PurchaseOrder"> | number
    status?: StringWithAggregatesFilter<"PurchaseOrder"> | string
    orderDate?: DateTimeWithAggregatesFilter<"PurchaseOrder"> | Date | string
    notes?: StringNullableWithAggregatesFilter<"PurchaseOrder"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"PurchaseOrder"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"PurchaseOrder"> | Date | string
  }

  export type BuildingWhereInput = {
    AND?: BuildingWhereInput | BuildingWhereInput[]
    OR?: BuildingWhereInput[]
    NOT?: BuildingWhereInput | BuildingWhereInput[]
    id?: StringFilter<"Building"> | string
    tenantId?: StringFilter<"Building"> | string
    name?: StringFilter<"Building"> | string
    description?: StringNullableFilter<"Building"> | string | null
    gender?: StringFilter<"Building"> | string
    capacity?: IntFilter<"Building"> | number
    createdAt?: DateTimeFilter<"Building"> | Date | string
    updatedAt?: DateTimeFilter<"Building"> | Date | string
    tenant?: XOR<TenantRelationFilter, TenantWhereInput>
    rooms?: RoomListRelationFilter
  }

  export type BuildingOrderByWithRelationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    gender?: SortOrder
    capacity?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    tenant?: TenantOrderByWithRelationInput
    rooms?: RoomOrderByRelationAggregateInput
  }

  export type BuildingWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: BuildingWhereInput | BuildingWhereInput[]
    OR?: BuildingWhereInput[]
    NOT?: BuildingWhereInput | BuildingWhereInput[]
    tenantId?: StringFilter<"Building"> | string
    name?: StringFilter<"Building"> | string
    description?: StringNullableFilter<"Building"> | string | null
    gender?: StringFilter<"Building"> | string
    capacity?: IntFilter<"Building"> | number
    createdAt?: DateTimeFilter<"Building"> | Date | string
    updatedAt?: DateTimeFilter<"Building"> | Date | string
    tenant?: XOR<TenantRelationFilter, TenantWhereInput>
    rooms?: RoomListRelationFilter
  }, "id">

  export type BuildingOrderByWithAggregationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    gender?: SortOrder
    capacity?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: BuildingCountOrderByAggregateInput
    _avg?: BuildingAvgOrderByAggregateInput
    _max?: BuildingMaxOrderByAggregateInput
    _min?: BuildingMinOrderByAggregateInput
    _sum?: BuildingSumOrderByAggregateInput
  }

  export type BuildingScalarWhereWithAggregatesInput = {
    AND?: BuildingScalarWhereWithAggregatesInput | BuildingScalarWhereWithAggregatesInput[]
    OR?: BuildingScalarWhereWithAggregatesInput[]
    NOT?: BuildingScalarWhereWithAggregatesInput | BuildingScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Building"> | string
    tenantId?: StringWithAggregatesFilter<"Building"> | string
    name?: StringWithAggregatesFilter<"Building"> | string
    description?: StringNullableWithAggregatesFilter<"Building"> | string | null
    gender?: StringWithAggregatesFilter<"Building"> | string
    capacity?: IntWithAggregatesFilter<"Building"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Building"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Building"> | Date | string
  }

  export type RoomWhereInput = {
    AND?: RoomWhereInput | RoomWhereInput[]
    OR?: RoomWhereInput[]
    NOT?: RoomWhereInput | RoomWhereInput[]
    id?: StringFilter<"Room"> | string
    tenantId?: StringFilter<"Room"> | string
    buildingId?: StringFilter<"Room"> | string
    name?: StringFilter<"Room"> | string
    capacity?: IntFilter<"Room"> | number
    picName?: StringNullableFilter<"Room"> | string | null
    createdAt?: DateTimeFilter<"Room"> | Date | string
    tenant?: XOR<TenantRelationFilter, TenantWhereInput>
    building?: XOR<BuildingRelationFilter, BuildingWhereInput>
    assignments?: RoomAssignmentListRelationFilter
    tickets?: MaintenanceTicketListRelationFilter
  }

  export type RoomOrderByWithRelationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    buildingId?: SortOrder
    name?: SortOrder
    capacity?: SortOrder
    picName?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    tenant?: TenantOrderByWithRelationInput
    building?: BuildingOrderByWithRelationInput
    assignments?: RoomAssignmentOrderByRelationAggregateInput
    tickets?: MaintenanceTicketOrderByRelationAggregateInput
  }

  export type RoomWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: RoomWhereInput | RoomWhereInput[]
    OR?: RoomWhereInput[]
    NOT?: RoomWhereInput | RoomWhereInput[]
    tenantId?: StringFilter<"Room"> | string
    buildingId?: StringFilter<"Room"> | string
    name?: StringFilter<"Room"> | string
    capacity?: IntFilter<"Room"> | number
    picName?: StringNullableFilter<"Room"> | string | null
    createdAt?: DateTimeFilter<"Room"> | Date | string
    tenant?: XOR<TenantRelationFilter, TenantWhereInput>
    building?: XOR<BuildingRelationFilter, BuildingWhereInput>
    assignments?: RoomAssignmentListRelationFilter
    tickets?: MaintenanceTicketListRelationFilter
  }, "id">

  export type RoomOrderByWithAggregationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    buildingId?: SortOrder
    name?: SortOrder
    capacity?: SortOrder
    picName?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: RoomCountOrderByAggregateInput
    _avg?: RoomAvgOrderByAggregateInput
    _max?: RoomMaxOrderByAggregateInput
    _min?: RoomMinOrderByAggregateInput
    _sum?: RoomSumOrderByAggregateInput
  }

  export type RoomScalarWhereWithAggregatesInput = {
    AND?: RoomScalarWhereWithAggregatesInput | RoomScalarWhereWithAggregatesInput[]
    OR?: RoomScalarWhereWithAggregatesInput[]
    NOT?: RoomScalarWhereWithAggregatesInput | RoomScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Room"> | string
    tenantId?: StringWithAggregatesFilter<"Room"> | string
    buildingId?: StringWithAggregatesFilter<"Room"> | string
    name?: StringWithAggregatesFilter<"Room"> | string
    capacity?: IntWithAggregatesFilter<"Room"> | number
    picName?: StringNullableWithAggregatesFilter<"Room"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Room"> | Date | string
  }

  export type RoomAssignmentWhereInput = {
    AND?: RoomAssignmentWhereInput | RoomAssignmentWhereInput[]
    OR?: RoomAssignmentWhereInput[]
    NOT?: RoomAssignmentWhereInput | RoomAssignmentWhereInput[]
    id?: StringFilter<"RoomAssignment"> | string
    tenantId?: StringFilter<"RoomAssignment"> | string
    roomId?: StringFilter<"RoomAssignment"> | string
    santriId?: StringFilter<"RoomAssignment"> | string
    startDate?: DateTimeFilter<"RoomAssignment"> | Date | string
    endDate?: DateTimeNullableFilter<"RoomAssignment"> | Date | string | null
    status?: StringFilter<"RoomAssignment"> | string
    tenant?: XOR<TenantRelationFilter, TenantWhereInput>
    room?: XOR<RoomRelationFilter, RoomWhereInput>
  }

  export type RoomAssignmentOrderByWithRelationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    roomId?: SortOrder
    santriId?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrderInput | SortOrder
    status?: SortOrder
    tenant?: TenantOrderByWithRelationInput
    room?: RoomOrderByWithRelationInput
  }

  export type RoomAssignmentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: RoomAssignmentWhereInput | RoomAssignmentWhereInput[]
    OR?: RoomAssignmentWhereInput[]
    NOT?: RoomAssignmentWhereInput | RoomAssignmentWhereInput[]
    tenantId?: StringFilter<"RoomAssignment"> | string
    roomId?: StringFilter<"RoomAssignment"> | string
    santriId?: StringFilter<"RoomAssignment"> | string
    startDate?: DateTimeFilter<"RoomAssignment"> | Date | string
    endDate?: DateTimeNullableFilter<"RoomAssignment"> | Date | string | null
    status?: StringFilter<"RoomAssignment"> | string
    tenant?: XOR<TenantRelationFilter, TenantWhereInput>
    room?: XOR<RoomRelationFilter, RoomWhereInput>
  }, "id">

  export type RoomAssignmentOrderByWithAggregationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    roomId?: SortOrder
    santriId?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrderInput | SortOrder
    status?: SortOrder
    _count?: RoomAssignmentCountOrderByAggregateInput
    _max?: RoomAssignmentMaxOrderByAggregateInput
    _min?: RoomAssignmentMinOrderByAggregateInput
  }

  export type RoomAssignmentScalarWhereWithAggregatesInput = {
    AND?: RoomAssignmentScalarWhereWithAggregatesInput | RoomAssignmentScalarWhereWithAggregatesInput[]
    OR?: RoomAssignmentScalarWhereWithAggregatesInput[]
    NOT?: RoomAssignmentScalarWhereWithAggregatesInput | RoomAssignmentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"RoomAssignment"> | string
    tenantId?: StringWithAggregatesFilter<"RoomAssignment"> | string
    roomId?: StringWithAggregatesFilter<"RoomAssignment"> | string
    santriId?: StringWithAggregatesFilter<"RoomAssignment"> | string
    startDate?: DateTimeWithAggregatesFilter<"RoomAssignment"> | Date | string
    endDate?: DateTimeNullableWithAggregatesFilter<"RoomAssignment"> | Date | string | null
    status?: StringWithAggregatesFilter<"RoomAssignment"> | string
  }

  export type MaintenanceTicketWhereInput = {
    AND?: MaintenanceTicketWhereInput | MaintenanceTicketWhereInput[]
    OR?: MaintenanceTicketWhereInput[]
    NOT?: MaintenanceTicketWhereInput | MaintenanceTicketWhereInput[]
    id?: StringFilter<"MaintenanceTicket"> | string
    tenantId?: StringFilter<"MaintenanceTicket"> | string
    roomId?: StringFilter<"MaintenanceTicket"> | string
    title?: StringFilter<"MaintenanceTicket"> | string
    description?: StringFilter<"MaintenanceTicket"> | string
    priority?: StringFilter<"MaintenanceTicket"> | string
    status?: StringFilter<"MaintenanceTicket"> | string
    reportedBy?: StringFilter<"MaintenanceTicket"> | string
    resolvedAt?: DateTimeNullableFilter<"MaintenanceTicket"> | Date | string | null
    createdAt?: DateTimeFilter<"MaintenanceTicket"> | Date | string
    updatedAt?: DateTimeFilter<"MaintenanceTicket"> | Date | string
    tenant?: XOR<TenantRelationFilter, TenantWhereInput>
    room?: XOR<RoomRelationFilter, RoomWhereInput>
  }

  export type MaintenanceTicketOrderByWithRelationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    roomId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    priority?: SortOrder
    status?: SortOrder
    reportedBy?: SortOrder
    resolvedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    tenant?: TenantOrderByWithRelationInput
    room?: RoomOrderByWithRelationInput
  }

  export type MaintenanceTicketWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: MaintenanceTicketWhereInput | MaintenanceTicketWhereInput[]
    OR?: MaintenanceTicketWhereInput[]
    NOT?: MaintenanceTicketWhereInput | MaintenanceTicketWhereInput[]
    tenantId?: StringFilter<"MaintenanceTicket"> | string
    roomId?: StringFilter<"MaintenanceTicket"> | string
    title?: StringFilter<"MaintenanceTicket"> | string
    description?: StringFilter<"MaintenanceTicket"> | string
    priority?: StringFilter<"MaintenanceTicket"> | string
    status?: StringFilter<"MaintenanceTicket"> | string
    reportedBy?: StringFilter<"MaintenanceTicket"> | string
    resolvedAt?: DateTimeNullableFilter<"MaintenanceTicket"> | Date | string | null
    createdAt?: DateTimeFilter<"MaintenanceTicket"> | Date | string
    updatedAt?: DateTimeFilter<"MaintenanceTicket"> | Date | string
    tenant?: XOR<TenantRelationFilter, TenantWhereInput>
    room?: XOR<RoomRelationFilter, RoomWhereInput>
  }, "id">

  export type MaintenanceTicketOrderByWithAggregationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    roomId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    priority?: SortOrder
    status?: SortOrder
    reportedBy?: SortOrder
    resolvedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: MaintenanceTicketCountOrderByAggregateInput
    _max?: MaintenanceTicketMaxOrderByAggregateInput
    _min?: MaintenanceTicketMinOrderByAggregateInput
  }

  export type MaintenanceTicketScalarWhereWithAggregatesInput = {
    AND?: MaintenanceTicketScalarWhereWithAggregatesInput | MaintenanceTicketScalarWhereWithAggregatesInput[]
    OR?: MaintenanceTicketScalarWhereWithAggregatesInput[]
    NOT?: MaintenanceTicketScalarWhereWithAggregatesInput | MaintenanceTicketScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"MaintenanceTicket"> | string
    tenantId?: StringWithAggregatesFilter<"MaintenanceTicket"> | string
    roomId?: StringWithAggregatesFilter<"MaintenanceTicket"> | string
    title?: StringWithAggregatesFilter<"MaintenanceTicket"> | string
    description?: StringWithAggregatesFilter<"MaintenanceTicket"> | string
    priority?: StringWithAggregatesFilter<"MaintenanceTicket"> | string
    status?: StringWithAggregatesFilter<"MaintenanceTicket"> | string
    reportedBy?: StringWithAggregatesFilter<"MaintenanceTicket"> | string
    resolvedAt?: DateTimeNullableWithAggregatesFilter<"MaintenanceTicket"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"MaintenanceTicket"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"MaintenanceTicket"> | Date | string
  }

  export type TenantCreateInput = {
    id?: string
    name: string
    address?: string | null
    phone?: string | null
    adminUserId?: string | null
    timezone?: string
    plan?: string
    billingContact?: string | null
    status?: string
    settings?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutTenantInput
    santri?: SantriCreateNestedManyWithoutTenantInput
    wali?: WaliCreateNestedManyWithoutTenantInput
    izin?: IzinCreateNestedManyWithoutTenantInput
    catatanHarian?: CatatanHarianCreateNestedManyWithoutTenantInput
    pengumuman?: PengumumanCreateNestedManyWithoutTenantInput
    invoices?: InvoiceCreateNestedManyWithoutTenantInput
    pelanggaran?: PelanggaranCreateNestedManyWithoutTenantInput
    pembinaan?: PembinaanCreateNestedManyWithoutTenantInput
    kunjungan?: KunjunganCreateNestedManyWithoutTenantInput
    healthRecords?: HealthRecordCreateNestedManyWithoutTenantInput
    auditLogs?: AuditLogCreateNestedManyWithoutTenantInput
    notifications?: NotificationCreateNestedManyWithoutTenantInput
    webhookEvents?: WebhookEventCreateNestedManyWithoutTenantInput
    tahfidz?: TahfidzCreateNestedManyWithoutTenantInput
    mutabaah?: MutabaahCreateNestedManyWithoutTenantInput
    wallets?: WalletCreateNestedManyWithoutTenantInput
    employees?: EmployeeCreateNestedManyWithoutTenantInput
    payrolls?: PayrollCreateNestedManyWithoutTenantInput
    academicScheds?: AcademicScheduleCreateNestedManyWithoutTenantInput
    attendances?: AttendanceCreateNestedManyWithoutTenantInput
    grades?: GradeCreateNestedManyWithoutTenantInput
    ppdbRegistrations?: PpdbRegistrationCreateNestedManyWithoutTenantInput
    ppdbDocuments?: PpdbDocumentCreateNestedManyWithoutTenantInput
    ppdbExams?: PpdbExamCreateNestedManyWithoutTenantInput
    inventoryItems?: ItemCreateNestedManyWithoutTenantInput
    inventoryTransactions?: InventoryTransactionCreateNestedManyWithoutTenantInput
    suppliers?: SupplierCreateNestedManyWithoutTenantInput
    purchaseOrders?: PurchaseOrderCreateNestedManyWithoutTenantInput
    buildings?: BuildingCreateNestedManyWithoutTenantInput
    rooms?: RoomCreateNestedManyWithoutTenantInput
    roomAssignments?: RoomAssignmentCreateNestedManyWithoutTenantInput
    maintenanceTickets?: MaintenanceTicketCreateNestedManyWithoutTenantInput
  }

  export type TenantUncheckedCreateInput = {
    id?: string
    name: string
    address?: string | null
    phone?: string | null
    adminUserId?: string | null
    timezone?: string
    plan?: string
    billingContact?: string | null
    status?: string
    settings?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutTenantInput
    santri?: SantriUncheckedCreateNestedManyWithoutTenantInput
    wali?: WaliUncheckedCreateNestedManyWithoutTenantInput
    izin?: IzinUncheckedCreateNestedManyWithoutTenantInput
    catatanHarian?: CatatanHarianUncheckedCreateNestedManyWithoutTenantInput
    pengumuman?: PengumumanUncheckedCreateNestedManyWithoutTenantInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutTenantInput
    pelanggaran?: PelanggaranUncheckedCreateNestedManyWithoutTenantInput
    pembinaan?: PembinaanUncheckedCreateNestedManyWithoutTenantInput
    kunjungan?: KunjunganUncheckedCreateNestedManyWithoutTenantInput
    healthRecords?: HealthRecordUncheckedCreateNestedManyWithoutTenantInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutTenantInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutTenantInput
    webhookEvents?: WebhookEventUncheckedCreateNestedManyWithoutTenantInput
    tahfidz?: TahfidzUncheckedCreateNestedManyWithoutTenantInput
    mutabaah?: MutabaahUncheckedCreateNestedManyWithoutTenantInput
    wallets?: WalletUncheckedCreateNestedManyWithoutTenantInput
    employees?: EmployeeUncheckedCreateNestedManyWithoutTenantInput
    payrolls?: PayrollUncheckedCreateNestedManyWithoutTenantInput
    academicScheds?: AcademicScheduleUncheckedCreateNestedManyWithoutTenantInput
    attendances?: AttendanceUncheckedCreateNestedManyWithoutTenantInput
    grades?: GradeUncheckedCreateNestedManyWithoutTenantInput
    ppdbRegistrations?: PpdbRegistrationUncheckedCreateNestedManyWithoutTenantInput
    ppdbDocuments?: PpdbDocumentUncheckedCreateNestedManyWithoutTenantInput
    ppdbExams?: PpdbExamUncheckedCreateNestedManyWithoutTenantInput
    inventoryItems?: ItemUncheckedCreateNestedManyWithoutTenantInput
    inventoryTransactions?: InventoryTransactionUncheckedCreateNestedManyWithoutTenantInput
    suppliers?: SupplierUncheckedCreateNestedManyWithoutTenantInput
    purchaseOrders?: PurchaseOrderUncheckedCreateNestedManyWithoutTenantInput
    buildings?: BuildingUncheckedCreateNestedManyWithoutTenantInput
    rooms?: RoomUncheckedCreateNestedManyWithoutTenantInput
    roomAssignments?: RoomAssignmentUncheckedCreateNestedManyWithoutTenantInput
    maintenanceTickets?: MaintenanceTicketUncheckedCreateNestedManyWithoutTenantInput
  }

  export type TenantUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    adminUserId?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    plan?: StringFieldUpdateOperationsInput | string
    billingContact?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    settings?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutTenantNestedInput
    santri?: SantriUpdateManyWithoutTenantNestedInput
    wali?: WaliUpdateManyWithoutTenantNestedInput
    izin?: IzinUpdateManyWithoutTenantNestedInput
    catatanHarian?: CatatanHarianUpdateManyWithoutTenantNestedInput
    pengumuman?: PengumumanUpdateManyWithoutTenantNestedInput
    invoices?: InvoiceUpdateManyWithoutTenantNestedInput
    pelanggaran?: PelanggaranUpdateManyWithoutTenantNestedInput
    pembinaan?: PembinaanUpdateManyWithoutTenantNestedInput
    kunjungan?: KunjunganUpdateManyWithoutTenantNestedInput
    healthRecords?: HealthRecordUpdateManyWithoutTenantNestedInput
    auditLogs?: AuditLogUpdateManyWithoutTenantNestedInput
    notifications?: NotificationUpdateManyWithoutTenantNestedInput
    webhookEvents?: WebhookEventUpdateManyWithoutTenantNestedInput
    tahfidz?: TahfidzUpdateManyWithoutTenantNestedInput
    mutabaah?: MutabaahUpdateManyWithoutTenantNestedInput
    wallets?: WalletUpdateManyWithoutTenantNestedInput
    employees?: EmployeeUpdateManyWithoutTenantNestedInput
    payrolls?: PayrollUpdateManyWithoutTenantNestedInput
    academicScheds?: AcademicScheduleUpdateManyWithoutTenantNestedInput
    attendances?: AttendanceUpdateManyWithoutTenantNestedInput
    grades?: GradeUpdateManyWithoutTenantNestedInput
    ppdbRegistrations?: PpdbRegistrationUpdateManyWithoutTenantNestedInput
    ppdbDocuments?: PpdbDocumentUpdateManyWithoutTenantNestedInput
    ppdbExams?: PpdbExamUpdateManyWithoutTenantNestedInput
    inventoryItems?: ItemUpdateManyWithoutTenantNestedInput
    inventoryTransactions?: InventoryTransactionUpdateManyWithoutTenantNestedInput
    suppliers?: SupplierUpdateManyWithoutTenantNestedInput
    purchaseOrders?: PurchaseOrderUpdateManyWithoutTenantNestedInput
    buildings?: BuildingUpdateManyWithoutTenantNestedInput
    rooms?: RoomUpdateManyWithoutTenantNestedInput
    roomAssignments?: RoomAssignmentUpdateManyWithoutTenantNestedInput
    maintenanceTickets?: MaintenanceTicketUpdateManyWithoutTenantNestedInput
  }

  export type TenantUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    adminUserId?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    plan?: StringFieldUpdateOperationsInput | string
    billingContact?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    settings?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutTenantNestedInput
    santri?: SantriUncheckedUpdateManyWithoutTenantNestedInput
    wali?: WaliUncheckedUpdateManyWithoutTenantNestedInput
    izin?: IzinUncheckedUpdateManyWithoutTenantNestedInput
    catatanHarian?: CatatanHarianUncheckedUpdateManyWithoutTenantNestedInput
    pengumuman?: PengumumanUncheckedUpdateManyWithoutTenantNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutTenantNestedInput
    pelanggaran?: PelanggaranUncheckedUpdateManyWithoutTenantNestedInput
    pembinaan?: PembinaanUncheckedUpdateManyWithoutTenantNestedInput
    kunjungan?: KunjunganUncheckedUpdateManyWithoutTenantNestedInput
    healthRecords?: HealthRecordUncheckedUpdateManyWithoutTenantNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutTenantNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutTenantNestedInput
    webhookEvents?: WebhookEventUncheckedUpdateManyWithoutTenantNestedInput
    tahfidz?: TahfidzUncheckedUpdateManyWithoutTenantNestedInput
    mutabaah?: MutabaahUncheckedUpdateManyWithoutTenantNestedInput
    wallets?: WalletUncheckedUpdateManyWithoutTenantNestedInput
    employees?: EmployeeUncheckedUpdateManyWithoutTenantNestedInput
    payrolls?: PayrollUncheckedUpdateManyWithoutTenantNestedInput
    academicScheds?: AcademicScheduleUncheckedUpdateManyWithoutTenantNestedInput
    attendances?: AttendanceUncheckedUpdateManyWithoutTenantNestedInput
    grades?: GradeUncheckedUpdateManyWithoutTenantNestedInput
    ppdbRegistrations?: PpdbRegistrationUncheckedUpdateManyWithoutTenantNestedInput
    ppdbDocuments?: PpdbDocumentUncheckedUpdateManyWithoutTenantNestedInput
    ppdbExams?: PpdbExamUncheckedUpdateManyWithoutTenantNestedInput
    inventoryItems?: ItemUncheckedUpdateManyWithoutTenantNestedInput
    inventoryTransactions?: InventoryTransactionUncheckedUpdateManyWithoutTenantNestedInput
    suppliers?: SupplierUncheckedUpdateManyWithoutTenantNestedInput
    purchaseOrders?: PurchaseOrderUncheckedUpdateManyWithoutTenantNestedInput
    buildings?: BuildingUncheckedUpdateManyWithoutTenantNestedInput
    rooms?: RoomUncheckedUpdateManyWithoutTenantNestedInput
    roomAssignments?: RoomAssignmentUncheckedUpdateManyWithoutTenantNestedInput
    maintenanceTickets?: MaintenanceTicketUncheckedUpdateManyWithoutTenantNestedInput
  }

  export type TenantCreateManyInput = {
    id?: string
    name: string
    address?: string | null
    phone?: string | null
    adminUserId?: string | null
    timezone?: string
    plan?: string
    billingContact?: string | null
    status?: string
    settings?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TenantUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    adminUserId?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    plan?: StringFieldUpdateOperationsInput | string
    billingContact?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    settings?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TenantUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    adminUserId?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    plan?: StringFieldUpdateOperationsInput | string
    billingContact?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    settings?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserCreateInput = {
    id?: string
    email: string
    passwordHash: string
    role?: string
    name: string
    phone?: string | null
    isActive?: boolean
    lastLogin?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant?: TenantCreateNestedOneWithoutUsersInput
    refreshTokens?: RefreshTokenCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateInput = {
    id?: string
    tenantId?: string | null
    email: string
    passwordHash: string
    role?: string
    name: string
    phone?: string | null
    isActive?: boolean
    lastLogin?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    refreshTokens?: RefreshTokenUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneWithoutUsersNestedInput
    refreshTokens?: RefreshTokenUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    refreshTokens?: RefreshTokenUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateManyInput = {
    id?: string
    tenantId?: string | null
    email: string
    passwordHash: string
    role?: string
    name: string
    phone?: string | null
    isActive?: boolean
    lastLogin?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RefreshTokenCreateInput = {
    id?: string
    token: string
    expiresAt: Date | string
    revoked?: boolean
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutRefreshTokensInput
  }

  export type RefreshTokenUncheckedCreateInput = {
    id?: string
    userId: string
    token: string
    expiresAt: Date | string
    revoked?: boolean
    createdAt?: Date | string
  }

  export type RefreshTokenUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    revoked?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutRefreshTokensNestedInput
  }

  export type RefreshTokenUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    revoked?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RefreshTokenCreateManyInput = {
    id?: string
    userId: string
    token: string
    expiresAt: Date | string
    revoked?: boolean
    createdAt?: Date | string
  }

  export type RefreshTokenUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    revoked?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RefreshTokenUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    revoked?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SantriCreateInput = {
    id?: string
    nisn?: string | null
    name: string
    gender: string
    dob?: Date | string | null
    kelas?: string | null
    room?: string | null
    contact?: string | null
    address?: string | null
    photo?: string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutSantriInput
    walis?: SantriWaliCreateNestedManyWithoutSantriInput
    izin?: IzinCreateNestedManyWithoutSantriInput
    catatanHarian?: CatatanHarianCreateNestedManyWithoutSantriInput
    invoices?: InvoiceCreateNestedManyWithoutSantriInput
    pelanggaran?: PelanggaranCreateNestedManyWithoutSantriInput
    pembinaan?: PembinaanCreateNestedManyWithoutSantriInput
    kunjungan?: KunjunganCreateNestedManyWithoutSantriInput
    healthRecords?: HealthRecordCreateNestedManyWithoutSantriInput
    medications?: MedicationCreateNestedManyWithoutSantriInput
    tahfidz?: TahfidzCreateNestedManyWithoutSantriInput
    mutabaah?: MutabaahCreateNestedManyWithoutSantriInput
    wallet?: WalletCreateNestedOneWithoutSantriInput
    attendances?: AttendanceCreateNestedManyWithoutSantriInput
    grades?: GradeCreateNestedManyWithoutSantriInput
  }

  export type SantriUncheckedCreateInput = {
    id?: string
    tenantId: string
    nisn?: string | null
    name: string
    gender: string
    dob?: Date | string | null
    kelas?: string | null
    room?: string | null
    contact?: string | null
    address?: string | null
    photo?: string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    walis?: SantriWaliUncheckedCreateNestedManyWithoutSantriInput
    izin?: IzinUncheckedCreateNestedManyWithoutSantriInput
    catatanHarian?: CatatanHarianUncheckedCreateNestedManyWithoutSantriInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutSantriInput
    pelanggaran?: PelanggaranUncheckedCreateNestedManyWithoutSantriInput
    pembinaan?: PembinaanUncheckedCreateNestedManyWithoutSantriInput
    kunjungan?: KunjunganUncheckedCreateNestedManyWithoutSantriInput
    healthRecords?: HealthRecordUncheckedCreateNestedManyWithoutSantriInput
    medications?: MedicationUncheckedCreateNestedManyWithoutSantriInput
    tahfidz?: TahfidzUncheckedCreateNestedManyWithoutSantriInput
    mutabaah?: MutabaahUncheckedCreateNestedManyWithoutSantriInput
    wallet?: WalletUncheckedCreateNestedOneWithoutSantriInput
    attendances?: AttendanceUncheckedCreateNestedManyWithoutSantriInput
    grades?: GradeUncheckedCreateNestedManyWithoutSantriInput
  }

  export type SantriUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    nisn?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    gender?: StringFieldUpdateOperationsInput | string
    dob?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    kelas?: NullableStringFieldUpdateOperationsInput | string | null
    room?: NullableStringFieldUpdateOperationsInput | string | null
    contact?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutSantriNestedInput
    walis?: SantriWaliUpdateManyWithoutSantriNestedInput
    izin?: IzinUpdateManyWithoutSantriNestedInput
    catatanHarian?: CatatanHarianUpdateManyWithoutSantriNestedInput
    invoices?: InvoiceUpdateManyWithoutSantriNestedInput
    pelanggaran?: PelanggaranUpdateManyWithoutSantriNestedInput
    pembinaan?: PembinaanUpdateManyWithoutSantriNestedInput
    kunjungan?: KunjunganUpdateManyWithoutSantriNestedInput
    healthRecords?: HealthRecordUpdateManyWithoutSantriNestedInput
    medications?: MedicationUpdateManyWithoutSantriNestedInput
    tahfidz?: TahfidzUpdateManyWithoutSantriNestedInput
    mutabaah?: MutabaahUpdateManyWithoutSantriNestedInput
    wallet?: WalletUpdateOneWithoutSantriNestedInput
    attendances?: AttendanceUpdateManyWithoutSantriNestedInput
    grades?: GradeUpdateManyWithoutSantriNestedInput
  }

  export type SantriUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    nisn?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    gender?: StringFieldUpdateOperationsInput | string
    dob?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    kelas?: NullableStringFieldUpdateOperationsInput | string | null
    room?: NullableStringFieldUpdateOperationsInput | string | null
    contact?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    walis?: SantriWaliUncheckedUpdateManyWithoutSantriNestedInput
    izin?: IzinUncheckedUpdateManyWithoutSantriNestedInput
    catatanHarian?: CatatanHarianUncheckedUpdateManyWithoutSantriNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutSantriNestedInput
    pelanggaran?: PelanggaranUncheckedUpdateManyWithoutSantriNestedInput
    pembinaan?: PembinaanUncheckedUpdateManyWithoutSantriNestedInput
    kunjungan?: KunjunganUncheckedUpdateManyWithoutSantriNestedInput
    healthRecords?: HealthRecordUncheckedUpdateManyWithoutSantriNestedInput
    medications?: MedicationUncheckedUpdateManyWithoutSantriNestedInput
    tahfidz?: TahfidzUncheckedUpdateManyWithoutSantriNestedInput
    mutabaah?: MutabaahUncheckedUpdateManyWithoutSantriNestedInput
    wallet?: WalletUncheckedUpdateOneWithoutSantriNestedInput
    attendances?: AttendanceUncheckedUpdateManyWithoutSantriNestedInput
    grades?: GradeUncheckedUpdateManyWithoutSantriNestedInput
  }

  export type SantriCreateManyInput = {
    id?: string
    tenantId: string
    nisn?: string | null
    name: string
    gender: string
    dob?: Date | string | null
    kelas?: string | null
    room?: string | null
    contact?: string | null
    address?: string | null
    photo?: string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SantriUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    nisn?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    gender?: StringFieldUpdateOperationsInput | string
    dob?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    kelas?: NullableStringFieldUpdateOperationsInput | string | null
    room?: NullableStringFieldUpdateOperationsInput | string | null
    contact?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SantriUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    nisn?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    gender?: StringFieldUpdateOperationsInput | string
    dob?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    kelas?: NullableStringFieldUpdateOperationsInput | string | null
    room?: NullableStringFieldUpdateOperationsInput | string | null
    contact?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WaliCreateInput = {
    id?: string
    name: string
    relation: string
    phone: string
    email?: string | null
    address?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutWaliInput
    santris?: SantriWaliCreateNestedManyWithoutWaliInput
  }

  export type WaliUncheckedCreateInput = {
    id?: string
    tenantId: string
    name: string
    relation: string
    phone: string
    email?: string | null
    address?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    santris?: SantriWaliUncheckedCreateNestedManyWithoutWaliInput
  }

  export type WaliUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    relation?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutWaliNestedInput
    santris?: SantriWaliUpdateManyWithoutWaliNestedInput
  }

  export type WaliUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    relation?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    santris?: SantriWaliUncheckedUpdateManyWithoutWaliNestedInput
  }

  export type WaliCreateManyInput = {
    id?: string
    tenantId: string
    name: string
    relation: string
    phone: string
    email?: string | null
    address?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WaliUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    relation?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WaliUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    relation?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SantriWaliCreateInput = {
    isPrimary?: boolean
    santri: SantriCreateNestedOneWithoutWalisInput
    wali: WaliCreateNestedOneWithoutSantrisInput
  }

  export type SantriWaliUncheckedCreateInput = {
    santriId: string
    waliId: string
    isPrimary?: boolean
  }

  export type SantriWaliUpdateInput = {
    isPrimary?: BoolFieldUpdateOperationsInput | boolean
    santri?: SantriUpdateOneRequiredWithoutWalisNestedInput
    wali?: WaliUpdateOneRequiredWithoutSantrisNestedInput
  }

  export type SantriWaliUncheckedUpdateInput = {
    santriId?: StringFieldUpdateOperationsInput | string
    waliId?: StringFieldUpdateOperationsInput | string
    isPrimary?: BoolFieldUpdateOperationsInput | boolean
  }

  export type SantriWaliCreateManyInput = {
    santriId: string
    waliId: string
    isPrimary?: boolean
  }

  export type SantriWaliUpdateManyMutationInput = {
    isPrimary?: BoolFieldUpdateOperationsInput | boolean
  }

  export type SantriWaliUncheckedUpdateManyInput = {
    santriId?: StringFieldUpdateOperationsInput | string
    waliId?: StringFieldUpdateOperationsInput | string
    isPrimary?: BoolFieldUpdateOperationsInput | boolean
  }

  export type IzinCreateInput = {
    id?: string
    type: string
    reason: string
    startAt: Date | string
    endAt: Date | string
    status?: string
    requestedBy: string
    approvedBy?: string | null
    approvedAt?: Date | string | null
    qrCodeData?: string | null
    checkoutAt?: Date | string | null
    checkoutBy?: string | null
    checkinAt?: Date | string | null
    checkinBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutIzinInput
    santri: SantriCreateNestedOneWithoutIzinInput
  }

  export type IzinUncheckedCreateInput = {
    id?: string
    tenantId: string
    santriId: string
    type: string
    reason: string
    startAt: Date | string
    endAt: Date | string
    status?: string
    requestedBy: string
    approvedBy?: string | null
    approvedAt?: Date | string | null
    qrCodeData?: string | null
    checkoutAt?: Date | string | null
    checkoutBy?: string | null
    checkinAt?: Date | string | null
    checkinBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type IzinUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    reason?: StringFieldUpdateOperationsInput | string
    startAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    requestedBy?: StringFieldUpdateOperationsInput | string
    approvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    qrCodeData?: NullableStringFieldUpdateOperationsInput | string | null
    checkoutAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    checkoutBy?: NullableStringFieldUpdateOperationsInput | string | null
    checkinAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    checkinBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutIzinNestedInput
    santri?: SantriUpdateOneRequiredWithoutIzinNestedInput
  }

  export type IzinUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    santriId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    reason?: StringFieldUpdateOperationsInput | string
    startAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    requestedBy?: StringFieldUpdateOperationsInput | string
    approvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    qrCodeData?: NullableStringFieldUpdateOperationsInput | string | null
    checkoutAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    checkoutBy?: NullableStringFieldUpdateOperationsInput | string | null
    checkinAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    checkinBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IzinCreateManyInput = {
    id?: string
    tenantId: string
    santriId: string
    type: string
    reason: string
    startAt: Date | string
    endAt: Date | string
    status?: string
    requestedBy: string
    approvedBy?: string | null
    approvedAt?: Date | string | null
    qrCodeData?: string | null
    checkoutAt?: Date | string | null
    checkoutBy?: string | null
    checkinAt?: Date | string | null
    checkinBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type IzinUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    reason?: StringFieldUpdateOperationsInput | string
    startAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    requestedBy?: StringFieldUpdateOperationsInput | string
    approvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    qrCodeData?: NullableStringFieldUpdateOperationsInput | string | null
    checkoutAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    checkoutBy?: NullableStringFieldUpdateOperationsInput | string | null
    checkinAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    checkinBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IzinUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    santriId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    reason?: StringFieldUpdateOperationsInput | string
    startAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    requestedBy?: StringFieldUpdateOperationsInput | string
    approvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    qrCodeData?: NullableStringFieldUpdateOperationsInput | string | null
    checkoutAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    checkoutBy?: NullableStringFieldUpdateOperationsInput | string | null
    checkinAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    checkinBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CatatanHarianCreateInput = {
    id?: string
    authorId: string
    date?: Date | string
    content: string
    category: string
    attachments?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutCatatanHarianInput
    santri: SantriCreateNestedOneWithoutCatatanHarianInput
  }

  export type CatatanHarianUncheckedCreateInput = {
    id?: string
    tenantId: string
    santriId: string
    authorId: string
    date?: Date | string
    content: string
    category: string
    attachments?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CatatanHarianUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    content?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    attachments?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutCatatanHarianNestedInput
    santri?: SantriUpdateOneRequiredWithoutCatatanHarianNestedInput
  }

  export type CatatanHarianUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    santriId?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    content?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    attachments?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CatatanHarianCreateManyInput = {
    id?: string
    tenantId: string
    santriId: string
    authorId: string
    date?: Date | string
    content: string
    category: string
    attachments?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CatatanHarianUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    content?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    attachments?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CatatanHarianUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    santriId?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    content?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    attachments?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PengumumanCreateInput = {
    id?: string
    title: string
    content: string
    audience: string
    pinnedUntil?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutPengumumanInput
  }

  export type PengumumanUncheckedCreateInput = {
    id?: string
    tenantId: string
    title: string
    content: string
    audience: string
    pinnedUntil?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PengumumanUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    audience?: StringFieldUpdateOperationsInput | string
    pinnedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutPengumumanNestedInput
  }

  export type PengumumanUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    audience?: StringFieldUpdateOperationsInput | string
    pinnedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PengumumanCreateManyInput = {
    id?: string
    tenantId: string
    title: string
    content: string
    audience: string
    pinnedUntil?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PengumumanUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    audience?: StringFieldUpdateOperationsInput | string
    pinnedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PengumumanUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    audience?: StringFieldUpdateOperationsInput | string
    pinnedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvoiceCreateInput = {
    id?: string
    amountDue: number
    dueDate: Date | string
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutInvoicesInput
    santri: SantriCreateNestedOneWithoutInvoicesInput
    lines?: InvoiceLineCreateNestedManyWithoutInvoiceInput
    payments?: PaymentCreateNestedManyWithoutInvoiceInput
  }

  export type InvoiceUncheckedCreateInput = {
    id?: string
    tenantId: string
    santriId: string
    amountDue: number
    dueDate: Date | string
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    lines?: InvoiceLineUncheckedCreateNestedManyWithoutInvoiceInput
    payments?: PaymentUncheckedCreateNestedManyWithoutInvoiceInput
  }

  export type InvoiceUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    amountDue?: FloatFieldUpdateOperationsInput | number
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutInvoicesNestedInput
    santri?: SantriUpdateOneRequiredWithoutInvoicesNestedInput
    lines?: InvoiceLineUpdateManyWithoutInvoiceNestedInput
    payments?: PaymentUpdateManyWithoutInvoiceNestedInput
  }

  export type InvoiceUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    santriId?: StringFieldUpdateOperationsInput | string
    amountDue?: FloatFieldUpdateOperationsInput | number
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lines?: InvoiceLineUncheckedUpdateManyWithoutInvoiceNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutInvoiceNestedInput
  }

  export type InvoiceCreateManyInput = {
    id?: string
    tenantId: string
    santriId: string
    amountDue: number
    dueDate: Date | string
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InvoiceUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    amountDue?: FloatFieldUpdateOperationsInput | number
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvoiceUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    santriId?: StringFieldUpdateOperationsInput | string
    amountDue?: FloatFieldUpdateOperationsInput | number
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvoiceLineCreateInput = {
    id?: string
    description: string
    amount: number
    type: string
    invoice: InvoiceCreateNestedOneWithoutLinesInput
  }

  export type InvoiceLineUncheckedCreateInput = {
    id?: string
    invoiceId: string
    description: string
    amount: number
    type: string
  }

  export type InvoiceLineUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    invoice?: InvoiceUpdateOneRequiredWithoutLinesNestedInput
  }

  export type InvoiceLineUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceId?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
  }

  export type InvoiceLineCreateManyInput = {
    id?: string
    invoiceId: string
    description: string
    amount: number
    type: string
  }

  export type InvoiceLineUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
  }

  export type InvoiceLineUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceId?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
  }

  export type PaymentCreateInput = {
    id?: string
    method: string
    amount: number
    status?: string
    transactionRef?: string | null
    paidAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    invoice: InvoiceCreateNestedOneWithoutPaymentsInput
  }

  export type PaymentUncheckedCreateInput = {
    id?: string
    invoiceId: string
    method: string
    amount: number
    status?: string
    transactionRef?: string | null
    paidAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PaymentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    method?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    transactionRef?: NullableStringFieldUpdateOperationsInput | string | null
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    invoice?: InvoiceUpdateOneRequiredWithoutPaymentsNestedInput
  }

  export type PaymentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceId?: StringFieldUpdateOperationsInput | string
    method?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    transactionRef?: NullableStringFieldUpdateOperationsInput | string | null
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentCreateManyInput = {
    id?: string
    invoiceId: string
    method: string
    amount: number
    status?: string
    transactionRef?: string | null
    paidAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PaymentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    method?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    transactionRef?: NullableStringFieldUpdateOperationsInput | string | null
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceId?: StringFieldUpdateOperationsInput | string
    method?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    transactionRef?: NullableStringFieldUpdateOperationsInput | string | null
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PelanggaranCreateInput = {
    id?: string
    recordedBy: string
    category: string
    severity: number
    points?: number
    description: string
    date?: Date | string
    resolved?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutPelanggaranInput
    santri: SantriCreateNestedOneWithoutPelanggaranInput
  }

  export type PelanggaranUncheckedCreateInput = {
    id?: string
    tenantId: string
    santriId: string
    recordedBy: string
    category: string
    severity: number
    points?: number
    description: string
    date?: Date | string
    resolved?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PelanggaranUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    recordedBy?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    severity?: IntFieldUpdateOperationsInput | number
    points?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    resolved?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutPelanggaranNestedInput
    santri?: SantriUpdateOneRequiredWithoutPelanggaranNestedInput
  }

  export type PelanggaranUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    santriId?: StringFieldUpdateOperationsInput | string
    recordedBy?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    severity?: IntFieldUpdateOperationsInput | number
    points?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    resolved?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PelanggaranCreateManyInput = {
    id?: string
    tenantId: string
    santriId: string
    recordedBy: string
    category: string
    severity: number
    points?: number
    description: string
    date?: Date | string
    resolved?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PelanggaranUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    recordedBy?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    severity?: IntFieldUpdateOperationsInput | number
    points?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    resolved?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PelanggaranUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    santriId?: StringFieldUpdateOperationsInput | string
    recordedBy?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    severity?: IntFieldUpdateOperationsInput | number
    points?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    resolved?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PembinaanCreateInput = {
    id?: string
    plan: string
    targetDate: Date | string
    status?: string
    assignedTo: string
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutPembinaanInput
    santri: SantriCreateNestedOneWithoutPembinaanInput
  }

  export type PembinaanUncheckedCreateInput = {
    id?: string
    tenantId: string
    santriId: string
    plan: string
    targetDate: Date | string
    status?: string
    assignedTo: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PembinaanUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    plan?: StringFieldUpdateOperationsInput | string
    targetDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    assignedTo?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutPembinaanNestedInput
    santri?: SantriUpdateOneRequiredWithoutPembinaanNestedInput
  }

  export type PembinaanUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    santriId?: StringFieldUpdateOperationsInput | string
    plan?: StringFieldUpdateOperationsInput | string
    targetDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    assignedTo?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PembinaanCreateManyInput = {
    id?: string
    tenantId: string
    santriId: string
    plan: string
    targetDate: Date | string
    status?: string
    assignedTo: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PembinaanUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    plan?: StringFieldUpdateOperationsInput | string
    targetDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    assignedTo?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PembinaanUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    santriId?: StringFieldUpdateOperationsInput | string
    plan?: StringFieldUpdateOperationsInput | string
    targetDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    assignedTo?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type KunjunganCreateInput = {
    id?: string
    scheduledAt: Date | string
    slot: string
    visitorLimit?: number
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutKunjunganInput
    santri: SantriCreateNestedOneWithoutKunjunganInput
    tamu?: TamuCreateNestedManyWithoutKunjunganInput
  }

  export type KunjunganUncheckedCreateInput = {
    id?: string
    tenantId: string
    santriId: string
    scheduledAt: Date | string
    slot: string
    visitorLimit?: number
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    tamu?: TamuUncheckedCreateNestedManyWithoutKunjunganInput
  }

  export type KunjunganUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    scheduledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    slot?: StringFieldUpdateOperationsInput | string
    visitorLimit?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutKunjunganNestedInput
    santri?: SantriUpdateOneRequiredWithoutKunjunganNestedInput
    tamu?: TamuUpdateManyWithoutKunjunganNestedInput
  }

  export type KunjunganUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    santriId?: StringFieldUpdateOperationsInput | string
    scheduledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    slot?: StringFieldUpdateOperationsInput | string
    visitorLimit?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tamu?: TamuUncheckedUpdateManyWithoutKunjunganNestedInput
  }

  export type KunjunganCreateManyInput = {
    id?: string
    tenantId: string
    santriId: string
    scheduledAt: Date | string
    slot: string
    visitorLimit?: number
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type KunjunganUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    scheduledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    slot?: StringFieldUpdateOperationsInput | string
    visitorLimit?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type KunjunganUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    santriId?: StringFieldUpdateOperationsInput | string
    scheduledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    slot?: StringFieldUpdateOperationsInput | string
    visitorLimit?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TamuCreateInput = {
    id?: string
    name: string
    phone?: string | null
    idNumber?: string | null
    checkinAt?: Date | string | null
    createdAt?: Date | string
    kunjungan: KunjunganCreateNestedOneWithoutTamuInput
  }

  export type TamuUncheckedCreateInput = {
    id?: string
    kunjunganId: string
    name: string
    phone?: string | null
    idNumber?: string | null
    checkinAt?: Date | string | null
    createdAt?: Date | string
  }

  export type TamuUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    idNumber?: NullableStringFieldUpdateOperationsInput | string | null
    checkinAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    kunjungan?: KunjunganUpdateOneRequiredWithoutTamuNestedInput
  }

  export type TamuUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    kunjunganId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    idNumber?: NullableStringFieldUpdateOperationsInput | string | null
    checkinAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TamuCreateManyInput = {
    id?: string
    kunjunganId: string
    name: string
    phone?: string | null
    idNumber?: string | null
    checkinAt?: Date | string | null
    createdAt?: Date | string
  }

  export type TamuUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    idNumber?: NullableStringFieldUpdateOperationsInput | string | null
    checkinAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TamuUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    kunjunganId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    idNumber?: NullableStringFieldUpdateOperationsInput | string | null
    checkinAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HealthRecordCreateInput = {
    id?: string
    recordedBy: string
    symptoms: string
    diagnosis?: string | null
    actionTaken?: string | null
    referred?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutHealthRecordsInput
    santri: SantriCreateNestedOneWithoutHealthRecordsInput
  }

  export type HealthRecordUncheckedCreateInput = {
    id?: string
    tenantId: string
    santriId: string
    recordedBy: string
    symptoms: string
    diagnosis?: string | null
    actionTaken?: string | null
    referred?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type HealthRecordUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    recordedBy?: StringFieldUpdateOperationsInput | string
    symptoms?: StringFieldUpdateOperationsInput | string
    diagnosis?: NullableStringFieldUpdateOperationsInput | string | null
    actionTaken?: NullableStringFieldUpdateOperationsInput | string | null
    referred?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutHealthRecordsNestedInput
    santri?: SantriUpdateOneRequiredWithoutHealthRecordsNestedInput
  }

  export type HealthRecordUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    santriId?: StringFieldUpdateOperationsInput | string
    recordedBy?: StringFieldUpdateOperationsInput | string
    symptoms?: StringFieldUpdateOperationsInput | string
    diagnosis?: NullableStringFieldUpdateOperationsInput | string | null
    actionTaken?: NullableStringFieldUpdateOperationsInput | string | null
    referred?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HealthRecordCreateManyInput = {
    id?: string
    tenantId: string
    santriId: string
    recordedBy: string
    symptoms: string
    diagnosis?: string | null
    actionTaken?: string | null
    referred?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type HealthRecordUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    recordedBy?: StringFieldUpdateOperationsInput | string
    symptoms?: StringFieldUpdateOperationsInput | string
    diagnosis?: NullableStringFieldUpdateOperationsInput | string | null
    actionTaken?: NullableStringFieldUpdateOperationsInput | string | null
    referred?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HealthRecordUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    santriId?: StringFieldUpdateOperationsInput | string
    recordedBy?: StringFieldUpdateOperationsInput | string
    symptoms?: StringFieldUpdateOperationsInput | string
    diagnosis?: NullableStringFieldUpdateOperationsInput | string | null
    actionTaken?: NullableStringFieldUpdateOperationsInput | string | null
    referred?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MedicationCreateInput = {
    id?: string
    medicineName: string
    dose: string
    schedule: string
    givenBy?: string | null
    givenAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    santri: SantriCreateNestedOneWithoutMedicationsInput
  }

  export type MedicationUncheckedCreateInput = {
    id?: string
    santriId: string
    medicineName: string
    dose: string
    schedule: string
    givenBy?: string | null
    givenAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MedicationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    medicineName?: StringFieldUpdateOperationsInput | string
    dose?: StringFieldUpdateOperationsInput | string
    schedule?: StringFieldUpdateOperationsInput | string
    givenBy?: NullableStringFieldUpdateOperationsInput | string | null
    givenAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    santri?: SantriUpdateOneRequiredWithoutMedicationsNestedInput
  }

  export type MedicationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    santriId?: StringFieldUpdateOperationsInput | string
    medicineName?: StringFieldUpdateOperationsInput | string
    dose?: StringFieldUpdateOperationsInput | string
    schedule?: StringFieldUpdateOperationsInput | string
    givenBy?: NullableStringFieldUpdateOperationsInput | string | null
    givenAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MedicationCreateManyInput = {
    id?: string
    santriId: string
    medicineName: string
    dose: string
    schedule: string
    givenBy?: string | null
    givenAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MedicationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    medicineName?: StringFieldUpdateOperationsInput | string
    dose?: StringFieldUpdateOperationsInput | string
    schedule?: StringFieldUpdateOperationsInput | string
    givenBy?: NullableStringFieldUpdateOperationsInput | string | null
    givenAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MedicationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    santriId?: StringFieldUpdateOperationsInput | string
    medicineName?: StringFieldUpdateOperationsInput | string
    dose?: StringFieldUpdateOperationsInput | string
    schedule?: StringFieldUpdateOperationsInput | string
    givenBy?: NullableStringFieldUpdateOperationsInput | string | null
    givenAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogCreateInput = {
    id?: string
    action: string
    entity: string
    entityId: string
    oldValue?: string | null
    newValue?: string | null
    ip?: string | null
    createdAt?: Date | string
    tenant?: TenantCreateNestedOneWithoutAuditLogsInput
    user?: UserCreateNestedOneWithoutAuditLogsInput
  }

  export type AuditLogUncheckedCreateInput = {
    id?: string
    tenantId?: string | null
    userId?: string | null
    action: string
    entity: string
    entityId: string
    oldValue?: string | null
    newValue?: string | null
    ip?: string | null
    createdAt?: Date | string
  }

  export type AuditLogUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    entity?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    oldValue?: NullableStringFieldUpdateOperationsInput | string | null
    newValue?: NullableStringFieldUpdateOperationsInput | string | null
    ip?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneWithoutAuditLogsNestedInput
    user?: UserUpdateOneWithoutAuditLogsNestedInput
  }

  export type AuditLogUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    action?: StringFieldUpdateOperationsInput | string
    entity?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    oldValue?: NullableStringFieldUpdateOperationsInput | string | null
    newValue?: NullableStringFieldUpdateOperationsInput | string | null
    ip?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogCreateManyInput = {
    id?: string
    tenantId?: string | null
    userId?: string | null
    action: string
    entity: string
    entityId: string
    oldValue?: string | null
    newValue?: string | null
    ip?: string | null
    createdAt?: Date | string
  }

  export type AuditLogUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    entity?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    oldValue?: NullableStringFieldUpdateOperationsInput | string | null
    newValue?: NullableStringFieldUpdateOperationsInput | string | null
    ip?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    action?: StringFieldUpdateOperationsInput | string
    entity?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    oldValue?: NullableStringFieldUpdateOperationsInput | string | null
    newValue?: NullableStringFieldUpdateOperationsInput | string | null
    ip?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationCreateInput = {
    id?: string
    type: string
    title: string
    body: string
    read?: boolean
    createdAt?: Date | string
    tenant: TenantCreateNestedOneWithoutNotificationsInput
    user: UserCreateNestedOneWithoutNotificationsInput
  }

  export type NotificationUncheckedCreateInput = {
    id?: string
    tenantId: string
    userId: string
    type: string
    title: string
    body: string
    read?: boolean
    createdAt?: Date | string
  }

  export type NotificationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    read?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutNotificationsNestedInput
    user?: UserUpdateOneRequiredWithoutNotificationsNestedInput
  }

  export type NotificationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    read?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationCreateManyInput = {
    id?: string
    tenantId: string
    userId: string
    type: string
    title: string
    body: string
    read?: boolean
    createdAt?: Date | string
  }

  export type NotificationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    read?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    read?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WebhookEventCreateInput = {
    id?: string
    eventType: string
    payload: string
    status?: string
    error?: string | null
    createdAt?: Date | string
    processedAt?: Date | string | null
    tenant?: TenantCreateNestedOneWithoutWebhookEventsInput
  }

  export type WebhookEventUncheckedCreateInput = {
    id?: string
    tenantId?: string | null
    eventType: string
    payload: string
    status?: string
    error?: string | null
    createdAt?: Date | string
    processedAt?: Date | string | null
  }

  export type WebhookEventUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    eventType?: StringFieldUpdateOperationsInput | string
    payload?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    error?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tenant?: TenantUpdateOneWithoutWebhookEventsNestedInput
  }

  export type WebhookEventUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: NullableStringFieldUpdateOperationsInput | string | null
    eventType?: StringFieldUpdateOperationsInput | string
    payload?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    error?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type WebhookEventCreateManyInput = {
    id?: string
    tenantId?: string | null
    eventType: string
    payload: string
    status?: string
    error?: string | null
    createdAt?: Date | string
    processedAt?: Date | string | null
  }

  export type WebhookEventUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    eventType?: StringFieldUpdateOperationsInput | string
    payload?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    error?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type WebhookEventUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: NullableStringFieldUpdateOperationsInput | string | null
    eventType?: StringFieldUpdateOperationsInput | string
    payload?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    error?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type TahfidzCreateInput = {
    id?: string
    surah: string
    ayat?: string | null
    type?: string
    grade?: string | null
    notes?: string | null
    recordedBy: string
    date?: Date | string
    createdAt?: Date | string
    tenant: TenantCreateNestedOneWithoutTahfidzInput
    santri: SantriCreateNestedOneWithoutTahfidzInput
  }

  export type TahfidzUncheckedCreateInput = {
    id?: string
    tenantId: string
    santriId: string
    surah: string
    ayat?: string | null
    type?: string
    grade?: string | null
    notes?: string | null
    recordedBy: string
    date?: Date | string
    createdAt?: Date | string
  }

  export type TahfidzUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    surah?: StringFieldUpdateOperationsInput | string
    ayat?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    grade?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    recordedBy?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutTahfidzNestedInput
    santri?: SantriUpdateOneRequiredWithoutTahfidzNestedInput
  }

  export type TahfidzUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    santriId?: StringFieldUpdateOperationsInput | string
    surah?: StringFieldUpdateOperationsInput | string
    ayat?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    grade?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    recordedBy?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TahfidzCreateManyInput = {
    id?: string
    tenantId: string
    santriId: string
    surah: string
    ayat?: string | null
    type?: string
    grade?: string | null
    notes?: string | null
    recordedBy: string
    date?: Date | string
    createdAt?: Date | string
  }

  export type TahfidzUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    surah?: StringFieldUpdateOperationsInput | string
    ayat?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    grade?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    recordedBy?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TahfidzUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    santriId?: StringFieldUpdateOperationsInput | string
    surah?: StringFieldUpdateOperationsInput | string
    ayat?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    grade?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    recordedBy?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MutabaahCreateInput = {
    id?: string
    date?: Date | string
    sholatWajib?: boolean
    tahajud?: boolean
    dhuha?: boolean
    puasaSunnah?: boolean
    bacaQuran?: boolean
    notes?: string | null
    recordedBy?: string | null
    createdAt?: Date | string
    tenant: TenantCreateNestedOneWithoutMutabaahInput
    santri: SantriCreateNestedOneWithoutMutabaahInput
  }

  export type MutabaahUncheckedCreateInput = {
    id?: string
    tenantId: string
    santriId: string
    date?: Date | string
    sholatWajib?: boolean
    tahajud?: boolean
    dhuha?: boolean
    puasaSunnah?: boolean
    bacaQuran?: boolean
    notes?: string | null
    recordedBy?: string | null
    createdAt?: Date | string
  }

  export type MutabaahUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    sholatWajib?: BoolFieldUpdateOperationsInput | boolean
    tahajud?: BoolFieldUpdateOperationsInput | boolean
    dhuha?: BoolFieldUpdateOperationsInput | boolean
    puasaSunnah?: BoolFieldUpdateOperationsInput | boolean
    bacaQuran?: BoolFieldUpdateOperationsInput | boolean
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    recordedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutMutabaahNestedInput
    santri?: SantriUpdateOneRequiredWithoutMutabaahNestedInput
  }

  export type MutabaahUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    santriId?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    sholatWajib?: BoolFieldUpdateOperationsInput | boolean
    tahajud?: BoolFieldUpdateOperationsInput | boolean
    dhuha?: BoolFieldUpdateOperationsInput | boolean
    puasaSunnah?: BoolFieldUpdateOperationsInput | boolean
    bacaQuran?: BoolFieldUpdateOperationsInput | boolean
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    recordedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MutabaahCreateManyInput = {
    id?: string
    tenantId: string
    santriId: string
    date?: Date | string
    sholatWajib?: boolean
    tahajud?: boolean
    dhuha?: boolean
    puasaSunnah?: boolean
    bacaQuran?: boolean
    notes?: string | null
    recordedBy?: string | null
    createdAt?: Date | string
  }

  export type MutabaahUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    sholatWajib?: BoolFieldUpdateOperationsInput | boolean
    tahajud?: BoolFieldUpdateOperationsInput | boolean
    dhuha?: BoolFieldUpdateOperationsInput | boolean
    puasaSunnah?: BoolFieldUpdateOperationsInput | boolean
    bacaQuran?: BoolFieldUpdateOperationsInput | boolean
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    recordedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MutabaahUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    santriId?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    sholatWajib?: BoolFieldUpdateOperationsInput | boolean
    tahajud?: BoolFieldUpdateOperationsInput | boolean
    dhuha?: BoolFieldUpdateOperationsInput | boolean
    puasaSunnah?: BoolFieldUpdateOperationsInput | boolean
    bacaQuran?: BoolFieldUpdateOperationsInput | boolean
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    recordedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WalletCreateInput = {
    id?: string
    balance?: number
    pin?: string | null
    isActive?: boolean
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutWalletsInput
    santri: SantriCreateNestedOneWithoutWalletInput
    transactions?: WalletTransactionCreateNestedManyWithoutWalletInput
  }

  export type WalletUncheckedCreateInput = {
    id?: string
    tenantId: string
    santriId: string
    balance?: number
    pin?: string | null
    isActive?: boolean
    updatedAt?: Date | string
    transactions?: WalletTransactionUncheckedCreateNestedManyWithoutWalletInput
  }

  export type WalletUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    balance?: FloatFieldUpdateOperationsInput | number
    pin?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutWalletsNestedInput
    santri?: SantriUpdateOneRequiredWithoutWalletNestedInput
    transactions?: WalletTransactionUpdateManyWithoutWalletNestedInput
  }

  export type WalletUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    santriId?: StringFieldUpdateOperationsInput | string
    balance?: FloatFieldUpdateOperationsInput | number
    pin?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transactions?: WalletTransactionUncheckedUpdateManyWithoutWalletNestedInput
  }

  export type WalletCreateManyInput = {
    id?: string
    tenantId: string
    santriId: string
    balance?: number
    pin?: string | null
    isActive?: boolean
    updatedAt?: Date | string
  }

  export type WalletUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    balance?: FloatFieldUpdateOperationsInput | number
    pin?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WalletUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    santriId?: StringFieldUpdateOperationsInput | string
    balance?: FloatFieldUpdateOperationsInput | number
    pin?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WalletTransactionCreateInput = {
    id?: string
    amount: number
    type: string
    method: string
    description?: string | null
    reference?: string | null
    status?: string
    handledBy?: string | null
    createdAt?: Date | string
    wallet: WalletCreateNestedOneWithoutTransactionsInput
  }

  export type WalletTransactionUncheckedCreateInput = {
    id?: string
    walletId: string
    amount: number
    type: string
    method: string
    description?: string | null
    reference?: string | null
    status?: string
    handledBy?: string | null
    createdAt?: Date | string
  }

  export type WalletTransactionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    method?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    handledBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    wallet?: WalletUpdateOneRequiredWithoutTransactionsNestedInput
  }

  export type WalletTransactionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    walletId?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    method?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    handledBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WalletTransactionCreateManyInput = {
    id?: string
    walletId: string
    amount: number
    type: string
    method: string
    description?: string | null
    reference?: string | null
    status?: string
    handledBy?: string | null
    createdAt?: Date | string
  }

  export type WalletTransactionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    method?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    handledBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WalletTransactionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    walletId?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    method?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    handledBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmployeeCreateInput = {
    id?: string
    userId?: string | null
    nip?: string | null
    name: string
    position: string
    phone?: string | null
    address?: string | null
    joinDate?: Date | string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutEmployeesInput
    payrolls?: PayrollCreateNestedManyWithoutEmployeeInput
  }

  export type EmployeeUncheckedCreateInput = {
    id?: string
    tenantId: string
    userId?: string | null
    nip?: string | null
    name: string
    position: string
    phone?: string | null
    address?: string | null
    joinDate?: Date | string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    payrolls?: PayrollUncheckedCreateNestedManyWithoutEmployeeInput
  }

  export type EmployeeUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    nip?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    position?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    joinDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutEmployeesNestedInput
    payrolls?: PayrollUpdateManyWithoutEmployeeNestedInput
  }

  export type EmployeeUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    nip?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    position?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    joinDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    payrolls?: PayrollUncheckedUpdateManyWithoutEmployeeNestedInput
  }

  export type EmployeeCreateManyInput = {
    id?: string
    tenantId: string
    userId?: string | null
    nip?: string | null
    name: string
    position: string
    phone?: string | null
    address?: string | null
    joinDate?: Date | string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EmployeeUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    nip?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    position?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    joinDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmployeeUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    nip?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    position?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    joinDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PayrollCreateInput = {
    id?: string
    month: number
    year: number
    baseSalary?: number
    allowances?: number
    deductions?: number
    netAmount: number
    status?: string
    paidAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutPayrollsInput
    employee: EmployeeCreateNestedOneWithoutPayrollsInput
  }

  export type PayrollUncheckedCreateInput = {
    id?: string
    tenantId: string
    employeeId: string
    month: number
    year: number
    baseSalary?: number
    allowances?: number
    deductions?: number
    netAmount: number
    status?: string
    paidAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PayrollUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    month?: IntFieldUpdateOperationsInput | number
    year?: IntFieldUpdateOperationsInput | number
    baseSalary?: FloatFieldUpdateOperationsInput | number
    allowances?: FloatFieldUpdateOperationsInput | number
    deductions?: FloatFieldUpdateOperationsInput | number
    netAmount?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutPayrollsNestedInput
    employee?: EmployeeUpdateOneRequiredWithoutPayrollsNestedInput
  }

  export type PayrollUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    employeeId?: StringFieldUpdateOperationsInput | string
    month?: IntFieldUpdateOperationsInput | number
    year?: IntFieldUpdateOperationsInput | number
    baseSalary?: FloatFieldUpdateOperationsInput | number
    allowances?: FloatFieldUpdateOperationsInput | number
    deductions?: FloatFieldUpdateOperationsInput | number
    netAmount?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PayrollCreateManyInput = {
    id?: string
    tenantId: string
    employeeId: string
    month: number
    year: number
    baseSalary?: number
    allowances?: number
    deductions?: number
    netAmount: number
    status?: string
    paidAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PayrollUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    month?: IntFieldUpdateOperationsInput | number
    year?: IntFieldUpdateOperationsInput | number
    baseSalary?: FloatFieldUpdateOperationsInput | number
    allowances?: FloatFieldUpdateOperationsInput | number
    deductions?: FloatFieldUpdateOperationsInput | number
    netAmount?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PayrollUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    employeeId?: StringFieldUpdateOperationsInput | string
    month?: IntFieldUpdateOperationsInput | number
    year?: IntFieldUpdateOperationsInput | number
    baseSalary?: FloatFieldUpdateOperationsInput | number
    allowances?: FloatFieldUpdateOperationsInput | number
    deductions?: FloatFieldUpdateOperationsInput | number
    netAmount?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AcademicScheduleCreateInput = {
    id?: string
    subject: string
    teacherId: string
    kelas: string
    dayOfWeek: number
    startTime: string
    endTime: string
    room?: string | null
    createdAt?: Date | string
    tenant: TenantCreateNestedOneWithoutAcademicSchedsInput
  }

  export type AcademicScheduleUncheckedCreateInput = {
    id?: string
    tenantId: string
    subject: string
    teacherId: string
    kelas: string
    dayOfWeek: number
    startTime: string
    endTime: string
    room?: string | null
    createdAt?: Date | string
  }

  export type AcademicScheduleUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    teacherId?: StringFieldUpdateOperationsInput | string
    kelas?: StringFieldUpdateOperationsInput | string
    dayOfWeek?: IntFieldUpdateOperationsInput | number
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    room?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutAcademicSchedsNestedInput
  }

  export type AcademicScheduleUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    teacherId?: StringFieldUpdateOperationsInput | string
    kelas?: StringFieldUpdateOperationsInput | string
    dayOfWeek?: IntFieldUpdateOperationsInput | number
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    room?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AcademicScheduleCreateManyInput = {
    id?: string
    tenantId: string
    subject: string
    teacherId: string
    kelas: string
    dayOfWeek: number
    startTime: string
    endTime: string
    room?: string | null
    createdAt?: Date | string
  }

  export type AcademicScheduleUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    teacherId?: StringFieldUpdateOperationsInput | string
    kelas?: StringFieldUpdateOperationsInput | string
    dayOfWeek?: IntFieldUpdateOperationsInput | number
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    room?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AcademicScheduleUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    teacherId?: StringFieldUpdateOperationsInput | string
    kelas?: StringFieldUpdateOperationsInput | string
    dayOfWeek?: IntFieldUpdateOperationsInput | number
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    room?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AttendanceCreateInput = {
    id?: string
    scheduleId?: string | null
    date?: Date | string
    status: string
    notes?: string | null
    recordedBy?: string | null
    createdAt?: Date | string
    tenant: TenantCreateNestedOneWithoutAttendancesInput
    santri: SantriCreateNestedOneWithoutAttendancesInput
  }

  export type AttendanceUncheckedCreateInput = {
    id?: string
    tenantId: string
    santriId: string
    scheduleId?: string | null
    date?: Date | string
    status: string
    notes?: string | null
    recordedBy?: string | null
    createdAt?: Date | string
  }

  export type AttendanceUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    scheduleId?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    recordedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutAttendancesNestedInput
    santri?: SantriUpdateOneRequiredWithoutAttendancesNestedInput
  }

  export type AttendanceUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    santriId?: StringFieldUpdateOperationsInput | string
    scheduleId?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    recordedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AttendanceCreateManyInput = {
    id?: string
    tenantId: string
    santriId: string
    scheduleId?: string | null
    date?: Date | string
    status: string
    notes?: string | null
    recordedBy?: string | null
    createdAt?: Date | string
  }

  export type AttendanceUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    scheduleId?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    recordedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AttendanceUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    santriId?: StringFieldUpdateOperationsInput | string
    scheduleId?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    recordedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GradeCreateInput = {
    id?: string
    subject: string
    semester: string
    academicYear: string
    type: string
    score: number
    notes?: string | null
    createdAt?: Date | string
    tenant: TenantCreateNestedOneWithoutGradesInput
    santri: SantriCreateNestedOneWithoutGradesInput
  }

  export type GradeUncheckedCreateInput = {
    id?: string
    tenantId: string
    santriId: string
    subject: string
    semester: string
    academicYear: string
    type: string
    score: number
    notes?: string | null
    createdAt?: Date | string
  }

  export type GradeUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    semester?: StringFieldUpdateOperationsInput | string
    academicYear?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    score?: FloatFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutGradesNestedInput
    santri?: SantriUpdateOneRequiredWithoutGradesNestedInput
  }

  export type GradeUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    santriId?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    semester?: StringFieldUpdateOperationsInput | string
    academicYear?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    score?: FloatFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GradeCreateManyInput = {
    id?: string
    tenantId: string
    santriId: string
    subject: string
    semester: string
    academicYear: string
    type: string
    score: number
    notes?: string | null
    createdAt?: Date | string
  }

  export type GradeUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    semester?: StringFieldUpdateOperationsInput | string
    academicYear?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    score?: FloatFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GradeUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    santriId?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    semester?: StringFieldUpdateOperationsInput | string
    academicYear?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    score?: FloatFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PpdbRegistrationCreateInput = {
    id?: string
    registrationNumber: string
    fullName: string
    gender: string
    dob?: Date | string | null
    previousSchool?: string | null
    pathway?: string
    status?: string
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutPpdbRegistrationsInput
    documents?: PpdbDocumentCreateNestedManyWithoutRegistrationInput
    exams?: PpdbExamCreateNestedManyWithoutRegistrationInput
  }

  export type PpdbRegistrationUncheckedCreateInput = {
    id?: string
    tenantId: string
    registrationNumber: string
    fullName: string
    gender: string
    dob?: Date | string | null
    previousSchool?: string | null
    pathway?: string
    status?: string
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    documents?: PpdbDocumentUncheckedCreateNestedManyWithoutRegistrationInput
    exams?: PpdbExamUncheckedCreateNestedManyWithoutRegistrationInput
  }

  export type PpdbRegistrationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    registrationNumber?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    gender?: StringFieldUpdateOperationsInput | string
    dob?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    previousSchool?: NullableStringFieldUpdateOperationsInput | string | null
    pathway?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutPpdbRegistrationsNestedInput
    documents?: PpdbDocumentUpdateManyWithoutRegistrationNestedInput
    exams?: PpdbExamUpdateManyWithoutRegistrationNestedInput
  }

  export type PpdbRegistrationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    registrationNumber?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    gender?: StringFieldUpdateOperationsInput | string
    dob?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    previousSchool?: NullableStringFieldUpdateOperationsInput | string | null
    pathway?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    documents?: PpdbDocumentUncheckedUpdateManyWithoutRegistrationNestedInput
    exams?: PpdbExamUncheckedUpdateManyWithoutRegistrationNestedInput
  }

  export type PpdbRegistrationCreateManyInput = {
    id?: string
    tenantId: string
    registrationNumber: string
    fullName: string
    gender: string
    dob?: Date | string | null
    previousSchool?: string | null
    pathway?: string
    status?: string
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PpdbRegistrationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    registrationNumber?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    gender?: StringFieldUpdateOperationsInput | string
    dob?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    previousSchool?: NullableStringFieldUpdateOperationsInput | string | null
    pathway?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PpdbRegistrationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    registrationNumber?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    gender?: StringFieldUpdateOperationsInput | string
    dob?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    previousSchool?: NullableStringFieldUpdateOperationsInput | string | null
    pathway?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PpdbDocumentCreateInput = {
    id?: string
    documentType: string
    fileUrl: string
    isVerified?: boolean
    createdAt?: Date | string
    tenant: TenantCreateNestedOneWithoutPpdbDocumentsInput
    registration: PpdbRegistrationCreateNestedOneWithoutDocumentsInput
  }

  export type PpdbDocumentUncheckedCreateInput = {
    id?: string
    tenantId: string
    registrationId: string
    documentType: string
    fileUrl: string
    isVerified?: boolean
    createdAt?: Date | string
  }

  export type PpdbDocumentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    documentType?: StringFieldUpdateOperationsInput | string
    fileUrl?: StringFieldUpdateOperationsInput | string
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutPpdbDocumentsNestedInput
    registration?: PpdbRegistrationUpdateOneRequiredWithoutDocumentsNestedInput
  }

  export type PpdbDocumentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    registrationId?: StringFieldUpdateOperationsInput | string
    documentType?: StringFieldUpdateOperationsInput | string
    fileUrl?: StringFieldUpdateOperationsInput | string
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PpdbDocumentCreateManyInput = {
    id?: string
    tenantId: string
    registrationId: string
    documentType: string
    fileUrl: string
    isVerified?: boolean
    createdAt?: Date | string
  }

  export type PpdbDocumentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    documentType?: StringFieldUpdateOperationsInput | string
    fileUrl?: StringFieldUpdateOperationsInput | string
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PpdbDocumentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    registrationId?: StringFieldUpdateOperationsInput | string
    documentType?: StringFieldUpdateOperationsInput | string
    fileUrl?: StringFieldUpdateOperationsInput | string
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PpdbExamCreateInput = {
    id?: string
    examType: string
    examDate: Date | string
    score?: number | null
    result?: string | null
    interviewer?: string | null
    createdAt?: Date | string
    tenant: TenantCreateNestedOneWithoutPpdbExamsInput
    registration: PpdbRegistrationCreateNestedOneWithoutExamsInput
  }

  export type PpdbExamUncheckedCreateInput = {
    id?: string
    tenantId: string
    registrationId: string
    examType: string
    examDate: Date | string
    score?: number | null
    result?: string | null
    interviewer?: string | null
    createdAt?: Date | string
  }

  export type PpdbExamUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    examType?: StringFieldUpdateOperationsInput | string
    examDate?: DateTimeFieldUpdateOperationsInput | Date | string
    score?: NullableFloatFieldUpdateOperationsInput | number | null
    result?: NullableStringFieldUpdateOperationsInput | string | null
    interviewer?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutPpdbExamsNestedInput
    registration?: PpdbRegistrationUpdateOneRequiredWithoutExamsNestedInput
  }

  export type PpdbExamUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    registrationId?: StringFieldUpdateOperationsInput | string
    examType?: StringFieldUpdateOperationsInput | string
    examDate?: DateTimeFieldUpdateOperationsInput | Date | string
    score?: NullableFloatFieldUpdateOperationsInput | number | null
    result?: NullableStringFieldUpdateOperationsInput | string | null
    interviewer?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PpdbExamCreateManyInput = {
    id?: string
    tenantId: string
    registrationId: string
    examType: string
    examDate: Date | string
    score?: number | null
    result?: string | null
    interviewer?: string | null
    createdAt?: Date | string
  }

  export type PpdbExamUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    examType?: StringFieldUpdateOperationsInput | string
    examDate?: DateTimeFieldUpdateOperationsInput | Date | string
    score?: NullableFloatFieldUpdateOperationsInput | number | null
    result?: NullableStringFieldUpdateOperationsInput | string | null
    interviewer?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PpdbExamUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    registrationId?: StringFieldUpdateOperationsInput | string
    examType?: StringFieldUpdateOperationsInput | string
    examDate?: DateTimeFieldUpdateOperationsInput | Date | string
    score?: NullableFloatFieldUpdateOperationsInput | number | null
    result?: NullableStringFieldUpdateOperationsInput | string | null
    interviewer?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ItemCreateInput = {
    id?: string
    sku: string
    name: string
    description?: string | null
    category: string
    price: number
    costPrice?: number | null
    stock?: number
    minStock?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutInventoryItemsInput
    transactions?: InventoryTransactionCreateNestedManyWithoutItemInput
  }

  export type ItemUncheckedCreateInput = {
    id?: string
    tenantId: string
    sku: string
    name: string
    description?: string | null
    category: string
    price: number
    costPrice?: number | null
    stock?: number
    minStock?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    transactions?: InventoryTransactionUncheckedCreateNestedManyWithoutItemInput
  }

  export type ItemUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    costPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    stock?: IntFieldUpdateOperationsInput | number
    minStock?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutInventoryItemsNestedInput
    transactions?: InventoryTransactionUpdateManyWithoutItemNestedInput
  }

  export type ItemUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    costPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    stock?: IntFieldUpdateOperationsInput | number
    minStock?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transactions?: InventoryTransactionUncheckedUpdateManyWithoutItemNestedInput
  }

  export type ItemCreateManyInput = {
    id?: string
    tenantId: string
    sku: string
    name: string
    description?: string | null
    category: string
    price: number
    costPrice?: number | null
    stock?: number
    minStock?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ItemUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    costPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    stock?: IntFieldUpdateOperationsInput | number
    minStock?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ItemUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    costPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    stock?: IntFieldUpdateOperationsInput | number
    minStock?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InventoryTransactionCreateInput = {
    id?: string
    type: string
    quantity: number
    reference?: string | null
    notes?: string | null
    handledBy?: string | null
    date?: Date | string
    tenant: TenantCreateNestedOneWithoutInventoryTransactionsInput
    item: ItemCreateNestedOneWithoutTransactionsInput
  }

  export type InventoryTransactionUncheckedCreateInput = {
    id?: string
    tenantId: string
    itemId: string
    type: string
    quantity: number
    reference?: string | null
    notes?: string | null
    handledBy?: string | null
    date?: Date | string
  }

  export type InventoryTransactionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    handledBy?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutInventoryTransactionsNestedInput
    item?: ItemUpdateOneRequiredWithoutTransactionsNestedInput
  }

  export type InventoryTransactionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    itemId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    handledBy?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InventoryTransactionCreateManyInput = {
    id?: string
    tenantId: string
    itemId: string
    type: string
    quantity: number
    reference?: string | null
    notes?: string | null
    handledBy?: string | null
    date?: Date | string
  }

  export type InventoryTransactionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    handledBy?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InventoryTransactionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    itemId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    handledBy?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SupplierCreateInput = {
    id?: string
    name: string
    contact?: string | null
    address?: string | null
    email?: string | null
    createdAt?: Date | string
    tenant: TenantCreateNestedOneWithoutSuppliersInput
    purchaseOrders?: PurchaseOrderCreateNestedManyWithoutSupplierInput
  }

  export type SupplierUncheckedCreateInput = {
    id?: string
    tenantId: string
    name: string
    contact?: string | null
    address?: string | null
    email?: string | null
    createdAt?: Date | string
    purchaseOrders?: PurchaseOrderUncheckedCreateNestedManyWithoutSupplierInput
  }

  export type SupplierUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    contact?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutSuppliersNestedInput
    purchaseOrders?: PurchaseOrderUpdateManyWithoutSupplierNestedInput
  }

  export type SupplierUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    contact?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    purchaseOrders?: PurchaseOrderUncheckedUpdateManyWithoutSupplierNestedInput
  }

  export type SupplierCreateManyInput = {
    id?: string
    tenantId: string
    name: string
    contact?: string | null
    address?: string | null
    email?: string | null
    createdAt?: Date | string
  }

  export type SupplierUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    contact?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SupplierUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    contact?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PurchaseOrderCreateInput = {
    id?: string
    poNumber: string
    totalCost: number
    status?: string
    orderDate?: Date | string
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutPurchaseOrdersInput
    supplier: SupplierCreateNestedOneWithoutPurchaseOrdersInput
  }

  export type PurchaseOrderUncheckedCreateInput = {
    id?: string
    tenantId: string
    supplierId: string
    poNumber: string
    totalCost: number
    status?: string
    orderDate?: Date | string
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PurchaseOrderUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    poNumber?: StringFieldUpdateOperationsInput | string
    totalCost?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    orderDate?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutPurchaseOrdersNestedInput
    supplier?: SupplierUpdateOneRequiredWithoutPurchaseOrdersNestedInput
  }

  export type PurchaseOrderUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    supplierId?: StringFieldUpdateOperationsInput | string
    poNumber?: StringFieldUpdateOperationsInput | string
    totalCost?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    orderDate?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PurchaseOrderCreateManyInput = {
    id?: string
    tenantId: string
    supplierId: string
    poNumber: string
    totalCost: number
    status?: string
    orderDate?: Date | string
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PurchaseOrderUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    poNumber?: StringFieldUpdateOperationsInput | string
    totalCost?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    orderDate?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PurchaseOrderUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    supplierId?: StringFieldUpdateOperationsInput | string
    poNumber?: StringFieldUpdateOperationsInput | string
    totalCost?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    orderDate?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BuildingCreateInput = {
    id?: string
    name: string
    description?: string | null
    gender: string
    capacity?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutBuildingsInput
    rooms?: RoomCreateNestedManyWithoutBuildingInput
  }

  export type BuildingUncheckedCreateInput = {
    id?: string
    tenantId: string
    name: string
    description?: string | null
    gender: string
    capacity?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    rooms?: RoomUncheckedCreateNestedManyWithoutBuildingInput
  }

  export type BuildingUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: StringFieldUpdateOperationsInput | string
    capacity?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutBuildingsNestedInput
    rooms?: RoomUpdateManyWithoutBuildingNestedInput
  }

  export type BuildingUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: StringFieldUpdateOperationsInput | string
    capacity?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rooms?: RoomUncheckedUpdateManyWithoutBuildingNestedInput
  }

  export type BuildingCreateManyInput = {
    id?: string
    tenantId: string
    name: string
    description?: string | null
    gender: string
    capacity?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BuildingUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: StringFieldUpdateOperationsInput | string
    capacity?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BuildingUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: StringFieldUpdateOperationsInput | string
    capacity?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RoomCreateInput = {
    id?: string
    name: string
    capacity: number
    picName?: string | null
    createdAt?: Date | string
    tenant: TenantCreateNestedOneWithoutRoomsInput
    building: BuildingCreateNestedOneWithoutRoomsInput
    assignments?: RoomAssignmentCreateNestedManyWithoutRoomInput
    tickets?: MaintenanceTicketCreateNestedManyWithoutRoomInput
  }

  export type RoomUncheckedCreateInput = {
    id?: string
    tenantId: string
    buildingId: string
    name: string
    capacity: number
    picName?: string | null
    createdAt?: Date | string
    assignments?: RoomAssignmentUncheckedCreateNestedManyWithoutRoomInput
    tickets?: MaintenanceTicketUncheckedCreateNestedManyWithoutRoomInput
  }

  export type RoomUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    capacity?: IntFieldUpdateOperationsInput | number
    picName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutRoomsNestedInput
    building?: BuildingUpdateOneRequiredWithoutRoomsNestedInput
    assignments?: RoomAssignmentUpdateManyWithoutRoomNestedInput
    tickets?: MaintenanceTicketUpdateManyWithoutRoomNestedInput
  }

  export type RoomUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    buildingId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    capacity?: IntFieldUpdateOperationsInput | number
    picName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignments?: RoomAssignmentUncheckedUpdateManyWithoutRoomNestedInput
    tickets?: MaintenanceTicketUncheckedUpdateManyWithoutRoomNestedInput
  }

  export type RoomCreateManyInput = {
    id?: string
    tenantId: string
    buildingId: string
    name: string
    capacity: number
    picName?: string | null
    createdAt?: Date | string
  }

  export type RoomUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    capacity?: IntFieldUpdateOperationsInput | number
    picName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RoomUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    buildingId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    capacity?: IntFieldUpdateOperationsInput | number
    picName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RoomAssignmentCreateInput = {
    id?: string
    santriId: string
    startDate?: Date | string
    endDate?: Date | string | null
    status?: string
    tenant: TenantCreateNestedOneWithoutRoomAssignmentsInput
    room: RoomCreateNestedOneWithoutAssignmentsInput
  }

  export type RoomAssignmentUncheckedCreateInput = {
    id?: string
    tenantId: string
    roomId: string
    santriId: string
    startDate?: Date | string
    endDate?: Date | string | null
    status?: string
  }

  export type RoomAssignmentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    santriId?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    tenant?: TenantUpdateOneRequiredWithoutRoomAssignmentsNestedInput
    room?: RoomUpdateOneRequiredWithoutAssignmentsNestedInput
  }

  export type RoomAssignmentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    roomId?: StringFieldUpdateOperationsInput | string
    santriId?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
  }

  export type RoomAssignmentCreateManyInput = {
    id?: string
    tenantId: string
    roomId: string
    santriId: string
    startDate?: Date | string
    endDate?: Date | string | null
    status?: string
  }

  export type RoomAssignmentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    santriId?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
  }

  export type RoomAssignmentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    roomId?: StringFieldUpdateOperationsInput | string
    santriId?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
  }

  export type MaintenanceTicketCreateInput = {
    id?: string
    title: string
    description: string
    priority?: string
    status?: string
    reportedBy: string
    resolvedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutMaintenanceTicketsInput
    room: RoomCreateNestedOneWithoutTicketsInput
  }

  export type MaintenanceTicketUncheckedCreateInput = {
    id?: string
    tenantId: string
    roomId: string
    title: string
    description: string
    priority?: string
    status?: string
    reportedBy: string
    resolvedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MaintenanceTicketUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    reportedBy?: StringFieldUpdateOperationsInput | string
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutMaintenanceTicketsNestedInput
    room?: RoomUpdateOneRequiredWithoutTicketsNestedInput
  }

  export type MaintenanceTicketUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    roomId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    reportedBy?: StringFieldUpdateOperationsInput | string
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MaintenanceTicketCreateManyInput = {
    id?: string
    tenantId: string
    roomId: string
    title: string
    description: string
    priority?: string
    status?: string
    reportedBy: string
    resolvedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MaintenanceTicketUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    reportedBy?: StringFieldUpdateOperationsInput | string
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MaintenanceTicketUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    roomId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    reportedBy?: StringFieldUpdateOperationsInput | string
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type UserListRelationFilter = {
    every?: UserWhereInput
    some?: UserWhereInput
    none?: UserWhereInput
  }

  export type SantriListRelationFilter = {
    every?: SantriWhereInput
    some?: SantriWhereInput
    none?: SantriWhereInput
  }

  export type WaliListRelationFilter = {
    every?: WaliWhereInput
    some?: WaliWhereInput
    none?: WaliWhereInput
  }

  export type IzinListRelationFilter = {
    every?: IzinWhereInput
    some?: IzinWhereInput
    none?: IzinWhereInput
  }

  export type CatatanHarianListRelationFilter = {
    every?: CatatanHarianWhereInput
    some?: CatatanHarianWhereInput
    none?: CatatanHarianWhereInput
  }

  export type PengumumanListRelationFilter = {
    every?: PengumumanWhereInput
    some?: PengumumanWhereInput
    none?: PengumumanWhereInput
  }

  export type InvoiceListRelationFilter = {
    every?: InvoiceWhereInput
    some?: InvoiceWhereInput
    none?: InvoiceWhereInput
  }

  export type PelanggaranListRelationFilter = {
    every?: PelanggaranWhereInput
    some?: PelanggaranWhereInput
    none?: PelanggaranWhereInput
  }

  export type PembinaanListRelationFilter = {
    every?: PembinaanWhereInput
    some?: PembinaanWhereInput
    none?: PembinaanWhereInput
  }

  export type KunjunganListRelationFilter = {
    every?: KunjunganWhereInput
    some?: KunjunganWhereInput
    none?: KunjunganWhereInput
  }

  export type HealthRecordListRelationFilter = {
    every?: HealthRecordWhereInput
    some?: HealthRecordWhereInput
    none?: HealthRecordWhereInput
  }

  export type AuditLogListRelationFilter = {
    every?: AuditLogWhereInput
    some?: AuditLogWhereInput
    none?: AuditLogWhereInput
  }

  export type NotificationListRelationFilter = {
    every?: NotificationWhereInput
    some?: NotificationWhereInput
    none?: NotificationWhereInput
  }

  export type WebhookEventListRelationFilter = {
    every?: WebhookEventWhereInput
    some?: WebhookEventWhereInput
    none?: WebhookEventWhereInput
  }

  export type TahfidzListRelationFilter = {
    every?: TahfidzWhereInput
    some?: TahfidzWhereInput
    none?: TahfidzWhereInput
  }

  export type MutabaahListRelationFilter = {
    every?: MutabaahWhereInput
    some?: MutabaahWhereInput
    none?: MutabaahWhereInput
  }

  export type WalletListRelationFilter = {
    every?: WalletWhereInput
    some?: WalletWhereInput
    none?: WalletWhereInput
  }

  export type EmployeeListRelationFilter = {
    every?: EmployeeWhereInput
    some?: EmployeeWhereInput
    none?: EmployeeWhereInput
  }

  export type PayrollListRelationFilter = {
    every?: PayrollWhereInput
    some?: PayrollWhereInput
    none?: PayrollWhereInput
  }

  export type AcademicScheduleListRelationFilter = {
    every?: AcademicScheduleWhereInput
    some?: AcademicScheduleWhereInput
    none?: AcademicScheduleWhereInput
  }

  export type AttendanceListRelationFilter = {
    every?: AttendanceWhereInput
    some?: AttendanceWhereInput
    none?: AttendanceWhereInput
  }

  export type GradeListRelationFilter = {
    every?: GradeWhereInput
    some?: GradeWhereInput
    none?: GradeWhereInput
  }

  export type PpdbRegistrationListRelationFilter = {
    every?: PpdbRegistrationWhereInput
    some?: PpdbRegistrationWhereInput
    none?: PpdbRegistrationWhereInput
  }

  export type PpdbDocumentListRelationFilter = {
    every?: PpdbDocumentWhereInput
    some?: PpdbDocumentWhereInput
    none?: PpdbDocumentWhereInput
  }

  export type PpdbExamListRelationFilter = {
    every?: PpdbExamWhereInput
    some?: PpdbExamWhereInput
    none?: PpdbExamWhereInput
  }

  export type ItemListRelationFilter = {
    every?: ItemWhereInput
    some?: ItemWhereInput
    none?: ItemWhereInput
  }

  export type InventoryTransactionListRelationFilter = {
    every?: InventoryTransactionWhereInput
    some?: InventoryTransactionWhereInput
    none?: InventoryTransactionWhereInput
  }

  export type SupplierListRelationFilter = {
    every?: SupplierWhereInput
    some?: SupplierWhereInput
    none?: SupplierWhereInput
  }

  export type PurchaseOrderListRelationFilter = {
    every?: PurchaseOrderWhereInput
    some?: PurchaseOrderWhereInput
    none?: PurchaseOrderWhereInput
  }

  export type BuildingListRelationFilter = {
    every?: BuildingWhereInput
    some?: BuildingWhereInput
    none?: BuildingWhereInput
  }

  export type RoomListRelationFilter = {
    every?: RoomWhereInput
    some?: RoomWhereInput
    none?: RoomWhereInput
  }

  export type RoomAssignmentListRelationFilter = {
    every?: RoomAssignmentWhereInput
    some?: RoomAssignmentWhereInput
    none?: RoomAssignmentWhereInput
  }

  export type MaintenanceTicketListRelationFilter = {
    every?: MaintenanceTicketWhereInput
    some?: MaintenanceTicketWhereInput
    none?: MaintenanceTicketWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type UserOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SantriOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type WaliOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type IzinOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CatatanHarianOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PengumumanOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type InvoiceOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PelanggaranOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PembinaanOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type KunjunganOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type HealthRecordOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AuditLogOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type NotificationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type WebhookEventOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TahfidzOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MutabaahOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type WalletOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type EmployeeOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PayrollOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AcademicScheduleOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AttendanceOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type GradeOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PpdbRegistrationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PpdbDocumentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PpdbExamOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ItemOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type InventoryTransactionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SupplierOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PurchaseOrderOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BuildingOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RoomOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RoomAssignmentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MaintenanceTicketOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TenantCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    address?: SortOrder
    phone?: SortOrder
    adminUserId?: SortOrder
    timezone?: SortOrder
    plan?: SortOrder
    billingContact?: SortOrder
    status?: SortOrder
    settings?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TenantMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    address?: SortOrder
    phone?: SortOrder
    adminUserId?: SortOrder
    timezone?: SortOrder
    plan?: SortOrder
    billingContact?: SortOrder
    status?: SortOrder
    settings?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TenantMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    address?: SortOrder
    phone?: SortOrder
    adminUserId?: SortOrder
    timezone?: SortOrder
    plan?: SortOrder
    billingContact?: SortOrder
    status?: SortOrder
    settings?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type TenantNullableRelationFilter = {
    is?: TenantWhereInput | null
    isNot?: TenantWhereInput | null
  }

  export type RefreshTokenListRelationFilter = {
    every?: RefreshTokenWhereInput
    some?: RefreshTokenWhereInput
    none?: RefreshTokenWhereInput
  }

  export type RefreshTokenOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    email?: SortOrder
    passwordHash?: SortOrder
    role?: SortOrder
    name?: SortOrder
    phone?: SortOrder
    isActive?: SortOrder
    lastLogin?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    email?: SortOrder
    passwordHash?: SortOrder
    role?: SortOrder
    name?: SortOrder
    phone?: SortOrder
    isActive?: SortOrder
    lastLogin?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    email?: SortOrder
    passwordHash?: SortOrder
    role?: SortOrder
    name?: SortOrder
    phone?: SortOrder
    isActive?: SortOrder
    lastLogin?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type UserRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type RefreshTokenCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    token?: SortOrder
    expiresAt?: SortOrder
    revoked?: SortOrder
    createdAt?: SortOrder
  }

  export type RefreshTokenMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    token?: SortOrder
    expiresAt?: SortOrder
    revoked?: SortOrder
    createdAt?: SortOrder
  }

  export type RefreshTokenMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    token?: SortOrder
    expiresAt?: SortOrder
    revoked?: SortOrder
    createdAt?: SortOrder
  }

  export type TenantRelationFilter = {
    is?: TenantWhereInput
    isNot?: TenantWhereInput
  }

  export type SantriWaliListRelationFilter = {
    every?: SantriWaliWhereInput
    some?: SantriWaliWhereInput
    none?: SantriWaliWhereInput
  }

  export type MedicationListRelationFilter = {
    every?: MedicationWhereInput
    some?: MedicationWhereInput
    none?: MedicationWhereInput
  }

  export type WalletNullableRelationFilter = {
    is?: WalletWhereInput | null
    isNot?: WalletWhereInput | null
  }

  export type SantriWaliOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MedicationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SantriCountOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    nisn?: SortOrder
    name?: SortOrder
    gender?: SortOrder
    dob?: SortOrder
    kelas?: SortOrder
    room?: SortOrder
    contact?: SortOrder
    address?: SortOrder
    photo?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SantriMaxOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    nisn?: SortOrder
    name?: SortOrder
    gender?: SortOrder
    dob?: SortOrder
    kelas?: SortOrder
    room?: SortOrder
    contact?: SortOrder
    address?: SortOrder
    photo?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SantriMinOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    nisn?: SortOrder
    name?: SortOrder
    gender?: SortOrder
    dob?: SortOrder
    kelas?: SortOrder
    room?: SortOrder
    contact?: SortOrder
    address?: SortOrder
    photo?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type WaliCountOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    name?: SortOrder
    relation?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    address?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type WaliMaxOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    name?: SortOrder
    relation?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    address?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type WaliMinOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    name?: SortOrder
    relation?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    address?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SantriRelationFilter = {
    is?: SantriWhereInput
    isNot?: SantriWhereInput
  }

  export type WaliRelationFilter = {
    is?: WaliWhereInput
    isNot?: WaliWhereInput
  }

  export type SantriWaliSantriIdWaliIdCompoundUniqueInput = {
    santriId: string
    waliId: string
  }

  export type SantriWaliCountOrderByAggregateInput = {
    santriId?: SortOrder
    waliId?: SortOrder
    isPrimary?: SortOrder
  }

  export type SantriWaliMaxOrderByAggregateInput = {
    santriId?: SortOrder
    waliId?: SortOrder
    isPrimary?: SortOrder
  }

  export type SantriWaliMinOrderByAggregateInput = {
    santriId?: SortOrder
    waliId?: SortOrder
    isPrimary?: SortOrder
  }

  export type IzinCountOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    santriId?: SortOrder
    type?: SortOrder
    reason?: SortOrder
    startAt?: SortOrder
    endAt?: SortOrder
    status?: SortOrder
    requestedBy?: SortOrder
    approvedBy?: SortOrder
    approvedAt?: SortOrder
    qrCodeData?: SortOrder
    checkoutAt?: SortOrder
    checkoutBy?: SortOrder
    checkinAt?: SortOrder
    checkinBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type IzinMaxOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    santriId?: SortOrder
    type?: SortOrder
    reason?: SortOrder
    startAt?: SortOrder
    endAt?: SortOrder
    status?: SortOrder
    requestedBy?: SortOrder
    approvedBy?: SortOrder
    approvedAt?: SortOrder
    qrCodeData?: SortOrder
    checkoutAt?: SortOrder
    checkoutBy?: SortOrder
    checkinAt?: SortOrder
    checkinBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type IzinMinOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    santriId?: SortOrder
    type?: SortOrder
    reason?: SortOrder
    startAt?: SortOrder
    endAt?: SortOrder
    status?: SortOrder
    requestedBy?: SortOrder
    approvedBy?: SortOrder
    approvedAt?: SortOrder
    qrCodeData?: SortOrder
    checkoutAt?: SortOrder
    checkoutBy?: SortOrder
    checkinAt?: SortOrder
    checkinBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CatatanHarianCountOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    santriId?: SortOrder
    authorId?: SortOrder
    date?: SortOrder
    content?: SortOrder
    category?: SortOrder
    attachments?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CatatanHarianMaxOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    santriId?: SortOrder
    authorId?: SortOrder
    date?: SortOrder
    content?: SortOrder
    category?: SortOrder
    attachments?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CatatanHarianMinOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    santriId?: SortOrder
    authorId?: SortOrder
    date?: SortOrder
    content?: SortOrder
    category?: SortOrder
    attachments?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PengumumanCountOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    title?: SortOrder
    content?: SortOrder
    audience?: SortOrder
    pinnedUntil?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PengumumanMaxOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    title?: SortOrder
    content?: SortOrder
    audience?: SortOrder
    pinnedUntil?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PengumumanMinOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    title?: SortOrder
    content?: SortOrder
    audience?: SortOrder
    pinnedUntil?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type InvoiceLineListRelationFilter = {
    every?: InvoiceLineWhereInput
    some?: InvoiceLineWhereInput
    none?: InvoiceLineWhereInput
  }

  export type PaymentListRelationFilter = {
    every?: PaymentWhereInput
    some?: PaymentWhereInput
    none?: PaymentWhereInput
  }

  export type InvoiceLineOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PaymentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type InvoiceCountOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    santriId?: SortOrder
    amountDue?: SortOrder
    dueDate?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type InvoiceAvgOrderByAggregateInput = {
    amountDue?: SortOrder
  }

  export type InvoiceMaxOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    santriId?: SortOrder
    amountDue?: SortOrder
    dueDate?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type InvoiceMinOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    santriId?: SortOrder
    amountDue?: SortOrder
    dueDate?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type InvoiceSumOrderByAggregateInput = {
    amountDue?: SortOrder
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type InvoiceRelationFilter = {
    is?: InvoiceWhereInput
    isNot?: InvoiceWhereInput
  }

  export type InvoiceLineCountOrderByAggregateInput = {
    id?: SortOrder
    invoiceId?: SortOrder
    description?: SortOrder
    amount?: SortOrder
    type?: SortOrder
  }

  export type InvoiceLineAvgOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type InvoiceLineMaxOrderByAggregateInput = {
    id?: SortOrder
    invoiceId?: SortOrder
    description?: SortOrder
    amount?: SortOrder
    type?: SortOrder
  }

  export type InvoiceLineMinOrderByAggregateInput = {
    id?: SortOrder
    invoiceId?: SortOrder
    description?: SortOrder
    amount?: SortOrder
    type?: SortOrder
  }

  export type InvoiceLineSumOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type PaymentCountOrderByAggregateInput = {
    id?: SortOrder
    invoiceId?: SortOrder
    method?: SortOrder
    amount?: SortOrder
    status?: SortOrder
    transactionRef?: SortOrder
    paidAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PaymentAvgOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type PaymentMaxOrderByAggregateInput = {
    id?: SortOrder
    invoiceId?: SortOrder
    method?: SortOrder
    amount?: SortOrder
    status?: SortOrder
    transactionRef?: SortOrder
    paidAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PaymentMinOrderByAggregateInput = {
    id?: SortOrder
    invoiceId?: SortOrder
    method?: SortOrder
    amount?: SortOrder
    status?: SortOrder
    transactionRef?: SortOrder
    paidAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PaymentSumOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type PelanggaranCountOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    santriId?: SortOrder
    recordedBy?: SortOrder
    category?: SortOrder
    severity?: SortOrder
    points?: SortOrder
    description?: SortOrder
    date?: SortOrder
    resolved?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PelanggaranAvgOrderByAggregateInput = {
    severity?: SortOrder
    points?: SortOrder
  }

  export type PelanggaranMaxOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    santriId?: SortOrder
    recordedBy?: SortOrder
    category?: SortOrder
    severity?: SortOrder
    points?: SortOrder
    description?: SortOrder
    date?: SortOrder
    resolved?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PelanggaranMinOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    santriId?: SortOrder
    recordedBy?: SortOrder
    category?: SortOrder
    severity?: SortOrder
    points?: SortOrder
    description?: SortOrder
    date?: SortOrder
    resolved?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PelanggaranSumOrderByAggregateInput = {
    severity?: SortOrder
    points?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type PembinaanCountOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    santriId?: SortOrder
    plan?: SortOrder
    targetDate?: SortOrder
    status?: SortOrder
    assignedTo?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PembinaanMaxOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    santriId?: SortOrder
    plan?: SortOrder
    targetDate?: SortOrder
    status?: SortOrder
    assignedTo?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PembinaanMinOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    santriId?: SortOrder
    plan?: SortOrder
    targetDate?: SortOrder
    status?: SortOrder
    assignedTo?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TamuListRelationFilter = {
    every?: TamuWhereInput
    some?: TamuWhereInput
    none?: TamuWhereInput
  }

  export type TamuOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type KunjunganCountOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    santriId?: SortOrder
    scheduledAt?: SortOrder
    slot?: SortOrder
    visitorLimit?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type KunjunganAvgOrderByAggregateInput = {
    visitorLimit?: SortOrder
  }

  export type KunjunganMaxOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    santriId?: SortOrder
    scheduledAt?: SortOrder
    slot?: SortOrder
    visitorLimit?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type KunjunganMinOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    santriId?: SortOrder
    scheduledAt?: SortOrder
    slot?: SortOrder
    visitorLimit?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type KunjunganSumOrderByAggregateInput = {
    visitorLimit?: SortOrder
  }

  export type KunjunganRelationFilter = {
    is?: KunjunganWhereInput
    isNot?: KunjunganWhereInput
  }

  export type TamuCountOrderByAggregateInput = {
    id?: SortOrder
    kunjunganId?: SortOrder
    name?: SortOrder
    phone?: SortOrder
    idNumber?: SortOrder
    checkinAt?: SortOrder
    createdAt?: SortOrder
  }

  export type TamuMaxOrderByAggregateInput = {
    id?: SortOrder
    kunjunganId?: SortOrder
    name?: SortOrder
    phone?: SortOrder
    idNumber?: SortOrder
    checkinAt?: SortOrder
    createdAt?: SortOrder
  }

  export type TamuMinOrderByAggregateInput = {
    id?: SortOrder
    kunjunganId?: SortOrder
    name?: SortOrder
    phone?: SortOrder
    idNumber?: SortOrder
    checkinAt?: SortOrder
    createdAt?: SortOrder
  }

  export type HealthRecordCountOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    santriId?: SortOrder
    recordedBy?: SortOrder
    symptoms?: SortOrder
    diagnosis?: SortOrder
    actionTaken?: SortOrder
    referred?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type HealthRecordMaxOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    santriId?: SortOrder
    recordedBy?: SortOrder
    symptoms?: SortOrder
    diagnosis?: SortOrder
    actionTaken?: SortOrder
    referred?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type HealthRecordMinOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    santriId?: SortOrder
    recordedBy?: SortOrder
    symptoms?: SortOrder
    diagnosis?: SortOrder
    actionTaken?: SortOrder
    referred?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MedicationCountOrderByAggregateInput = {
    id?: SortOrder
    santriId?: SortOrder
    medicineName?: SortOrder
    dose?: SortOrder
    schedule?: SortOrder
    givenBy?: SortOrder
    givenAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MedicationMaxOrderByAggregateInput = {
    id?: SortOrder
    santriId?: SortOrder
    medicineName?: SortOrder
    dose?: SortOrder
    schedule?: SortOrder
    givenBy?: SortOrder
    givenAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MedicationMinOrderByAggregateInput = {
    id?: SortOrder
    santriId?: SortOrder
    medicineName?: SortOrder
    dose?: SortOrder
    schedule?: SortOrder
    givenBy?: SortOrder
    givenAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserNullableRelationFilter = {
    is?: UserWhereInput | null
    isNot?: UserWhereInput | null
  }

  export type AuditLogCountOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    userId?: SortOrder
    action?: SortOrder
    entity?: SortOrder
    entityId?: SortOrder
    oldValue?: SortOrder
    newValue?: SortOrder
    ip?: SortOrder
    createdAt?: SortOrder
  }

  export type AuditLogMaxOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    userId?: SortOrder
    action?: SortOrder
    entity?: SortOrder
    entityId?: SortOrder
    oldValue?: SortOrder
    newValue?: SortOrder
    ip?: SortOrder
    createdAt?: SortOrder
  }

  export type AuditLogMinOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    userId?: SortOrder
    action?: SortOrder
    entity?: SortOrder
    entityId?: SortOrder
    oldValue?: SortOrder
    newValue?: SortOrder
    ip?: SortOrder
    createdAt?: SortOrder
  }

  export type NotificationCountOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    title?: SortOrder
    body?: SortOrder
    read?: SortOrder
    createdAt?: SortOrder
  }

  export type NotificationMaxOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    title?: SortOrder
    body?: SortOrder
    read?: SortOrder
    createdAt?: SortOrder
  }

  export type NotificationMinOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    title?: SortOrder
    body?: SortOrder
    read?: SortOrder
    createdAt?: SortOrder
  }

  export type WebhookEventCountOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    eventType?: SortOrder
    payload?: SortOrder
    status?: SortOrder
    error?: SortOrder
    createdAt?: SortOrder
    processedAt?: SortOrder
  }

  export type WebhookEventMaxOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    eventType?: SortOrder
    payload?: SortOrder
    status?: SortOrder
    error?: SortOrder
    createdAt?: SortOrder
    processedAt?: SortOrder
  }

  export type WebhookEventMinOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    eventType?: SortOrder
    payload?: SortOrder
    status?: SortOrder
    error?: SortOrder
    createdAt?: SortOrder
    processedAt?: SortOrder
  }

  export type TahfidzCountOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    santriId?: SortOrder
    surah?: SortOrder
    ayat?: SortOrder
    type?: SortOrder
    grade?: SortOrder
    notes?: SortOrder
    recordedBy?: SortOrder
    date?: SortOrder
    createdAt?: SortOrder
  }

  export type TahfidzMaxOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    santriId?: SortOrder
    surah?: SortOrder
    ayat?: SortOrder
    type?: SortOrder
    grade?: SortOrder
    notes?: SortOrder
    recordedBy?: SortOrder
    date?: SortOrder
    createdAt?: SortOrder
  }

  export type TahfidzMinOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    santriId?: SortOrder
    surah?: SortOrder
    ayat?: SortOrder
    type?: SortOrder
    grade?: SortOrder
    notes?: SortOrder
    recordedBy?: SortOrder
    date?: SortOrder
    createdAt?: SortOrder
  }

  export type MutabaahCountOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    santriId?: SortOrder
    date?: SortOrder
    sholatWajib?: SortOrder
    tahajud?: SortOrder
    dhuha?: SortOrder
    puasaSunnah?: SortOrder
    bacaQuran?: SortOrder
    notes?: SortOrder
    recordedBy?: SortOrder
    createdAt?: SortOrder
  }

  export type MutabaahMaxOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    santriId?: SortOrder
    date?: SortOrder
    sholatWajib?: SortOrder
    tahajud?: SortOrder
    dhuha?: SortOrder
    puasaSunnah?: SortOrder
    bacaQuran?: SortOrder
    notes?: SortOrder
    recordedBy?: SortOrder
    createdAt?: SortOrder
  }

  export type MutabaahMinOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    santriId?: SortOrder
    date?: SortOrder
    sholatWajib?: SortOrder
    tahajud?: SortOrder
    dhuha?: SortOrder
    puasaSunnah?: SortOrder
    bacaQuran?: SortOrder
    notes?: SortOrder
    recordedBy?: SortOrder
    createdAt?: SortOrder
  }

  export type WalletTransactionListRelationFilter = {
    every?: WalletTransactionWhereInput
    some?: WalletTransactionWhereInput
    none?: WalletTransactionWhereInput
  }

  export type WalletTransactionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type WalletCountOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    santriId?: SortOrder
    balance?: SortOrder
    pin?: SortOrder
    isActive?: SortOrder
    updatedAt?: SortOrder
  }

  export type WalletAvgOrderByAggregateInput = {
    balance?: SortOrder
  }

  export type WalletMaxOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    santriId?: SortOrder
    balance?: SortOrder
    pin?: SortOrder
    isActive?: SortOrder
    updatedAt?: SortOrder
  }

  export type WalletMinOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    santriId?: SortOrder
    balance?: SortOrder
    pin?: SortOrder
    isActive?: SortOrder
    updatedAt?: SortOrder
  }

  export type WalletSumOrderByAggregateInput = {
    balance?: SortOrder
  }

  export type WalletRelationFilter = {
    is?: WalletWhereInput
    isNot?: WalletWhereInput
  }

  export type WalletTransactionCountOrderByAggregateInput = {
    id?: SortOrder
    walletId?: SortOrder
    amount?: SortOrder
    type?: SortOrder
    method?: SortOrder
    description?: SortOrder
    reference?: SortOrder
    status?: SortOrder
    handledBy?: SortOrder
    createdAt?: SortOrder
  }

  export type WalletTransactionAvgOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type WalletTransactionMaxOrderByAggregateInput = {
    id?: SortOrder
    walletId?: SortOrder
    amount?: SortOrder
    type?: SortOrder
    method?: SortOrder
    description?: SortOrder
    reference?: SortOrder
    status?: SortOrder
    handledBy?: SortOrder
    createdAt?: SortOrder
  }

  export type WalletTransactionMinOrderByAggregateInput = {
    id?: SortOrder
    walletId?: SortOrder
    amount?: SortOrder
    type?: SortOrder
    method?: SortOrder
    description?: SortOrder
    reference?: SortOrder
    status?: SortOrder
    handledBy?: SortOrder
    createdAt?: SortOrder
  }

  export type WalletTransactionSumOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type EmployeeCountOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    userId?: SortOrder
    nip?: SortOrder
    name?: SortOrder
    position?: SortOrder
    phone?: SortOrder
    address?: SortOrder
    joinDate?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EmployeeMaxOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    userId?: SortOrder
    nip?: SortOrder
    name?: SortOrder
    position?: SortOrder
    phone?: SortOrder
    address?: SortOrder
    joinDate?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EmployeeMinOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    userId?: SortOrder
    nip?: SortOrder
    name?: SortOrder
    position?: SortOrder
    phone?: SortOrder
    address?: SortOrder
    joinDate?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EmployeeRelationFilter = {
    is?: EmployeeWhereInput
    isNot?: EmployeeWhereInput
  }

  export type PayrollCountOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    employeeId?: SortOrder
    month?: SortOrder
    year?: SortOrder
    baseSalary?: SortOrder
    allowances?: SortOrder
    deductions?: SortOrder
    netAmount?: SortOrder
    status?: SortOrder
    paidAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PayrollAvgOrderByAggregateInput = {
    month?: SortOrder
    year?: SortOrder
    baseSalary?: SortOrder
    allowances?: SortOrder
    deductions?: SortOrder
    netAmount?: SortOrder
  }

  export type PayrollMaxOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    employeeId?: SortOrder
    month?: SortOrder
    year?: SortOrder
    baseSalary?: SortOrder
    allowances?: SortOrder
    deductions?: SortOrder
    netAmount?: SortOrder
    status?: SortOrder
    paidAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PayrollMinOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    employeeId?: SortOrder
    month?: SortOrder
    year?: SortOrder
    baseSalary?: SortOrder
    allowances?: SortOrder
    deductions?: SortOrder
    netAmount?: SortOrder
    status?: SortOrder
    paidAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PayrollSumOrderByAggregateInput = {
    month?: SortOrder
    year?: SortOrder
    baseSalary?: SortOrder
    allowances?: SortOrder
    deductions?: SortOrder
    netAmount?: SortOrder
  }

  export type AcademicScheduleCountOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    subject?: SortOrder
    teacherId?: SortOrder
    kelas?: SortOrder
    dayOfWeek?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    room?: SortOrder
    createdAt?: SortOrder
  }

  export type AcademicScheduleAvgOrderByAggregateInput = {
    dayOfWeek?: SortOrder
  }

  export type AcademicScheduleMaxOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    subject?: SortOrder
    teacherId?: SortOrder
    kelas?: SortOrder
    dayOfWeek?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    room?: SortOrder
    createdAt?: SortOrder
  }

  export type AcademicScheduleMinOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    subject?: SortOrder
    teacherId?: SortOrder
    kelas?: SortOrder
    dayOfWeek?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    room?: SortOrder
    createdAt?: SortOrder
  }

  export type AcademicScheduleSumOrderByAggregateInput = {
    dayOfWeek?: SortOrder
  }

  export type AttendanceCountOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    santriId?: SortOrder
    scheduleId?: SortOrder
    date?: SortOrder
    status?: SortOrder
    notes?: SortOrder
    recordedBy?: SortOrder
    createdAt?: SortOrder
  }

  export type AttendanceMaxOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    santriId?: SortOrder
    scheduleId?: SortOrder
    date?: SortOrder
    status?: SortOrder
    notes?: SortOrder
    recordedBy?: SortOrder
    createdAt?: SortOrder
  }

  export type AttendanceMinOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    santriId?: SortOrder
    scheduleId?: SortOrder
    date?: SortOrder
    status?: SortOrder
    notes?: SortOrder
    recordedBy?: SortOrder
    createdAt?: SortOrder
  }

  export type GradeCountOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    santriId?: SortOrder
    subject?: SortOrder
    semester?: SortOrder
    academicYear?: SortOrder
    type?: SortOrder
    score?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
  }

  export type GradeAvgOrderByAggregateInput = {
    score?: SortOrder
  }

  export type GradeMaxOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    santriId?: SortOrder
    subject?: SortOrder
    semester?: SortOrder
    academicYear?: SortOrder
    type?: SortOrder
    score?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
  }

  export type GradeMinOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    santriId?: SortOrder
    subject?: SortOrder
    semester?: SortOrder
    academicYear?: SortOrder
    type?: SortOrder
    score?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
  }

  export type GradeSumOrderByAggregateInput = {
    score?: SortOrder
  }

  export type PpdbRegistrationCountOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    registrationNumber?: SortOrder
    fullName?: SortOrder
    gender?: SortOrder
    dob?: SortOrder
    previousSchool?: SortOrder
    pathway?: SortOrder
    status?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PpdbRegistrationMaxOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    registrationNumber?: SortOrder
    fullName?: SortOrder
    gender?: SortOrder
    dob?: SortOrder
    previousSchool?: SortOrder
    pathway?: SortOrder
    status?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PpdbRegistrationMinOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    registrationNumber?: SortOrder
    fullName?: SortOrder
    gender?: SortOrder
    dob?: SortOrder
    previousSchool?: SortOrder
    pathway?: SortOrder
    status?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PpdbRegistrationRelationFilter = {
    is?: PpdbRegistrationWhereInput
    isNot?: PpdbRegistrationWhereInput
  }

  export type PpdbDocumentCountOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    registrationId?: SortOrder
    documentType?: SortOrder
    fileUrl?: SortOrder
    isVerified?: SortOrder
    createdAt?: SortOrder
  }

  export type PpdbDocumentMaxOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    registrationId?: SortOrder
    documentType?: SortOrder
    fileUrl?: SortOrder
    isVerified?: SortOrder
    createdAt?: SortOrder
  }

  export type PpdbDocumentMinOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    registrationId?: SortOrder
    documentType?: SortOrder
    fileUrl?: SortOrder
    isVerified?: SortOrder
    createdAt?: SortOrder
  }

  export type FloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type PpdbExamCountOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    registrationId?: SortOrder
    examType?: SortOrder
    examDate?: SortOrder
    score?: SortOrder
    result?: SortOrder
    interviewer?: SortOrder
    createdAt?: SortOrder
  }

  export type PpdbExamAvgOrderByAggregateInput = {
    score?: SortOrder
  }

  export type PpdbExamMaxOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    registrationId?: SortOrder
    examType?: SortOrder
    examDate?: SortOrder
    score?: SortOrder
    result?: SortOrder
    interviewer?: SortOrder
    createdAt?: SortOrder
  }

  export type PpdbExamMinOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    registrationId?: SortOrder
    examType?: SortOrder
    examDate?: SortOrder
    score?: SortOrder
    result?: SortOrder
    interviewer?: SortOrder
    createdAt?: SortOrder
  }

  export type PpdbExamSumOrderByAggregateInput = {
    score?: SortOrder
  }

  export type FloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type ItemCountOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    sku?: SortOrder
    name?: SortOrder
    description?: SortOrder
    category?: SortOrder
    price?: SortOrder
    costPrice?: SortOrder
    stock?: SortOrder
    minStock?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ItemAvgOrderByAggregateInput = {
    price?: SortOrder
    costPrice?: SortOrder
    stock?: SortOrder
    minStock?: SortOrder
  }

  export type ItemMaxOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    sku?: SortOrder
    name?: SortOrder
    description?: SortOrder
    category?: SortOrder
    price?: SortOrder
    costPrice?: SortOrder
    stock?: SortOrder
    minStock?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ItemMinOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    sku?: SortOrder
    name?: SortOrder
    description?: SortOrder
    category?: SortOrder
    price?: SortOrder
    costPrice?: SortOrder
    stock?: SortOrder
    minStock?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ItemSumOrderByAggregateInput = {
    price?: SortOrder
    costPrice?: SortOrder
    stock?: SortOrder
    minStock?: SortOrder
  }

  export type ItemRelationFilter = {
    is?: ItemWhereInput
    isNot?: ItemWhereInput
  }

  export type InventoryTransactionCountOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    itemId?: SortOrder
    type?: SortOrder
    quantity?: SortOrder
    reference?: SortOrder
    notes?: SortOrder
    handledBy?: SortOrder
    date?: SortOrder
  }

  export type InventoryTransactionAvgOrderByAggregateInput = {
    quantity?: SortOrder
  }

  export type InventoryTransactionMaxOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    itemId?: SortOrder
    type?: SortOrder
    quantity?: SortOrder
    reference?: SortOrder
    notes?: SortOrder
    handledBy?: SortOrder
    date?: SortOrder
  }

  export type InventoryTransactionMinOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    itemId?: SortOrder
    type?: SortOrder
    quantity?: SortOrder
    reference?: SortOrder
    notes?: SortOrder
    handledBy?: SortOrder
    date?: SortOrder
  }

  export type InventoryTransactionSumOrderByAggregateInput = {
    quantity?: SortOrder
  }

  export type SupplierCountOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    name?: SortOrder
    contact?: SortOrder
    address?: SortOrder
    email?: SortOrder
    createdAt?: SortOrder
  }

  export type SupplierMaxOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    name?: SortOrder
    contact?: SortOrder
    address?: SortOrder
    email?: SortOrder
    createdAt?: SortOrder
  }

  export type SupplierMinOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    name?: SortOrder
    contact?: SortOrder
    address?: SortOrder
    email?: SortOrder
    createdAt?: SortOrder
  }

  export type SupplierRelationFilter = {
    is?: SupplierWhereInput
    isNot?: SupplierWhereInput
  }

  export type PurchaseOrderCountOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    supplierId?: SortOrder
    poNumber?: SortOrder
    totalCost?: SortOrder
    status?: SortOrder
    orderDate?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PurchaseOrderAvgOrderByAggregateInput = {
    totalCost?: SortOrder
  }

  export type PurchaseOrderMaxOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    supplierId?: SortOrder
    poNumber?: SortOrder
    totalCost?: SortOrder
    status?: SortOrder
    orderDate?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PurchaseOrderMinOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    supplierId?: SortOrder
    poNumber?: SortOrder
    totalCost?: SortOrder
    status?: SortOrder
    orderDate?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PurchaseOrderSumOrderByAggregateInput = {
    totalCost?: SortOrder
  }

  export type BuildingCountOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    gender?: SortOrder
    capacity?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BuildingAvgOrderByAggregateInput = {
    capacity?: SortOrder
  }

  export type BuildingMaxOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    gender?: SortOrder
    capacity?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BuildingMinOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    gender?: SortOrder
    capacity?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BuildingSumOrderByAggregateInput = {
    capacity?: SortOrder
  }

  export type BuildingRelationFilter = {
    is?: BuildingWhereInput
    isNot?: BuildingWhereInput
  }

  export type RoomCountOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    buildingId?: SortOrder
    name?: SortOrder
    capacity?: SortOrder
    picName?: SortOrder
    createdAt?: SortOrder
  }

  export type RoomAvgOrderByAggregateInput = {
    capacity?: SortOrder
  }

  export type RoomMaxOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    buildingId?: SortOrder
    name?: SortOrder
    capacity?: SortOrder
    picName?: SortOrder
    createdAt?: SortOrder
  }

  export type RoomMinOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    buildingId?: SortOrder
    name?: SortOrder
    capacity?: SortOrder
    picName?: SortOrder
    createdAt?: SortOrder
  }

  export type RoomSumOrderByAggregateInput = {
    capacity?: SortOrder
  }

  export type RoomRelationFilter = {
    is?: RoomWhereInput
    isNot?: RoomWhereInput
  }

  export type RoomAssignmentCountOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    roomId?: SortOrder
    santriId?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    status?: SortOrder
  }

  export type RoomAssignmentMaxOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    roomId?: SortOrder
    santriId?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    status?: SortOrder
  }

  export type RoomAssignmentMinOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    roomId?: SortOrder
    santriId?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    status?: SortOrder
  }

  export type MaintenanceTicketCountOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    roomId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    priority?: SortOrder
    status?: SortOrder
    reportedBy?: SortOrder
    resolvedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MaintenanceTicketMaxOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    roomId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    priority?: SortOrder
    status?: SortOrder
    reportedBy?: SortOrder
    resolvedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MaintenanceTicketMinOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    roomId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    priority?: SortOrder
    status?: SortOrder
    reportedBy?: SortOrder
    resolvedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserCreateNestedManyWithoutTenantInput = {
    create?: XOR<UserCreateWithoutTenantInput, UserUncheckedCreateWithoutTenantInput> | UserCreateWithoutTenantInput[] | UserUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: UserCreateOrConnectWithoutTenantInput | UserCreateOrConnectWithoutTenantInput[]
    createMany?: UserCreateManyTenantInputEnvelope
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type SantriCreateNestedManyWithoutTenantInput = {
    create?: XOR<SantriCreateWithoutTenantInput, SantriUncheckedCreateWithoutTenantInput> | SantriCreateWithoutTenantInput[] | SantriUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: SantriCreateOrConnectWithoutTenantInput | SantriCreateOrConnectWithoutTenantInput[]
    createMany?: SantriCreateManyTenantInputEnvelope
    connect?: SantriWhereUniqueInput | SantriWhereUniqueInput[]
  }

  export type WaliCreateNestedManyWithoutTenantInput = {
    create?: XOR<WaliCreateWithoutTenantInput, WaliUncheckedCreateWithoutTenantInput> | WaliCreateWithoutTenantInput[] | WaliUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: WaliCreateOrConnectWithoutTenantInput | WaliCreateOrConnectWithoutTenantInput[]
    createMany?: WaliCreateManyTenantInputEnvelope
    connect?: WaliWhereUniqueInput | WaliWhereUniqueInput[]
  }

  export type IzinCreateNestedManyWithoutTenantInput = {
    create?: XOR<IzinCreateWithoutTenantInput, IzinUncheckedCreateWithoutTenantInput> | IzinCreateWithoutTenantInput[] | IzinUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: IzinCreateOrConnectWithoutTenantInput | IzinCreateOrConnectWithoutTenantInput[]
    createMany?: IzinCreateManyTenantInputEnvelope
    connect?: IzinWhereUniqueInput | IzinWhereUniqueInput[]
  }

  export type CatatanHarianCreateNestedManyWithoutTenantInput = {
    create?: XOR<CatatanHarianCreateWithoutTenantInput, CatatanHarianUncheckedCreateWithoutTenantInput> | CatatanHarianCreateWithoutTenantInput[] | CatatanHarianUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: CatatanHarianCreateOrConnectWithoutTenantInput | CatatanHarianCreateOrConnectWithoutTenantInput[]
    createMany?: CatatanHarianCreateManyTenantInputEnvelope
    connect?: CatatanHarianWhereUniqueInput | CatatanHarianWhereUniqueInput[]
  }

  export type PengumumanCreateNestedManyWithoutTenantInput = {
    create?: XOR<PengumumanCreateWithoutTenantInput, PengumumanUncheckedCreateWithoutTenantInput> | PengumumanCreateWithoutTenantInput[] | PengumumanUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: PengumumanCreateOrConnectWithoutTenantInput | PengumumanCreateOrConnectWithoutTenantInput[]
    createMany?: PengumumanCreateManyTenantInputEnvelope
    connect?: PengumumanWhereUniqueInput | PengumumanWhereUniqueInput[]
  }

  export type InvoiceCreateNestedManyWithoutTenantInput = {
    create?: XOR<InvoiceCreateWithoutTenantInput, InvoiceUncheckedCreateWithoutTenantInput> | InvoiceCreateWithoutTenantInput[] | InvoiceUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: InvoiceCreateOrConnectWithoutTenantInput | InvoiceCreateOrConnectWithoutTenantInput[]
    createMany?: InvoiceCreateManyTenantInputEnvelope
    connect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
  }

  export type PelanggaranCreateNestedManyWithoutTenantInput = {
    create?: XOR<PelanggaranCreateWithoutTenantInput, PelanggaranUncheckedCreateWithoutTenantInput> | PelanggaranCreateWithoutTenantInput[] | PelanggaranUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: PelanggaranCreateOrConnectWithoutTenantInput | PelanggaranCreateOrConnectWithoutTenantInput[]
    createMany?: PelanggaranCreateManyTenantInputEnvelope
    connect?: PelanggaranWhereUniqueInput | PelanggaranWhereUniqueInput[]
  }

  export type PembinaanCreateNestedManyWithoutTenantInput = {
    create?: XOR<PembinaanCreateWithoutTenantInput, PembinaanUncheckedCreateWithoutTenantInput> | PembinaanCreateWithoutTenantInput[] | PembinaanUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: PembinaanCreateOrConnectWithoutTenantInput | PembinaanCreateOrConnectWithoutTenantInput[]
    createMany?: PembinaanCreateManyTenantInputEnvelope
    connect?: PembinaanWhereUniqueInput | PembinaanWhereUniqueInput[]
  }

  export type KunjunganCreateNestedManyWithoutTenantInput = {
    create?: XOR<KunjunganCreateWithoutTenantInput, KunjunganUncheckedCreateWithoutTenantInput> | KunjunganCreateWithoutTenantInput[] | KunjunganUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: KunjunganCreateOrConnectWithoutTenantInput | KunjunganCreateOrConnectWithoutTenantInput[]
    createMany?: KunjunganCreateManyTenantInputEnvelope
    connect?: KunjunganWhereUniqueInput | KunjunganWhereUniqueInput[]
  }

  export type HealthRecordCreateNestedManyWithoutTenantInput = {
    create?: XOR<HealthRecordCreateWithoutTenantInput, HealthRecordUncheckedCreateWithoutTenantInput> | HealthRecordCreateWithoutTenantInput[] | HealthRecordUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: HealthRecordCreateOrConnectWithoutTenantInput | HealthRecordCreateOrConnectWithoutTenantInput[]
    createMany?: HealthRecordCreateManyTenantInputEnvelope
    connect?: HealthRecordWhereUniqueInput | HealthRecordWhereUniqueInput[]
  }

  export type AuditLogCreateNestedManyWithoutTenantInput = {
    create?: XOR<AuditLogCreateWithoutTenantInput, AuditLogUncheckedCreateWithoutTenantInput> | AuditLogCreateWithoutTenantInput[] | AuditLogUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutTenantInput | AuditLogCreateOrConnectWithoutTenantInput[]
    createMany?: AuditLogCreateManyTenantInputEnvelope
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
  }

  export type NotificationCreateNestedManyWithoutTenantInput = {
    create?: XOR<NotificationCreateWithoutTenantInput, NotificationUncheckedCreateWithoutTenantInput> | NotificationCreateWithoutTenantInput[] | NotificationUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutTenantInput | NotificationCreateOrConnectWithoutTenantInput[]
    createMany?: NotificationCreateManyTenantInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type WebhookEventCreateNestedManyWithoutTenantInput = {
    create?: XOR<WebhookEventCreateWithoutTenantInput, WebhookEventUncheckedCreateWithoutTenantInput> | WebhookEventCreateWithoutTenantInput[] | WebhookEventUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: WebhookEventCreateOrConnectWithoutTenantInput | WebhookEventCreateOrConnectWithoutTenantInput[]
    createMany?: WebhookEventCreateManyTenantInputEnvelope
    connect?: WebhookEventWhereUniqueInput | WebhookEventWhereUniqueInput[]
  }

  export type TahfidzCreateNestedManyWithoutTenantInput = {
    create?: XOR<TahfidzCreateWithoutTenantInput, TahfidzUncheckedCreateWithoutTenantInput> | TahfidzCreateWithoutTenantInput[] | TahfidzUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: TahfidzCreateOrConnectWithoutTenantInput | TahfidzCreateOrConnectWithoutTenantInput[]
    createMany?: TahfidzCreateManyTenantInputEnvelope
    connect?: TahfidzWhereUniqueInput | TahfidzWhereUniqueInput[]
  }

  export type MutabaahCreateNestedManyWithoutTenantInput = {
    create?: XOR<MutabaahCreateWithoutTenantInput, MutabaahUncheckedCreateWithoutTenantInput> | MutabaahCreateWithoutTenantInput[] | MutabaahUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: MutabaahCreateOrConnectWithoutTenantInput | MutabaahCreateOrConnectWithoutTenantInput[]
    createMany?: MutabaahCreateManyTenantInputEnvelope
    connect?: MutabaahWhereUniqueInput | MutabaahWhereUniqueInput[]
  }

  export type WalletCreateNestedManyWithoutTenantInput = {
    create?: XOR<WalletCreateWithoutTenantInput, WalletUncheckedCreateWithoutTenantInput> | WalletCreateWithoutTenantInput[] | WalletUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: WalletCreateOrConnectWithoutTenantInput | WalletCreateOrConnectWithoutTenantInput[]
    createMany?: WalletCreateManyTenantInputEnvelope
    connect?: WalletWhereUniqueInput | WalletWhereUniqueInput[]
  }

  export type EmployeeCreateNestedManyWithoutTenantInput = {
    create?: XOR<EmployeeCreateWithoutTenantInput, EmployeeUncheckedCreateWithoutTenantInput> | EmployeeCreateWithoutTenantInput[] | EmployeeUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: EmployeeCreateOrConnectWithoutTenantInput | EmployeeCreateOrConnectWithoutTenantInput[]
    createMany?: EmployeeCreateManyTenantInputEnvelope
    connect?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
  }

  export type PayrollCreateNestedManyWithoutTenantInput = {
    create?: XOR<PayrollCreateWithoutTenantInput, PayrollUncheckedCreateWithoutTenantInput> | PayrollCreateWithoutTenantInput[] | PayrollUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: PayrollCreateOrConnectWithoutTenantInput | PayrollCreateOrConnectWithoutTenantInput[]
    createMany?: PayrollCreateManyTenantInputEnvelope
    connect?: PayrollWhereUniqueInput | PayrollWhereUniqueInput[]
  }

  export type AcademicScheduleCreateNestedManyWithoutTenantInput = {
    create?: XOR<AcademicScheduleCreateWithoutTenantInput, AcademicScheduleUncheckedCreateWithoutTenantInput> | AcademicScheduleCreateWithoutTenantInput[] | AcademicScheduleUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: AcademicScheduleCreateOrConnectWithoutTenantInput | AcademicScheduleCreateOrConnectWithoutTenantInput[]
    createMany?: AcademicScheduleCreateManyTenantInputEnvelope
    connect?: AcademicScheduleWhereUniqueInput | AcademicScheduleWhereUniqueInput[]
  }

  export type AttendanceCreateNestedManyWithoutTenantInput = {
    create?: XOR<AttendanceCreateWithoutTenantInput, AttendanceUncheckedCreateWithoutTenantInput> | AttendanceCreateWithoutTenantInput[] | AttendanceUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: AttendanceCreateOrConnectWithoutTenantInput | AttendanceCreateOrConnectWithoutTenantInput[]
    createMany?: AttendanceCreateManyTenantInputEnvelope
    connect?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
  }

  export type GradeCreateNestedManyWithoutTenantInput = {
    create?: XOR<GradeCreateWithoutTenantInput, GradeUncheckedCreateWithoutTenantInput> | GradeCreateWithoutTenantInput[] | GradeUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: GradeCreateOrConnectWithoutTenantInput | GradeCreateOrConnectWithoutTenantInput[]
    createMany?: GradeCreateManyTenantInputEnvelope
    connect?: GradeWhereUniqueInput | GradeWhereUniqueInput[]
  }

  export type PpdbRegistrationCreateNestedManyWithoutTenantInput = {
    create?: XOR<PpdbRegistrationCreateWithoutTenantInput, PpdbRegistrationUncheckedCreateWithoutTenantInput> | PpdbRegistrationCreateWithoutTenantInput[] | PpdbRegistrationUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: PpdbRegistrationCreateOrConnectWithoutTenantInput | PpdbRegistrationCreateOrConnectWithoutTenantInput[]
    createMany?: PpdbRegistrationCreateManyTenantInputEnvelope
    connect?: PpdbRegistrationWhereUniqueInput | PpdbRegistrationWhereUniqueInput[]
  }

  export type PpdbDocumentCreateNestedManyWithoutTenantInput = {
    create?: XOR<PpdbDocumentCreateWithoutTenantInput, PpdbDocumentUncheckedCreateWithoutTenantInput> | PpdbDocumentCreateWithoutTenantInput[] | PpdbDocumentUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: PpdbDocumentCreateOrConnectWithoutTenantInput | PpdbDocumentCreateOrConnectWithoutTenantInput[]
    createMany?: PpdbDocumentCreateManyTenantInputEnvelope
    connect?: PpdbDocumentWhereUniqueInput | PpdbDocumentWhereUniqueInput[]
  }

  export type PpdbExamCreateNestedManyWithoutTenantInput = {
    create?: XOR<PpdbExamCreateWithoutTenantInput, PpdbExamUncheckedCreateWithoutTenantInput> | PpdbExamCreateWithoutTenantInput[] | PpdbExamUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: PpdbExamCreateOrConnectWithoutTenantInput | PpdbExamCreateOrConnectWithoutTenantInput[]
    createMany?: PpdbExamCreateManyTenantInputEnvelope
    connect?: PpdbExamWhereUniqueInput | PpdbExamWhereUniqueInput[]
  }

  export type ItemCreateNestedManyWithoutTenantInput = {
    create?: XOR<ItemCreateWithoutTenantInput, ItemUncheckedCreateWithoutTenantInput> | ItemCreateWithoutTenantInput[] | ItemUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: ItemCreateOrConnectWithoutTenantInput | ItemCreateOrConnectWithoutTenantInput[]
    createMany?: ItemCreateManyTenantInputEnvelope
    connect?: ItemWhereUniqueInput | ItemWhereUniqueInput[]
  }

  export type InventoryTransactionCreateNestedManyWithoutTenantInput = {
    create?: XOR<InventoryTransactionCreateWithoutTenantInput, InventoryTransactionUncheckedCreateWithoutTenantInput> | InventoryTransactionCreateWithoutTenantInput[] | InventoryTransactionUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: InventoryTransactionCreateOrConnectWithoutTenantInput | InventoryTransactionCreateOrConnectWithoutTenantInput[]
    createMany?: InventoryTransactionCreateManyTenantInputEnvelope
    connect?: InventoryTransactionWhereUniqueInput | InventoryTransactionWhereUniqueInput[]
  }

  export type SupplierCreateNestedManyWithoutTenantInput = {
    create?: XOR<SupplierCreateWithoutTenantInput, SupplierUncheckedCreateWithoutTenantInput> | SupplierCreateWithoutTenantInput[] | SupplierUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: SupplierCreateOrConnectWithoutTenantInput | SupplierCreateOrConnectWithoutTenantInput[]
    createMany?: SupplierCreateManyTenantInputEnvelope
    connect?: SupplierWhereUniqueInput | SupplierWhereUniqueInput[]
  }

  export type PurchaseOrderCreateNestedManyWithoutTenantInput = {
    create?: XOR<PurchaseOrderCreateWithoutTenantInput, PurchaseOrderUncheckedCreateWithoutTenantInput> | PurchaseOrderCreateWithoutTenantInput[] | PurchaseOrderUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: PurchaseOrderCreateOrConnectWithoutTenantInput | PurchaseOrderCreateOrConnectWithoutTenantInput[]
    createMany?: PurchaseOrderCreateManyTenantInputEnvelope
    connect?: PurchaseOrderWhereUniqueInput | PurchaseOrderWhereUniqueInput[]
  }

  export type BuildingCreateNestedManyWithoutTenantInput = {
    create?: XOR<BuildingCreateWithoutTenantInput, BuildingUncheckedCreateWithoutTenantInput> | BuildingCreateWithoutTenantInput[] | BuildingUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: BuildingCreateOrConnectWithoutTenantInput | BuildingCreateOrConnectWithoutTenantInput[]
    createMany?: BuildingCreateManyTenantInputEnvelope
    connect?: BuildingWhereUniqueInput | BuildingWhereUniqueInput[]
  }

  export type RoomCreateNestedManyWithoutTenantInput = {
    create?: XOR<RoomCreateWithoutTenantInput, RoomUncheckedCreateWithoutTenantInput> | RoomCreateWithoutTenantInput[] | RoomUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: RoomCreateOrConnectWithoutTenantInput | RoomCreateOrConnectWithoutTenantInput[]
    createMany?: RoomCreateManyTenantInputEnvelope
    connect?: RoomWhereUniqueInput | RoomWhereUniqueInput[]
  }

  export type RoomAssignmentCreateNestedManyWithoutTenantInput = {
    create?: XOR<RoomAssignmentCreateWithoutTenantInput, RoomAssignmentUncheckedCreateWithoutTenantInput> | RoomAssignmentCreateWithoutTenantInput[] | RoomAssignmentUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: RoomAssignmentCreateOrConnectWithoutTenantInput | RoomAssignmentCreateOrConnectWithoutTenantInput[]
    createMany?: RoomAssignmentCreateManyTenantInputEnvelope
    connect?: RoomAssignmentWhereUniqueInput | RoomAssignmentWhereUniqueInput[]
  }

  export type MaintenanceTicketCreateNestedManyWithoutTenantInput = {
    create?: XOR<MaintenanceTicketCreateWithoutTenantInput, MaintenanceTicketUncheckedCreateWithoutTenantInput> | MaintenanceTicketCreateWithoutTenantInput[] | MaintenanceTicketUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: MaintenanceTicketCreateOrConnectWithoutTenantInput | MaintenanceTicketCreateOrConnectWithoutTenantInput[]
    createMany?: MaintenanceTicketCreateManyTenantInputEnvelope
    connect?: MaintenanceTicketWhereUniqueInput | MaintenanceTicketWhereUniqueInput[]
  }

  export type UserUncheckedCreateNestedManyWithoutTenantInput = {
    create?: XOR<UserCreateWithoutTenantInput, UserUncheckedCreateWithoutTenantInput> | UserCreateWithoutTenantInput[] | UserUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: UserCreateOrConnectWithoutTenantInput | UserCreateOrConnectWithoutTenantInput[]
    createMany?: UserCreateManyTenantInputEnvelope
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type SantriUncheckedCreateNestedManyWithoutTenantInput = {
    create?: XOR<SantriCreateWithoutTenantInput, SantriUncheckedCreateWithoutTenantInput> | SantriCreateWithoutTenantInput[] | SantriUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: SantriCreateOrConnectWithoutTenantInput | SantriCreateOrConnectWithoutTenantInput[]
    createMany?: SantriCreateManyTenantInputEnvelope
    connect?: SantriWhereUniqueInput | SantriWhereUniqueInput[]
  }

  export type WaliUncheckedCreateNestedManyWithoutTenantInput = {
    create?: XOR<WaliCreateWithoutTenantInput, WaliUncheckedCreateWithoutTenantInput> | WaliCreateWithoutTenantInput[] | WaliUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: WaliCreateOrConnectWithoutTenantInput | WaliCreateOrConnectWithoutTenantInput[]
    createMany?: WaliCreateManyTenantInputEnvelope
    connect?: WaliWhereUniqueInput | WaliWhereUniqueInput[]
  }

  export type IzinUncheckedCreateNestedManyWithoutTenantInput = {
    create?: XOR<IzinCreateWithoutTenantInput, IzinUncheckedCreateWithoutTenantInput> | IzinCreateWithoutTenantInput[] | IzinUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: IzinCreateOrConnectWithoutTenantInput | IzinCreateOrConnectWithoutTenantInput[]
    createMany?: IzinCreateManyTenantInputEnvelope
    connect?: IzinWhereUniqueInput | IzinWhereUniqueInput[]
  }

  export type CatatanHarianUncheckedCreateNestedManyWithoutTenantInput = {
    create?: XOR<CatatanHarianCreateWithoutTenantInput, CatatanHarianUncheckedCreateWithoutTenantInput> | CatatanHarianCreateWithoutTenantInput[] | CatatanHarianUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: CatatanHarianCreateOrConnectWithoutTenantInput | CatatanHarianCreateOrConnectWithoutTenantInput[]
    createMany?: CatatanHarianCreateManyTenantInputEnvelope
    connect?: CatatanHarianWhereUniqueInput | CatatanHarianWhereUniqueInput[]
  }

  export type PengumumanUncheckedCreateNestedManyWithoutTenantInput = {
    create?: XOR<PengumumanCreateWithoutTenantInput, PengumumanUncheckedCreateWithoutTenantInput> | PengumumanCreateWithoutTenantInput[] | PengumumanUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: PengumumanCreateOrConnectWithoutTenantInput | PengumumanCreateOrConnectWithoutTenantInput[]
    createMany?: PengumumanCreateManyTenantInputEnvelope
    connect?: PengumumanWhereUniqueInput | PengumumanWhereUniqueInput[]
  }

  export type InvoiceUncheckedCreateNestedManyWithoutTenantInput = {
    create?: XOR<InvoiceCreateWithoutTenantInput, InvoiceUncheckedCreateWithoutTenantInput> | InvoiceCreateWithoutTenantInput[] | InvoiceUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: InvoiceCreateOrConnectWithoutTenantInput | InvoiceCreateOrConnectWithoutTenantInput[]
    createMany?: InvoiceCreateManyTenantInputEnvelope
    connect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
  }

  export type PelanggaranUncheckedCreateNestedManyWithoutTenantInput = {
    create?: XOR<PelanggaranCreateWithoutTenantInput, PelanggaranUncheckedCreateWithoutTenantInput> | PelanggaranCreateWithoutTenantInput[] | PelanggaranUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: PelanggaranCreateOrConnectWithoutTenantInput | PelanggaranCreateOrConnectWithoutTenantInput[]
    createMany?: PelanggaranCreateManyTenantInputEnvelope
    connect?: PelanggaranWhereUniqueInput | PelanggaranWhereUniqueInput[]
  }

  export type PembinaanUncheckedCreateNestedManyWithoutTenantInput = {
    create?: XOR<PembinaanCreateWithoutTenantInput, PembinaanUncheckedCreateWithoutTenantInput> | PembinaanCreateWithoutTenantInput[] | PembinaanUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: PembinaanCreateOrConnectWithoutTenantInput | PembinaanCreateOrConnectWithoutTenantInput[]
    createMany?: PembinaanCreateManyTenantInputEnvelope
    connect?: PembinaanWhereUniqueInput | PembinaanWhereUniqueInput[]
  }

  export type KunjunganUncheckedCreateNestedManyWithoutTenantInput = {
    create?: XOR<KunjunganCreateWithoutTenantInput, KunjunganUncheckedCreateWithoutTenantInput> | KunjunganCreateWithoutTenantInput[] | KunjunganUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: KunjunganCreateOrConnectWithoutTenantInput | KunjunganCreateOrConnectWithoutTenantInput[]
    createMany?: KunjunganCreateManyTenantInputEnvelope
    connect?: KunjunganWhereUniqueInput | KunjunganWhereUniqueInput[]
  }

  export type HealthRecordUncheckedCreateNestedManyWithoutTenantInput = {
    create?: XOR<HealthRecordCreateWithoutTenantInput, HealthRecordUncheckedCreateWithoutTenantInput> | HealthRecordCreateWithoutTenantInput[] | HealthRecordUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: HealthRecordCreateOrConnectWithoutTenantInput | HealthRecordCreateOrConnectWithoutTenantInput[]
    createMany?: HealthRecordCreateManyTenantInputEnvelope
    connect?: HealthRecordWhereUniqueInput | HealthRecordWhereUniqueInput[]
  }

  export type AuditLogUncheckedCreateNestedManyWithoutTenantInput = {
    create?: XOR<AuditLogCreateWithoutTenantInput, AuditLogUncheckedCreateWithoutTenantInput> | AuditLogCreateWithoutTenantInput[] | AuditLogUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutTenantInput | AuditLogCreateOrConnectWithoutTenantInput[]
    createMany?: AuditLogCreateManyTenantInputEnvelope
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
  }

  export type NotificationUncheckedCreateNestedManyWithoutTenantInput = {
    create?: XOR<NotificationCreateWithoutTenantInput, NotificationUncheckedCreateWithoutTenantInput> | NotificationCreateWithoutTenantInput[] | NotificationUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutTenantInput | NotificationCreateOrConnectWithoutTenantInput[]
    createMany?: NotificationCreateManyTenantInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type WebhookEventUncheckedCreateNestedManyWithoutTenantInput = {
    create?: XOR<WebhookEventCreateWithoutTenantInput, WebhookEventUncheckedCreateWithoutTenantInput> | WebhookEventCreateWithoutTenantInput[] | WebhookEventUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: WebhookEventCreateOrConnectWithoutTenantInput | WebhookEventCreateOrConnectWithoutTenantInput[]
    createMany?: WebhookEventCreateManyTenantInputEnvelope
    connect?: WebhookEventWhereUniqueInput | WebhookEventWhereUniqueInput[]
  }

  export type TahfidzUncheckedCreateNestedManyWithoutTenantInput = {
    create?: XOR<TahfidzCreateWithoutTenantInput, TahfidzUncheckedCreateWithoutTenantInput> | TahfidzCreateWithoutTenantInput[] | TahfidzUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: TahfidzCreateOrConnectWithoutTenantInput | TahfidzCreateOrConnectWithoutTenantInput[]
    createMany?: TahfidzCreateManyTenantInputEnvelope
    connect?: TahfidzWhereUniqueInput | TahfidzWhereUniqueInput[]
  }

  export type MutabaahUncheckedCreateNestedManyWithoutTenantInput = {
    create?: XOR<MutabaahCreateWithoutTenantInput, MutabaahUncheckedCreateWithoutTenantInput> | MutabaahCreateWithoutTenantInput[] | MutabaahUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: MutabaahCreateOrConnectWithoutTenantInput | MutabaahCreateOrConnectWithoutTenantInput[]
    createMany?: MutabaahCreateManyTenantInputEnvelope
    connect?: MutabaahWhereUniqueInput | MutabaahWhereUniqueInput[]
  }

  export type WalletUncheckedCreateNestedManyWithoutTenantInput = {
    create?: XOR<WalletCreateWithoutTenantInput, WalletUncheckedCreateWithoutTenantInput> | WalletCreateWithoutTenantInput[] | WalletUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: WalletCreateOrConnectWithoutTenantInput | WalletCreateOrConnectWithoutTenantInput[]
    createMany?: WalletCreateManyTenantInputEnvelope
    connect?: WalletWhereUniqueInput | WalletWhereUniqueInput[]
  }

  export type EmployeeUncheckedCreateNestedManyWithoutTenantInput = {
    create?: XOR<EmployeeCreateWithoutTenantInput, EmployeeUncheckedCreateWithoutTenantInput> | EmployeeCreateWithoutTenantInput[] | EmployeeUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: EmployeeCreateOrConnectWithoutTenantInput | EmployeeCreateOrConnectWithoutTenantInput[]
    createMany?: EmployeeCreateManyTenantInputEnvelope
    connect?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
  }

  export type PayrollUncheckedCreateNestedManyWithoutTenantInput = {
    create?: XOR<PayrollCreateWithoutTenantInput, PayrollUncheckedCreateWithoutTenantInput> | PayrollCreateWithoutTenantInput[] | PayrollUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: PayrollCreateOrConnectWithoutTenantInput | PayrollCreateOrConnectWithoutTenantInput[]
    createMany?: PayrollCreateManyTenantInputEnvelope
    connect?: PayrollWhereUniqueInput | PayrollWhereUniqueInput[]
  }

  export type AcademicScheduleUncheckedCreateNestedManyWithoutTenantInput = {
    create?: XOR<AcademicScheduleCreateWithoutTenantInput, AcademicScheduleUncheckedCreateWithoutTenantInput> | AcademicScheduleCreateWithoutTenantInput[] | AcademicScheduleUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: AcademicScheduleCreateOrConnectWithoutTenantInput | AcademicScheduleCreateOrConnectWithoutTenantInput[]
    createMany?: AcademicScheduleCreateManyTenantInputEnvelope
    connect?: AcademicScheduleWhereUniqueInput | AcademicScheduleWhereUniqueInput[]
  }

  export type AttendanceUncheckedCreateNestedManyWithoutTenantInput = {
    create?: XOR<AttendanceCreateWithoutTenantInput, AttendanceUncheckedCreateWithoutTenantInput> | AttendanceCreateWithoutTenantInput[] | AttendanceUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: AttendanceCreateOrConnectWithoutTenantInput | AttendanceCreateOrConnectWithoutTenantInput[]
    createMany?: AttendanceCreateManyTenantInputEnvelope
    connect?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
  }

  export type GradeUncheckedCreateNestedManyWithoutTenantInput = {
    create?: XOR<GradeCreateWithoutTenantInput, GradeUncheckedCreateWithoutTenantInput> | GradeCreateWithoutTenantInput[] | GradeUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: GradeCreateOrConnectWithoutTenantInput | GradeCreateOrConnectWithoutTenantInput[]
    createMany?: GradeCreateManyTenantInputEnvelope
    connect?: GradeWhereUniqueInput | GradeWhereUniqueInput[]
  }

  export type PpdbRegistrationUncheckedCreateNestedManyWithoutTenantInput = {
    create?: XOR<PpdbRegistrationCreateWithoutTenantInput, PpdbRegistrationUncheckedCreateWithoutTenantInput> | PpdbRegistrationCreateWithoutTenantInput[] | PpdbRegistrationUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: PpdbRegistrationCreateOrConnectWithoutTenantInput | PpdbRegistrationCreateOrConnectWithoutTenantInput[]
    createMany?: PpdbRegistrationCreateManyTenantInputEnvelope
    connect?: PpdbRegistrationWhereUniqueInput | PpdbRegistrationWhereUniqueInput[]
  }

  export type PpdbDocumentUncheckedCreateNestedManyWithoutTenantInput = {
    create?: XOR<PpdbDocumentCreateWithoutTenantInput, PpdbDocumentUncheckedCreateWithoutTenantInput> | PpdbDocumentCreateWithoutTenantInput[] | PpdbDocumentUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: PpdbDocumentCreateOrConnectWithoutTenantInput | PpdbDocumentCreateOrConnectWithoutTenantInput[]
    createMany?: PpdbDocumentCreateManyTenantInputEnvelope
    connect?: PpdbDocumentWhereUniqueInput | PpdbDocumentWhereUniqueInput[]
  }

  export type PpdbExamUncheckedCreateNestedManyWithoutTenantInput = {
    create?: XOR<PpdbExamCreateWithoutTenantInput, PpdbExamUncheckedCreateWithoutTenantInput> | PpdbExamCreateWithoutTenantInput[] | PpdbExamUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: PpdbExamCreateOrConnectWithoutTenantInput | PpdbExamCreateOrConnectWithoutTenantInput[]
    createMany?: PpdbExamCreateManyTenantInputEnvelope
    connect?: PpdbExamWhereUniqueInput | PpdbExamWhereUniqueInput[]
  }

  export type ItemUncheckedCreateNestedManyWithoutTenantInput = {
    create?: XOR<ItemCreateWithoutTenantInput, ItemUncheckedCreateWithoutTenantInput> | ItemCreateWithoutTenantInput[] | ItemUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: ItemCreateOrConnectWithoutTenantInput | ItemCreateOrConnectWithoutTenantInput[]
    createMany?: ItemCreateManyTenantInputEnvelope
    connect?: ItemWhereUniqueInput | ItemWhereUniqueInput[]
  }

  export type InventoryTransactionUncheckedCreateNestedManyWithoutTenantInput = {
    create?: XOR<InventoryTransactionCreateWithoutTenantInput, InventoryTransactionUncheckedCreateWithoutTenantInput> | InventoryTransactionCreateWithoutTenantInput[] | InventoryTransactionUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: InventoryTransactionCreateOrConnectWithoutTenantInput | InventoryTransactionCreateOrConnectWithoutTenantInput[]
    createMany?: InventoryTransactionCreateManyTenantInputEnvelope
    connect?: InventoryTransactionWhereUniqueInput | InventoryTransactionWhereUniqueInput[]
  }

  export type SupplierUncheckedCreateNestedManyWithoutTenantInput = {
    create?: XOR<SupplierCreateWithoutTenantInput, SupplierUncheckedCreateWithoutTenantInput> | SupplierCreateWithoutTenantInput[] | SupplierUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: SupplierCreateOrConnectWithoutTenantInput | SupplierCreateOrConnectWithoutTenantInput[]
    createMany?: SupplierCreateManyTenantInputEnvelope
    connect?: SupplierWhereUniqueInput | SupplierWhereUniqueInput[]
  }

  export type PurchaseOrderUncheckedCreateNestedManyWithoutTenantInput = {
    create?: XOR<PurchaseOrderCreateWithoutTenantInput, PurchaseOrderUncheckedCreateWithoutTenantInput> | PurchaseOrderCreateWithoutTenantInput[] | PurchaseOrderUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: PurchaseOrderCreateOrConnectWithoutTenantInput | PurchaseOrderCreateOrConnectWithoutTenantInput[]
    createMany?: PurchaseOrderCreateManyTenantInputEnvelope
    connect?: PurchaseOrderWhereUniqueInput | PurchaseOrderWhereUniqueInput[]
  }

  export type BuildingUncheckedCreateNestedManyWithoutTenantInput = {
    create?: XOR<BuildingCreateWithoutTenantInput, BuildingUncheckedCreateWithoutTenantInput> | BuildingCreateWithoutTenantInput[] | BuildingUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: BuildingCreateOrConnectWithoutTenantInput | BuildingCreateOrConnectWithoutTenantInput[]
    createMany?: BuildingCreateManyTenantInputEnvelope
    connect?: BuildingWhereUniqueInput | BuildingWhereUniqueInput[]
  }

  export type RoomUncheckedCreateNestedManyWithoutTenantInput = {
    create?: XOR<RoomCreateWithoutTenantInput, RoomUncheckedCreateWithoutTenantInput> | RoomCreateWithoutTenantInput[] | RoomUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: RoomCreateOrConnectWithoutTenantInput | RoomCreateOrConnectWithoutTenantInput[]
    createMany?: RoomCreateManyTenantInputEnvelope
    connect?: RoomWhereUniqueInput | RoomWhereUniqueInput[]
  }

  export type RoomAssignmentUncheckedCreateNestedManyWithoutTenantInput = {
    create?: XOR<RoomAssignmentCreateWithoutTenantInput, RoomAssignmentUncheckedCreateWithoutTenantInput> | RoomAssignmentCreateWithoutTenantInput[] | RoomAssignmentUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: RoomAssignmentCreateOrConnectWithoutTenantInput | RoomAssignmentCreateOrConnectWithoutTenantInput[]
    createMany?: RoomAssignmentCreateManyTenantInputEnvelope
    connect?: RoomAssignmentWhereUniqueInput | RoomAssignmentWhereUniqueInput[]
  }

  export type MaintenanceTicketUncheckedCreateNestedManyWithoutTenantInput = {
    create?: XOR<MaintenanceTicketCreateWithoutTenantInput, MaintenanceTicketUncheckedCreateWithoutTenantInput> | MaintenanceTicketCreateWithoutTenantInput[] | MaintenanceTicketUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: MaintenanceTicketCreateOrConnectWithoutTenantInput | MaintenanceTicketCreateOrConnectWithoutTenantInput[]
    createMany?: MaintenanceTicketCreateManyTenantInputEnvelope
    connect?: MaintenanceTicketWhereUniqueInput | MaintenanceTicketWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type UserUpdateManyWithoutTenantNestedInput = {
    create?: XOR<UserCreateWithoutTenantInput, UserUncheckedCreateWithoutTenantInput> | UserCreateWithoutTenantInput[] | UserUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: UserCreateOrConnectWithoutTenantInput | UserCreateOrConnectWithoutTenantInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutTenantInput | UserUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: UserCreateManyTenantInputEnvelope
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutTenantInput | UserUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: UserUpdateManyWithWhereWithoutTenantInput | UserUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type SantriUpdateManyWithoutTenantNestedInput = {
    create?: XOR<SantriCreateWithoutTenantInput, SantriUncheckedCreateWithoutTenantInput> | SantriCreateWithoutTenantInput[] | SantriUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: SantriCreateOrConnectWithoutTenantInput | SantriCreateOrConnectWithoutTenantInput[]
    upsert?: SantriUpsertWithWhereUniqueWithoutTenantInput | SantriUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: SantriCreateManyTenantInputEnvelope
    set?: SantriWhereUniqueInput | SantriWhereUniqueInput[]
    disconnect?: SantriWhereUniqueInput | SantriWhereUniqueInput[]
    delete?: SantriWhereUniqueInput | SantriWhereUniqueInput[]
    connect?: SantriWhereUniqueInput | SantriWhereUniqueInput[]
    update?: SantriUpdateWithWhereUniqueWithoutTenantInput | SantriUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: SantriUpdateManyWithWhereWithoutTenantInput | SantriUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: SantriScalarWhereInput | SantriScalarWhereInput[]
  }

  export type WaliUpdateManyWithoutTenantNestedInput = {
    create?: XOR<WaliCreateWithoutTenantInput, WaliUncheckedCreateWithoutTenantInput> | WaliCreateWithoutTenantInput[] | WaliUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: WaliCreateOrConnectWithoutTenantInput | WaliCreateOrConnectWithoutTenantInput[]
    upsert?: WaliUpsertWithWhereUniqueWithoutTenantInput | WaliUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: WaliCreateManyTenantInputEnvelope
    set?: WaliWhereUniqueInput | WaliWhereUniqueInput[]
    disconnect?: WaliWhereUniqueInput | WaliWhereUniqueInput[]
    delete?: WaliWhereUniqueInput | WaliWhereUniqueInput[]
    connect?: WaliWhereUniqueInput | WaliWhereUniqueInput[]
    update?: WaliUpdateWithWhereUniqueWithoutTenantInput | WaliUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: WaliUpdateManyWithWhereWithoutTenantInput | WaliUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: WaliScalarWhereInput | WaliScalarWhereInput[]
  }

  export type IzinUpdateManyWithoutTenantNestedInput = {
    create?: XOR<IzinCreateWithoutTenantInput, IzinUncheckedCreateWithoutTenantInput> | IzinCreateWithoutTenantInput[] | IzinUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: IzinCreateOrConnectWithoutTenantInput | IzinCreateOrConnectWithoutTenantInput[]
    upsert?: IzinUpsertWithWhereUniqueWithoutTenantInput | IzinUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: IzinCreateManyTenantInputEnvelope
    set?: IzinWhereUniqueInput | IzinWhereUniqueInput[]
    disconnect?: IzinWhereUniqueInput | IzinWhereUniqueInput[]
    delete?: IzinWhereUniqueInput | IzinWhereUniqueInput[]
    connect?: IzinWhereUniqueInput | IzinWhereUniqueInput[]
    update?: IzinUpdateWithWhereUniqueWithoutTenantInput | IzinUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: IzinUpdateManyWithWhereWithoutTenantInput | IzinUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: IzinScalarWhereInput | IzinScalarWhereInput[]
  }

  export type CatatanHarianUpdateManyWithoutTenantNestedInput = {
    create?: XOR<CatatanHarianCreateWithoutTenantInput, CatatanHarianUncheckedCreateWithoutTenantInput> | CatatanHarianCreateWithoutTenantInput[] | CatatanHarianUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: CatatanHarianCreateOrConnectWithoutTenantInput | CatatanHarianCreateOrConnectWithoutTenantInput[]
    upsert?: CatatanHarianUpsertWithWhereUniqueWithoutTenantInput | CatatanHarianUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: CatatanHarianCreateManyTenantInputEnvelope
    set?: CatatanHarianWhereUniqueInput | CatatanHarianWhereUniqueInput[]
    disconnect?: CatatanHarianWhereUniqueInput | CatatanHarianWhereUniqueInput[]
    delete?: CatatanHarianWhereUniqueInput | CatatanHarianWhereUniqueInput[]
    connect?: CatatanHarianWhereUniqueInput | CatatanHarianWhereUniqueInput[]
    update?: CatatanHarianUpdateWithWhereUniqueWithoutTenantInput | CatatanHarianUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: CatatanHarianUpdateManyWithWhereWithoutTenantInput | CatatanHarianUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: CatatanHarianScalarWhereInput | CatatanHarianScalarWhereInput[]
  }

  export type PengumumanUpdateManyWithoutTenantNestedInput = {
    create?: XOR<PengumumanCreateWithoutTenantInput, PengumumanUncheckedCreateWithoutTenantInput> | PengumumanCreateWithoutTenantInput[] | PengumumanUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: PengumumanCreateOrConnectWithoutTenantInput | PengumumanCreateOrConnectWithoutTenantInput[]
    upsert?: PengumumanUpsertWithWhereUniqueWithoutTenantInput | PengumumanUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: PengumumanCreateManyTenantInputEnvelope
    set?: PengumumanWhereUniqueInput | PengumumanWhereUniqueInput[]
    disconnect?: PengumumanWhereUniqueInput | PengumumanWhereUniqueInput[]
    delete?: PengumumanWhereUniqueInput | PengumumanWhereUniqueInput[]
    connect?: PengumumanWhereUniqueInput | PengumumanWhereUniqueInput[]
    update?: PengumumanUpdateWithWhereUniqueWithoutTenantInput | PengumumanUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: PengumumanUpdateManyWithWhereWithoutTenantInput | PengumumanUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: PengumumanScalarWhereInput | PengumumanScalarWhereInput[]
  }

  export type InvoiceUpdateManyWithoutTenantNestedInput = {
    create?: XOR<InvoiceCreateWithoutTenantInput, InvoiceUncheckedCreateWithoutTenantInput> | InvoiceCreateWithoutTenantInput[] | InvoiceUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: InvoiceCreateOrConnectWithoutTenantInput | InvoiceCreateOrConnectWithoutTenantInput[]
    upsert?: InvoiceUpsertWithWhereUniqueWithoutTenantInput | InvoiceUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: InvoiceCreateManyTenantInputEnvelope
    set?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    disconnect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    delete?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    connect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    update?: InvoiceUpdateWithWhereUniqueWithoutTenantInput | InvoiceUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: InvoiceUpdateManyWithWhereWithoutTenantInput | InvoiceUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: InvoiceScalarWhereInput | InvoiceScalarWhereInput[]
  }

  export type PelanggaranUpdateManyWithoutTenantNestedInput = {
    create?: XOR<PelanggaranCreateWithoutTenantInput, PelanggaranUncheckedCreateWithoutTenantInput> | PelanggaranCreateWithoutTenantInput[] | PelanggaranUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: PelanggaranCreateOrConnectWithoutTenantInput | PelanggaranCreateOrConnectWithoutTenantInput[]
    upsert?: PelanggaranUpsertWithWhereUniqueWithoutTenantInput | PelanggaranUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: PelanggaranCreateManyTenantInputEnvelope
    set?: PelanggaranWhereUniqueInput | PelanggaranWhereUniqueInput[]
    disconnect?: PelanggaranWhereUniqueInput | PelanggaranWhereUniqueInput[]
    delete?: PelanggaranWhereUniqueInput | PelanggaranWhereUniqueInput[]
    connect?: PelanggaranWhereUniqueInput | PelanggaranWhereUniqueInput[]
    update?: PelanggaranUpdateWithWhereUniqueWithoutTenantInput | PelanggaranUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: PelanggaranUpdateManyWithWhereWithoutTenantInput | PelanggaranUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: PelanggaranScalarWhereInput | PelanggaranScalarWhereInput[]
  }

  export type PembinaanUpdateManyWithoutTenantNestedInput = {
    create?: XOR<PembinaanCreateWithoutTenantInput, PembinaanUncheckedCreateWithoutTenantInput> | PembinaanCreateWithoutTenantInput[] | PembinaanUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: PembinaanCreateOrConnectWithoutTenantInput | PembinaanCreateOrConnectWithoutTenantInput[]
    upsert?: PembinaanUpsertWithWhereUniqueWithoutTenantInput | PembinaanUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: PembinaanCreateManyTenantInputEnvelope
    set?: PembinaanWhereUniqueInput | PembinaanWhereUniqueInput[]
    disconnect?: PembinaanWhereUniqueInput | PembinaanWhereUniqueInput[]
    delete?: PembinaanWhereUniqueInput | PembinaanWhereUniqueInput[]
    connect?: PembinaanWhereUniqueInput | PembinaanWhereUniqueInput[]
    update?: PembinaanUpdateWithWhereUniqueWithoutTenantInput | PembinaanUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: PembinaanUpdateManyWithWhereWithoutTenantInput | PembinaanUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: PembinaanScalarWhereInput | PembinaanScalarWhereInput[]
  }

  export type KunjunganUpdateManyWithoutTenantNestedInput = {
    create?: XOR<KunjunganCreateWithoutTenantInput, KunjunganUncheckedCreateWithoutTenantInput> | KunjunganCreateWithoutTenantInput[] | KunjunganUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: KunjunganCreateOrConnectWithoutTenantInput | KunjunganCreateOrConnectWithoutTenantInput[]
    upsert?: KunjunganUpsertWithWhereUniqueWithoutTenantInput | KunjunganUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: KunjunganCreateManyTenantInputEnvelope
    set?: KunjunganWhereUniqueInput | KunjunganWhereUniqueInput[]
    disconnect?: KunjunganWhereUniqueInput | KunjunganWhereUniqueInput[]
    delete?: KunjunganWhereUniqueInput | KunjunganWhereUniqueInput[]
    connect?: KunjunganWhereUniqueInput | KunjunganWhereUniqueInput[]
    update?: KunjunganUpdateWithWhereUniqueWithoutTenantInput | KunjunganUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: KunjunganUpdateManyWithWhereWithoutTenantInput | KunjunganUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: KunjunganScalarWhereInput | KunjunganScalarWhereInput[]
  }

  export type HealthRecordUpdateManyWithoutTenantNestedInput = {
    create?: XOR<HealthRecordCreateWithoutTenantInput, HealthRecordUncheckedCreateWithoutTenantInput> | HealthRecordCreateWithoutTenantInput[] | HealthRecordUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: HealthRecordCreateOrConnectWithoutTenantInput | HealthRecordCreateOrConnectWithoutTenantInput[]
    upsert?: HealthRecordUpsertWithWhereUniqueWithoutTenantInput | HealthRecordUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: HealthRecordCreateManyTenantInputEnvelope
    set?: HealthRecordWhereUniqueInput | HealthRecordWhereUniqueInput[]
    disconnect?: HealthRecordWhereUniqueInput | HealthRecordWhereUniqueInput[]
    delete?: HealthRecordWhereUniqueInput | HealthRecordWhereUniqueInput[]
    connect?: HealthRecordWhereUniqueInput | HealthRecordWhereUniqueInput[]
    update?: HealthRecordUpdateWithWhereUniqueWithoutTenantInput | HealthRecordUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: HealthRecordUpdateManyWithWhereWithoutTenantInput | HealthRecordUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: HealthRecordScalarWhereInput | HealthRecordScalarWhereInput[]
  }

  export type AuditLogUpdateManyWithoutTenantNestedInput = {
    create?: XOR<AuditLogCreateWithoutTenantInput, AuditLogUncheckedCreateWithoutTenantInput> | AuditLogCreateWithoutTenantInput[] | AuditLogUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutTenantInput | AuditLogCreateOrConnectWithoutTenantInput[]
    upsert?: AuditLogUpsertWithWhereUniqueWithoutTenantInput | AuditLogUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: AuditLogCreateManyTenantInputEnvelope
    set?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    disconnect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    delete?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    update?: AuditLogUpdateWithWhereUniqueWithoutTenantInput | AuditLogUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: AuditLogUpdateManyWithWhereWithoutTenantInput | AuditLogUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
  }

  export type NotificationUpdateManyWithoutTenantNestedInput = {
    create?: XOR<NotificationCreateWithoutTenantInput, NotificationUncheckedCreateWithoutTenantInput> | NotificationCreateWithoutTenantInput[] | NotificationUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutTenantInput | NotificationCreateOrConnectWithoutTenantInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutTenantInput | NotificationUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: NotificationCreateManyTenantInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutTenantInput | NotificationUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutTenantInput | NotificationUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type WebhookEventUpdateManyWithoutTenantNestedInput = {
    create?: XOR<WebhookEventCreateWithoutTenantInput, WebhookEventUncheckedCreateWithoutTenantInput> | WebhookEventCreateWithoutTenantInput[] | WebhookEventUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: WebhookEventCreateOrConnectWithoutTenantInput | WebhookEventCreateOrConnectWithoutTenantInput[]
    upsert?: WebhookEventUpsertWithWhereUniqueWithoutTenantInput | WebhookEventUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: WebhookEventCreateManyTenantInputEnvelope
    set?: WebhookEventWhereUniqueInput | WebhookEventWhereUniqueInput[]
    disconnect?: WebhookEventWhereUniqueInput | WebhookEventWhereUniqueInput[]
    delete?: WebhookEventWhereUniqueInput | WebhookEventWhereUniqueInput[]
    connect?: WebhookEventWhereUniqueInput | WebhookEventWhereUniqueInput[]
    update?: WebhookEventUpdateWithWhereUniqueWithoutTenantInput | WebhookEventUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: WebhookEventUpdateManyWithWhereWithoutTenantInput | WebhookEventUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: WebhookEventScalarWhereInput | WebhookEventScalarWhereInput[]
  }

  export type TahfidzUpdateManyWithoutTenantNestedInput = {
    create?: XOR<TahfidzCreateWithoutTenantInput, TahfidzUncheckedCreateWithoutTenantInput> | TahfidzCreateWithoutTenantInput[] | TahfidzUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: TahfidzCreateOrConnectWithoutTenantInput | TahfidzCreateOrConnectWithoutTenantInput[]
    upsert?: TahfidzUpsertWithWhereUniqueWithoutTenantInput | TahfidzUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: TahfidzCreateManyTenantInputEnvelope
    set?: TahfidzWhereUniqueInput | TahfidzWhereUniqueInput[]
    disconnect?: TahfidzWhereUniqueInput | TahfidzWhereUniqueInput[]
    delete?: TahfidzWhereUniqueInput | TahfidzWhereUniqueInput[]
    connect?: TahfidzWhereUniqueInput | TahfidzWhereUniqueInput[]
    update?: TahfidzUpdateWithWhereUniqueWithoutTenantInput | TahfidzUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: TahfidzUpdateManyWithWhereWithoutTenantInput | TahfidzUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: TahfidzScalarWhereInput | TahfidzScalarWhereInput[]
  }

  export type MutabaahUpdateManyWithoutTenantNestedInput = {
    create?: XOR<MutabaahCreateWithoutTenantInput, MutabaahUncheckedCreateWithoutTenantInput> | MutabaahCreateWithoutTenantInput[] | MutabaahUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: MutabaahCreateOrConnectWithoutTenantInput | MutabaahCreateOrConnectWithoutTenantInput[]
    upsert?: MutabaahUpsertWithWhereUniqueWithoutTenantInput | MutabaahUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: MutabaahCreateManyTenantInputEnvelope
    set?: MutabaahWhereUniqueInput | MutabaahWhereUniqueInput[]
    disconnect?: MutabaahWhereUniqueInput | MutabaahWhereUniqueInput[]
    delete?: MutabaahWhereUniqueInput | MutabaahWhereUniqueInput[]
    connect?: MutabaahWhereUniqueInput | MutabaahWhereUniqueInput[]
    update?: MutabaahUpdateWithWhereUniqueWithoutTenantInput | MutabaahUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: MutabaahUpdateManyWithWhereWithoutTenantInput | MutabaahUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: MutabaahScalarWhereInput | MutabaahScalarWhereInput[]
  }

  export type WalletUpdateManyWithoutTenantNestedInput = {
    create?: XOR<WalletCreateWithoutTenantInput, WalletUncheckedCreateWithoutTenantInput> | WalletCreateWithoutTenantInput[] | WalletUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: WalletCreateOrConnectWithoutTenantInput | WalletCreateOrConnectWithoutTenantInput[]
    upsert?: WalletUpsertWithWhereUniqueWithoutTenantInput | WalletUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: WalletCreateManyTenantInputEnvelope
    set?: WalletWhereUniqueInput | WalletWhereUniqueInput[]
    disconnect?: WalletWhereUniqueInput | WalletWhereUniqueInput[]
    delete?: WalletWhereUniqueInput | WalletWhereUniqueInput[]
    connect?: WalletWhereUniqueInput | WalletWhereUniqueInput[]
    update?: WalletUpdateWithWhereUniqueWithoutTenantInput | WalletUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: WalletUpdateManyWithWhereWithoutTenantInput | WalletUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: WalletScalarWhereInput | WalletScalarWhereInput[]
  }

  export type EmployeeUpdateManyWithoutTenantNestedInput = {
    create?: XOR<EmployeeCreateWithoutTenantInput, EmployeeUncheckedCreateWithoutTenantInput> | EmployeeCreateWithoutTenantInput[] | EmployeeUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: EmployeeCreateOrConnectWithoutTenantInput | EmployeeCreateOrConnectWithoutTenantInput[]
    upsert?: EmployeeUpsertWithWhereUniqueWithoutTenantInput | EmployeeUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: EmployeeCreateManyTenantInputEnvelope
    set?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
    disconnect?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
    delete?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
    connect?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
    update?: EmployeeUpdateWithWhereUniqueWithoutTenantInput | EmployeeUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: EmployeeUpdateManyWithWhereWithoutTenantInput | EmployeeUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: EmployeeScalarWhereInput | EmployeeScalarWhereInput[]
  }

  export type PayrollUpdateManyWithoutTenantNestedInput = {
    create?: XOR<PayrollCreateWithoutTenantInput, PayrollUncheckedCreateWithoutTenantInput> | PayrollCreateWithoutTenantInput[] | PayrollUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: PayrollCreateOrConnectWithoutTenantInput | PayrollCreateOrConnectWithoutTenantInput[]
    upsert?: PayrollUpsertWithWhereUniqueWithoutTenantInput | PayrollUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: PayrollCreateManyTenantInputEnvelope
    set?: PayrollWhereUniqueInput | PayrollWhereUniqueInput[]
    disconnect?: PayrollWhereUniqueInput | PayrollWhereUniqueInput[]
    delete?: PayrollWhereUniqueInput | PayrollWhereUniqueInput[]
    connect?: PayrollWhereUniqueInput | PayrollWhereUniqueInput[]
    update?: PayrollUpdateWithWhereUniqueWithoutTenantInput | PayrollUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: PayrollUpdateManyWithWhereWithoutTenantInput | PayrollUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: PayrollScalarWhereInput | PayrollScalarWhereInput[]
  }

  export type AcademicScheduleUpdateManyWithoutTenantNestedInput = {
    create?: XOR<AcademicScheduleCreateWithoutTenantInput, AcademicScheduleUncheckedCreateWithoutTenantInput> | AcademicScheduleCreateWithoutTenantInput[] | AcademicScheduleUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: AcademicScheduleCreateOrConnectWithoutTenantInput | AcademicScheduleCreateOrConnectWithoutTenantInput[]
    upsert?: AcademicScheduleUpsertWithWhereUniqueWithoutTenantInput | AcademicScheduleUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: AcademicScheduleCreateManyTenantInputEnvelope
    set?: AcademicScheduleWhereUniqueInput | AcademicScheduleWhereUniqueInput[]
    disconnect?: AcademicScheduleWhereUniqueInput | AcademicScheduleWhereUniqueInput[]
    delete?: AcademicScheduleWhereUniqueInput | AcademicScheduleWhereUniqueInput[]
    connect?: AcademicScheduleWhereUniqueInput | AcademicScheduleWhereUniqueInput[]
    update?: AcademicScheduleUpdateWithWhereUniqueWithoutTenantInput | AcademicScheduleUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: AcademicScheduleUpdateManyWithWhereWithoutTenantInput | AcademicScheduleUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: AcademicScheduleScalarWhereInput | AcademicScheduleScalarWhereInput[]
  }

  export type AttendanceUpdateManyWithoutTenantNestedInput = {
    create?: XOR<AttendanceCreateWithoutTenantInput, AttendanceUncheckedCreateWithoutTenantInput> | AttendanceCreateWithoutTenantInput[] | AttendanceUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: AttendanceCreateOrConnectWithoutTenantInput | AttendanceCreateOrConnectWithoutTenantInput[]
    upsert?: AttendanceUpsertWithWhereUniqueWithoutTenantInput | AttendanceUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: AttendanceCreateManyTenantInputEnvelope
    set?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
    disconnect?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
    delete?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
    connect?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
    update?: AttendanceUpdateWithWhereUniqueWithoutTenantInput | AttendanceUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: AttendanceUpdateManyWithWhereWithoutTenantInput | AttendanceUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: AttendanceScalarWhereInput | AttendanceScalarWhereInput[]
  }

  export type GradeUpdateManyWithoutTenantNestedInput = {
    create?: XOR<GradeCreateWithoutTenantInput, GradeUncheckedCreateWithoutTenantInput> | GradeCreateWithoutTenantInput[] | GradeUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: GradeCreateOrConnectWithoutTenantInput | GradeCreateOrConnectWithoutTenantInput[]
    upsert?: GradeUpsertWithWhereUniqueWithoutTenantInput | GradeUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: GradeCreateManyTenantInputEnvelope
    set?: GradeWhereUniqueInput | GradeWhereUniqueInput[]
    disconnect?: GradeWhereUniqueInput | GradeWhereUniqueInput[]
    delete?: GradeWhereUniqueInput | GradeWhereUniqueInput[]
    connect?: GradeWhereUniqueInput | GradeWhereUniqueInput[]
    update?: GradeUpdateWithWhereUniqueWithoutTenantInput | GradeUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: GradeUpdateManyWithWhereWithoutTenantInput | GradeUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: GradeScalarWhereInput | GradeScalarWhereInput[]
  }

  export type PpdbRegistrationUpdateManyWithoutTenantNestedInput = {
    create?: XOR<PpdbRegistrationCreateWithoutTenantInput, PpdbRegistrationUncheckedCreateWithoutTenantInput> | PpdbRegistrationCreateWithoutTenantInput[] | PpdbRegistrationUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: PpdbRegistrationCreateOrConnectWithoutTenantInput | PpdbRegistrationCreateOrConnectWithoutTenantInput[]
    upsert?: PpdbRegistrationUpsertWithWhereUniqueWithoutTenantInput | PpdbRegistrationUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: PpdbRegistrationCreateManyTenantInputEnvelope
    set?: PpdbRegistrationWhereUniqueInput | PpdbRegistrationWhereUniqueInput[]
    disconnect?: PpdbRegistrationWhereUniqueInput | PpdbRegistrationWhereUniqueInput[]
    delete?: PpdbRegistrationWhereUniqueInput | PpdbRegistrationWhereUniqueInput[]
    connect?: PpdbRegistrationWhereUniqueInput | PpdbRegistrationWhereUniqueInput[]
    update?: PpdbRegistrationUpdateWithWhereUniqueWithoutTenantInput | PpdbRegistrationUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: PpdbRegistrationUpdateManyWithWhereWithoutTenantInput | PpdbRegistrationUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: PpdbRegistrationScalarWhereInput | PpdbRegistrationScalarWhereInput[]
  }

  export type PpdbDocumentUpdateManyWithoutTenantNestedInput = {
    create?: XOR<PpdbDocumentCreateWithoutTenantInput, PpdbDocumentUncheckedCreateWithoutTenantInput> | PpdbDocumentCreateWithoutTenantInput[] | PpdbDocumentUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: PpdbDocumentCreateOrConnectWithoutTenantInput | PpdbDocumentCreateOrConnectWithoutTenantInput[]
    upsert?: PpdbDocumentUpsertWithWhereUniqueWithoutTenantInput | PpdbDocumentUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: PpdbDocumentCreateManyTenantInputEnvelope
    set?: PpdbDocumentWhereUniqueInput | PpdbDocumentWhereUniqueInput[]
    disconnect?: PpdbDocumentWhereUniqueInput | PpdbDocumentWhereUniqueInput[]
    delete?: PpdbDocumentWhereUniqueInput | PpdbDocumentWhereUniqueInput[]
    connect?: PpdbDocumentWhereUniqueInput | PpdbDocumentWhereUniqueInput[]
    update?: PpdbDocumentUpdateWithWhereUniqueWithoutTenantInput | PpdbDocumentUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: PpdbDocumentUpdateManyWithWhereWithoutTenantInput | PpdbDocumentUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: PpdbDocumentScalarWhereInput | PpdbDocumentScalarWhereInput[]
  }

  export type PpdbExamUpdateManyWithoutTenantNestedInput = {
    create?: XOR<PpdbExamCreateWithoutTenantInput, PpdbExamUncheckedCreateWithoutTenantInput> | PpdbExamCreateWithoutTenantInput[] | PpdbExamUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: PpdbExamCreateOrConnectWithoutTenantInput | PpdbExamCreateOrConnectWithoutTenantInput[]
    upsert?: PpdbExamUpsertWithWhereUniqueWithoutTenantInput | PpdbExamUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: PpdbExamCreateManyTenantInputEnvelope
    set?: PpdbExamWhereUniqueInput | PpdbExamWhereUniqueInput[]
    disconnect?: PpdbExamWhereUniqueInput | PpdbExamWhereUniqueInput[]
    delete?: PpdbExamWhereUniqueInput | PpdbExamWhereUniqueInput[]
    connect?: PpdbExamWhereUniqueInput | PpdbExamWhereUniqueInput[]
    update?: PpdbExamUpdateWithWhereUniqueWithoutTenantInput | PpdbExamUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: PpdbExamUpdateManyWithWhereWithoutTenantInput | PpdbExamUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: PpdbExamScalarWhereInput | PpdbExamScalarWhereInput[]
  }

  export type ItemUpdateManyWithoutTenantNestedInput = {
    create?: XOR<ItemCreateWithoutTenantInput, ItemUncheckedCreateWithoutTenantInput> | ItemCreateWithoutTenantInput[] | ItemUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: ItemCreateOrConnectWithoutTenantInput | ItemCreateOrConnectWithoutTenantInput[]
    upsert?: ItemUpsertWithWhereUniqueWithoutTenantInput | ItemUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: ItemCreateManyTenantInputEnvelope
    set?: ItemWhereUniqueInput | ItemWhereUniqueInput[]
    disconnect?: ItemWhereUniqueInput | ItemWhereUniqueInput[]
    delete?: ItemWhereUniqueInput | ItemWhereUniqueInput[]
    connect?: ItemWhereUniqueInput | ItemWhereUniqueInput[]
    update?: ItemUpdateWithWhereUniqueWithoutTenantInput | ItemUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: ItemUpdateManyWithWhereWithoutTenantInput | ItemUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: ItemScalarWhereInput | ItemScalarWhereInput[]
  }

  export type InventoryTransactionUpdateManyWithoutTenantNestedInput = {
    create?: XOR<InventoryTransactionCreateWithoutTenantInput, InventoryTransactionUncheckedCreateWithoutTenantInput> | InventoryTransactionCreateWithoutTenantInput[] | InventoryTransactionUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: InventoryTransactionCreateOrConnectWithoutTenantInput | InventoryTransactionCreateOrConnectWithoutTenantInput[]
    upsert?: InventoryTransactionUpsertWithWhereUniqueWithoutTenantInput | InventoryTransactionUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: InventoryTransactionCreateManyTenantInputEnvelope
    set?: InventoryTransactionWhereUniqueInput | InventoryTransactionWhereUniqueInput[]
    disconnect?: InventoryTransactionWhereUniqueInput | InventoryTransactionWhereUniqueInput[]
    delete?: InventoryTransactionWhereUniqueInput | InventoryTransactionWhereUniqueInput[]
    connect?: InventoryTransactionWhereUniqueInput | InventoryTransactionWhereUniqueInput[]
    update?: InventoryTransactionUpdateWithWhereUniqueWithoutTenantInput | InventoryTransactionUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: InventoryTransactionUpdateManyWithWhereWithoutTenantInput | InventoryTransactionUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: InventoryTransactionScalarWhereInput | InventoryTransactionScalarWhereInput[]
  }

  export type SupplierUpdateManyWithoutTenantNestedInput = {
    create?: XOR<SupplierCreateWithoutTenantInput, SupplierUncheckedCreateWithoutTenantInput> | SupplierCreateWithoutTenantInput[] | SupplierUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: SupplierCreateOrConnectWithoutTenantInput | SupplierCreateOrConnectWithoutTenantInput[]
    upsert?: SupplierUpsertWithWhereUniqueWithoutTenantInput | SupplierUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: SupplierCreateManyTenantInputEnvelope
    set?: SupplierWhereUniqueInput | SupplierWhereUniqueInput[]
    disconnect?: SupplierWhereUniqueInput | SupplierWhereUniqueInput[]
    delete?: SupplierWhereUniqueInput | SupplierWhereUniqueInput[]
    connect?: SupplierWhereUniqueInput | SupplierWhereUniqueInput[]
    update?: SupplierUpdateWithWhereUniqueWithoutTenantInput | SupplierUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: SupplierUpdateManyWithWhereWithoutTenantInput | SupplierUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: SupplierScalarWhereInput | SupplierScalarWhereInput[]
  }

  export type PurchaseOrderUpdateManyWithoutTenantNestedInput = {
    create?: XOR<PurchaseOrderCreateWithoutTenantInput, PurchaseOrderUncheckedCreateWithoutTenantInput> | PurchaseOrderCreateWithoutTenantInput[] | PurchaseOrderUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: PurchaseOrderCreateOrConnectWithoutTenantInput | PurchaseOrderCreateOrConnectWithoutTenantInput[]
    upsert?: PurchaseOrderUpsertWithWhereUniqueWithoutTenantInput | PurchaseOrderUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: PurchaseOrderCreateManyTenantInputEnvelope
    set?: PurchaseOrderWhereUniqueInput | PurchaseOrderWhereUniqueInput[]
    disconnect?: PurchaseOrderWhereUniqueInput | PurchaseOrderWhereUniqueInput[]
    delete?: PurchaseOrderWhereUniqueInput | PurchaseOrderWhereUniqueInput[]
    connect?: PurchaseOrderWhereUniqueInput | PurchaseOrderWhereUniqueInput[]
    update?: PurchaseOrderUpdateWithWhereUniqueWithoutTenantInput | PurchaseOrderUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: PurchaseOrderUpdateManyWithWhereWithoutTenantInput | PurchaseOrderUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: PurchaseOrderScalarWhereInput | PurchaseOrderScalarWhereInput[]
  }

  export type BuildingUpdateManyWithoutTenantNestedInput = {
    create?: XOR<BuildingCreateWithoutTenantInput, BuildingUncheckedCreateWithoutTenantInput> | BuildingCreateWithoutTenantInput[] | BuildingUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: BuildingCreateOrConnectWithoutTenantInput | BuildingCreateOrConnectWithoutTenantInput[]
    upsert?: BuildingUpsertWithWhereUniqueWithoutTenantInput | BuildingUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: BuildingCreateManyTenantInputEnvelope
    set?: BuildingWhereUniqueInput | BuildingWhereUniqueInput[]
    disconnect?: BuildingWhereUniqueInput | BuildingWhereUniqueInput[]
    delete?: BuildingWhereUniqueInput | BuildingWhereUniqueInput[]
    connect?: BuildingWhereUniqueInput | BuildingWhereUniqueInput[]
    update?: BuildingUpdateWithWhereUniqueWithoutTenantInput | BuildingUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: BuildingUpdateManyWithWhereWithoutTenantInput | BuildingUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: BuildingScalarWhereInput | BuildingScalarWhereInput[]
  }

  export type RoomUpdateManyWithoutTenantNestedInput = {
    create?: XOR<RoomCreateWithoutTenantInput, RoomUncheckedCreateWithoutTenantInput> | RoomCreateWithoutTenantInput[] | RoomUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: RoomCreateOrConnectWithoutTenantInput | RoomCreateOrConnectWithoutTenantInput[]
    upsert?: RoomUpsertWithWhereUniqueWithoutTenantInput | RoomUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: RoomCreateManyTenantInputEnvelope
    set?: RoomWhereUniqueInput | RoomWhereUniqueInput[]
    disconnect?: RoomWhereUniqueInput | RoomWhereUniqueInput[]
    delete?: RoomWhereUniqueInput | RoomWhereUniqueInput[]
    connect?: RoomWhereUniqueInput | RoomWhereUniqueInput[]
    update?: RoomUpdateWithWhereUniqueWithoutTenantInput | RoomUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: RoomUpdateManyWithWhereWithoutTenantInput | RoomUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: RoomScalarWhereInput | RoomScalarWhereInput[]
  }

  export type RoomAssignmentUpdateManyWithoutTenantNestedInput = {
    create?: XOR<RoomAssignmentCreateWithoutTenantInput, RoomAssignmentUncheckedCreateWithoutTenantInput> | RoomAssignmentCreateWithoutTenantInput[] | RoomAssignmentUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: RoomAssignmentCreateOrConnectWithoutTenantInput | RoomAssignmentCreateOrConnectWithoutTenantInput[]
    upsert?: RoomAssignmentUpsertWithWhereUniqueWithoutTenantInput | RoomAssignmentUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: RoomAssignmentCreateManyTenantInputEnvelope
    set?: RoomAssignmentWhereUniqueInput | RoomAssignmentWhereUniqueInput[]
    disconnect?: RoomAssignmentWhereUniqueInput | RoomAssignmentWhereUniqueInput[]
    delete?: RoomAssignmentWhereUniqueInput | RoomAssignmentWhereUniqueInput[]
    connect?: RoomAssignmentWhereUniqueInput | RoomAssignmentWhereUniqueInput[]
    update?: RoomAssignmentUpdateWithWhereUniqueWithoutTenantInput | RoomAssignmentUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: RoomAssignmentUpdateManyWithWhereWithoutTenantInput | RoomAssignmentUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: RoomAssignmentScalarWhereInput | RoomAssignmentScalarWhereInput[]
  }

  export type MaintenanceTicketUpdateManyWithoutTenantNestedInput = {
    create?: XOR<MaintenanceTicketCreateWithoutTenantInput, MaintenanceTicketUncheckedCreateWithoutTenantInput> | MaintenanceTicketCreateWithoutTenantInput[] | MaintenanceTicketUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: MaintenanceTicketCreateOrConnectWithoutTenantInput | MaintenanceTicketCreateOrConnectWithoutTenantInput[]
    upsert?: MaintenanceTicketUpsertWithWhereUniqueWithoutTenantInput | MaintenanceTicketUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: MaintenanceTicketCreateManyTenantInputEnvelope
    set?: MaintenanceTicketWhereUniqueInput | MaintenanceTicketWhereUniqueInput[]
    disconnect?: MaintenanceTicketWhereUniqueInput | MaintenanceTicketWhereUniqueInput[]
    delete?: MaintenanceTicketWhereUniqueInput | MaintenanceTicketWhereUniqueInput[]
    connect?: MaintenanceTicketWhereUniqueInput | MaintenanceTicketWhereUniqueInput[]
    update?: MaintenanceTicketUpdateWithWhereUniqueWithoutTenantInput | MaintenanceTicketUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: MaintenanceTicketUpdateManyWithWhereWithoutTenantInput | MaintenanceTicketUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: MaintenanceTicketScalarWhereInput | MaintenanceTicketScalarWhereInput[]
  }

  export type UserUncheckedUpdateManyWithoutTenantNestedInput = {
    create?: XOR<UserCreateWithoutTenantInput, UserUncheckedCreateWithoutTenantInput> | UserCreateWithoutTenantInput[] | UserUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: UserCreateOrConnectWithoutTenantInput | UserCreateOrConnectWithoutTenantInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutTenantInput | UserUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: UserCreateManyTenantInputEnvelope
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutTenantInput | UserUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: UserUpdateManyWithWhereWithoutTenantInput | UserUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type SantriUncheckedUpdateManyWithoutTenantNestedInput = {
    create?: XOR<SantriCreateWithoutTenantInput, SantriUncheckedCreateWithoutTenantInput> | SantriCreateWithoutTenantInput[] | SantriUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: SantriCreateOrConnectWithoutTenantInput | SantriCreateOrConnectWithoutTenantInput[]
    upsert?: SantriUpsertWithWhereUniqueWithoutTenantInput | SantriUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: SantriCreateManyTenantInputEnvelope
    set?: SantriWhereUniqueInput | SantriWhereUniqueInput[]
    disconnect?: SantriWhereUniqueInput | SantriWhereUniqueInput[]
    delete?: SantriWhereUniqueInput | SantriWhereUniqueInput[]
    connect?: SantriWhereUniqueInput | SantriWhereUniqueInput[]
    update?: SantriUpdateWithWhereUniqueWithoutTenantInput | SantriUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: SantriUpdateManyWithWhereWithoutTenantInput | SantriUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: SantriScalarWhereInput | SantriScalarWhereInput[]
  }

  export type WaliUncheckedUpdateManyWithoutTenantNestedInput = {
    create?: XOR<WaliCreateWithoutTenantInput, WaliUncheckedCreateWithoutTenantInput> | WaliCreateWithoutTenantInput[] | WaliUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: WaliCreateOrConnectWithoutTenantInput | WaliCreateOrConnectWithoutTenantInput[]
    upsert?: WaliUpsertWithWhereUniqueWithoutTenantInput | WaliUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: WaliCreateManyTenantInputEnvelope
    set?: WaliWhereUniqueInput | WaliWhereUniqueInput[]
    disconnect?: WaliWhereUniqueInput | WaliWhereUniqueInput[]
    delete?: WaliWhereUniqueInput | WaliWhereUniqueInput[]
    connect?: WaliWhereUniqueInput | WaliWhereUniqueInput[]
    update?: WaliUpdateWithWhereUniqueWithoutTenantInput | WaliUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: WaliUpdateManyWithWhereWithoutTenantInput | WaliUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: WaliScalarWhereInput | WaliScalarWhereInput[]
  }

  export type IzinUncheckedUpdateManyWithoutTenantNestedInput = {
    create?: XOR<IzinCreateWithoutTenantInput, IzinUncheckedCreateWithoutTenantInput> | IzinCreateWithoutTenantInput[] | IzinUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: IzinCreateOrConnectWithoutTenantInput | IzinCreateOrConnectWithoutTenantInput[]
    upsert?: IzinUpsertWithWhereUniqueWithoutTenantInput | IzinUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: IzinCreateManyTenantInputEnvelope
    set?: IzinWhereUniqueInput | IzinWhereUniqueInput[]
    disconnect?: IzinWhereUniqueInput | IzinWhereUniqueInput[]
    delete?: IzinWhereUniqueInput | IzinWhereUniqueInput[]
    connect?: IzinWhereUniqueInput | IzinWhereUniqueInput[]
    update?: IzinUpdateWithWhereUniqueWithoutTenantInput | IzinUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: IzinUpdateManyWithWhereWithoutTenantInput | IzinUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: IzinScalarWhereInput | IzinScalarWhereInput[]
  }

  export type CatatanHarianUncheckedUpdateManyWithoutTenantNestedInput = {
    create?: XOR<CatatanHarianCreateWithoutTenantInput, CatatanHarianUncheckedCreateWithoutTenantInput> | CatatanHarianCreateWithoutTenantInput[] | CatatanHarianUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: CatatanHarianCreateOrConnectWithoutTenantInput | CatatanHarianCreateOrConnectWithoutTenantInput[]
    upsert?: CatatanHarianUpsertWithWhereUniqueWithoutTenantInput | CatatanHarianUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: CatatanHarianCreateManyTenantInputEnvelope
    set?: CatatanHarianWhereUniqueInput | CatatanHarianWhereUniqueInput[]
    disconnect?: CatatanHarianWhereUniqueInput | CatatanHarianWhereUniqueInput[]
    delete?: CatatanHarianWhereUniqueInput | CatatanHarianWhereUniqueInput[]
    connect?: CatatanHarianWhereUniqueInput | CatatanHarianWhereUniqueInput[]
    update?: CatatanHarianUpdateWithWhereUniqueWithoutTenantInput | CatatanHarianUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: CatatanHarianUpdateManyWithWhereWithoutTenantInput | CatatanHarianUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: CatatanHarianScalarWhereInput | CatatanHarianScalarWhereInput[]
  }

  export type PengumumanUncheckedUpdateManyWithoutTenantNestedInput = {
    create?: XOR<PengumumanCreateWithoutTenantInput, PengumumanUncheckedCreateWithoutTenantInput> | PengumumanCreateWithoutTenantInput[] | PengumumanUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: PengumumanCreateOrConnectWithoutTenantInput | PengumumanCreateOrConnectWithoutTenantInput[]
    upsert?: PengumumanUpsertWithWhereUniqueWithoutTenantInput | PengumumanUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: PengumumanCreateManyTenantInputEnvelope
    set?: PengumumanWhereUniqueInput | PengumumanWhereUniqueInput[]
    disconnect?: PengumumanWhereUniqueInput | PengumumanWhereUniqueInput[]
    delete?: PengumumanWhereUniqueInput | PengumumanWhereUniqueInput[]
    connect?: PengumumanWhereUniqueInput | PengumumanWhereUniqueInput[]
    update?: PengumumanUpdateWithWhereUniqueWithoutTenantInput | PengumumanUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: PengumumanUpdateManyWithWhereWithoutTenantInput | PengumumanUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: PengumumanScalarWhereInput | PengumumanScalarWhereInput[]
  }

  export type InvoiceUncheckedUpdateManyWithoutTenantNestedInput = {
    create?: XOR<InvoiceCreateWithoutTenantInput, InvoiceUncheckedCreateWithoutTenantInput> | InvoiceCreateWithoutTenantInput[] | InvoiceUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: InvoiceCreateOrConnectWithoutTenantInput | InvoiceCreateOrConnectWithoutTenantInput[]
    upsert?: InvoiceUpsertWithWhereUniqueWithoutTenantInput | InvoiceUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: InvoiceCreateManyTenantInputEnvelope
    set?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    disconnect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    delete?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    connect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    update?: InvoiceUpdateWithWhereUniqueWithoutTenantInput | InvoiceUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: InvoiceUpdateManyWithWhereWithoutTenantInput | InvoiceUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: InvoiceScalarWhereInput | InvoiceScalarWhereInput[]
  }

  export type PelanggaranUncheckedUpdateManyWithoutTenantNestedInput = {
    create?: XOR<PelanggaranCreateWithoutTenantInput, PelanggaranUncheckedCreateWithoutTenantInput> | PelanggaranCreateWithoutTenantInput[] | PelanggaranUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: PelanggaranCreateOrConnectWithoutTenantInput | PelanggaranCreateOrConnectWithoutTenantInput[]
    upsert?: PelanggaranUpsertWithWhereUniqueWithoutTenantInput | PelanggaranUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: PelanggaranCreateManyTenantInputEnvelope
    set?: PelanggaranWhereUniqueInput | PelanggaranWhereUniqueInput[]
    disconnect?: PelanggaranWhereUniqueInput | PelanggaranWhereUniqueInput[]
    delete?: PelanggaranWhereUniqueInput | PelanggaranWhereUniqueInput[]
    connect?: PelanggaranWhereUniqueInput | PelanggaranWhereUniqueInput[]
    update?: PelanggaranUpdateWithWhereUniqueWithoutTenantInput | PelanggaranUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: PelanggaranUpdateManyWithWhereWithoutTenantInput | PelanggaranUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: PelanggaranScalarWhereInput | PelanggaranScalarWhereInput[]
  }

  export type PembinaanUncheckedUpdateManyWithoutTenantNestedInput = {
    create?: XOR<PembinaanCreateWithoutTenantInput, PembinaanUncheckedCreateWithoutTenantInput> | PembinaanCreateWithoutTenantInput[] | PembinaanUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: PembinaanCreateOrConnectWithoutTenantInput | PembinaanCreateOrConnectWithoutTenantInput[]
    upsert?: PembinaanUpsertWithWhereUniqueWithoutTenantInput | PembinaanUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: PembinaanCreateManyTenantInputEnvelope
    set?: PembinaanWhereUniqueInput | PembinaanWhereUniqueInput[]
    disconnect?: PembinaanWhereUniqueInput | PembinaanWhereUniqueInput[]
    delete?: PembinaanWhereUniqueInput | PembinaanWhereUniqueInput[]
    connect?: PembinaanWhereUniqueInput | PembinaanWhereUniqueInput[]
    update?: PembinaanUpdateWithWhereUniqueWithoutTenantInput | PembinaanUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: PembinaanUpdateManyWithWhereWithoutTenantInput | PembinaanUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: PembinaanScalarWhereInput | PembinaanScalarWhereInput[]
  }

  export type KunjunganUncheckedUpdateManyWithoutTenantNestedInput = {
    create?: XOR<KunjunganCreateWithoutTenantInput, KunjunganUncheckedCreateWithoutTenantInput> | KunjunganCreateWithoutTenantInput[] | KunjunganUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: KunjunganCreateOrConnectWithoutTenantInput | KunjunganCreateOrConnectWithoutTenantInput[]
    upsert?: KunjunganUpsertWithWhereUniqueWithoutTenantInput | KunjunganUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: KunjunganCreateManyTenantInputEnvelope
    set?: KunjunganWhereUniqueInput | KunjunganWhereUniqueInput[]
    disconnect?: KunjunganWhereUniqueInput | KunjunganWhereUniqueInput[]
    delete?: KunjunganWhereUniqueInput | KunjunganWhereUniqueInput[]
    connect?: KunjunganWhereUniqueInput | KunjunganWhereUniqueInput[]
    update?: KunjunganUpdateWithWhereUniqueWithoutTenantInput | KunjunganUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: KunjunganUpdateManyWithWhereWithoutTenantInput | KunjunganUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: KunjunganScalarWhereInput | KunjunganScalarWhereInput[]
  }

  export type HealthRecordUncheckedUpdateManyWithoutTenantNestedInput = {
    create?: XOR<HealthRecordCreateWithoutTenantInput, HealthRecordUncheckedCreateWithoutTenantInput> | HealthRecordCreateWithoutTenantInput[] | HealthRecordUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: HealthRecordCreateOrConnectWithoutTenantInput | HealthRecordCreateOrConnectWithoutTenantInput[]
    upsert?: HealthRecordUpsertWithWhereUniqueWithoutTenantInput | HealthRecordUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: HealthRecordCreateManyTenantInputEnvelope
    set?: HealthRecordWhereUniqueInput | HealthRecordWhereUniqueInput[]
    disconnect?: HealthRecordWhereUniqueInput | HealthRecordWhereUniqueInput[]
    delete?: HealthRecordWhereUniqueInput | HealthRecordWhereUniqueInput[]
    connect?: HealthRecordWhereUniqueInput | HealthRecordWhereUniqueInput[]
    update?: HealthRecordUpdateWithWhereUniqueWithoutTenantInput | HealthRecordUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: HealthRecordUpdateManyWithWhereWithoutTenantInput | HealthRecordUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: HealthRecordScalarWhereInput | HealthRecordScalarWhereInput[]
  }

  export type AuditLogUncheckedUpdateManyWithoutTenantNestedInput = {
    create?: XOR<AuditLogCreateWithoutTenantInput, AuditLogUncheckedCreateWithoutTenantInput> | AuditLogCreateWithoutTenantInput[] | AuditLogUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutTenantInput | AuditLogCreateOrConnectWithoutTenantInput[]
    upsert?: AuditLogUpsertWithWhereUniqueWithoutTenantInput | AuditLogUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: AuditLogCreateManyTenantInputEnvelope
    set?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    disconnect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    delete?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    update?: AuditLogUpdateWithWhereUniqueWithoutTenantInput | AuditLogUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: AuditLogUpdateManyWithWhereWithoutTenantInput | AuditLogUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
  }

  export type NotificationUncheckedUpdateManyWithoutTenantNestedInput = {
    create?: XOR<NotificationCreateWithoutTenantInput, NotificationUncheckedCreateWithoutTenantInput> | NotificationCreateWithoutTenantInput[] | NotificationUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutTenantInput | NotificationCreateOrConnectWithoutTenantInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutTenantInput | NotificationUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: NotificationCreateManyTenantInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutTenantInput | NotificationUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutTenantInput | NotificationUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type WebhookEventUncheckedUpdateManyWithoutTenantNestedInput = {
    create?: XOR<WebhookEventCreateWithoutTenantInput, WebhookEventUncheckedCreateWithoutTenantInput> | WebhookEventCreateWithoutTenantInput[] | WebhookEventUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: WebhookEventCreateOrConnectWithoutTenantInput | WebhookEventCreateOrConnectWithoutTenantInput[]
    upsert?: WebhookEventUpsertWithWhereUniqueWithoutTenantInput | WebhookEventUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: WebhookEventCreateManyTenantInputEnvelope
    set?: WebhookEventWhereUniqueInput | WebhookEventWhereUniqueInput[]
    disconnect?: WebhookEventWhereUniqueInput | WebhookEventWhereUniqueInput[]
    delete?: WebhookEventWhereUniqueInput | WebhookEventWhereUniqueInput[]
    connect?: WebhookEventWhereUniqueInput | WebhookEventWhereUniqueInput[]
    update?: WebhookEventUpdateWithWhereUniqueWithoutTenantInput | WebhookEventUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: WebhookEventUpdateManyWithWhereWithoutTenantInput | WebhookEventUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: WebhookEventScalarWhereInput | WebhookEventScalarWhereInput[]
  }

  export type TahfidzUncheckedUpdateManyWithoutTenantNestedInput = {
    create?: XOR<TahfidzCreateWithoutTenantInput, TahfidzUncheckedCreateWithoutTenantInput> | TahfidzCreateWithoutTenantInput[] | TahfidzUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: TahfidzCreateOrConnectWithoutTenantInput | TahfidzCreateOrConnectWithoutTenantInput[]
    upsert?: TahfidzUpsertWithWhereUniqueWithoutTenantInput | TahfidzUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: TahfidzCreateManyTenantInputEnvelope
    set?: TahfidzWhereUniqueInput | TahfidzWhereUniqueInput[]
    disconnect?: TahfidzWhereUniqueInput | TahfidzWhereUniqueInput[]
    delete?: TahfidzWhereUniqueInput | TahfidzWhereUniqueInput[]
    connect?: TahfidzWhereUniqueInput | TahfidzWhereUniqueInput[]
    update?: TahfidzUpdateWithWhereUniqueWithoutTenantInput | TahfidzUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: TahfidzUpdateManyWithWhereWithoutTenantInput | TahfidzUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: TahfidzScalarWhereInput | TahfidzScalarWhereInput[]
  }

  export type MutabaahUncheckedUpdateManyWithoutTenantNestedInput = {
    create?: XOR<MutabaahCreateWithoutTenantInput, MutabaahUncheckedCreateWithoutTenantInput> | MutabaahCreateWithoutTenantInput[] | MutabaahUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: MutabaahCreateOrConnectWithoutTenantInput | MutabaahCreateOrConnectWithoutTenantInput[]
    upsert?: MutabaahUpsertWithWhereUniqueWithoutTenantInput | MutabaahUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: MutabaahCreateManyTenantInputEnvelope
    set?: MutabaahWhereUniqueInput | MutabaahWhereUniqueInput[]
    disconnect?: MutabaahWhereUniqueInput | MutabaahWhereUniqueInput[]
    delete?: MutabaahWhereUniqueInput | MutabaahWhereUniqueInput[]
    connect?: MutabaahWhereUniqueInput | MutabaahWhereUniqueInput[]
    update?: MutabaahUpdateWithWhereUniqueWithoutTenantInput | MutabaahUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: MutabaahUpdateManyWithWhereWithoutTenantInput | MutabaahUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: MutabaahScalarWhereInput | MutabaahScalarWhereInput[]
  }

  export type WalletUncheckedUpdateManyWithoutTenantNestedInput = {
    create?: XOR<WalletCreateWithoutTenantInput, WalletUncheckedCreateWithoutTenantInput> | WalletCreateWithoutTenantInput[] | WalletUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: WalletCreateOrConnectWithoutTenantInput | WalletCreateOrConnectWithoutTenantInput[]
    upsert?: WalletUpsertWithWhereUniqueWithoutTenantInput | WalletUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: WalletCreateManyTenantInputEnvelope
    set?: WalletWhereUniqueInput | WalletWhereUniqueInput[]
    disconnect?: WalletWhereUniqueInput | WalletWhereUniqueInput[]
    delete?: WalletWhereUniqueInput | WalletWhereUniqueInput[]
    connect?: WalletWhereUniqueInput | WalletWhereUniqueInput[]
    update?: WalletUpdateWithWhereUniqueWithoutTenantInput | WalletUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: WalletUpdateManyWithWhereWithoutTenantInput | WalletUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: WalletScalarWhereInput | WalletScalarWhereInput[]
  }

  export type EmployeeUncheckedUpdateManyWithoutTenantNestedInput = {
    create?: XOR<EmployeeCreateWithoutTenantInput, EmployeeUncheckedCreateWithoutTenantInput> | EmployeeCreateWithoutTenantInput[] | EmployeeUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: EmployeeCreateOrConnectWithoutTenantInput | EmployeeCreateOrConnectWithoutTenantInput[]
    upsert?: EmployeeUpsertWithWhereUniqueWithoutTenantInput | EmployeeUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: EmployeeCreateManyTenantInputEnvelope
    set?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
    disconnect?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
    delete?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
    connect?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
    update?: EmployeeUpdateWithWhereUniqueWithoutTenantInput | EmployeeUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: EmployeeUpdateManyWithWhereWithoutTenantInput | EmployeeUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: EmployeeScalarWhereInput | EmployeeScalarWhereInput[]
  }

  export type PayrollUncheckedUpdateManyWithoutTenantNestedInput = {
    create?: XOR<PayrollCreateWithoutTenantInput, PayrollUncheckedCreateWithoutTenantInput> | PayrollCreateWithoutTenantInput[] | PayrollUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: PayrollCreateOrConnectWithoutTenantInput | PayrollCreateOrConnectWithoutTenantInput[]
    upsert?: PayrollUpsertWithWhereUniqueWithoutTenantInput | PayrollUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: PayrollCreateManyTenantInputEnvelope
    set?: PayrollWhereUniqueInput | PayrollWhereUniqueInput[]
    disconnect?: PayrollWhereUniqueInput | PayrollWhereUniqueInput[]
    delete?: PayrollWhereUniqueInput | PayrollWhereUniqueInput[]
    connect?: PayrollWhereUniqueInput | PayrollWhereUniqueInput[]
    update?: PayrollUpdateWithWhereUniqueWithoutTenantInput | PayrollUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: PayrollUpdateManyWithWhereWithoutTenantInput | PayrollUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: PayrollScalarWhereInput | PayrollScalarWhereInput[]
  }

  export type AcademicScheduleUncheckedUpdateManyWithoutTenantNestedInput = {
    create?: XOR<AcademicScheduleCreateWithoutTenantInput, AcademicScheduleUncheckedCreateWithoutTenantInput> | AcademicScheduleCreateWithoutTenantInput[] | AcademicScheduleUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: AcademicScheduleCreateOrConnectWithoutTenantInput | AcademicScheduleCreateOrConnectWithoutTenantInput[]
    upsert?: AcademicScheduleUpsertWithWhereUniqueWithoutTenantInput | AcademicScheduleUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: AcademicScheduleCreateManyTenantInputEnvelope
    set?: AcademicScheduleWhereUniqueInput | AcademicScheduleWhereUniqueInput[]
    disconnect?: AcademicScheduleWhereUniqueInput | AcademicScheduleWhereUniqueInput[]
    delete?: AcademicScheduleWhereUniqueInput | AcademicScheduleWhereUniqueInput[]
    connect?: AcademicScheduleWhereUniqueInput | AcademicScheduleWhereUniqueInput[]
    update?: AcademicScheduleUpdateWithWhereUniqueWithoutTenantInput | AcademicScheduleUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: AcademicScheduleUpdateManyWithWhereWithoutTenantInput | AcademicScheduleUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: AcademicScheduleScalarWhereInput | AcademicScheduleScalarWhereInput[]
  }

  export type AttendanceUncheckedUpdateManyWithoutTenantNestedInput = {
    create?: XOR<AttendanceCreateWithoutTenantInput, AttendanceUncheckedCreateWithoutTenantInput> | AttendanceCreateWithoutTenantInput[] | AttendanceUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: AttendanceCreateOrConnectWithoutTenantInput | AttendanceCreateOrConnectWithoutTenantInput[]
    upsert?: AttendanceUpsertWithWhereUniqueWithoutTenantInput | AttendanceUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: AttendanceCreateManyTenantInputEnvelope
    set?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
    disconnect?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
    delete?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
    connect?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
    update?: AttendanceUpdateWithWhereUniqueWithoutTenantInput | AttendanceUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: AttendanceUpdateManyWithWhereWithoutTenantInput | AttendanceUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: AttendanceScalarWhereInput | AttendanceScalarWhereInput[]
  }

  export type GradeUncheckedUpdateManyWithoutTenantNestedInput = {
    create?: XOR<GradeCreateWithoutTenantInput, GradeUncheckedCreateWithoutTenantInput> | GradeCreateWithoutTenantInput[] | GradeUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: GradeCreateOrConnectWithoutTenantInput | GradeCreateOrConnectWithoutTenantInput[]
    upsert?: GradeUpsertWithWhereUniqueWithoutTenantInput | GradeUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: GradeCreateManyTenantInputEnvelope
    set?: GradeWhereUniqueInput | GradeWhereUniqueInput[]
    disconnect?: GradeWhereUniqueInput | GradeWhereUniqueInput[]
    delete?: GradeWhereUniqueInput | GradeWhereUniqueInput[]
    connect?: GradeWhereUniqueInput | GradeWhereUniqueInput[]
    update?: GradeUpdateWithWhereUniqueWithoutTenantInput | GradeUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: GradeUpdateManyWithWhereWithoutTenantInput | GradeUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: GradeScalarWhereInput | GradeScalarWhereInput[]
  }

  export type PpdbRegistrationUncheckedUpdateManyWithoutTenantNestedInput = {
    create?: XOR<PpdbRegistrationCreateWithoutTenantInput, PpdbRegistrationUncheckedCreateWithoutTenantInput> | PpdbRegistrationCreateWithoutTenantInput[] | PpdbRegistrationUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: PpdbRegistrationCreateOrConnectWithoutTenantInput | PpdbRegistrationCreateOrConnectWithoutTenantInput[]
    upsert?: PpdbRegistrationUpsertWithWhereUniqueWithoutTenantInput | PpdbRegistrationUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: PpdbRegistrationCreateManyTenantInputEnvelope
    set?: PpdbRegistrationWhereUniqueInput | PpdbRegistrationWhereUniqueInput[]
    disconnect?: PpdbRegistrationWhereUniqueInput | PpdbRegistrationWhereUniqueInput[]
    delete?: PpdbRegistrationWhereUniqueInput | PpdbRegistrationWhereUniqueInput[]
    connect?: PpdbRegistrationWhereUniqueInput | PpdbRegistrationWhereUniqueInput[]
    update?: PpdbRegistrationUpdateWithWhereUniqueWithoutTenantInput | PpdbRegistrationUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: PpdbRegistrationUpdateManyWithWhereWithoutTenantInput | PpdbRegistrationUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: PpdbRegistrationScalarWhereInput | PpdbRegistrationScalarWhereInput[]
  }

  export type PpdbDocumentUncheckedUpdateManyWithoutTenantNestedInput = {
    create?: XOR<PpdbDocumentCreateWithoutTenantInput, PpdbDocumentUncheckedCreateWithoutTenantInput> | PpdbDocumentCreateWithoutTenantInput[] | PpdbDocumentUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: PpdbDocumentCreateOrConnectWithoutTenantInput | PpdbDocumentCreateOrConnectWithoutTenantInput[]
    upsert?: PpdbDocumentUpsertWithWhereUniqueWithoutTenantInput | PpdbDocumentUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: PpdbDocumentCreateManyTenantInputEnvelope
    set?: PpdbDocumentWhereUniqueInput | PpdbDocumentWhereUniqueInput[]
    disconnect?: PpdbDocumentWhereUniqueInput | PpdbDocumentWhereUniqueInput[]
    delete?: PpdbDocumentWhereUniqueInput | PpdbDocumentWhereUniqueInput[]
    connect?: PpdbDocumentWhereUniqueInput | PpdbDocumentWhereUniqueInput[]
    update?: PpdbDocumentUpdateWithWhereUniqueWithoutTenantInput | PpdbDocumentUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: PpdbDocumentUpdateManyWithWhereWithoutTenantInput | PpdbDocumentUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: PpdbDocumentScalarWhereInput | PpdbDocumentScalarWhereInput[]
  }

  export type PpdbExamUncheckedUpdateManyWithoutTenantNestedInput = {
    create?: XOR<PpdbExamCreateWithoutTenantInput, PpdbExamUncheckedCreateWithoutTenantInput> | PpdbExamCreateWithoutTenantInput[] | PpdbExamUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: PpdbExamCreateOrConnectWithoutTenantInput | PpdbExamCreateOrConnectWithoutTenantInput[]
    upsert?: PpdbExamUpsertWithWhereUniqueWithoutTenantInput | PpdbExamUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: PpdbExamCreateManyTenantInputEnvelope
    set?: PpdbExamWhereUniqueInput | PpdbExamWhereUniqueInput[]
    disconnect?: PpdbExamWhereUniqueInput | PpdbExamWhereUniqueInput[]
    delete?: PpdbExamWhereUniqueInput | PpdbExamWhereUniqueInput[]
    connect?: PpdbExamWhereUniqueInput | PpdbExamWhereUniqueInput[]
    update?: PpdbExamUpdateWithWhereUniqueWithoutTenantInput | PpdbExamUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: PpdbExamUpdateManyWithWhereWithoutTenantInput | PpdbExamUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: PpdbExamScalarWhereInput | PpdbExamScalarWhereInput[]
  }

  export type ItemUncheckedUpdateManyWithoutTenantNestedInput = {
    create?: XOR<ItemCreateWithoutTenantInput, ItemUncheckedCreateWithoutTenantInput> | ItemCreateWithoutTenantInput[] | ItemUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: ItemCreateOrConnectWithoutTenantInput | ItemCreateOrConnectWithoutTenantInput[]
    upsert?: ItemUpsertWithWhereUniqueWithoutTenantInput | ItemUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: ItemCreateManyTenantInputEnvelope
    set?: ItemWhereUniqueInput | ItemWhereUniqueInput[]
    disconnect?: ItemWhereUniqueInput | ItemWhereUniqueInput[]
    delete?: ItemWhereUniqueInput | ItemWhereUniqueInput[]
    connect?: ItemWhereUniqueInput | ItemWhereUniqueInput[]
    update?: ItemUpdateWithWhereUniqueWithoutTenantInput | ItemUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: ItemUpdateManyWithWhereWithoutTenantInput | ItemUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: ItemScalarWhereInput | ItemScalarWhereInput[]
  }

  export type InventoryTransactionUncheckedUpdateManyWithoutTenantNestedInput = {
    create?: XOR<InventoryTransactionCreateWithoutTenantInput, InventoryTransactionUncheckedCreateWithoutTenantInput> | InventoryTransactionCreateWithoutTenantInput[] | InventoryTransactionUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: InventoryTransactionCreateOrConnectWithoutTenantInput | InventoryTransactionCreateOrConnectWithoutTenantInput[]
    upsert?: InventoryTransactionUpsertWithWhereUniqueWithoutTenantInput | InventoryTransactionUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: InventoryTransactionCreateManyTenantInputEnvelope
    set?: InventoryTransactionWhereUniqueInput | InventoryTransactionWhereUniqueInput[]
    disconnect?: InventoryTransactionWhereUniqueInput | InventoryTransactionWhereUniqueInput[]
    delete?: InventoryTransactionWhereUniqueInput | InventoryTransactionWhereUniqueInput[]
    connect?: InventoryTransactionWhereUniqueInput | InventoryTransactionWhereUniqueInput[]
    update?: InventoryTransactionUpdateWithWhereUniqueWithoutTenantInput | InventoryTransactionUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: InventoryTransactionUpdateManyWithWhereWithoutTenantInput | InventoryTransactionUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: InventoryTransactionScalarWhereInput | InventoryTransactionScalarWhereInput[]
  }

  export type SupplierUncheckedUpdateManyWithoutTenantNestedInput = {
    create?: XOR<SupplierCreateWithoutTenantInput, SupplierUncheckedCreateWithoutTenantInput> | SupplierCreateWithoutTenantInput[] | SupplierUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: SupplierCreateOrConnectWithoutTenantInput | SupplierCreateOrConnectWithoutTenantInput[]
    upsert?: SupplierUpsertWithWhereUniqueWithoutTenantInput | SupplierUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: SupplierCreateManyTenantInputEnvelope
    set?: SupplierWhereUniqueInput | SupplierWhereUniqueInput[]
    disconnect?: SupplierWhereUniqueInput | SupplierWhereUniqueInput[]
    delete?: SupplierWhereUniqueInput | SupplierWhereUniqueInput[]
    connect?: SupplierWhereUniqueInput | SupplierWhereUniqueInput[]
    update?: SupplierUpdateWithWhereUniqueWithoutTenantInput | SupplierUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: SupplierUpdateManyWithWhereWithoutTenantInput | SupplierUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: SupplierScalarWhereInput | SupplierScalarWhereInput[]
  }

  export type PurchaseOrderUncheckedUpdateManyWithoutTenantNestedInput = {
    create?: XOR<PurchaseOrderCreateWithoutTenantInput, PurchaseOrderUncheckedCreateWithoutTenantInput> | PurchaseOrderCreateWithoutTenantInput[] | PurchaseOrderUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: PurchaseOrderCreateOrConnectWithoutTenantInput | PurchaseOrderCreateOrConnectWithoutTenantInput[]
    upsert?: PurchaseOrderUpsertWithWhereUniqueWithoutTenantInput | PurchaseOrderUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: PurchaseOrderCreateManyTenantInputEnvelope
    set?: PurchaseOrderWhereUniqueInput | PurchaseOrderWhereUniqueInput[]
    disconnect?: PurchaseOrderWhereUniqueInput | PurchaseOrderWhereUniqueInput[]
    delete?: PurchaseOrderWhereUniqueInput | PurchaseOrderWhereUniqueInput[]
    connect?: PurchaseOrderWhereUniqueInput | PurchaseOrderWhereUniqueInput[]
    update?: PurchaseOrderUpdateWithWhereUniqueWithoutTenantInput | PurchaseOrderUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: PurchaseOrderUpdateManyWithWhereWithoutTenantInput | PurchaseOrderUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: PurchaseOrderScalarWhereInput | PurchaseOrderScalarWhereInput[]
  }

  export type BuildingUncheckedUpdateManyWithoutTenantNestedInput = {
    create?: XOR<BuildingCreateWithoutTenantInput, BuildingUncheckedCreateWithoutTenantInput> | BuildingCreateWithoutTenantInput[] | BuildingUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: BuildingCreateOrConnectWithoutTenantInput | BuildingCreateOrConnectWithoutTenantInput[]
    upsert?: BuildingUpsertWithWhereUniqueWithoutTenantInput | BuildingUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: BuildingCreateManyTenantInputEnvelope
    set?: BuildingWhereUniqueInput | BuildingWhereUniqueInput[]
    disconnect?: BuildingWhereUniqueInput | BuildingWhereUniqueInput[]
    delete?: BuildingWhereUniqueInput | BuildingWhereUniqueInput[]
    connect?: BuildingWhereUniqueInput | BuildingWhereUniqueInput[]
    update?: BuildingUpdateWithWhereUniqueWithoutTenantInput | BuildingUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: BuildingUpdateManyWithWhereWithoutTenantInput | BuildingUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: BuildingScalarWhereInput | BuildingScalarWhereInput[]
  }

  export type RoomUncheckedUpdateManyWithoutTenantNestedInput = {
    create?: XOR<RoomCreateWithoutTenantInput, RoomUncheckedCreateWithoutTenantInput> | RoomCreateWithoutTenantInput[] | RoomUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: RoomCreateOrConnectWithoutTenantInput | RoomCreateOrConnectWithoutTenantInput[]
    upsert?: RoomUpsertWithWhereUniqueWithoutTenantInput | RoomUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: RoomCreateManyTenantInputEnvelope
    set?: RoomWhereUniqueInput | RoomWhereUniqueInput[]
    disconnect?: RoomWhereUniqueInput | RoomWhereUniqueInput[]
    delete?: RoomWhereUniqueInput | RoomWhereUniqueInput[]
    connect?: RoomWhereUniqueInput | RoomWhereUniqueInput[]
    update?: RoomUpdateWithWhereUniqueWithoutTenantInput | RoomUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: RoomUpdateManyWithWhereWithoutTenantInput | RoomUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: RoomScalarWhereInput | RoomScalarWhereInput[]
  }

  export type RoomAssignmentUncheckedUpdateManyWithoutTenantNestedInput = {
    create?: XOR<RoomAssignmentCreateWithoutTenantInput, RoomAssignmentUncheckedCreateWithoutTenantInput> | RoomAssignmentCreateWithoutTenantInput[] | RoomAssignmentUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: RoomAssignmentCreateOrConnectWithoutTenantInput | RoomAssignmentCreateOrConnectWithoutTenantInput[]
    upsert?: RoomAssignmentUpsertWithWhereUniqueWithoutTenantInput | RoomAssignmentUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: RoomAssignmentCreateManyTenantInputEnvelope
    set?: RoomAssignmentWhereUniqueInput | RoomAssignmentWhereUniqueInput[]
    disconnect?: RoomAssignmentWhereUniqueInput | RoomAssignmentWhereUniqueInput[]
    delete?: RoomAssignmentWhereUniqueInput | RoomAssignmentWhereUniqueInput[]
    connect?: RoomAssignmentWhereUniqueInput | RoomAssignmentWhereUniqueInput[]
    update?: RoomAssignmentUpdateWithWhereUniqueWithoutTenantInput | RoomAssignmentUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: RoomAssignmentUpdateManyWithWhereWithoutTenantInput | RoomAssignmentUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: RoomAssignmentScalarWhereInput | RoomAssignmentScalarWhereInput[]
  }

  export type MaintenanceTicketUncheckedUpdateManyWithoutTenantNestedInput = {
    create?: XOR<MaintenanceTicketCreateWithoutTenantInput, MaintenanceTicketUncheckedCreateWithoutTenantInput> | MaintenanceTicketCreateWithoutTenantInput[] | MaintenanceTicketUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: MaintenanceTicketCreateOrConnectWithoutTenantInput | MaintenanceTicketCreateOrConnectWithoutTenantInput[]
    upsert?: MaintenanceTicketUpsertWithWhereUniqueWithoutTenantInput | MaintenanceTicketUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: MaintenanceTicketCreateManyTenantInputEnvelope
    set?: MaintenanceTicketWhereUniqueInput | MaintenanceTicketWhereUniqueInput[]
    disconnect?: MaintenanceTicketWhereUniqueInput | MaintenanceTicketWhereUniqueInput[]
    delete?: MaintenanceTicketWhereUniqueInput | MaintenanceTicketWhereUniqueInput[]
    connect?: MaintenanceTicketWhereUniqueInput | MaintenanceTicketWhereUniqueInput[]
    update?: MaintenanceTicketUpdateWithWhereUniqueWithoutTenantInput | MaintenanceTicketUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: MaintenanceTicketUpdateManyWithWhereWithoutTenantInput | MaintenanceTicketUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: MaintenanceTicketScalarWhereInput | MaintenanceTicketScalarWhereInput[]
  }

  export type TenantCreateNestedOneWithoutUsersInput = {
    create?: XOR<TenantCreateWithoutUsersInput, TenantUncheckedCreateWithoutUsersInput>
    connectOrCreate?: TenantCreateOrConnectWithoutUsersInput
    connect?: TenantWhereUniqueInput
  }

  export type RefreshTokenCreateNestedManyWithoutUserInput = {
    create?: XOR<RefreshTokenCreateWithoutUserInput, RefreshTokenUncheckedCreateWithoutUserInput> | RefreshTokenCreateWithoutUserInput[] | RefreshTokenUncheckedCreateWithoutUserInput[]
    connectOrCreate?: RefreshTokenCreateOrConnectWithoutUserInput | RefreshTokenCreateOrConnectWithoutUserInput[]
    createMany?: RefreshTokenCreateManyUserInputEnvelope
    connect?: RefreshTokenWhereUniqueInput | RefreshTokenWhereUniqueInput[]
  }

  export type AuditLogCreateNestedManyWithoutUserInput = {
    create?: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput> | AuditLogCreateWithoutUserInput[] | AuditLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutUserInput | AuditLogCreateOrConnectWithoutUserInput[]
    createMany?: AuditLogCreateManyUserInputEnvelope
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
  }

  export type NotificationCreateNestedManyWithoutUserInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type RefreshTokenUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<RefreshTokenCreateWithoutUserInput, RefreshTokenUncheckedCreateWithoutUserInput> | RefreshTokenCreateWithoutUserInput[] | RefreshTokenUncheckedCreateWithoutUserInput[]
    connectOrCreate?: RefreshTokenCreateOrConnectWithoutUserInput | RefreshTokenCreateOrConnectWithoutUserInput[]
    createMany?: RefreshTokenCreateManyUserInputEnvelope
    connect?: RefreshTokenWhereUniqueInput | RefreshTokenWhereUniqueInput[]
  }

  export type AuditLogUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput> | AuditLogCreateWithoutUserInput[] | AuditLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutUserInput | AuditLogCreateOrConnectWithoutUserInput[]
    createMany?: AuditLogCreateManyUserInputEnvelope
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
  }

  export type NotificationUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type TenantUpdateOneWithoutUsersNestedInput = {
    create?: XOR<TenantCreateWithoutUsersInput, TenantUncheckedCreateWithoutUsersInput>
    connectOrCreate?: TenantCreateOrConnectWithoutUsersInput
    upsert?: TenantUpsertWithoutUsersInput
    disconnect?: TenantWhereInput | boolean
    delete?: TenantWhereInput | boolean
    connect?: TenantWhereUniqueInput
    update?: XOR<XOR<TenantUpdateToOneWithWhereWithoutUsersInput, TenantUpdateWithoutUsersInput>, TenantUncheckedUpdateWithoutUsersInput>
  }

  export type RefreshTokenUpdateManyWithoutUserNestedInput = {
    create?: XOR<RefreshTokenCreateWithoutUserInput, RefreshTokenUncheckedCreateWithoutUserInput> | RefreshTokenCreateWithoutUserInput[] | RefreshTokenUncheckedCreateWithoutUserInput[]
    connectOrCreate?: RefreshTokenCreateOrConnectWithoutUserInput | RefreshTokenCreateOrConnectWithoutUserInput[]
    upsert?: RefreshTokenUpsertWithWhereUniqueWithoutUserInput | RefreshTokenUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: RefreshTokenCreateManyUserInputEnvelope
    set?: RefreshTokenWhereUniqueInput | RefreshTokenWhereUniqueInput[]
    disconnect?: RefreshTokenWhereUniqueInput | RefreshTokenWhereUniqueInput[]
    delete?: RefreshTokenWhereUniqueInput | RefreshTokenWhereUniqueInput[]
    connect?: RefreshTokenWhereUniqueInput | RefreshTokenWhereUniqueInput[]
    update?: RefreshTokenUpdateWithWhereUniqueWithoutUserInput | RefreshTokenUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: RefreshTokenUpdateManyWithWhereWithoutUserInput | RefreshTokenUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: RefreshTokenScalarWhereInput | RefreshTokenScalarWhereInput[]
  }

  export type AuditLogUpdateManyWithoutUserNestedInput = {
    create?: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput> | AuditLogCreateWithoutUserInput[] | AuditLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutUserInput | AuditLogCreateOrConnectWithoutUserInput[]
    upsert?: AuditLogUpsertWithWhereUniqueWithoutUserInput | AuditLogUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AuditLogCreateManyUserInputEnvelope
    set?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    disconnect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    delete?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    update?: AuditLogUpdateWithWhereUniqueWithoutUserInput | AuditLogUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AuditLogUpdateManyWithWhereWithoutUserInput | AuditLogUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
  }

  export type NotificationUpdateManyWithoutUserNestedInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutUserInput | NotificationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutUserInput | NotificationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutUserInput | NotificationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type RefreshTokenUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<RefreshTokenCreateWithoutUserInput, RefreshTokenUncheckedCreateWithoutUserInput> | RefreshTokenCreateWithoutUserInput[] | RefreshTokenUncheckedCreateWithoutUserInput[]
    connectOrCreate?: RefreshTokenCreateOrConnectWithoutUserInput | RefreshTokenCreateOrConnectWithoutUserInput[]
    upsert?: RefreshTokenUpsertWithWhereUniqueWithoutUserInput | RefreshTokenUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: RefreshTokenCreateManyUserInputEnvelope
    set?: RefreshTokenWhereUniqueInput | RefreshTokenWhereUniqueInput[]
    disconnect?: RefreshTokenWhereUniqueInput | RefreshTokenWhereUniqueInput[]
    delete?: RefreshTokenWhereUniqueInput | RefreshTokenWhereUniqueInput[]
    connect?: RefreshTokenWhereUniqueInput | RefreshTokenWhereUniqueInput[]
    update?: RefreshTokenUpdateWithWhereUniqueWithoutUserInput | RefreshTokenUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: RefreshTokenUpdateManyWithWhereWithoutUserInput | RefreshTokenUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: RefreshTokenScalarWhereInput | RefreshTokenScalarWhereInput[]
  }

  export type AuditLogUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput> | AuditLogCreateWithoutUserInput[] | AuditLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutUserInput | AuditLogCreateOrConnectWithoutUserInput[]
    upsert?: AuditLogUpsertWithWhereUniqueWithoutUserInput | AuditLogUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AuditLogCreateManyUserInputEnvelope
    set?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    disconnect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    delete?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    update?: AuditLogUpdateWithWhereUniqueWithoutUserInput | AuditLogUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AuditLogUpdateManyWithWhereWithoutUserInput | AuditLogUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
  }

  export type NotificationUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutUserInput | NotificationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutUserInput | NotificationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutUserInput | NotificationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutRefreshTokensInput = {
    create?: XOR<UserCreateWithoutRefreshTokensInput, UserUncheckedCreateWithoutRefreshTokensInput>
    connectOrCreate?: UserCreateOrConnectWithoutRefreshTokensInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutRefreshTokensNestedInput = {
    create?: XOR<UserCreateWithoutRefreshTokensInput, UserUncheckedCreateWithoutRefreshTokensInput>
    connectOrCreate?: UserCreateOrConnectWithoutRefreshTokensInput
    upsert?: UserUpsertWithoutRefreshTokensInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutRefreshTokensInput, UserUpdateWithoutRefreshTokensInput>, UserUncheckedUpdateWithoutRefreshTokensInput>
  }

  export type TenantCreateNestedOneWithoutSantriInput = {
    create?: XOR<TenantCreateWithoutSantriInput, TenantUncheckedCreateWithoutSantriInput>
    connectOrCreate?: TenantCreateOrConnectWithoutSantriInput
    connect?: TenantWhereUniqueInput
  }

  export type SantriWaliCreateNestedManyWithoutSantriInput = {
    create?: XOR<SantriWaliCreateWithoutSantriInput, SantriWaliUncheckedCreateWithoutSantriInput> | SantriWaliCreateWithoutSantriInput[] | SantriWaliUncheckedCreateWithoutSantriInput[]
    connectOrCreate?: SantriWaliCreateOrConnectWithoutSantriInput | SantriWaliCreateOrConnectWithoutSantriInput[]
    createMany?: SantriWaliCreateManySantriInputEnvelope
    connect?: SantriWaliWhereUniqueInput | SantriWaliWhereUniqueInput[]
  }

  export type IzinCreateNestedManyWithoutSantriInput = {
    create?: XOR<IzinCreateWithoutSantriInput, IzinUncheckedCreateWithoutSantriInput> | IzinCreateWithoutSantriInput[] | IzinUncheckedCreateWithoutSantriInput[]
    connectOrCreate?: IzinCreateOrConnectWithoutSantriInput | IzinCreateOrConnectWithoutSantriInput[]
    createMany?: IzinCreateManySantriInputEnvelope
    connect?: IzinWhereUniqueInput | IzinWhereUniqueInput[]
  }

  export type CatatanHarianCreateNestedManyWithoutSantriInput = {
    create?: XOR<CatatanHarianCreateWithoutSantriInput, CatatanHarianUncheckedCreateWithoutSantriInput> | CatatanHarianCreateWithoutSantriInput[] | CatatanHarianUncheckedCreateWithoutSantriInput[]
    connectOrCreate?: CatatanHarianCreateOrConnectWithoutSantriInput | CatatanHarianCreateOrConnectWithoutSantriInput[]
    createMany?: CatatanHarianCreateManySantriInputEnvelope
    connect?: CatatanHarianWhereUniqueInput | CatatanHarianWhereUniqueInput[]
  }

  export type InvoiceCreateNestedManyWithoutSantriInput = {
    create?: XOR<InvoiceCreateWithoutSantriInput, InvoiceUncheckedCreateWithoutSantriInput> | InvoiceCreateWithoutSantriInput[] | InvoiceUncheckedCreateWithoutSantriInput[]
    connectOrCreate?: InvoiceCreateOrConnectWithoutSantriInput | InvoiceCreateOrConnectWithoutSantriInput[]
    createMany?: InvoiceCreateManySantriInputEnvelope
    connect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
  }

  export type PelanggaranCreateNestedManyWithoutSantriInput = {
    create?: XOR<PelanggaranCreateWithoutSantriInput, PelanggaranUncheckedCreateWithoutSantriInput> | PelanggaranCreateWithoutSantriInput[] | PelanggaranUncheckedCreateWithoutSantriInput[]
    connectOrCreate?: PelanggaranCreateOrConnectWithoutSantriInput | PelanggaranCreateOrConnectWithoutSantriInput[]
    createMany?: PelanggaranCreateManySantriInputEnvelope
    connect?: PelanggaranWhereUniqueInput | PelanggaranWhereUniqueInput[]
  }

  export type PembinaanCreateNestedManyWithoutSantriInput = {
    create?: XOR<PembinaanCreateWithoutSantriInput, PembinaanUncheckedCreateWithoutSantriInput> | PembinaanCreateWithoutSantriInput[] | PembinaanUncheckedCreateWithoutSantriInput[]
    connectOrCreate?: PembinaanCreateOrConnectWithoutSantriInput | PembinaanCreateOrConnectWithoutSantriInput[]
    createMany?: PembinaanCreateManySantriInputEnvelope
    connect?: PembinaanWhereUniqueInput | PembinaanWhereUniqueInput[]
  }

  export type KunjunganCreateNestedManyWithoutSantriInput = {
    create?: XOR<KunjunganCreateWithoutSantriInput, KunjunganUncheckedCreateWithoutSantriInput> | KunjunganCreateWithoutSantriInput[] | KunjunganUncheckedCreateWithoutSantriInput[]
    connectOrCreate?: KunjunganCreateOrConnectWithoutSantriInput | KunjunganCreateOrConnectWithoutSantriInput[]
    createMany?: KunjunganCreateManySantriInputEnvelope
    connect?: KunjunganWhereUniqueInput | KunjunganWhereUniqueInput[]
  }

  export type HealthRecordCreateNestedManyWithoutSantriInput = {
    create?: XOR<HealthRecordCreateWithoutSantriInput, HealthRecordUncheckedCreateWithoutSantriInput> | HealthRecordCreateWithoutSantriInput[] | HealthRecordUncheckedCreateWithoutSantriInput[]
    connectOrCreate?: HealthRecordCreateOrConnectWithoutSantriInput | HealthRecordCreateOrConnectWithoutSantriInput[]
    createMany?: HealthRecordCreateManySantriInputEnvelope
    connect?: HealthRecordWhereUniqueInput | HealthRecordWhereUniqueInput[]
  }

  export type MedicationCreateNestedManyWithoutSantriInput = {
    create?: XOR<MedicationCreateWithoutSantriInput, MedicationUncheckedCreateWithoutSantriInput> | MedicationCreateWithoutSantriInput[] | MedicationUncheckedCreateWithoutSantriInput[]
    connectOrCreate?: MedicationCreateOrConnectWithoutSantriInput | MedicationCreateOrConnectWithoutSantriInput[]
    createMany?: MedicationCreateManySantriInputEnvelope
    connect?: MedicationWhereUniqueInput | MedicationWhereUniqueInput[]
  }

  export type TahfidzCreateNestedManyWithoutSantriInput = {
    create?: XOR<TahfidzCreateWithoutSantriInput, TahfidzUncheckedCreateWithoutSantriInput> | TahfidzCreateWithoutSantriInput[] | TahfidzUncheckedCreateWithoutSantriInput[]
    connectOrCreate?: TahfidzCreateOrConnectWithoutSantriInput | TahfidzCreateOrConnectWithoutSantriInput[]
    createMany?: TahfidzCreateManySantriInputEnvelope
    connect?: TahfidzWhereUniqueInput | TahfidzWhereUniqueInput[]
  }

  export type MutabaahCreateNestedManyWithoutSantriInput = {
    create?: XOR<MutabaahCreateWithoutSantriInput, MutabaahUncheckedCreateWithoutSantriInput> | MutabaahCreateWithoutSantriInput[] | MutabaahUncheckedCreateWithoutSantriInput[]
    connectOrCreate?: MutabaahCreateOrConnectWithoutSantriInput | MutabaahCreateOrConnectWithoutSantriInput[]
    createMany?: MutabaahCreateManySantriInputEnvelope
    connect?: MutabaahWhereUniqueInput | MutabaahWhereUniqueInput[]
  }

  export type WalletCreateNestedOneWithoutSantriInput = {
    create?: XOR<WalletCreateWithoutSantriInput, WalletUncheckedCreateWithoutSantriInput>
    connectOrCreate?: WalletCreateOrConnectWithoutSantriInput
    connect?: WalletWhereUniqueInput
  }

  export type AttendanceCreateNestedManyWithoutSantriInput = {
    create?: XOR<AttendanceCreateWithoutSantriInput, AttendanceUncheckedCreateWithoutSantriInput> | AttendanceCreateWithoutSantriInput[] | AttendanceUncheckedCreateWithoutSantriInput[]
    connectOrCreate?: AttendanceCreateOrConnectWithoutSantriInput | AttendanceCreateOrConnectWithoutSantriInput[]
    createMany?: AttendanceCreateManySantriInputEnvelope
    connect?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
  }

  export type GradeCreateNestedManyWithoutSantriInput = {
    create?: XOR<GradeCreateWithoutSantriInput, GradeUncheckedCreateWithoutSantriInput> | GradeCreateWithoutSantriInput[] | GradeUncheckedCreateWithoutSantriInput[]
    connectOrCreate?: GradeCreateOrConnectWithoutSantriInput | GradeCreateOrConnectWithoutSantriInput[]
    createMany?: GradeCreateManySantriInputEnvelope
    connect?: GradeWhereUniqueInput | GradeWhereUniqueInput[]
  }

  export type SantriWaliUncheckedCreateNestedManyWithoutSantriInput = {
    create?: XOR<SantriWaliCreateWithoutSantriInput, SantriWaliUncheckedCreateWithoutSantriInput> | SantriWaliCreateWithoutSantriInput[] | SantriWaliUncheckedCreateWithoutSantriInput[]
    connectOrCreate?: SantriWaliCreateOrConnectWithoutSantriInput | SantriWaliCreateOrConnectWithoutSantriInput[]
    createMany?: SantriWaliCreateManySantriInputEnvelope
    connect?: SantriWaliWhereUniqueInput | SantriWaliWhereUniqueInput[]
  }

  export type IzinUncheckedCreateNestedManyWithoutSantriInput = {
    create?: XOR<IzinCreateWithoutSantriInput, IzinUncheckedCreateWithoutSantriInput> | IzinCreateWithoutSantriInput[] | IzinUncheckedCreateWithoutSantriInput[]
    connectOrCreate?: IzinCreateOrConnectWithoutSantriInput | IzinCreateOrConnectWithoutSantriInput[]
    createMany?: IzinCreateManySantriInputEnvelope
    connect?: IzinWhereUniqueInput | IzinWhereUniqueInput[]
  }

  export type CatatanHarianUncheckedCreateNestedManyWithoutSantriInput = {
    create?: XOR<CatatanHarianCreateWithoutSantriInput, CatatanHarianUncheckedCreateWithoutSantriInput> | CatatanHarianCreateWithoutSantriInput[] | CatatanHarianUncheckedCreateWithoutSantriInput[]
    connectOrCreate?: CatatanHarianCreateOrConnectWithoutSantriInput | CatatanHarianCreateOrConnectWithoutSantriInput[]
    createMany?: CatatanHarianCreateManySantriInputEnvelope
    connect?: CatatanHarianWhereUniqueInput | CatatanHarianWhereUniqueInput[]
  }

  export type InvoiceUncheckedCreateNestedManyWithoutSantriInput = {
    create?: XOR<InvoiceCreateWithoutSantriInput, InvoiceUncheckedCreateWithoutSantriInput> | InvoiceCreateWithoutSantriInput[] | InvoiceUncheckedCreateWithoutSantriInput[]
    connectOrCreate?: InvoiceCreateOrConnectWithoutSantriInput | InvoiceCreateOrConnectWithoutSantriInput[]
    createMany?: InvoiceCreateManySantriInputEnvelope
    connect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
  }

  export type PelanggaranUncheckedCreateNestedManyWithoutSantriInput = {
    create?: XOR<PelanggaranCreateWithoutSantriInput, PelanggaranUncheckedCreateWithoutSantriInput> | PelanggaranCreateWithoutSantriInput[] | PelanggaranUncheckedCreateWithoutSantriInput[]
    connectOrCreate?: PelanggaranCreateOrConnectWithoutSantriInput | PelanggaranCreateOrConnectWithoutSantriInput[]
    createMany?: PelanggaranCreateManySantriInputEnvelope
    connect?: PelanggaranWhereUniqueInput | PelanggaranWhereUniqueInput[]
  }

  export type PembinaanUncheckedCreateNestedManyWithoutSantriInput = {
    create?: XOR<PembinaanCreateWithoutSantriInput, PembinaanUncheckedCreateWithoutSantriInput> | PembinaanCreateWithoutSantriInput[] | PembinaanUncheckedCreateWithoutSantriInput[]
    connectOrCreate?: PembinaanCreateOrConnectWithoutSantriInput | PembinaanCreateOrConnectWithoutSantriInput[]
    createMany?: PembinaanCreateManySantriInputEnvelope
    connect?: PembinaanWhereUniqueInput | PembinaanWhereUniqueInput[]
  }

  export type KunjunganUncheckedCreateNestedManyWithoutSantriInput = {
    create?: XOR<KunjunganCreateWithoutSantriInput, KunjunganUncheckedCreateWithoutSantriInput> | KunjunganCreateWithoutSantriInput[] | KunjunganUncheckedCreateWithoutSantriInput[]
    connectOrCreate?: KunjunganCreateOrConnectWithoutSantriInput | KunjunganCreateOrConnectWithoutSantriInput[]
    createMany?: KunjunganCreateManySantriInputEnvelope
    connect?: KunjunganWhereUniqueInput | KunjunganWhereUniqueInput[]
  }

  export type HealthRecordUncheckedCreateNestedManyWithoutSantriInput = {
    create?: XOR<HealthRecordCreateWithoutSantriInput, HealthRecordUncheckedCreateWithoutSantriInput> | HealthRecordCreateWithoutSantriInput[] | HealthRecordUncheckedCreateWithoutSantriInput[]
    connectOrCreate?: HealthRecordCreateOrConnectWithoutSantriInput | HealthRecordCreateOrConnectWithoutSantriInput[]
    createMany?: HealthRecordCreateManySantriInputEnvelope
    connect?: HealthRecordWhereUniqueInput | HealthRecordWhereUniqueInput[]
  }

  export type MedicationUncheckedCreateNestedManyWithoutSantriInput = {
    create?: XOR<MedicationCreateWithoutSantriInput, MedicationUncheckedCreateWithoutSantriInput> | MedicationCreateWithoutSantriInput[] | MedicationUncheckedCreateWithoutSantriInput[]
    connectOrCreate?: MedicationCreateOrConnectWithoutSantriInput | MedicationCreateOrConnectWithoutSantriInput[]
    createMany?: MedicationCreateManySantriInputEnvelope
    connect?: MedicationWhereUniqueInput | MedicationWhereUniqueInput[]
  }

  export type TahfidzUncheckedCreateNestedManyWithoutSantriInput = {
    create?: XOR<TahfidzCreateWithoutSantriInput, TahfidzUncheckedCreateWithoutSantriInput> | TahfidzCreateWithoutSantriInput[] | TahfidzUncheckedCreateWithoutSantriInput[]
    connectOrCreate?: TahfidzCreateOrConnectWithoutSantriInput | TahfidzCreateOrConnectWithoutSantriInput[]
    createMany?: TahfidzCreateManySantriInputEnvelope
    connect?: TahfidzWhereUniqueInput | TahfidzWhereUniqueInput[]
  }

  export type MutabaahUncheckedCreateNestedManyWithoutSantriInput = {
    create?: XOR<MutabaahCreateWithoutSantriInput, MutabaahUncheckedCreateWithoutSantriInput> | MutabaahCreateWithoutSantriInput[] | MutabaahUncheckedCreateWithoutSantriInput[]
    connectOrCreate?: MutabaahCreateOrConnectWithoutSantriInput | MutabaahCreateOrConnectWithoutSantriInput[]
    createMany?: MutabaahCreateManySantriInputEnvelope
    connect?: MutabaahWhereUniqueInput | MutabaahWhereUniqueInput[]
  }

  export type WalletUncheckedCreateNestedOneWithoutSantriInput = {
    create?: XOR<WalletCreateWithoutSantriInput, WalletUncheckedCreateWithoutSantriInput>
    connectOrCreate?: WalletCreateOrConnectWithoutSantriInput
    connect?: WalletWhereUniqueInput
  }

  export type AttendanceUncheckedCreateNestedManyWithoutSantriInput = {
    create?: XOR<AttendanceCreateWithoutSantriInput, AttendanceUncheckedCreateWithoutSantriInput> | AttendanceCreateWithoutSantriInput[] | AttendanceUncheckedCreateWithoutSantriInput[]
    connectOrCreate?: AttendanceCreateOrConnectWithoutSantriInput | AttendanceCreateOrConnectWithoutSantriInput[]
    createMany?: AttendanceCreateManySantriInputEnvelope
    connect?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
  }

  export type GradeUncheckedCreateNestedManyWithoutSantriInput = {
    create?: XOR<GradeCreateWithoutSantriInput, GradeUncheckedCreateWithoutSantriInput> | GradeCreateWithoutSantriInput[] | GradeUncheckedCreateWithoutSantriInput[]
    connectOrCreate?: GradeCreateOrConnectWithoutSantriInput | GradeCreateOrConnectWithoutSantriInput[]
    createMany?: GradeCreateManySantriInputEnvelope
    connect?: GradeWhereUniqueInput | GradeWhereUniqueInput[]
  }

  export type TenantUpdateOneRequiredWithoutSantriNestedInput = {
    create?: XOR<TenantCreateWithoutSantriInput, TenantUncheckedCreateWithoutSantriInput>
    connectOrCreate?: TenantCreateOrConnectWithoutSantriInput
    upsert?: TenantUpsertWithoutSantriInput
    connect?: TenantWhereUniqueInput
    update?: XOR<XOR<TenantUpdateToOneWithWhereWithoutSantriInput, TenantUpdateWithoutSantriInput>, TenantUncheckedUpdateWithoutSantriInput>
  }

  export type SantriWaliUpdateManyWithoutSantriNestedInput = {
    create?: XOR<SantriWaliCreateWithoutSantriInput, SantriWaliUncheckedCreateWithoutSantriInput> | SantriWaliCreateWithoutSantriInput[] | SantriWaliUncheckedCreateWithoutSantriInput[]
    connectOrCreate?: SantriWaliCreateOrConnectWithoutSantriInput | SantriWaliCreateOrConnectWithoutSantriInput[]
    upsert?: SantriWaliUpsertWithWhereUniqueWithoutSantriInput | SantriWaliUpsertWithWhereUniqueWithoutSantriInput[]
    createMany?: SantriWaliCreateManySantriInputEnvelope
    set?: SantriWaliWhereUniqueInput | SantriWaliWhereUniqueInput[]
    disconnect?: SantriWaliWhereUniqueInput | SantriWaliWhereUniqueInput[]
    delete?: SantriWaliWhereUniqueInput | SantriWaliWhereUniqueInput[]
    connect?: SantriWaliWhereUniqueInput | SantriWaliWhereUniqueInput[]
    update?: SantriWaliUpdateWithWhereUniqueWithoutSantriInput | SantriWaliUpdateWithWhereUniqueWithoutSantriInput[]
    updateMany?: SantriWaliUpdateManyWithWhereWithoutSantriInput | SantriWaliUpdateManyWithWhereWithoutSantriInput[]
    deleteMany?: SantriWaliScalarWhereInput | SantriWaliScalarWhereInput[]
  }

  export type IzinUpdateManyWithoutSantriNestedInput = {
    create?: XOR<IzinCreateWithoutSantriInput, IzinUncheckedCreateWithoutSantriInput> | IzinCreateWithoutSantriInput[] | IzinUncheckedCreateWithoutSantriInput[]
    connectOrCreate?: IzinCreateOrConnectWithoutSantriInput | IzinCreateOrConnectWithoutSantriInput[]
    upsert?: IzinUpsertWithWhereUniqueWithoutSantriInput | IzinUpsertWithWhereUniqueWithoutSantriInput[]
    createMany?: IzinCreateManySantriInputEnvelope
    set?: IzinWhereUniqueInput | IzinWhereUniqueInput[]
    disconnect?: IzinWhereUniqueInput | IzinWhereUniqueInput[]
    delete?: IzinWhereUniqueInput | IzinWhereUniqueInput[]
    connect?: IzinWhereUniqueInput | IzinWhereUniqueInput[]
    update?: IzinUpdateWithWhereUniqueWithoutSantriInput | IzinUpdateWithWhereUniqueWithoutSantriInput[]
    updateMany?: IzinUpdateManyWithWhereWithoutSantriInput | IzinUpdateManyWithWhereWithoutSantriInput[]
    deleteMany?: IzinScalarWhereInput | IzinScalarWhereInput[]
  }

  export type CatatanHarianUpdateManyWithoutSantriNestedInput = {
    create?: XOR<CatatanHarianCreateWithoutSantriInput, CatatanHarianUncheckedCreateWithoutSantriInput> | CatatanHarianCreateWithoutSantriInput[] | CatatanHarianUncheckedCreateWithoutSantriInput[]
    connectOrCreate?: CatatanHarianCreateOrConnectWithoutSantriInput | CatatanHarianCreateOrConnectWithoutSantriInput[]
    upsert?: CatatanHarianUpsertWithWhereUniqueWithoutSantriInput | CatatanHarianUpsertWithWhereUniqueWithoutSantriInput[]
    createMany?: CatatanHarianCreateManySantriInputEnvelope
    set?: CatatanHarianWhereUniqueInput | CatatanHarianWhereUniqueInput[]
    disconnect?: CatatanHarianWhereUniqueInput | CatatanHarianWhereUniqueInput[]
    delete?: CatatanHarianWhereUniqueInput | CatatanHarianWhereUniqueInput[]
    connect?: CatatanHarianWhereUniqueInput | CatatanHarianWhereUniqueInput[]
    update?: CatatanHarianUpdateWithWhereUniqueWithoutSantriInput | CatatanHarianUpdateWithWhereUniqueWithoutSantriInput[]
    updateMany?: CatatanHarianUpdateManyWithWhereWithoutSantriInput | CatatanHarianUpdateManyWithWhereWithoutSantriInput[]
    deleteMany?: CatatanHarianScalarWhereInput | CatatanHarianScalarWhereInput[]
  }

  export type InvoiceUpdateManyWithoutSantriNestedInput = {
    create?: XOR<InvoiceCreateWithoutSantriInput, InvoiceUncheckedCreateWithoutSantriInput> | InvoiceCreateWithoutSantriInput[] | InvoiceUncheckedCreateWithoutSantriInput[]
    connectOrCreate?: InvoiceCreateOrConnectWithoutSantriInput | InvoiceCreateOrConnectWithoutSantriInput[]
    upsert?: InvoiceUpsertWithWhereUniqueWithoutSantriInput | InvoiceUpsertWithWhereUniqueWithoutSantriInput[]
    createMany?: InvoiceCreateManySantriInputEnvelope
    set?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    disconnect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    delete?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    connect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    update?: InvoiceUpdateWithWhereUniqueWithoutSantriInput | InvoiceUpdateWithWhereUniqueWithoutSantriInput[]
    updateMany?: InvoiceUpdateManyWithWhereWithoutSantriInput | InvoiceUpdateManyWithWhereWithoutSantriInput[]
    deleteMany?: InvoiceScalarWhereInput | InvoiceScalarWhereInput[]
  }

  export type PelanggaranUpdateManyWithoutSantriNestedInput = {
    create?: XOR<PelanggaranCreateWithoutSantriInput, PelanggaranUncheckedCreateWithoutSantriInput> | PelanggaranCreateWithoutSantriInput[] | PelanggaranUncheckedCreateWithoutSantriInput[]
    connectOrCreate?: PelanggaranCreateOrConnectWithoutSantriInput | PelanggaranCreateOrConnectWithoutSantriInput[]
    upsert?: PelanggaranUpsertWithWhereUniqueWithoutSantriInput | PelanggaranUpsertWithWhereUniqueWithoutSantriInput[]
    createMany?: PelanggaranCreateManySantriInputEnvelope
    set?: PelanggaranWhereUniqueInput | PelanggaranWhereUniqueInput[]
    disconnect?: PelanggaranWhereUniqueInput | PelanggaranWhereUniqueInput[]
    delete?: PelanggaranWhereUniqueInput | PelanggaranWhereUniqueInput[]
    connect?: PelanggaranWhereUniqueInput | PelanggaranWhereUniqueInput[]
    update?: PelanggaranUpdateWithWhereUniqueWithoutSantriInput | PelanggaranUpdateWithWhereUniqueWithoutSantriInput[]
    updateMany?: PelanggaranUpdateManyWithWhereWithoutSantriInput | PelanggaranUpdateManyWithWhereWithoutSantriInput[]
    deleteMany?: PelanggaranScalarWhereInput | PelanggaranScalarWhereInput[]
  }

  export type PembinaanUpdateManyWithoutSantriNestedInput = {
    create?: XOR<PembinaanCreateWithoutSantriInput, PembinaanUncheckedCreateWithoutSantriInput> | PembinaanCreateWithoutSantriInput[] | PembinaanUncheckedCreateWithoutSantriInput[]
    connectOrCreate?: PembinaanCreateOrConnectWithoutSantriInput | PembinaanCreateOrConnectWithoutSantriInput[]
    upsert?: PembinaanUpsertWithWhereUniqueWithoutSantriInput | PembinaanUpsertWithWhereUniqueWithoutSantriInput[]
    createMany?: PembinaanCreateManySantriInputEnvelope
    set?: PembinaanWhereUniqueInput | PembinaanWhereUniqueInput[]
    disconnect?: PembinaanWhereUniqueInput | PembinaanWhereUniqueInput[]
    delete?: PembinaanWhereUniqueInput | PembinaanWhereUniqueInput[]
    connect?: PembinaanWhereUniqueInput | PembinaanWhereUniqueInput[]
    update?: PembinaanUpdateWithWhereUniqueWithoutSantriInput | PembinaanUpdateWithWhereUniqueWithoutSantriInput[]
    updateMany?: PembinaanUpdateManyWithWhereWithoutSantriInput | PembinaanUpdateManyWithWhereWithoutSantriInput[]
    deleteMany?: PembinaanScalarWhereInput | PembinaanScalarWhereInput[]
  }

  export type KunjunganUpdateManyWithoutSantriNestedInput = {
    create?: XOR<KunjunganCreateWithoutSantriInput, KunjunganUncheckedCreateWithoutSantriInput> | KunjunganCreateWithoutSantriInput[] | KunjunganUncheckedCreateWithoutSantriInput[]
    connectOrCreate?: KunjunganCreateOrConnectWithoutSantriInput | KunjunganCreateOrConnectWithoutSantriInput[]
    upsert?: KunjunganUpsertWithWhereUniqueWithoutSantriInput | KunjunganUpsertWithWhereUniqueWithoutSantriInput[]
    createMany?: KunjunganCreateManySantriInputEnvelope
    set?: KunjunganWhereUniqueInput | KunjunganWhereUniqueInput[]
    disconnect?: KunjunganWhereUniqueInput | KunjunganWhereUniqueInput[]
    delete?: KunjunganWhereUniqueInput | KunjunganWhereUniqueInput[]
    connect?: KunjunganWhereUniqueInput | KunjunganWhereUniqueInput[]
    update?: KunjunganUpdateWithWhereUniqueWithoutSantriInput | KunjunganUpdateWithWhereUniqueWithoutSantriInput[]
    updateMany?: KunjunganUpdateManyWithWhereWithoutSantriInput | KunjunganUpdateManyWithWhereWithoutSantriInput[]
    deleteMany?: KunjunganScalarWhereInput | KunjunganScalarWhereInput[]
  }

  export type HealthRecordUpdateManyWithoutSantriNestedInput = {
    create?: XOR<HealthRecordCreateWithoutSantriInput, HealthRecordUncheckedCreateWithoutSantriInput> | HealthRecordCreateWithoutSantriInput[] | HealthRecordUncheckedCreateWithoutSantriInput[]
    connectOrCreate?: HealthRecordCreateOrConnectWithoutSantriInput | HealthRecordCreateOrConnectWithoutSantriInput[]
    upsert?: HealthRecordUpsertWithWhereUniqueWithoutSantriInput | HealthRecordUpsertWithWhereUniqueWithoutSantriInput[]
    createMany?: HealthRecordCreateManySantriInputEnvelope
    set?: HealthRecordWhereUniqueInput | HealthRecordWhereUniqueInput[]
    disconnect?: HealthRecordWhereUniqueInput | HealthRecordWhereUniqueInput[]
    delete?: HealthRecordWhereUniqueInput | HealthRecordWhereUniqueInput[]
    connect?: HealthRecordWhereUniqueInput | HealthRecordWhereUniqueInput[]
    update?: HealthRecordUpdateWithWhereUniqueWithoutSantriInput | HealthRecordUpdateWithWhereUniqueWithoutSantriInput[]
    updateMany?: HealthRecordUpdateManyWithWhereWithoutSantriInput | HealthRecordUpdateManyWithWhereWithoutSantriInput[]
    deleteMany?: HealthRecordScalarWhereInput | HealthRecordScalarWhereInput[]
  }

  export type MedicationUpdateManyWithoutSantriNestedInput = {
    create?: XOR<MedicationCreateWithoutSantriInput, MedicationUncheckedCreateWithoutSantriInput> | MedicationCreateWithoutSantriInput[] | MedicationUncheckedCreateWithoutSantriInput[]
    connectOrCreate?: MedicationCreateOrConnectWithoutSantriInput | MedicationCreateOrConnectWithoutSantriInput[]
    upsert?: MedicationUpsertWithWhereUniqueWithoutSantriInput | MedicationUpsertWithWhereUniqueWithoutSantriInput[]
    createMany?: MedicationCreateManySantriInputEnvelope
    set?: MedicationWhereUniqueInput | MedicationWhereUniqueInput[]
    disconnect?: MedicationWhereUniqueInput | MedicationWhereUniqueInput[]
    delete?: MedicationWhereUniqueInput | MedicationWhereUniqueInput[]
    connect?: MedicationWhereUniqueInput | MedicationWhereUniqueInput[]
    update?: MedicationUpdateWithWhereUniqueWithoutSantriInput | MedicationUpdateWithWhereUniqueWithoutSantriInput[]
    updateMany?: MedicationUpdateManyWithWhereWithoutSantriInput | MedicationUpdateManyWithWhereWithoutSantriInput[]
    deleteMany?: MedicationScalarWhereInput | MedicationScalarWhereInput[]
  }

  export type TahfidzUpdateManyWithoutSantriNestedInput = {
    create?: XOR<TahfidzCreateWithoutSantriInput, TahfidzUncheckedCreateWithoutSantriInput> | TahfidzCreateWithoutSantriInput[] | TahfidzUncheckedCreateWithoutSantriInput[]
    connectOrCreate?: TahfidzCreateOrConnectWithoutSantriInput | TahfidzCreateOrConnectWithoutSantriInput[]
    upsert?: TahfidzUpsertWithWhereUniqueWithoutSantriInput | TahfidzUpsertWithWhereUniqueWithoutSantriInput[]
    createMany?: TahfidzCreateManySantriInputEnvelope
    set?: TahfidzWhereUniqueInput | TahfidzWhereUniqueInput[]
    disconnect?: TahfidzWhereUniqueInput | TahfidzWhereUniqueInput[]
    delete?: TahfidzWhereUniqueInput | TahfidzWhereUniqueInput[]
    connect?: TahfidzWhereUniqueInput | TahfidzWhereUniqueInput[]
    update?: TahfidzUpdateWithWhereUniqueWithoutSantriInput | TahfidzUpdateWithWhereUniqueWithoutSantriInput[]
    updateMany?: TahfidzUpdateManyWithWhereWithoutSantriInput | TahfidzUpdateManyWithWhereWithoutSantriInput[]
    deleteMany?: TahfidzScalarWhereInput | TahfidzScalarWhereInput[]
  }

  export type MutabaahUpdateManyWithoutSantriNestedInput = {
    create?: XOR<MutabaahCreateWithoutSantriInput, MutabaahUncheckedCreateWithoutSantriInput> | MutabaahCreateWithoutSantriInput[] | MutabaahUncheckedCreateWithoutSantriInput[]
    connectOrCreate?: MutabaahCreateOrConnectWithoutSantriInput | MutabaahCreateOrConnectWithoutSantriInput[]
    upsert?: MutabaahUpsertWithWhereUniqueWithoutSantriInput | MutabaahUpsertWithWhereUniqueWithoutSantriInput[]
    createMany?: MutabaahCreateManySantriInputEnvelope
    set?: MutabaahWhereUniqueInput | MutabaahWhereUniqueInput[]
    disconnect?: MutabaahWhereUniqueInput | MutabaahWhereUniqueInput[]
    delete?: MutabaahWhereUniqueInput | MutabaahWhereUniqueInput[]
    connect?: MutabaahWhereUniqueInput | MutabaahWhereUniqueInput[]
    update?: MutabaahUpdateWithWhereUniqueWithoutSantriInput | MutabaahUpdateWithWhereUniqueWithoutSantriInput[]
    updateMany?: MutabaahUpdateManyWithWhereWithoutSantriInput | MutabaahUpdateManyWithWhereWithoutSantriInput[]
    deleteMany?: MutabaahScalarWhereInput | MutabaahScalarWhereInput[]
  }

  export type WalletUpdateOneWithoutSantriNestedInput = {
    create?: XOR<WalletCreateWithoutSantriInput, WalletUncheckedCreateWithoutSantriInput>
    connectOrCreate?: WalletCreateOrConnectWithoutSantriInput
    upsert?: WalletUpsertWithoutSantriInput
    disconnect?: WalletWhereInput | boolean
    delete?: WalletWhereInput | boolean
    connect?: WalletWhereUniqueInput
    update?: XOR<XOR<WalletUpdateToOneWithWhereWithoutSantriInput, WalletUpdateWithoutSantriInput>, WalletUncheckedUpdateWithoutSantriInput>
  }

  export type AttendanceUpdateManyWithoutSantriNestedInput = {
    create?: XOR<AttendanceCreateWithoutSantriInput, AttendanceUncheckedCreateWithoutSantriInput> | AttendanceCreateWithoutSantriInput[] | AttendanceUncheckedCreateWithoutSantriInput[]
    connectOrCreate?: AttendanceCreateOrConnectWithoutSantriInput | AttendanceCreateOrConnectWithoutSantriInput[]
    upsert?: AttendanceUpsertWithWhereUniqueWithoutSantriInput | AttendanceUpsertWithWhereUniqueWithoutSantriInput[]
    createMany?: AttendanceCreateManySantriInputEnvelope
    set?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
    disconnect?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
    delete?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
    connect?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
    update?: AttendanceUpdateWithWhereUniqueWithoutSantriInput | AttendanceUpdateWithWhereUniqueWithoutSantriInput[]
    updateMany?: AttendanceUpdateManyWithWhereWithoutSantriInput | AttendanceUpdateManyWithWhereWithoutSantriInput[]
    deleteMany?: AttendanceScalarWhereInput | AttendanceScalarWhereInput[]
  }

  export type GradeUpdateManyWithoutSantriNestedInput = {
    create?: XOR<GradeCreateWithoutSantriInput, GradeUncheckedCreateWithoutSantriInput> | GradeCreateWithoutSantriInput[] | GradeUncheckedCreateWithoutSantriInput[]
    connectOrCreate?: GradeCreateOrConnectWithoutSantriInput | GradeCreateOrConnectWithoutSantriInput[]
    upsert?: GradeUpsertWithWhereUniqueWithoutSantriInput | GradeUpsertWithWhereUniqueWithoutSantriInput[]
    createMany?: GradeCreateManySantriInputEnvelope
    set?: GradeWhereUniqueInput | GradeWhereUniqueInput[]
    disconnect?: GradeWhereUniqueInput | GradeWhereUniqueInput[]
    delete?: GradeWhereUniqueInput | GradeWhereUniqueInput[]
    connect?: GradeWhereUniqueInput | GradeWhereUniqueInput[]
    update?: GradeUpdateWithWhereUniqueWithoutSantriInput | GradeUpdateWithWhereUniqueWithoutSantriInput[]
    updateMany?: GradeUpdateManyWithWhereWithoutSantriInput | GradeUpdateManyWithWhereWithoutSantriInput[]
    deleteMany?: GradeScalarWhereInput | GradeScalarWhereInput[]
  }

  export type SantriWaliUncheckedUpdateManyWithoutSantriNestedInput = {
    create?: XOR<SantriWaliCreateWithoutSantriInput, SantriWaliUncheckedCreateWithoutSantriInput> | SantriWaliCreateWithoutSantriInput[] | SantriWaliUncheckedCreateWithoutSantriInput[]
    connectOrCreate?: SantriWaliCreateOrConnectWithoutSantriInput | SantriWaliCreateOrConnectWithoutSantriInput[]
    upsert?: SantriWaliUpsertWithWhereUniqueWithoutSantriInput | SantriWaliUpsertWithWhereUniqueWithoutSantriInput[]
    createMany?: SantriWaliCreateManySantriInputEnvelope
    set?: SantriWaliWhereUniqueInput | SantriWaliWhereUniqueInput[]
    disconnect?: SantriWaliWhereUniqueInput | SantriWaliWhereUniqueInput[]
    delete?: SantriWaliWhereUniqueInput | SantriWaliWhereUniqueInput[]
    connect?: SantriWaliWhereUniqueInput | SantriWaliWhereUniqueInput[]
    update?: SantriWaliUpdateWithWhereUniqueWithoutSantriInput | SantriWaliUpdateWithWhereUniqueWithoutSantriInput[]
    updateMany?: SantriWaliUpdateManyWithWhereWithoutSantriInput | SantriWaliUpdateManyWithWhereWithoutSantriInput[]
    deleteMany?: SantriWaliScalarWhereInput | SantriWaliScalarWhereInput[]
  }

  export type IzinUncheckedUpdateManyWithoutSantriNestedInput = {
    create?: XOR<IzinCreateWithoutSantriInput, IzinUncheckedCreateWithoutSantriInput> | IzinCreateWithoutSantriInput[] | IzinUncheckedCreateWithoutSantriInput[]
    connectOrCreate?: IzinCreateOrConnectWithoutSantriInput | IzinCreateOrConnectWithoutSantriInput[]
    upsert?: IzinUpsertWithWhereUniqueWithoutSantriInput | IzinUpsertWithWhereUniqueWithoutSantriInput[]
    createMany?: IzinCreateManySantriInputEnvelope
    set?: IzinWhereUniqueInput | IzinWhereUniqueInput[]
    disconnect?: IzinWhereUniqueInput | IzinWhereUniqueInput[]
    delete?: IzinWhereUniqueInput | IzinWhereUniqueInput[]
    connect?: IzinWhereUniqueInput | IzinWhereUniqueInput[]
    update?: IzinUpdateWithWhereUniqueWithoutSantriInput | IzinUpdateWithWhereUniqueWithoutSantriInput[]
    updateMany?: IzinUpdateManyWithWhereWithoutSantriInput | IzinUpdateManyWithWhereWithoutSantriInput[]
    deleteMany?: IzinScalarWhereInput | IzinScalarWhereInput[]
  }

  export type CatatanHarianUncheckedUpdateManyWithoutSantriNestedInput = {
    create?: XOR<CatatanHarianCreateWithoutSantriInput, CatatanHarianUncheckedCreateWithoutSantriInput> | CatatanHarianCreateWithoutSantriInput[] | CatatanHarianUncheckedCreateWithoutSantriInput[]
    connectOrCreate?: CatatanHarianCreateOrConnectWithoutSantriInput | CatatanHarianCreateOrConnectWithoutSantriInput[]
    upsert?: CatatanHarianUpsertWithWhereUniqueWithoutSantriInput | CatatanHarianUpsertWithWhereUniqueWithoutSantriInput[]
    createMany?: CatatanHarianCreateManySantriInputEnvelope
    set?: CatatanHarianWhereUniqueInput | CatatanHarianWhereUniqueInput[]
    disconnect?: CatatanHarianWhereUniqueInput | CatatanHarianWhereUniqueInput[]
    delete?: CatatanHarianWhereUniqueInput | CatatanHarianWhereUniqueInput[]
    connect?: CatatanHarianWhereUniqueInput | CatatanHarianWhereUniqueInput[]
    update?: CatatanHarianUpdateWithWhereUniqueWithoutSantriInput | CatatanHarianUpdateWithWhereUniqueWithoutSantriInput[]
    updateMany?: CatatanHarianUpdateManyWithWhereWithoutSantriInput | CatatanHarianUpdateManyWithWhereWithoutSantriInput[]
    deleteMany?: CatatanHarianScalarWhereInput | CatatanHarianScalarWhereInput[]
  }

  export type InvoiceUncheckedUpdateManyWithoutSantriNestedInput = {
    create?: XOR<InvoiceCreateWithoutSantriInput, InvoiceUncheckedCreateWithoutSantriInput> | InvoiceCreateWithoutSantriInput[] | InvoiceUncheckedCreateWithoutSantriInput[]
    connectOrCreate?: InvoiceCreateOrConnectWithoutSantriInput | InvoiceCreateOrConnectWithoutSantriInput[]
    upsert?: InvoiceUpsertWithWhereUniqueWithoutSantriInput | InvoiceUpsertWithWhereUniqueWithoutSantriInput[]
    createMany?: InvoiceCreateManySantriInputEnvelope
    set?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    disconnect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    delete?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    connect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    update?: InvoiceUpdateWithWhereUniqueWithoutSantriInput | InvoiceUpdateWithWhereUniqueWithoutSantriInput[]
    updateMany?: InvoiceUpdateManyWithWhereWithoutSantriInput | InvoiceUpdateManyWithWhereWithoutSantriInput[]
    deleteMany?: InvoiceScalarWhereInput | InvoiceScalarWhereInput[]
  }

  export type PelanggaranUncheckedUpdateManyWithoutSantriNestedInput = {
    create?: XOR<PelanggaranCreateWithoutSantriInput, PelanggaranUncheckedCreateWithoutSantriInput> | PelanggaranCreateWithoutSantriInput[] | PelanggaranUncheckedCreateWithoutSantriInput[]
    connectOrCreate?: PelanggaranCreateOrConnectWithoutSantriInput | PelanggaranCreateOrConnectWithoutSantriInput[]
    upsert?: PelanggaranUpsertWithWhereUniqueWithoutSantriInput | PelanggaranUpsertWithWhereUniqueWithoutSantriInput[]
    createMany?: PelanggaranCreateManySantriInputEnvelope
    set?: PelanggaranWhereUniqueInput | PelanggaranWhereUniqueInput[]
    disconnect?: PelanggaranWhereUniqueInput | PelanggaranWhereUniqueInput[]
    delete?: PelanggaranWhereUniqueInput | PelanggaranWhereUniqueInput[]
    connect?: PelanggaranWhereUniqueInput | PelanggaranWhereUniqueInput[]
    update?: PelanggaranUpdateWithWhereUniqueWithoutSantriInput | PelanggaranUpdateWithWhereUniqueWithoutSantriInput[]
    updateMany?: PelanggaranUpdateManyWithWhereWithoutSantriInput | PelanggaranUpdateManyWithWhereWithoutSantriInput[]
    deleteMany?: PelanggaranScalarWhereInput | PelanggaranScalarWhereInput[]
  }

  export type PembinaanUncheckedUpdateManyWithoutSantriNestedInput = {
    create?: XOR<PembinaanCreateWithoutSantriInput, PembinaanUncheckedCreateWithoutSantriInput> | PembinaanCreateWithoutSantriInput[] | PembinaanUncheckedCreateWithoutSantriInput[]
    connectOrCreate?: PembinaanCreateOrConnectWithoutSantriInput | PembinaanCreateOrConnectWithoutSantriInput[]
    upsert?: PembinaanUpsertWithWhereUniqueWithoutSantriInput | PembinaanUpsertWithWhereUniqueWithoutSantriInput[]
    createMany?: PembinaanCreateManySantriInputEnvelope
    set?: PembinaanWhereUniqueInput | PembinaanWhereUniqueInput[]
    disconnect?: PembinaanWhereUniqueInput | PembinaanWhereUniqueInput[]
    delete?: PembinaanWhereUniqueInput | PembinaanWhereUniqueInput[]
    connect?: PembinaanWhereUniqueInput | PembinaanWhereUniqueInput[]
    update?: PembinaanUpdateWithWhereUniqueWithoutSantriInput | PembinaanUpdateWithWhereUniqueWithoutSantriInput[]
    updateMany?: PembinaanUpdateManyWithWhereWithoutSantriInput | PembinaanUpdateManyWithWhereWithoutSantriInput[]
    deleteMany?: PembinaanScalarWhereInput | PembinaanScalarWhereInput[]
  }

  export type KunjunganUncheckedUpdateManyWithoutSantriNestedInput = {
    create?: XOR<KunjunganCreateWithoutSantriInput, KunjunganUncheckedCreateWithoutSantriInput> | KunjunganCreateWithoutSantriInput[] | KunjunganUncheckedCreateWithoutSantriInput[]
    connectOrCreate?: KunjunganCreateOrConnectWithoutSantriInput | KunjunganCreateOrConnectWithoutSantriInput[]
    upsert?: KunjunganUpsertWithWhereUniqueWithoutSantriInput | KunjunganUpsertWithWhereUniqueWithoutSantriInput[]
    createMany?: KunjunganCreateManySantriInputEnvelope
    set?: KunjunganWhereUniqueInput | KunjunganWhereUniqueInput[]
    disconnect?: KunjunganWhereUniqueInput | KunjunganWhereUniqueInput[]
    delete?: KunjunganWhereUniqueInput | KunjunganWhereUniqueInput[]
    connect?: KunjunganWhereUniqueInput | KunjunganWhereUniqueInput[]
    update?: KunjunganUpdateWithWhereUniqueWithoutSantriInput | KunjunganUpdateWithWhereUniqueWithoutSantriInput[]
    updateMany?: KunjunganUpdateManyWithWhereWithoutSantriInput | KunjunganUpdateManyWithWhereWithoutSantriInput[]
    deleteMany?: KunjunganScalarWhereInput | KunjunganScalarWhereInput[]
  }

  export type HealthRecordUncheckedUpdateManyWithoutSantriNestedInput = {
    create?: XOR<HealthRecordCreateWithoutSantriInput, HealthRecordUncheckedCreateWithoutSantriInput> | HealthRecordCreateWithoutSantriInput[] | HealthRecordUncheckedCreateWithoutSantriInput[]
    connectOrCreate?: HealthRecordCreateOrConnectWithoutSantriInput | HealthRecordCreateOrConnectWithoutSantriInput[]
    upsert?: HealthRecordUpsertWithWhereUniqueWithoutSantriInput | HealthRecordUpsertWithWhereUniqueWithoutSantriInput[]
    createMany?: HealthRecordCreateManySantriInputEnvelope
    set?: HealthRecordWhereUniqueInput | HealthRecordWhereUniqueInput[]
    disconnect?: HealthRecordWhereUniqueInput | HealthRecordWhereUniqueInput[]
    delete?: HealthRecordWhereUniqueInput | HealthRecordWhereUniqueInput[]
    connect?: HealthRecordWhereUniqueInput | HealthRecordWhereUniqueInput[]
    update?: HealthRecordUpdateWithWhereUniqueWithoutSantriInput | HealthRecordUpdateWithWhereUniqueWithoutSantriInput[]
    updateMany?: HealthRecordUpdateManyWithWhereWithoutSantriInput | HealthRecordUpdateManyWithWhereWithoutSantriInput[]
    deleteMany?: HealthRecordScalarWhereInput | HealthRecordScalarWhereInput[]
  }

  export type MedicationUncheckedUpdateManyWithoutSantriNestedInput = {
    create?: XOR<MedicationCreateWithoutSantriInput, MedicationUncheckedCreateWithoutSantriInput> | MedicationCreateWithoutSantriInput[] | MedicationUncheckedCreateWithoutSantriInput[]
    connectOrCreate?: MedicationCreateOrConnectWithoutSantriInput | MedicationCreateOrConnectWithoutSantriInput[]
    upsert?: MedicationUpsertWithWhereUniqueWithoutSantriInput | MedicationUpsertWithWhereUniqueWithoutSantriInput[]
    createMany?: MedicationCreateManySantriInputEnvelope
    set?: MedicationWhereUniqueInput | MedicationWhereUniqueInput[]
    disconnect?: MedicationWhereUniqueInput | MedicationWhereUniqueInput[]
    delete?: MedicationWhereUniqueInput | MedicationWhereUniqueInput[]
    connect?: MedicationWhereUniqueInput | MedicationWhereUniqueInput[]
    update?: MedicationUpdateWithWhereUniqueWithoutSantriInput | MedicationUpdateWithWhereUniqueWithoutSantriInput[]
    updateMany?: MedicationUpdateManyWithWhereWithoutSantriInput | MedicationUpdateManyWithWhereWithoutSantriInput[]
    deleteMany?: MedicationScalarWhereInput | MedicationScalarWhereInput[]
  }

  export type TahfidzUncheckedUpdateManyWithoutSantriNestedInput = {
    create?: XOR<TahfidzCreateWithoutSantriInput, TahfidzUncheckedCreateWithoutSantriInput> | TahfidzCreateWithoutSantriInput[] | TahfidzUncheckedCreateWithoutSantriInput[]
    connectOrCreate?: TahfidzCreateOrConnectWithoutSantriInput | TahfidzCreateOrConnectWithoutSantriInput[]
    upsert?: TahfidzUpsertWithWhereUniqueWithoutSantriInput | TahfidzUpsertWithWhereUniqueWithoutSantriInput[]
    createMany?: TahfidzCreateManySantriInputEnvelope
    set?: TahfidzWhereUniqueInput | TahfidzWhereUniqueInput[]
    disconnect?: TahfidzWhereUniqueInput | TahfidzWhereUniqueInput[]
    delete?: TahfidzWhereUniqueInput | TahfidzWhereUniqueInput[]
    connect?: TahfidzWhereUniqueInput | TahfidzWhereUniqueInput[]
    update?: TahfidzUpdateWithWhereUniqueWithoutSantriInput | TahfidzUpdateWithWhereUniqueWithoutSantriInput[]
    updateMany?: TahfidzUpdateManyWithWhereWithoutSantriInput | TahfidzUpdateManyWithWhereWithoutSantriInput[]
    deleteMany?: TahfidzScalarWhereInput | TahfidzScalarWhereInput[]
  }

  export type MutabaahUncheckedUpdateManyWithoutSantriNestedInput = {
    create?: XOR<MutabaahCreateWithoutSantriInput, MutabaahUncheckedCreateWithoutSantriInput> | MutabaahCreateWithoutSantriInput[] | MutabaahUncheckedCreateWithoutSantriInput[]
    connectOrCreate?: MutabaahCreateOrConnectWithoutSantriInput | MutabaahCreateOrConnectWithoutSantriInput[]
    upsert?: MutabaahUpsertWithWhereUniqueWithoutSantriInput | MutabaahUpsertWithWhereUniqueWithoutSantriInput[]
    createMany?: MutabaahCreateManySantriInputEnvelope
    set?: MutabaahWhereUniqueInput | MutabaahWhereUniqueInput[]
    disconnect?: MutabaahWhereUniqueInput | MutabaahWhereUniqueInput[]
    delete?: MutabaahWhereUniqueInput | MutabaahWhereUniqueInput[]
    connect?: MutabaahWhereUniqueInput | MutabaahWhereUniqueInput[]
    update?: MutabaahUpdateWithWhereUniqueWithoutSantriInput | MutabaahUpdateWithWhereUniqueWithoutSantriInput[]
    updateMany?: MutabaahUpdateManyWithWhereWithoutSantriInput | MutabaahUpdateManyWithWhereWithoutSantriInput[]
    deleteMany?: MutabaahScalarWhereInput | MutabaahScalarWhereInput[]
  }

  export type WalletUncheckedUpdateOneWithoutSantriNestedInput = {
    create?: XOR<WalletCreateWithoutSantriInput, WalletUncheckedCreateWithoutSantriInput>
    connectOrCreate?: WalletCreateOrConnectWithoutSantriInput
    upsert?: WalletUpsertWithoutSantriInput
    disconnect?: WalletWhereInput | boolean
    delete?: WalletWhereInput | boolean
    connect?: WalletWhereUniqueInput
    update?: XOR<XOR<WalletUpdateToOneWithWhereWithoutSantriInput, WalletUpdateWithoutSantriInput>, WalletUncheckedUpdateWithoutSantriInput>
  }

  export type AttendanceUncheckedUpdateManyWithoutSantriNestedInput = {
    create?: XOR<AttendanceCreateWithoutSantriInput, AttendanceUncheckedCreateWithoutSantriInput> | AttendanceCreateWithoutSantriInput[] | AttendanceUncheckedCreateWithoutSantriInput[]
    connectOrCreate?: AttendanceCreateOrConnectWithoutSantriInput | AttendanceCreateOrConnectWithoutSantriInput[]
    upsert?: AttendanceUpsertWithWhereUniqueWithoutSantriInput | AttendanceUpsertWithWhereUniqueWithoutSantriInput[]
    createMany?: AttendanceCreateManySantriInputEnvelope
    set?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
    disconnect?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
    delete?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
    connect?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
    update?: AttendanceUpdateWithWhereUniqueWithoutSantriInput | AttendanceUpdateWithWhereUniqueWithoutSantriInput[]
    updateMany?: AttendanceUpdateManyWithWhereWithoutSantriInput | AttendanceUpdateManyWithWhereWithoutSantriInput[]
    deleteMany?: AttendanceScalarWhereInput | AttendanceScalarWhereInput[]
  }

  export type GradeUncheckedUpdateManyWithoutSantriNestedInput = {
    create?: XOR<GradeCreateWithoutSantriInput, GradeUncheckedCreateWithoutSantriInput> | GradeCreateWithoutSantriInput[] | GradeUncheckedCreateWithoutSantriInput[]
    connectOrCreate?: GradeCreateOrConnectWithoutSantriInput | GradeCreateOrConnectWithoutSantriInput[]
    upsert?: GradeUpsertWithWhereUniqueWithoutSantriInput | GradeUpsertWithWhereUniqueWithoutSantriInput[]
    createMany?: GradeCreateManySantriInputEnvelope
    set?: GradeWhereUniqueInput | GradeWhereUniqueInput[]
    disconnect?: GradeWhereUniqueInput | GradeWhereUniqueInput[]
    delete?: GradeWhereUniqueInput | GradeWhereUniqueInput[]
    connect?: GradeWhereUniqueInput | GradeWhereUniqueInput[]
    update?: GradeUpdateWithWhereUniqueWithoutSantriInput | GradeUpdateWithWhereUniqueWithoutSantriInput[]
    updateMany?: GradeUpdateManyWithWhereWithoutSantriInput | GradeUpdateManyWithWhereWithoutSantriInput[]
    deleteMany?: GradeScalarWhereInput | GradeScalarWhereInput[]
  }

  export type TenantCreateNestedOneWithoutWaliInput = {
    create?: XOR<TenantCreateWithoutWaliInput, TenantUncheckedCreateWithoutWaliInput>
    connectOrCreate?: TenantCreateOrConnectWithoutWaliInput
    connect?: TenantWhereUniqueInput
  }

  export type SantriWaliCreateNestedManyWithoutWaliInput = {
    create?: XOR<SantriWaliCreateWithoutWaliInput, SantriWaliUncheckedCreateWithoutWaliInput> | SantriWaliCreateWithoutWaliInput[] | SantriWaliUncheckedCreateWithoutWaliInput[]
    connectOrCreate?: SantriWaliCreateOrConnectWithoutWaliInput | SantriWaliCreateOrConnectWithoutWaliInput[]
    createMany?: SantriWaliCreateManyWaliInputEnvelope
    connect?: SantriWaliWhereUniqueInput | SantriWaliWhereUniqueInput[]
  }

  export type SantriWaliUncheckedCreateNestedManyWithoutWaliInput = {
    create?: XOR<SantriWaliCreateWithoutWaliInput, SantriWaliUncheckedCreateWithoutWaliInput> | SantriWaliCreateWithoutWaliInput[] | SantriWaliUncheckedCreateWithoutWaliInput[]
    connectOrCreate?: SantriWaliCreateOrConnectWithoutWaliInput | SantriWaliCreateOrConnectWithoutWaliInput[]
    createMany?: SantriWaliCreateManyWaliInputEnvelope
    connect?: SantriWaliWhereUniqueInput | SantriWaliWhereUniqueInput[]
  }

  export type TenantUpdateOneRequiredWithoutWaliNestedInput = {
    create?: XOR<TenantCreateWithoutWaliInput, TenantUncheckedCreateWithoutWaliInput>
    connectOrCreate?: TenantCreateOrConnectWithoutWaliInput
    upsert?: TenantUpsertWithoutWaliInput
    connect?: TenantWhereUniqueInput
    update?: XOR<XOR<TenantUpdateToOneWithWhereWithoutWaliInput, TenantUpdateWithoutWaliInput>, TenantUncheckedUpdateWithoutWaliInput>
  }

  export type SantriWaliUpdateManyWithoutWaliNestedInput = {
    create?: XOR<SantriWaliCreateWithoutWaliInput, SantriWaliUncheckedCreateWithoutWaliInput> | SantriWaliCreateWithoutWaliInput[] | SantriWaliUncheckedCreateWithoutWaliInput[]
    connectOrCreate?: SantriWaliCreateOrConnectWithoutWaliInput | SantriWaliCreateOrConnectWithoutWaliInput[]
    upsert?: SantriWaliUpsertWithWhereUniqueWithoutWaliInput | SantriWaliUpsertWithWhereUniqueWithoutWaliInput[]
    createMany?: SantriWaliCreateManyWaliInputEnvelope
    set?: SantriWaliWhereUniqueInput | SantriWaliWhereUniqueInput[]
    disconnect?: SantriWaliWhereUniqueInput | SantriWaliWhereUniqueInput[]
    delete?: SantriWaliWhereUniqueInput | SantriWaliWhereUniqueInput[]
    connect?: SantriWaliWhereUniqueInput | SantriWaliWhereUniqueInput[]
    update?: SantriWaliUpdateWithWhereUniqueWithoutWaliInput | SantriWaliUpdateWithWhereUniqueWithoutWaliInput[]
    updateMany?: SantriWaliUpdateManyWithWhereWithoutWaliInput | SantriWaliUpdateManyWithWhereWithoutWaliInput[]
    deleteMany?: SantriWaliScalarWhereInput | SantriWaliScalarWhereInput[]
  }

  export type SantriWaliUncheckedUpdateManyWithoutWaliNestedInput = {
    create?: XOR<SantriWaliCreateWithoutWaliInput, SantriWaliUncheckedCreateWithoutWaliInput> | SantriWaliCreateWithoutWaliInput[] | SantriWaliUncheckedCreateWithoutWaliInput[]
    connectOrCreate?: SantriWaliCreateOrConnectWithoutWaliInput | SantriWaliCreateOrConnectWithoutWaliInput[]
    upsert?: SantriWaliUpsertWithWhereUniqueWithoutWaliInput | SantriWaliUpsertWithWhereUniqueWithoutWaliInput[]
    createMany?: SantriWaliCreateManyWaliInputEnvelope
    set?: SantriWaliWhereUniqueInput | SantriWaliWhereUniqueInput[]
    disconnect?: SantriWaliWhereUniqueInput | SantriWaliWhereUniqueInput[]
    delete?: SantriWaliWhereUniqueInput | SantriWaliWhereUniqueInput[]
    connect?: SantriWaliWhereUniqueInput | SantriWaliWhereUniqueInput[]
    update?: SantriWaliUpdateWithWhereUniqueWithoutWaliInput | SantriWaliUpdateWithWhereUniqueWithoutWaliInput[]
    updateMany?: SantriWaliUpdateManyWithWhereWithoutWaliInput | SantriWaliUpdateManyWithWhereWithoutWaliInput[]
    deleteMany?: SantriWaliScalarWhereInput | SantriWaliScalarWhereInput[]
  }

  export type SantriCreateNestedOneWithoutWalisInput = {
    create?: XOR<SantriCreateWithoutWalisInput, SantriUncheckedCreateWithoutWalisInput>
    connectOrCreate?: SantriCreateOrConnectWithoutWalisInput
    connect?: SantriWhereUniqueInput
  }

  export type WaliCreateNestedOneWithoutSantrisInput = {
    create?: XOR<WaliCreateWithoutSantrisInput, WaliUncheckedCreateWithoutSantrisInput>
    connectOrCreate?: WaliCreateOrConnectWithoutSantrisInput
    connect?: WaliWhereUniqueInput
  }

  export type SantriUpdateOneRequiredWithoutWalisNestedInput = {
    create?: XOR<SantriCreateWithoutWalisInput, SantriUncheckedCreateWithoutWalisInput>
    connectOrCreate?: SantriCreateOrConnectWithoutWalisInput
    upsert?: SantriUpsertWithoutWalisInput
    connect?: SantriWhereUniqueInput
    update?: XOR<XOR<SantriUpdateToOneWithWhereWithoutWalisInput, SantriUpdateWithoutWalisInput>, SantriUncheckedUpdateWithoutWalisInput>
  }

  export type WaliUpdateOneRequiredWithoutSantrisNestedInput = {
    create?: XOR<WaliCreateWithoutSantrisInput, WaliUncheckedCreateWithoutSantrisInput>
    connectOrCreate?: WaliCreateOrConnectWithoutSantrisInput
    upsert?: WaliUpsertWithoutSantrisInput
    connect?: WaliWhereUniqueInput
    update?: XOR<XOR<WaliUpdateToOneWithWhereWithoutSantrisInput, WaliUpdateWithoutSantrisInput>, WaliUncheckedUpdateWithoutSantrisInput>
  }

  export type TenantCreateNestedOneWithoutIzinInput = {
    create?: XOR<TenantCreateWithoutIzinInput, TenantUncheckedCreateWithoutIzinInput>
    connectOrCreate?: TenantCreateOrConnectWithoutIzinInput
    connect?: TenantWhereUniqueInput
  }

  export type SantriCreateNestedOneWithoutIzinInput = {
    create?: XOR<SantriCreateWithoutIzinInput, SantriUncheckedCreateWithoutIzinInput>
    connectOrCreate?: SantriCreateOrConnectWithoutIzinInput
    connect?: SantriWhereUniqueInput
  }

  export type TenantUpdateOneRequiredWithoutIzinNestedInput = {
    create?: XOR<TenantCreateWithoutIzinInput, TenantUncheckedCreateWithoutIzinInput>
    connectOrCreate?: TenantCreateOrConnectWithoutIzinInput
    upsert?: TenantUpsertWithoutIzinInput
    connect?: TenantWhereUniqueInput
    update?: XOR<XOR<TenantUpdateToOneWithWhereWithoutIzinInput, TenantUpdateWithoutIzinInput>, TenantUncheckedUpdateWithoutIzinInput>
  }

  export type SantriUpdateOneRequiredWithoutIzinNestedInput = {
    create?: XOR<SantriCreateWithoutIzinInput, SantriUncheckedCreateWithoutIzinInput>
    connectOrCreate?: SantriCreateOrConnectWithoutIzinInput
    upsert?: SantriUpsertWithoutIzinInput
    connect?: SantriWhereUniqueInput
    update?: XOR<XOR<SantriUpdateToOneWithWhereWithoutIzinInput, SantriUpdateWithoutIzinInput>, SantriUncheckedUpdateWithoutIzinInput>
  }

  export type TenantCreateNestedOneWithoutCatatanHarianInput = {
    create?: XOR<TenantCreateWithoutCatatanHarianInput, TenantUncheckedCreateWithoutCatatanHarianInput>
    connectOrCreate?: TenantCreateOrConnectWithoutCatatanHarianInput
    connect?: TenantWhereUniqueInput
  }

  export type SantriCreateNestedOneWithoutCatatanHarianInput = {
    create?: XOR<SantriCreateWithoutCatatanHarianInput, SantriUncheckedCreateWithoutCatatanHarianInput>
    connectOrCreate?: SantriCreateOrConnectWithoutCatatanHarianInput
    connect?: SantriWhereUniqueInput
  }

  export type TenantUpdateOneRequiredWithoutCatatanHarianNestedInput = {
    create?: XOR<TenantCreateWithoutCatatanHarianInput, TenantUncheckedCreateWithoutCatatanHarianInput>
    connectOrCreate?: TenantCreateOrConnectWithoutCatatanHarianInput
    upsert?: TenantUpsertWithoutCatatanHarianInput
    connect?: TenantWhereUniqueInput
    update?: XOR<XOR<TenantUpdateToOneWithWhereWithoutCatatanHarianInput, TenantUpdateWithoutCatatanHarianInput>, TenantUncheckedUpdateWithoutCatatanHarianInput>
  }

  export type SantriUpdateOneRequiredWithoutCatatanHarianNestedInput = {
    create?: XOR<SantriCreateWithoutCatatanHarianInput, SantriUncheckedCreateWithoutCatatanHarianInput>
    connectOrCreate?: SantriCreateOrConnectWithoutCatatanHarianInput
    upsert?: SantriUpsertWithoutCatatanHarianInput
    connect?: SantriWhereUniqueInput
    update?: XOR<XOR<SantriUpdateToOneWithWhereWithoutCatatanHarianInput, SantriUpdateWithoutCatatanHarianInput>, SantriUncheckedUpdateWithoutCatatanHarianInput>
  }

  export type TenantCreateNestedOneWithoutPengumumanInput = {
    create?: XOR<TenantCreateWithoutPengumumanInput, TenantUncheckedCreateWithoutPengumumanInput>
    connectOrCreate?: TenantCreateOrConnectWithoutPengumumanInput
    connect?: TenantWhereUniqueInput
  }

  export type TenantUpdateOneRequiredWithoutPengumumanNestedInput = {
    create?: XOR<TenantCreateWithoutPengumumanInput, TenantUncheckedCreateWithoutPengumumanInput>
    connectOrCreate?: TenantCreateOrConnectWithoutPengumumanInput
    upsert?: TenantUpsertWithoutPengumumanInput
    connect?: TenantWhereUniqueInput
    update?: XOR<XOR<TenantUpdateToOneWithWhereWithoutPengumumanInput, TenantUpdateWithoutPengumumanInput>, TenantUncheckedUpdateWithoutPengumumanInput>
  }

  export type TenantCreateNestedOneWithoutInvoicesInput = {
    create?: XOR<TenantCreateWithoutInvoicesInput, TenantUncheckedCreateWithoutInvoicesInput>
    connectOrCreate?: TenantCreateOrConnectWithoutInvoicesInput
    connect?: TenantWhereUniqueInput
  }

  export type SantriCreateNestedOneWithoutInvoicesInput = {
    create?: XOR<SantriCreateWithoutInvoicesInput, SantriUncheckedCreateWithoutInvoicesInput>
    connectOrCreate?: SantriCreateOrConnectWithoutInvoicesInput
    connect?: SantriWhereUniqueInput
  }

  export type InvoiceLineCreateNestedManyWithoutInvoiceInput = {
    create?: XOR<InvoiceLineCreateWithoutInvoiceInput, InvoiceLineUncheckedCreateWithoutInvoiceInput> | InvoiceLineCreateWithoutInvoiceInput[] | InvoiceLineUncheckedCreateWithoutInvoiceInput[]
    connectOrCreate?: InvoiceLineCreateOrConnectWithoutInvoiceInput | InvoiceLineCreateOrConnectWithoutInvoiceInput[]
    createMany?: InvoiceLineCreateManyInvoiceInputEnvelope
    connect?: InvoiceLineWhereUniqueInput | InvoiceLineWhereUniqueInput[]
  }

  export type PaymentCreateNestedManyWithoutInvoiceInput = {
    create?: XOR<PaymentCreateWithoutInvoiceInput, PaymentUncheckedCreateWithoutInvoiceInput> | PaymentCreateWithoutInvoiceInput[] | PaymentUncheckedCreateWithoutInvoiceInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutInvoiceInput | PaymentCreateOrConnectWithoutInvoiceInput[]
    createMany?: PaymentCreateManyInvoiceInputEnvelope
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
  }

  export type InvoiceLineUncheckedCreateNestedManyWithoutInvoiceInput = {
    create?: XOR<InvoiceLineCreateWithoutInvoiceInput, InvoiceLineUncheckedCreateWithoutInvoiceInput> | InvoiceLineCreateWithoutInvoiceInput[] | InvoiceLineUncheckedCreateWithoutInvoiceInput[]
    connectOrCreate?: InvoiceLineCreateOrConnectWithoutInvoiceInput | InvoiceLineCreateOrConnectWithoutInvoiceInput[]
    createMany?: InvoiceLineCreateManyInvoiceInputEnvelope
    connect?: InvoiceLineWhereUniqueInput | InvoiceLineWhereUniqueInput[]
  }

  export type PaymentUncheckedCreateNestedManyWithoutInvoiceInput = {
    create?: XOR<PaymentCreateWithoutInvoiceInput, PaymentUncheckedCreateWithoutInvoiceInput> | PaymentCreateWithoutInvoiceInput[] | PaymentUncheckedCreateWithoutInvoiceInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutInvoiceInput | PaymentCreateOrConnectWithoutInvoiceInput[]
    createMany?: PaymentCreateManyInvoiceInputEnvelope
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type TenantUpdateOneRequiredWithoutInvoicesNestedInput = {
    create?: XOR<TenantCreateWithoutInvoicesInput, TenantUncheckedCreateWithoutInvoicesInput>
    connectOrCreate?: TenantCreateOrConnectWithoutInvoicesInput
    upsert?: TenantUpsertWithoutInvoicesInput
    connect?: TenantWhereUniqueInput
    update?: XOR<XOR<TenantUpdateToOneWithWhereWithoutInvoicesInput, TenantUpdateWithoutInvoicesInput>, TenantUncheckedUpdateWithoutInvoicesInput>
  }

  export type SantriUpdateOneRequiredWithoutInvoicesNestedInput = {
    create?: XOR<SantriCreateWithoutInvoicesInput, SantriUncheckedCreateWithoutInvoicesInput>
    connectOrCreate?: SantriCreateOrConnectWithoutInvoicesInput
    upsert?: SantriUpsertWithoutInvoicesInput
    connect?: SantriWhereUniqueInput
    update?: XOR<XOR<SantriUpdateToOneWithWhereWithoutInvoicesInput, SantriUpdateWithoutInvoicesInput>, SantriUncheckedUpdateWithoutInvoicesInput>
  }

  export type InvoiceLineUpdateManyWithoutInvoiceNestedInput = {
    create?: XOR<InvoiceLineCreateWithoutInvoiceInput, InvoiceLineUncheckedCreateWithoutInvoiceInput> | InvoiceLineCreateWithoutInvoiceInput[] | InvoiceLineUncheckedCreateWithoutInvoiceInput[]
    connectOrCreate?: InvoiceLineCreateOrConnectWithoutInvoiceInput | InvoiceLineCreateOrConnectWithoutInvoiceInput[]
    upsert?: InvoiceLineUpsertWithWhereUniqueWithoutInvoiceInput | InvoiceLineUpsertWithWhereUniqueWithoutInvoiceInput[]
    createMany?: InvoiceLineCreateManyInvoiceInputEnvelope
    set?: InvoiceLineWhereUniqueInput | InvoiceLineWhereUniqueInput[]
    disconnect?: InvoiceLineWhereUniqueInput | InvoiceLineWhereUniqueInput[]
    delete?: InvoiceLineWhereUniqueInput | InvoiceLineWhereUniqueInput[]
    connect?: InvoiceLineWhereUniqueInput | InvoiceLineWhereUniqueInput[]
    update?: InvoiceLineUpdateWithWhereUniqueWithoutInvoiceInput | InvoiceLineUpdateWithWhereUniqueWithoutInvoiceInput[]
    updateMany?: InvoiceLineUpdateManyWithWhereWithoutInvoiceInput | InvoiceLineUpdateManyWithWhereWithoutInvoiceInput[]
    deleteMany?: InvoiceLineScalarWhereInput | InvoiceLineScalarWhereInput[]
  }

  export type PaymentUpdateManyWithoutInvoiceNestedInput = {
    create?: XOR<PaymentCreateWithoutInvoiceInput, PaymentUncheckedCreateWithoutInvoiceInput> | PaymentCreateWithoutInvoiceInput[] | PaymentUncheckedCreateWithoutInvoiceInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutInvoiceInput | PaymentCreateOrConnectWithoutInvoiceInput[]
    upsert?: PaymentUpsertWithWhereUniqueWithoutInvoiceInput | PaymentUpsertWithWhereUniqueWithoutInvoiceInput[]
    createMany?: PaymentCreateManyInvoiceInputEnvelope
    set?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    disconnect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    delete?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    update?: PaymentUpdateWithWhereUniqueWithoutInvoiceInput | PaymentUpdateWithWhereUniqueWithoutInvoiceInput[]
    updateMany?: PaymentUpdateManyWithWhereWithoutInvoiceInput | PaymentUpdateManyWithWhereWithoutInvoiceInput[]
    deleteMany?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
  }

  export type InvoiceLineUncheckedUpdateManyWithoutInvoiceNestedInput = {
    create?: XOR<InvoiceLineCreateWithoutInvoiceInput, InvoiceLineUncheckedCreateWithoutInvoiceInput> | InvoiceLineCreateWithoutInvoiceInput[] | InvoiceLineUncheckedCreateWithoutInvoiceInput[]
    connectOrCreate?: InvoiceLineCreateOrConnectWithoutInvoiceInput | InvoiceLineCreateOrConnectWithoutInvoiceInput[]
    upsert?: InvoiceLineUpsertWithWhereUniqueWithoutInvoiceInput | InvoiceLineUpsertWithWhereUniqueWithoutInvoiceInput[]
    createMany?: InvoiceLineCreateManyInvoiceInputEnvelope
    set?: InvoiceLineWhereUniqueInput | InvoiceLineWhereUniqueInput[]
    disconnect?: InvoiceLineWhereUniqueInput | InvoiceLineWhereUniqueInput[]
    delete?: InvoiceLineWhereUniqueInput | InvoiceLineWhereUniqueInput[]
    connect?: InvoiceLineWhereUniqueInput | InvoiceLineWhereUniqueInput[]
    update?: InvoiceLineUpdateWithWhereUniqueWithoutInvoiceInput | InvoiceLineUpdateWithWhereUniqueWithoutInvoiceInput[]
    updateMany?: InvoiceLineUpdateManyWithWhereWithoutInvoiceInput | InvoiceLineUpdateManyWithWhereWithoutInvoiceInput[]
    deleteMany?: InvoiceLineScalarWhereInput | InvoiceLineScalarWhereInput[]
  }

  export type PaymentUncheckedUpdateManyWithoutInvoiceNestedInput = {
    create?: XOR<PaymentCreateWithoutInvoiceInput, PaymentUncheckedCreateWithoutInvoiceInput> | PaymentCreateWithoutInvoiceInput[] | PaymentUncheckedCreateWithoutInvoiceInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutInvoiceInput | PaymentCreateOrConnectWithoutInvoiceInput[]
    upsert?: PaymentUpsertWithWhereUniqueWithoutInvoiceInput | PaymentUpsertWithWhereUniqueWithoutInvoiceInput[]
    createMany?: PaymentCreateManyInvoiceInputEnvelope
    set?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    disconnect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    delete?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    update?: PaymentUpdateWithWhereUniqueWithoutInvoiceInput | PaymentUpdateWithWhereUniqueWithoutInvoiceInput[]
    updateMany?: PaymentUpdateManyWithWhereWithoutInvoiceInput | PaymentUpdateManyWithWhereWithoutInvoiceInput[]
    deleteMany?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
  }

  export type InvoiceCreateNestedOneWithoutLinesInput = {
    create?: XOR<InvoiceCreateWithoutLinesInput, InvoiceUncheckedCreateWithoutLinesInput>
    connectOrCreate?: InvoiceCreateOrConnectWithoutLinesInput
    connect?: InvoiceWhereUniqueInput
  }

  export type InvoiceUpdateOneRequiredWithoutLinesNestedInput = {
    create?: XOR<InvoiceCreateWithoutLinesInput, InvoiceUncheckedCreateWithoutLinesInput>
    connectOrCreate?: InvoiceCreateOrConnectWithoutLinesInput
    upsert?: InvoiceUpsertWithoutLinesInput
    connect?: InvoiceWhereUniqueInput
    update?: XOR<XOR<InvoiceUpdateToOneWithWhereWithoutLinesInput, InvoiceUpdateWithoutLinesInput>, InvoiceUncheckedUpdateWithoutLinesInput>
  }

  export type InvoiceCreateNestedOneWithoutPaymentsInput = {
    create?: XOR<InvoiceCreateWithoutPaymentsInput, InvoiceUncheckedCreateWithoutPaymentsInput>
    connectOrCreate?: InvoiceCreateOrConnectWithoutPaymentsInput
    connect?: InvoiceWhereUniqueInput
  }

  export type InvoiceUpdateOneRequiredWithoutPaymentsNestedInput = {
    create?: XOR<InvoiceCreateWithoutPaymentsInput, InvoiceUncheckedCreateWithoutPaymentsInput>
    connectOrCreate?: InvoiceCreateOrConnectWithoutPaymentsInput
    upsert?: InvoiceUpsertWithoutPaymentsInput
    connect?: InvoiceWhereUniqueInput
    update?: XOR<XOR<InvoiceUpdateToOneWithWhereWithoutPaymentsInput, InvoiceUpdateWithoutPaymentsInput>, InvoiceUncheckedUpdateWithoutPaymentsInput>
  }

  export type TenantCreateNestedOneWithoutPelanggaranInput = {
    create?: XOR<TenantCreateWithoutPelanggaranInput, TenantUncheckedCreateWithoutPelanggaranInput>
    connectOrCreate?: TenantCreateOrConnectWithoutPelanggaranInput
    connect?: TenantWhereUniqueInput
  }

  export type SantriCreateNestedOneWithoutPelanggaranInput = {
    create?: XOR<SantriCreateWithoutPelanggaranInput, SantriUncheckedCreateWithoutPelanggaranInput>
    connectOrCreate?: SantriCreateOrConnectWithoutPelanggaranInput
    connect?: SantriWhereUniqueInput
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type TenantUpdateOneRequiredWithoutPelanggaranNestedInput = {
    create?: XOR<TenantCreateWithoutPelanggaranInput, TenantUncheckedCreateWithoutPelanggaranInput>
    connectOrCreate?: TenantCreateOrConnectWithoutPelanggaranInput
    upsert?: TenantUpsertWithoutPelanggaranInput
    connect?: TenantWhereUniqueInput
    update?: XOR<XOR<TenantUpdateToOneWithWhereWithoutPelanggaranInput, TenantUpdateWithoutPelanggaranInput>, TenantUncheckedUpdateWithoutPelanggaranInput>
  }

  export type SantriUpdateOneRequiredWithoutPelanggaranNestedInput = {
    create?: XOR<SantriCreateWithoutPelanggaranInput, SantriUncheckedCreateWithoutPelanggaranInput>
    connectOrCreate?: SantriCreateOrConnectWithoutPelanggaranInput
    upsert?: SantriUpsertWithoutPelanggaranInput
    connect?: SantriWhereUniqueInput
    update?: XOR<XOR<SantriUpdateToOneWithWhereWithoutPelanggaranInput, SantriUpdateWithoutPelanggaranInput>, SantriUncheckedUpdateWithoutPelanggaranInput>
  }

  export type TenantCreateNestedOneWithoutPembinaanInput = {
    create?: XOR<TenantCreateWithoutPembinaanInput, TenantUncheckedCreateWithoutPembinaanInput>
    connectOrCreate?: TenantCreateOrConnectWithoutPembinaanInput
    connect?: TenantWhereUniqueInput
  }

  export type SantriCreateNestedOneWithoutPembinaanInput = {
    create?: XOR<SantriCreateWithoutPembinaanInput, SantriUncheckedCreateWithoutPembinaanInput>
    connectOrCreate?: SantriCreateOrConnectWithoutPembinaanInput
    connect?: SantriWhereUniqueInput
  }

  export type TenantUpdateOneRequiredWithoutPembinaanNestedInput = {
    create?: XOR<TenantCreateWithoutPembinaanInput, TenantUncheckedCreateWithoutPembinaanInput>
    connectOrCreate?: TenantCreateOrConnectWithoutPembinaanInput
    upsert?: TenantUpsertWithoutPembinaanInput
    connect?: TenantWhereUniqueInput
    update?: XOR<XOR<TenantUpdateToOneWithWhereWithoutPembinaanInput, TenantUpdateWithoutPembinaanInput>, TenantUncheckedUpdateWithoutPembinaanInput>
  }

  export type SantriUpdateOneRequiredWithoutPembinaanNestedInput = {
    create?: XOR<SantriCreateWithoutPembinaanInput, SantriUncheckedCreateWithoutPembinaanInput>
    connectOrCreate?: SantriCreateOrConnectWithoutPembinaanInput
    upsert?: SantriUpsertWithoutPembinaanInput
    connect?: SantriWhereUniqueInput
    update?: XOR<XOR<SantriUpdateToOneWithWhereWithoutPembinaanInput, SantriUpdateWithoutPembinaanInput>, SantriUncheckedUpdateWithoutPembinaanInput>
  }

  export type TenantCreateNestedOneWithoutKunjunganInput = {
    create?: XOR<TenantCreateWithoutKunjunganInput, TenantUncheckedCreateWithoutKunjunganInput>
    connectOrCreate?: TenantCreateOrConnectWithoutKunjunganInput
    connect?: TenantWhereUniqueInput
  }

  export type SantriCreateNestedOneWithoutKunjunganInput = {
    create?: XOR<SantriCreateWithoutKunjunganInput, SantriUncheckedCreateWithoutKunjunganInput>
    connectOrCreate?: SantriCreateOrConnectWithoutKunjunganInput
    connect?: SantriWhereUniqueInput
  }

  export type TamuCreateNestedManyWithoutKunjunganInput = {
    create?: XOR<TamuCreateWithoutKunjunganInput, TamuUncheckedCreateWithoutKunjunganInput> | TamuCreateWithoutKunjunganInput[] | TamuUncheckedCreateWithoutKunjunganInput[]
    connectOrCreate?: TamuCreateOrConnectWithoutKunjunganInput | TamuCreateOrConnectWithoutKunjunganInput[]
    createMany?: TamuCreateManyKunjunganInputEnvelope
    connect?: TamuWhereUniqueInput | TamuWhereUniqueInput[]
  }

  export type TamuUncheckedCreateNestedManyWithoutKunjunganInput = {
    create?: XOR<TamuCreateWithoutKunjunganInput, TamuUncheckedCreateWithoutKunjunganInput> | TamuCreateWithoutKunjunganInput[] | TamuUncheckedCreateWithoutKunjunganInput[]
    connectOrCreate?: TamuCreateOrConnectWithoutKunjunganInput | TamuCreateOrConnectWithoutKunjunganInput[]
    createMany?: TamuCreateManyKunjunganInputEnvelope
    connect?: TamuWhereUniqueInput | TamuWhereUniqueInput[]
  }

  export type TenantUpdateOneRequiredWithoutKunjunganNestedInput = {
    create?: XOR<TenantCreateWithoutKunjunganInput, TenantUncheckedCreateWithoutKunjunganInput>
    connectOrCreate?: TenantCreateOrConnectWithoutKunjunganInput
    upsert?: TenantUpsertWithoutKunjunganInput
    connect?: TenantWhereUniqueInput
    update?: XOR<XOR<TenantUpdateToOneWithWhereWithoutKunjunganInput, TenantUpdateWithoutKunjunganInput>, TenantUncheckedUpdateWithoutKunjunganInput>
  }

  export type SantriUpdateOneRequiredWithoutKunjunganNestedInput = {
    create?: XOR<SantriCreateWithoutKunjunganInput, SantriUncheckedCreateWithoutKunjunganInput>
    connectOrCreate?: SantriCreateOrConnectWithoutKunjunganInput
    upsert?: SantriUpsertWithoutKunjunganInput
    connect?: SantriWhereUniqueInput
    update?: XOR<XOR<SantriUpdateToOneWithWhereWithoutKunjunganInput, SantriUpdateWithoutKunjunganInput>, SantriUncheckedUpdateWithoutKunjunganInput>
  }

  export type TamuUpdateManyWithoutKunjunganNestedInput = {
    create?: XOR<TamuCreateWithoutKunjunganInput, TamuUncheckedCreateWithoutKunjunganInput> | TamuCreateWithoutKunjunganInput[] | TamuUncheckedCreateWithoutKunjunganInput[]
    connectOrCreate?: TamuCreateOrConnectWithoutKunjunganInput | TamuCreateOrConnectWithoutKunjunganInput[]
    upsert?: TamuUpsertWithWhereUniqueWithoutKunjunganInput | TamuUpsertWithWhereUniqueWithoutKunjunganInput[]
    createMany?: TamuCreateManyKunjunganInputEnvelope
    set?: TamuWhereUniqueInput | TamuWhereUniqueInput[]
    disconnect?: TamuWhereUniqueInput | TamuWhereUniqueInput[]
    delete?: TamuWhereUniqueInput | TamuWhereUniqueInput[]
    connect?: TamuWhereUniqueInput | TamuWhereUniqueInput[]
    update?: TamuUpdateWithWhereUniqueWithoutKunjunganInput | TamuUpdateWithWhereUniqueWithoutKunjunganInput[]
    updateMany?: TamuUpdateManyWithWhereWithoutKunjunganInput | TamuUpdateManyWithWhereWithoutKunjunganInput[]
    deleteMany?: TamuScalarWhereInput | TamuScalarWhereInput[]
  }

  export type TamuUncheckedUpdateManyWithoutKunjunganNestedInput = {
    create?: XOR<TamuCreateWithoutKunjunganInput, TamuUncheckedCreateWithoutKunjunganInput> | TamuCreateWithoutKunjunganInput[] | TamuUncheckedCreateWithoutKunjunganInput[]
    connectOrCreate?: TamuCreateOrConnectWithoutKunjunganInput | TamuCreateOrConnectWithoutKunjunganInput[]
    upsert?: TamuUpsertWithWhereUniqueWithoutKunjunganInput | TamuUpsertWithWhereUniqueWithoutKunjunganInput[]
    createMany?: TamuCreateManyKunjunganInputEnvelope
    set?: TamuWhereUniqueInput | TamuWhereUniqueInput[]
    disconnect?: TamuWhereUniqueInput | TamuWhereUniqueInput[]
    delete?: TamuWhereUniqueInput | TamuWhereUniqueInput[]
    connect?: TamuWhereUniqueInput | TamuWhereUniqueInput[]
    update?: TamuUpdateWithWhereUniqueWithoutKunjunganInput | TamuUpdateWithWhereUniqueWithoutKunjunganInput[]
    updateMany?: TamuUpdateManyWithWhereWithoutKunjunganInput | TamuUpdateManyWithWhereWithoutKunjunganInput[]
    deleteMany?: TamuScalarWhereInput | TamuScalarWhereInput[]
  }

  export type KunjunganCreateNestedOneWithoutTamuInput = {
    create?: XOR<KunjunganCreateWithoutTamuInput, KunjunganUncheckedCreateWithoutTamuInput>
    connectOrCreate?: KunjunganCreateOrConnectWithoutTamuInput
    connect?: KunjunganWhereUniqueInput
  }

  export type KunjunganUpdateOneRequiredWithoutTamuNestedInput = {
    create?: XOR<KunjunganCreateWithoutTamuInput, KunjunganUncheckedCreateWithoutTamuInput>
    connectOrCreate?: KunjunganCreateOrConnectWithoutTamuInput
    upsert?: KunjunganUpsertWithoutTamuInput
    connect?: KunjunganWhereUniqueInput
    update?: XOR<XOR<KunjunganUpdateToOneWithWhereWithoutTamuInput, KunjunganUpdateWithoutTamuInput>, KunjunganUncheckedUpdateWithoutTamuInput>
  }

  export type TenantCreateNestedOneWithoutHealthRecordsInput = {
    create?: XOR<TenantCreateWithoutHealthRecordsInput, TenantUncheckedCreateWithoutHealthRecordsInput>
    connectOrCreate?: TenantCreateOrConnectWithoutHealthRecordsInput
    connect?: TenantWhereUniqueInput
  }

  export type SantriCreateNestedOneWithoutHealthRecordsInput = {
    create?: XOR<SantriCreateWithoutHealthRecordsInput, SantriUncheckedCreateWithoutHealthRecordsInput>
    connectOrCreate?: SantriCreateOrConnectWithoutHealthRecordsInput
    connect?: SantriWhereUniqueInput
  }

  export type TenantUpdateOneRequiredWithoutHealthRecordsNestedInput = {
    create?: XOR<TenantCreateWithoutHealthRecordsInput, TenantUncheckedCreateWithoutHealthRecordsInput>
    connectOrCreate?: TenantCreateOrConnectWithoutHealthRecordsInput
    upsert?: TenantUpsertWithoutHealthRecordsInput
    connect?: TenantWhereUniqueInput
    update?: XOR<XOR<TenantUpdateToOneWithWhereWithoutHealthRecordsInput, TenantUpdateWithoutHealthRecordsInput>, TenantUncheckedUpdateWithoutHealthRecordsInput>
  }

  export type SantriUpdateOneRequiredWithoutHealthRecordsNestedInput = {
    create?: XOR<SantriCreateWithoutHealthRecordsInput, SantriUncheckedCreateWithoutHealthRecordsInput>
    connectOrCreate?: SantriCreateOrConnectWithoutHealthRecordsInput
    upsert?: SantriUpsertWithoutHealthRecordsInput
    connect?: SantriWhereUniqueInput
    update?: XOR<XOR<SantriUpdateToOneWithWhereWithoutHealthRecordsInput, SantriUpdateWithoutHealthRecordsInput>, SantriUncheckedUpdateWithoutHealthRecordsInput>
  }

  export type SantriCreateNestedOneWithoutMedicationsInput = {
    create?: XOR<SantriCreateWithoutMedicationsInput, SantriUncheckedCreateWithoutMedicationsInput>
    connectOrCreate?: SantriCreateOrConnectWithoutMedicationsInput
    connect?: SantriWhereUniqueInput
  }

  export type SantriUpdateOneRequiredWithoutMedicationsNestedInput = {
    create?: XOR<SantriCreateWithoutMedicationsInput, SantriUncheckedCreateWithoutMedicationsInput>
    connectOrCreate?: SantriCreateOrConnectWithoutMedicationsInput
    upsert?: SantriUpsertWithoutMedicationsInput
    connect?: SantriWhereUniqueInput
    update?: XOR<XOR<SantriUpdateToOneWithWhereWithoutMedicationsInput, SantriUpdateWithoutMedicationsInput>, SantriUncheckedUpdateWithoutMedicationsInput>
  }

  export type TenantCreateNestedOneWithoutAuditLogsInput = {
    create?: XOR<TenantCreateWithoutAuditLogsInput, TenantUncheckedCreateWithoutAuditLogsInput>
    connectOrCreate?: TenantCreateOrConnectWithoutAuditLogsInput
    connect?: TenantWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutAuditLogsInput = {
    create?: XOR<UserCreateWithoutAuditLogsInput, UserUncheckedCreateWithoutAuditLogsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAuditLogsInput
    connect?: UserWhereUniqueInput
  }

  export type TenantUpdateOneWithoutAuditLogsNestedInput = {
    create?: XOR<TenantCreateWithoutAuditLogsInput, TenantUncheckedCreateWithoutAuditLogsInput>
    connectOrCreate?: TenantCreateOrConnectWithoutAuditLogsInput
    upsert?: TenantUpsertWithoutAuditLogsInput
    disconnect?: TenantWhereInput | boolean
    delete?: TenantWhereInput | boolean
    connect?: TenantWhereUniqueInput
    update?: XOR<XOR<TenantUpdateToOneWithWhereWithoutAuditLogsInput, TenantUpdateWithoutAuditLogsInput>, TenantUncheckedUpdateWithoutAuditLogsInput>
  }

  export type UserUpdateOneWithoutAuditLogsNestedInput = {
    create?: XOR<UserCreateWithoutAuditLogsInput, UserUncheckedCreateWithoutAuditLogsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAuditLogsInput
    upsert?: UserUpsertWithoutAuditLogsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAuditLogsInput, UserUpdateWithoutAuditLogsInput>, UserUncheckedUpdateWithoutAuditLogsInput>
  }

  export type TenantCreateNestedOneWithoutNotificationsInput = {
    create?: XOR<TenantCreateWithoutNotificationsInput, TenantUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: TenantCreateOrConnectWithoutNotificationsInput
    connect?: TenantWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutNotificationsInput = {
    create?: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutNotificationsInput
    connect?: UserWhereUniqueInput
  }

  export type TenantUpdateOneRequiredWithoutNotificationsNestedInput = {
    create?: XOR<TenantCreateWithoutNotificationsInput, TenantUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: TenantCreateOrConnectWithoutNotificationsInput
    upsert?: TenantUpsertWithoutNotificationsInput
    connect?: TenantWhereUniqueInput
    update?: XOR<XOR<TenantUpdateToOneWithWhereWithoutNotificationsInput, TenantUpdateWithoutNotificationsInput>, TenantUncheckedUpdateWithoutNotificationsInput>
  }

  export type UserUpdateOneRequiredWithoutNotificationsNestedInput = {
    create?: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutNotificationsInput
    upsert?: UserUpsertWithoutNotificationsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutNotificationsInput, UserUpdateWithoutNotificationsInput>, UserUncheckedUpdateWithoutNotificationsInput>
  }

  export type TenantCreateNestedOneWithoutWebhookEventsInput = {
    create?: XOR<TenantCreateWithoutWebhookEventsInput, TenantUncheckedCreateWithoutWebhookEventsInput>
    connectOrCreate?: TenantCreateOrConnectWithoutWebhookEventsInput
    connect?: TenantWhereUniqueInput
  }

  export type TenantUpdateOneWithoutWebhookEventsNestedInput = {
    create?: XOR<TenantCreateWithoutWebhookEventsInput, TenantUncheckedCreateWithoutWebhookEventsInput>
    connectOrCreate?: TenantCreateOrConnectWithoutWebhookEventsInput
    upsert?: TenantUpsertWithoutWebhookEventsInput
    disconnect?: TenantWhereInput | boolean
    delete?: TenantWhereInput | boolean
    connect?: TenantWhereUniqueInput
    update?: XOR<XOR<TenantUpdateToOneWithWhereWithoutWebhookEventsInput, TenantUpdateWithoutWebhookEventsInput>, TenantUncheckedUpdateWithoutWebhookEventsInput>
  }

  export type TenantCreateNestedOneWithoutTahfidzInput = {
    create?: XOR<TenantCreateWithoutTahfidzInput, TenantUncheckedCreateWithoutTahfidzInput>
    connectOrCreate?: TenantCreateOrConnectWithoutTahfidzInput
    connect?: TenantWhereUniqueInput
  }

  export type SantriCreateNestedOneWithoutTahfidzInput = {
    create?: XOR<SantriCreateWithoutTahfidzInput, SantriUncheckedCreateWithoutTahfidzInput>
    connectOrCreate?: SantriCreateOrConnectWithoutTahfidzInput
    connect?: SantriWhereUniqueInput
  }

  export type TenantUpdateOneRequiredWithoutTahfidzNestedInput = {
    create?: XOR<TenantCreateWithoutTahfidzInput, TenantUncheckedCreateWithoutTahfidzInput>
    connectOrCreate?: TenantCreateOrConnectWithoutTahfidzInput
    upsert?: TenantUpsertWithoutTahfidzInput
    connect?: TenantWhereUniqueInput
    update?: XOR<XOR<TenantUpdateToOneWithWhereWithoutTahfidzInput, TenantUpdateWithoutTahfidzInput>, TenantUncheckedUpdateWithoutTahfidzInput>
  }

  export type SantriUpdateOneRequiredWithoutTahfidzNestedInput = {
    create?: XOR<SantriCreateWithoutTahfidzInput, SantriUncheckedCreateWithoutTahfidzInput>
    connectOrCreate?: SantriCreateOrConnectWithoutTahfidzInput
    upsert?: SantriUpsertWithoutTahfidzInput
    connect?: SantriWhereUniqueInput
    update?: XOR<XOR<SantriUpdateToOneWithWhereWithoutTahfidzInput, SantriUpdateWithoutTahfidzInput>, SantriUncheckedUpdateWithoutTahfidzInput>
  }

  export type TenantCreateNestedOneWithoutMutabaahInput = {
    create?: XOR<TenantCreateWithoutMutabaahInput, TenantUncheckedCreateWithoutMutabaahInput>
    connectOrCreate?: TenantCreateOrConnectWithoutMutabaahInput
    connect?: TenantWhereUniqueInput
  }

  export type SantriCreateNestedOneWithoutMutabaahInput = {
    create?: XOR<SantriCreateWithoutMutabaahInput, SantriUncheckedCreateWithoutMutabaahInput>
    connectOrCreate?: SantriCreateOrConnectWithoutMutabaahInput
    connect?: SantriWhereUniqueInput
  }

  export type TenantUpdateOneRequiredWithoutMutabaahNestedInput = {
    create?: XOR<TenantCreateWithoutMutabaahInput, TenantUncheckedCreateWithoutMutabaahInput>
    connectOrCreate?: TenantCreateOrConnectWithoutMutabaahInput
    upsert?: TenantUpsertWithoutMutabaahInput
    connect?: TenantWhereUniqueInput
    update?: XOR<XOR<TenantUpdateToOneWithWhereWithoutMutabaahInput, TenantUpdateWithoutMutabaahInput>, TenantUncheckedUpdateWithoutMutabaahInput>
  }

  export type SantriUpdateOneRequiredWithoutMutabaahNestedInput = {
    create?: XOR<SantriCreateWithoutMutabaahInput, SantriUncheckedCreateWithoutMutabaahInput>
    connectOrCreate?: SantriCreateOrConnectWithoutMutabaahInput
    upsert?: SantriUpsertWithoutMutabaahInput
    connect?: SantriWhereUniqueInput
    update?: XOR<XOR<SantriUpdateToOneWithWhereWithoutMutabaahInput, SantriUpdateWithoutMutabaahInput>, SantriUncheckedUpdateWithoutMutabaahInput>
  }

  export type TenantCreateNestedOneWithoutWalletsInput = {
    create?: XOR<TenantCreateWithoutWalletsInput, TenantUncheckedCreateWithoutWalletsInput>
    connectOrCreate?: TenantCreateOrConnectWithoutWalletsInput
    connect?: TenantWhereUniqueInput
  }

  export type SantriCreateNestedOneWithoutWalletInput = {
    create?: XOR<SantriCreateWithoutWalletInput, SantriUncheckedCreateWithoutWalletInput>
    connectOrCreate?: SantriCreateOrConnectWithoutWalletInput
    connect?: SantriWhereUniqueInput
  }

  export type WalletTransactionCreateNestedManyWithoutWalletInput = {
    create?: XOR<WalletTransactionCreateWithoutWalletInput, WalletTransactionUncheckedCreateWithoutWalletInput> | WalletTransactionCreateWithoutWalletInput[] | WalletTransactionUncheckedCreateWithoutWalletInput[]
    connectOrCreate?: WalletTransactionCreateOrConnectWithoutWalletInput | WalletTransactionCreateOrConnectWithoutWalletInput[]
    createMany?: WalletTransactionCreateManyWalletInputEnvelope
    connect?: WalletTransactionWhereUniqueInput | WalletTransactionWhereUniqueInput[]
  }

  export type WalletTransactionUncheckedCreateNestedManyWithoutWalletInput = {
    create?: XOR<WalletTransactionCreateWithoutWalletInput, WalletTransactionUncheckedCreateWithoutWalletInput> | WalletTransactionCreateWithoutWalletInput[] | WalletTransactionUncheckedCreateWithoutWalletInput[]
    connectOrCreate?: WalletTransactionCreateOrConnectWithoutWalletInput | WalletTransactionCreateOrConnectWithoutWalletInput[]
    createMany?: WalletTransactionCreateManyWalletInputEnvelope
    connect?: WalletTransactionWhereUniqueInput | WalletTransactionWhereUniqueInput[]
  }

  export type TenantUpdateOneRequiredWithoutWalletsNestedInput = {
    create?: XOR<TenantCreateWithoutWalletsInput, TenantUncheckedCreateWithoutWalletsInput>
    connectOrCreate?: TenantCreateOrConnectWithoutWalletsInput
    upsert?: TenantUpsertWithoutWalletsInput
    connect?: TenantWhereUniqueInput
    update?: XOR<XOR<TenantUpdateToOneWithWhereWithoutWalletsInput, TenantUpdateWithoutWalletsInput>, TenantUncheckedUpdateWithoutWalletsInput>
  }

  export type SantriUpdateOneRequiredWithoutWalletNestedInput = {
    create?: XOR<SantriCreateWithoutWalletInput, SantriUncheckedCreateWithoutWalletInput>
    connectOrCreate?: SantriCreateOrConnectWithoutWalletInput
    upsert?: SantriUpsertWithoutWalletInput
    connect?: SantriWhereUniqueInput
    update?: XOR<XOR<SantriUpdateToOneWithWhereWithoutWalletInput, SantriUpdateWithoutWalletInput>, SantriUncheckedUpdateWithoutWalletInput>
  }

  export type WalletTransactionUpdateManyWithoutWalletNestedInput = {
    create?: XOR<WalletTransactionCreateWithoutWalletInput, WalletTransactionUncheckedCreateWithoutWalletInput> | WalletTransactionCreateWithoutWalletInput[] | WalletTransactionUncheckedCreateWithoutWalletInput[]
    connectOrCreate?: WalletTransactionCreateOrConnectWithoutWalletInput | WalletTransactionCreateOrConnectWithoutWalletInput[]
    upsert?: WalletTransactionUpsertWithWhereUniqueWithoutWalletInput | WalletTransactionUpsertWithWhereUniqueWithoutWalletInput[]
    createMany?: WalletTransactionCreateManyWalletInputEnvelope
    set?: WalletTransactionWhereUniqueInput | WalletTransactionWhereUniqueInput[]
    disconnect?: WalletTransactionWhereUniqueInput | WalletTransactionWhereUniqueInput[]
    delete?: WalletTransactionWhereUniqueInput | WalletTransactionWhereUniqueInput[]
    connect?: WalletTransactionWhereUniqueInput | WalletTransactionWhereUniqueInput[]
    update?: WalletTransactionUpdateWithWhereUniqueWithoutWalletInput | WalletTransactionUpdateWithWhereUniqueWithoutWalletInput[]
    updateMany?: WalletTransactionUpdateManyWithWhereWithoutWalletInput | WalletTransactionUpdateManyWithWhereWithoutWalletInput[]
    deleteMany?: WalletTransactionScalarWhereInput | WalletTransactionScalarWhereInput[]
  }

  export type WalletTransactionUncheckedUpdateManyWithoutWalletNestedInput = {
    create?: XOR<WalletTransactionCreateWithoutWalletInput, WalletTransactionUncheckedCreateWithoutWalletInput> | WalletTransactionCreateWithoutWalletInput[] | WalletTransactionUncheckedCreateWithoutWalletInput[]
    connectOrCreate?: WalletTransactionCreateOrConnectWithoutWalletInput | WalletTransactionCreateOrConnectWithoutWalletInput[]
    upsert?: WalletTransactionUpsertWithWhereUniqueWithoutWalletInput | WalletTransactionUpsertWithWhereUniqueWithoutWalletInput[]
    createMany?: WalletTransactionCreateManyWalletInputEnvelope
    set?: WalletTransactionWhereUniqueInput | WalletTransactionWhereUniqueInput[]
    disconnect?: WalletTransactionWhereUniqueInput | WalletTransactionWhereUniqueInput[]
    delete?: WalletTransactionWhereUniqueInput | WalletTransactionWhereUniqueInput[]
    connect?: WalletTransactionWhereUniqueInput | WalletTransactionWhereUniqueInput[]
    update?: WalletTransactionUpdateWithWhereUniqueWithoutWalletInput | WalletTransactionUpdateWithWhereUniqueWithoutWalletInput[]
    updateMany?: WalletTransactionUpdateManyWithWhereWithoutWalletInput | WalletTransactionUpdateManyWithWhereWithoutWalletInput[]
    deleteMany?: WalletTransactionScalarWhereInput | WalletTransactionScalarWhereInput[]
  }

  export type WalletCreateNestedOneWithoutTransactionsInput = {
    create?: XOR<WalletCreateWithoutTransactionsInput, WalletUncheckedCreateWithoutTransactionsInput>
    connectOrCreate?: WalletCreateOrConnectWithoutTransactionsInput
    connect?: WalletWhereUniqueInput
  }

  export type WalletUpdateOneRequiredWithoutTransactionsNestedInput = {
    create?: XOR<WalletCreateWithoutTransactionsInput, WalletUncheckedCreateWithoutTransactionsInput>
    connectOrCreate?: WalletCreateOrConnectWithoutTransactionsInput
    upsert?: WalletUpsertWithoutTransactionsInput
    connect?: WalletWhereUniqueInput
    update?: XOR<XOR<WalletUpdateToOneWithWhereWithoutTransactionsInput, WalletUpdateWithoutTransactionsInput>, WalletUncheckedUpdateWithoutTransactionsInput>
  }

  export type TenantCreateNestedOneWithoutEmployeesInput = {
    create?: XOR<TenantCreateWithoutEmployeesInput, TenantUncheckedCreateWithoutEmployeesInput>
    connectOrCreate?: TenantCreateOrConnectWithoutEmployeesInput
    connect?: TenantWhereUniqueInput
  }

  export type PayrollCreateNestedManyWithoutEmployeeInput = {
    create?: XOR<PayrollCreateWithoutEmployeeInput, PayrollUncheckedCreateWithoutEmployeeInput> | PayrollCreateWithoutEmployeeInput[] | PayrollUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: PayrollCreateOrConnectWithoutEmployeeInput | PayrollCreateOrConnectWithoutEmployeeInput[]
    createMany?: PayrollCreateManyEmployeeInputEnvelope
    connect?: PayrollWhereUniqueInput | PayrollWhereUniqueInput[]
  }

  export type PayrollUncheckedCreateNestedManyWithoutEmployeeInput = {
    create?: XOR<PayrollCreateWithoutEmployeeInput, PayrollUncheckedCreateWithoutEmployeeInput> | PayrollCreateWithoutEmployeeInput[] | PayrollUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: PayrollCreateOrConnectWithoutEmployeeInput | PayrollCreateOrConnectWithoutEmployeeInput[]
    createMany?: PayrollCreateManyEmployeeInputEnvelope
    connect?: PayrollWhereUniqueInput | PayrollWhereUniqueInput[]
  }

  export type TenantUpdateOneRequiredWithoutEmployeesNestedInput = {
    create?: XOR<TenantCreateWithoutEmployeesInput, TenantUncheckedCreateWithoutEmployeesInput>
    connectOrCreate?: TenantCreateOrConnectWithoutEmployeesInput
    upsert?: TenantUpsertWithoutEmployeesInput
    connect?: TenantWhereUniqueInput
    update?: XOR<XOR<TenantUpdateToOneWithWhereWithoutEmployeesInput, TenantUpdateWithoutEmployeesInput>, TenantUncheckedUpdateWithoutEmployeesInput>
  }

  export type PayrollUpdateManyWithoutEmployeeNestedInput = {
    create?: XOR<PayrollCreateWithoutEmployeeInput, PayrollUncheckedCreateWithoutEmployeeInput> | PayrollCreateWithoutEmployeeInput[] | PayrollUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: PayrollCreateOrConnectWithoutEmployeeInput | PayrollCreateOrConnectWithoutEmployeeInput[]
    upsert?: PayrollUpsertWithWhereUniqueWithoutEmployeeInput | PayrollUpsertWithWhereUniqueWithoutEmployeeInput[]
    createMany?: PayrollCreateManyEmployeeInputEnvelope
    set?: PayrollWhereUniqueInput | PayrollWhereUniqueInput[]
    disconnect?: PayrollWhereUniqueInput | PayrollWhereUniqueInput[]
    delete?: PayrollWhereUniqueInput | PayrollWhereUniqueInput[]
    connect?: PayrollWhereUniqueInput | PayrollWhereUniqueInput[]
    update?: PayrollUpdateWithWhereUniqueWithoutEmployeeInput | PayrollUpdateWithWhereUniqueWithoutEmployeeInput[]
    updateMany?: PayrollUpdateManyWithWhereWithoutEmployeeInput | PayrollUpdateManyWithWhereWithoutEmployeeInput[]
    deleteMany?: PayrollScalarWhereInput | PayrollScalarWhereInput[]
  }

  export type PayrollUncheckedUpdateManyWithoutEmployeeNestedInput = {
    create?: XOR<PayrollCreateWithoutEmployeeInput, PayrollUncheckedCreateWithoutEmployeeInput> | PayrollCreateWithoutEmployeeInput[] | PayrollUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: PayrollCreateOrConnectWithoutEmployeeInput | PayrollCreateOrConnectWithoutEmployeeInput[]
    upsert?: PayrollUpsertWithWhereUniqueWithoutEmployeeInput | PayrollUpsertWithWhereUniqueWithoutEmployeeInput[]
    createMany?: PayrollCreateManyEmployeeInputEnvelope
    set?: PayrollWhereUniqueInput | PayrollWhereUniqueInput[]
    disconnect?: PayrollWhereUniqueInput | PayrollWhereUniqueInput[]
    delete?: PayrollWhereUniqueInput | PayrollWhereUniqueInput[]
    connect?: PayrollWhereUniqueInput | PayrollWhereUniqueInput[]
    update?: PayrollUpdateWithWhereUniqueWithoutEmployeeInput | PayrollUpdateWithWhereUniqueWithoutEmployeeInput[]
    updateMany?: PayrollUpdateManyWithWhereWithoutEmployeeInput | PayrollUpdateManyWithWhereWithoutEmployeeInput[]
    deleteMany?: PayrollScalarWhereInput | PayrollScalarWhereInput[]
  }

  export type TenantCreateNestedOneWithoutPayrollsInput = {
    create?: XOR<TenantCreateWithoutPayrollsInput, TenantUncheckedCreateWithoutPayrollsInput>
    connectOrCreate?: TenantCreateOrConnectWithoutPayrollsInput
    connect?: TenantWhereUniqueInput
  }

  export type EmployeeCreateNestedOneWithoutPayrollsInput = {
    create?: XOR<EmployeeCreateWithoutPayrollsInput, EmployeeUncheckedCreateWithoutPayrollsInput>
    connectOrCreate?: EmployeeCreateOrConnectWithoutPayrollsInput
    connect?: EmployeeWhereUniqueInput
  }

  export type TenantUpdateOneRequiredWithoutPayrollsNestedInput = {
    create?: XOR<TenantCreateWithoutPayrollsInput, TenantUncheckedCreateWithoutPayrollsInput>
    connectOrCreate?: TenantCreateOrConnectWithoutPayrollsInput
    upsert?: TenantUpsertWithoutPayrollsInput
    connect?: TenantWhereUniqueInput
    update?: XOR<XOR<TenantUpdateToOneWithWhereWithoutPayrollsInput, TenantUpdateWithoutPayrollsInput>, TenantUncheckedUpdateWithoutPayrollsInput>
  }

  export type EmployeeUpdateOneRequiredWithoutPayrollsNestedInput = {
    create?: XOR<EmployeeCreateWithoutPayrollsInput, EmployeeUncheckedCreateWithoutPayrollsInput>
    connectOrCreate?: EmployeeCreateOrConnectWithoutPayrollsInput
    upsert?: EmployeeUpsertWithoutPayrollsInput
    connect?: EmployeeWhereUniqueInput
    update?: XOR<XOR<EmployeeUpdateToOneWithWhereWithoutPayrollsInput, EmployeeUpdateWithoutPayrollsInput>, EmployeeUncheckedUpdateWithoutPayrollsInput>
  }

  export type TenantCreateNestedOneWithoutAcademicSchedsInput = {
    create?: XOR<TenantCreateWithoutAcademicSchedsInput, TenantUncheckedCreateWithoutAcademicSchedsInput>
    connectOrCreate?: TenantCreateOrConnectWithoutAcademicSchedsInput
    connect?: TenantWhereUniqueInput
  }

  export type TenantUpdateOneRequiredWithoutAcademicSchedsNestedInput = {
    create?: XOR<TenantCreateWithoutAcademicSchedsInput, TenantUncheckedCreateWithoutAcademicSchedsInput>
    connectOrCreate?: TenantCreateOrConnectWithoutAcademicSchedsInput
    upsert?: TenantUpsertWithoutAcademicSchedsInput
    connect?: TenantWhereUniqueInput
    update?: XOR<XOR<TenantUpdateToOneWithWhereWithoutAcademicSchedsInput, TenantUpdateWithoutAcademicSchedsInput>, TenantUncheckedUpdateWithoutAcademicSchedsInput>
  }

  export type TenantCreateNestedOneWithoutAttendancesInput = {
    create?: XOR<TenantCreateWithoutAttendancesInput, TenantUncheckedCreateWithoutAttendancesInput>
    connectOrCreate?: TenantCreateOrConnectWithoutAttendancesInput
    connect?: TenantWhereUniqueInput
  }

  export type SantriCreateNestedOneWithoutAttendancesInput = {
    create?: XOR<SantriCreateWithoutAttendancesInput, SantriUncheckedCreateWithoutAttendancesInput>
    connectOrCreate?: SantriCreateOrConnectWithoutAttendancesInput
    connect?: SantriWhereUniqueInput
  }

  export type TenantUpdateOneRequiredWithoutAttendancesNestedInput = {
    create?: XOR<TenantCreateWithoutAttendancesInput, TenantUncheckedCreateWithoutAttendancesInput>
    connectOrCreate?: TenantCreateOrConnectWithoutAttendancesInput
    upsert?: TenantUpsertWithoutAttendancesInput
    connect?: TenantWhereUniqueInput
    update?: XOR<XOR<TenantUpdateToOneWithWhereWithoutAttendancesInput, TenantUpdateWithoutAttendancesInput>, TenantUncheckedUpdateWithoutAttendancesInput>
  }

  export type SantriUpdateOneRequiredWithoutAttendancesNestedInput = {
    create?: XOR<SantriCreateWithoutAttendancesInput, SantriUncheckedCreateWithoutAttendancesInput>
    connectOrCreate?: SantriCreateOrConnectWithoutAttendancesInput
    upsert?: SantriUpsertWithoutAttendancesInput
    connect?: SantriWhereUniqueInput
    update?: XOR<XOR<SantriUpdateToOneWithWhereWithoutAttendancesInput, SantriUpdateWithoutAttendancesInput>, SantriUncheckedUpdateWithoutAttendancesInput>
  }

  export type TenantCreateNestedOneWithoutGradesInput = {
    create?: XOR<TenantCreateWithoutGradesInput, TenantUncheckedCreateWithoutGradesInput>
    connectOrCreate?: TenantCreateOrConnectWithoutGradesInput
    connect?: TenantWhereUniqueInput
  }

  export type SantriCreateNestedOneWithoutGradesInput = {
    create?: XOR<SantriCreateWithoutGradesInput, SantriUncheckedCreateWithoutGradesInput>
    connectOrCreate?: SantriCreateOrConnectWithoutGradesInput
    connect?: SantriWhereUniqueInput
  }

  export type TenantUpdateOneRequiredWithoutGradesNestedInput = {
    create?: XOR<TenantCreateWithoutGradesInput, TenantUncheckedCreateWithoutGradesInput>
    connectOrCreate?: TenantCreateOrConnectWithoutGradesInput
    upsert?: TenantUpsertWithoutGradesInput
    connect?: TenantWhereUniqueInput
    update?: XOR<XOR<TenantUpdateToOneWithWhereWithoutGradesInput, TenantUpdateWithoutGradesInput>, TenantUncheckedUpdateWithoutGradesInput>
  }

  export type SantriUpdateOneRequiredWithoutGradesNestedInput = {
    create?: XOR<SantriCreateWithoutGradesInput, SantriUncheckedCreateWithoutGradesInput>
    connectOrCreate?: SantriCreateOrConnectWithoutGradesInput
    upsert?: SantriUpsertWithoutGradesInput
    connect?: SantriWhereUniqueInput
    update?: XOR<XOR<SantriUpdateToOneWithWhereWithoutGradesInput, SantriUpdateWithoutGradesInput>, SantriUncheckedUpdateWithoutGradesInput>
  }

  export type TenantCreateNestedOneWithoutPpdbRegistrationsInput = {
    create?: XOR<TenantCreateWithoutPpdbRegistrationsInput, TenantUncheckedCreateWithoutPpdbRegistrationsInput>
    connectOrCreate?: TenantCreateOrConnectWithoutPpdbRegistrationsInput
    connect?: TenantWhereUniqueInput
  }

  export type PpdbDocumentCreateNestedManyWithoutRegistrationInput = {
    create?: XOR<PpdbDocumentCreateWithoutRegistrationInput, PpdbDocumentUncheckedCreateWithoutRegistrationInput> | PpdbDocumentCreateWithoutRegistrationInput[] | PpdbDocumentUncheckedCreateWithoutRegistrationInput[]
    connectOrCreate?: PpdbDocumentCreateOrConnectWithoutRegistrationInput | PpdbDocumentCreateOrConnectWithoutRegistrationInput[]
    createMany?: PpdbDocumentCreateManyRegistrationInputEnvelope
    connect?: PpdbDocumentWhereUniqueInput | PpdbDocumentWhereUniqueInput[]
  }

  export type PpdbExamCreateNestedManyWithoutRegistrationInput = {
    create?: XOR<PpdbExamCreateWithoutRegistrationInput, PpdbExamUncheckedCreateWithoutRegistrationInput> | PpdbExamCreateWithoutRegistrationInput[] | PpdbExamUncheckedCreateWithoutRegistrationInput[]
    connectOrCreate?: PpdbExamCreateOrConnectWithoutRegistrationInput | PpdbExamCreateOrConnectWithoutRegistrationInput[]
    createMany?: PpdbExamCreateManyRegistrationInputEnvelope
    connect?: PpdbExamWhereUniqueInput | PpdbExamWhereUniqueInput[]
  }

  export type PpdbDocumentUncheckedCreateNestedManyWithoutRegistrationInput = {
    create?: XOR<PpdbDocumentCreateWithoutRegistrationInput, PpdbDocumentUncheckedCreateWithoutRegistrationInput> | PpdbDocumentCreateWithoutRegistrationInput[] | PpdbDocumentUncheckedCreateWithoutRegistrationInput[]
    connectOrCreate?: PpdbDocumentCreateOrConnectWithoutRegistrationInput | PpdbDocumentCreateOrConnectWithoutRegistrationInput[]
    createMany?: PpdbDocumentCreateManyRegistrationInputEnvelope
    connect?: PpdbDocumentWhereUniqueInput | PpdbDocumentWhereUniqueInput[]
  }

  export type PpdbExamUncheckedCreateNestedManyWithoutRegistrationInput = {
    create?: XOR<PpdbExamCreateWithoutRegistrationInput, PpdbExamUncheckedCreateWithoutRegistrationInput> | PpdbExamCreateWithoutRegistrationInput[] | PpdbExamUncheckedCreateWithoutRegistrationInput[]
    connectOrCreate?: PpdbExamCreateOrConnectWithoutRegistrationInput | PpdbExamCreateOrConnectWithoutRegistrationInput[]
    createMany?: PpdbExamCreateManyRegistrationInputEnvelope
    connect?: PpdbExamWhereUniqueInput | PpdbExamWhereUniqueInput[]
  }

  export type TenantUpdateOneRequiredWithoutPpdbRegistrationsNestedInput = {
    create?: XOR<TenantCreateWithoutPpdbRegistrationsInput, TenantUncheckedCreateWithoutPpdbRegistrationsInput>
    connectOrCreate?: TenantCreateOrConnectWithoutPpdbRegistrationsInput
    upsert?: TenantUpsertWithoutPpdbRegistrationsInput
    connect?: TenantWhereUniqueInput
    update?: XOR<XOR<TenantUpdateToOneWithWhereWithoutPpdbRegistrationsInput, TenantUpdateWithoutPpdbRegistrationsInput>, TenantUncheckedUpdateWithoutPpdbRegistrationsInput>
  }

  export type PpdbDocumentUpdateManyWithoutRegistrationNestedInput = {
    create?: XOR<PpdbDocumentCreateWithoutRegistrationInput, PpdbDocumentUncheckedCreateWithoutRegistrationInput> | PpdbDocumentCreateWithoutRegistrationInput[] | PpdbDocumentUncheckedCreateWithoutRegistrationInput[]
    connectOrCreate?: PpdbDocumentCreateOrConnectWithoutRegistrationInput | PpdbDocumentCreateOrConnectWithoutRegistrationInput[]
    upsert?: PpdbDocumentUpsertWithWhereUniqueWithoutRegistrationInput | PpdbDocumentUpsertWithWhereUniqueWithoutRegistrationInput[]
    createMany?: PpdbDocumentCreateManyRegistrationInputEnvelope
    set?: PpdbDocumentWhereUniqueInput | PpdbDocumentWhereUniqueInput[]
    disconnect?: PpdbDocumentWhereUniqueInput | PpdbDocumentWhereUniqueInput[]
    delete?: PpdbDocumentWhereUniqueInput | PpdbDocumentWhereUniqueInput[]
    connect?: PpdbDocumentWhereUniqueInput | PpdbDocumentWhereUniqueInput[]
    update?: PpdbDocumentUpdateWithWhereUniqueWithoutRegistrationInput | PpdbDocumentUpdateWithWhereUniqueWithoutRegistrationInput[]
    updateMany?: PpdbDocumentUpdateManyWithWhereWithoutRegistrationInput | PpdbDocumentUpdateManyWithWhereWithoutRegistrationInput[]
    deleteMany?: PpdbDocumentScalarWhereInput | PpdbDocumentScalarWhereInput[]
  }

  export type PpdbExamUpdateManyWithoutRegistrationNestedInput = {
    create?: XOR<PpdbExamCreateWithoutRegistrationInput, PpdbExamUncheckedCreateWithoutRegistrationInput> | PpdbExamCreateWithoutRegistrationInput[] | PpdbExamUncheckedCreateWithoutRegistrationInput[]
    connectOrCreate?: PpdbExamCreateOrConnectWithoutRegistrationInput | PpdbExamCreateOrConnectWithoutRegistrationInput[]
    upsert?: PpdbExamUpsertWithWhereUniqueWithoutRegistrationInput | PpdbExamUpsertWithWhereUniqueWithoutRegistrationInput[]
    createMany?: PpdbExamCreateManyRegistrationInputEnvelope
    set?: PpdbExamWhereUniqueInput | PpdbExamWhereUniqueInput[]
    disconnect?: PpdbExamWhereUniqueInput | PpdbExamWhereUniqueInput[]
    delete?: PpdbExamWhereUniqueInput | PpdbExamWhereUniqueInput[]
    connect?: PpdbExamWhereUniqueInput | PpdbExamWhereUniqueInput[]
    update?: PpdbExamUpdateWithWhereUniqueWithoutRegistrationInput | PpdbExamUpdateWithWhereUniqueWithoutRegistrationInput[]
    updateMany?: PpdbExamUpdateManyWithWhereWithoutRegistrationInput | PpdbExamUpdateManyWithWhereWithoutRegistrationInput[]
    deleteMany?: PpdbExamScalarWhereInput | PpdbExamScalarWhereInput[]
  }

  export type PpdbDocumentUncheckedUpdateManyWithoutRegistrationNestedInput = {
    create?: XOR<PpdbDocumentCreateWithoutRegistrationInput, PpdbDocumentUncheckedCreateWithoutRegistrationInput> | PpdbDocumentCreateWithoutRegistrationInput[] | PpdbDocumentUncheckedCreateWithoutRegistrationInput[]
    connectOrCreate?: PpdbDocumentCreateOrConnectWithoutRegistrationInput | PpdbDocumentCreateOrConnectWithoutRegistrationInput[]
    upsert?: PpdbDocumentUpsertWithWhereUniqueWithoutRegistrationInput | PpdbDocumentUpsertWithWhereUniqueWithoutRegistrationInput[]
    createMany?: PpdbDocumentCreateManyRegistrationInputEnvelope
    set?: PpdbDocumentWhereUniqueInput | PpdbDocumentWhereUniqueInput[]
    disconnect?: PpdbDocumentWhereUniqueInput | PpdbDocumentWhereUniqueInput[]
    delete?: PpdbDocumentWhereUniqueInput | PpdbDocumentWhereUniqueInput[]
    connect?: PpdbDocumentWhereUniqueInput | PpdbDocumentWhereUniqueInput[]
    update?: PpdbDocumentUpdateWithWhereUniqueWithoutRegistrationInput | PpdbDocumentUpdateWithWhereUniqueWithoutRegistrationInput[]
    updateMany?: PpdbDocumentUpdateManyWithWhereWithoutRegistrationInput | PpdbDocumentUpdateManyWithWhereWithoutRegistrationInput[]
    deleteMany?: PpdbDocumentScalarWhereInput | PpdbDocumentScalarWhereInput[]
  }

  export type PpdbExamUncheckedUpdateManyWithoutRegistrationNestedInput = {
    create?: XOR<PpdbExamCreateWithoutRegistrationInput, PpdbExamUncheckedCreateWithoutRegistrationInput> | PpdbExamCreateWithoutRegistrationInput[] | PpdbExamUncheckedCreateWithoutRegistrationInput[]
    connectOrCreate?: PpdbExamCreateOrConnectWithoutRegistrationInput | PpdbExamCreateOrConnectWithoutRegistrationInput[]
    upsert?: PpdbExamUpsertWithWhereUniqueWithoutRegistrationInput | PpdbExamUpsertWithWhereUniqueWithoutRegistrationInput[]
    createMany?: PpdbExamCreateManyRegistrationInputEnvelope
    set?: PpdbExamWhereUniqueInput | PpdbExamWhereUniqueInput[]
    disconnect?: PpdbExamWhereUniqueInput | PpdbExamWhereUniqueInput[]
    delete?: PpdbExamWhereUniqueInput | PpdbExamWhereUniqueInput[]
    connect?: PpdbExamWhereUniqueInput | PpdbExamWhereUniqueInput[]
    update?: PpdbExamUpdateWithWhereUniqueWithoutRegistrationInput | PpdbExamUpdateWithWhereUniqueWithoutRegistrationInput[]
    updateMany?: PpdbExamUpdateManyWithWhereWithoutRegistrationInput | PpdbExamUpdateManyWithWhereWithoutRegistrationInput[]
    deleteMany?: PpdbExamScalarWhereInput | PpdbExamScalarWhereInput[]
  }

  export type TenantCreateNestedOneWithoutPpdbDocumentsInput = {
    create?: XOR<TenantCreateWithoutPpdbDocumentsInput, TenantUncheckedCreateWithoutPpdbDocumentsInput>
    connectOrCreate?: TenantCreateOrConnectWithoutPpdbDocumentsInput
    connect?: TenantWhereUniqueInput
  }

  export type PpdbRegistrationCreateNestedOneWithoutDocumentsInput = {
    create?: XOR<PpdbRegistrationCreateWithoutDocumentsInput, PpdbRegistrationUncheckedCreateWithoutDocumentsInput>
    connectOrCreate?: PpdbRegistrationCreateOrConnectWithoutDocumentsInput
    connect?: PpdbRegistrationWhereUniqueInput
  }

  export type TenantUpdateOneRequiredWithoutPpdbDocumentsNestedInput = {
    create?: XOR<TenantCreateWithoutPpdbDocumentsInput, TenantUncheckedCreateWithoutPpdbDocumentsInput>
    connectOrCreate?: TenantCreateOrConnectWithoutPpdbDocumentsInput
    upsert?: TenantUpsertWithoutPpdbDocumentsInput
    connect?: TenantWhereUniqueInput
    update?: XOR<XOR<TenantUpdateToOneWithWhereWithoutPpdbDocumentsInput, TenantUpdateWithoutPpdbDocumentsInput>, TenantUncheckedUpdateWithoutPpdbDocumentsInput>
  }

  export type PpdbRegistrationUpdateOneRequiredWithoutDocumentsNestedInput = {
    create?: XOR<PpdbRegistrationCreateWithoutDocumentsInput, PpdbRegistrationUncheckedCreateWithoutDocumentsInput>
    connectOrCreate?: PpdbRegistrationCreateOrConnectWithoutDocumentsInput
    upsert?: PpdbRegistrationUpsertWithoutDocumentsInput
    connect?: PpdbRegistrationWhereUniqueInput
    update?: XOR<XOR<PpdbRegistrationUpdateToOneWithWhereWithoutDocumentsInput, PpdbRegistrationUpdateWithoutDocumentsInput>, PpdbRegistrationUncheckedUpdateWithoutDocumentsInput>
  }

  export type TenantCreateNestedOneWithoutPpdbExamsInput = {
    create?: XOR<TenantCreateWithoutPpdbExamsInput, TenantUncheckedCreateWithoutPpdbExamsInput>
    connectOrCreate?: TenantCreateOrConnectWithoutPpdbExamsInput
    connect?: TenantWhereUniqueInput
  }

  export type PpdbRegistrationCreateNestedOneWithoutExamsInput = {
    create?: XOR<PpdbRegistrationCreateWithoutExamsInput, PpdbRegistrationUncheckedCreateWithoutExamsInput>
    connectOrCreate?: PpdbRegistrationCreateOrConnectWithoutExamsInput
    connect?: PpdbRegistrationWhereUniqueInput
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type TenantUpdateOneRequiredWithoutPpdbExamsNestedInput = {
    create?: XOR<TenantCreateWithoutPpdbExamsInput, TenantUncheckedCreateWithoutPpdbExamsInput>
    connectOrCreate?: TenantCreateOrConnectWithoutPpdbExamsInput
    upsert?: TenantUpsertWithoutPpdbExamsInput
    connect?: TenantWhereUniqueInput
    update?: XOR<XOR<TenantUpdateToOneWithWhereWithoutPpdbExamsInput, TenantUpdateWithoutPpdbExamsInput>, TenantUncheckedUpdateWithoutPpdbExamsInput>
  }

  export type PpdbRegistrationUpdateOneRequiredWithoutExamsNestedInput = {
    create?: XOR<PpdbRegistrationCreateWithoutExamsInput, PpdbRegistrationUncheckedCreateWithoutExamsInput>
    connectOrCreate?: PpdbRegistrationCreateOrConnectWithoutExamsInput
    upsert?: PpdbRegistrationUpsertWithoutExamsInput
    connect?: PpdbRegistrationWhereUniqueInput
    update?: XOR<XOR<PpdbRegistrationUpdateToOneWithWhereWithoutExamsInput, PpdbRegistrationUpdateWithoutExamsInput>, PpdbRegistrationUncheckedUpdateWithoutExamsInput>
  }

  export type TenantCreateNestedOneWithoutInventoryItemsInput = {
    create?: XOR<TenantCreateWithoutInventoryItemsInput, TenantUncheckedCreateWithoutInventoryItemsInput>
    connectOrCreate?: TenantCreateOrConnectWithoutInventoryItemsInput
    connect?: TenantWhereUniqueInput
  }

  export type InventoryTransactionCreateNestedManyWithoutItemInput = {
    create?: XOR<InventoryTransactionCreateWithoutItemInput, InventoryTransactionUncheckedCreateWithoutItemInput> | InventoryTransactionCreateWithoutItemInput[] | InventoryTransactionUncheckedCreateWithoutItemInput[]
    connectOrCreate?: InventoryTransactionCreateOrConnectWithoutItemInput | InventoryTransactionCreateOrConnectWithoutItemInput[]
    createMany?: InventoryTransactionCreateManyItemInputEnvelope
    connect?: InventoryTransactionWhereUniqueInput | InventoryTransactionWhereUniqueInput[]
  }

  export type InventoryTransactionUncheckedCreateNestedManyWithoutItemInput = {
    create?: XOR<InventoryTransactionCreateWithoutItemInput, InventoryTransactionUncheckedCreateWithoutItemInput> | InventoryTransactionCreateWithoutItemInput[] | InventoryTransactionUncheckedCreateWithoutItemInput[]
    connectOrCreate?: InventoryTransactionCreateOrConnectWithoutItemInput | InventoryTransactionCreateOrConnectWithoutItemInput[]
    createMany?: InventoryTransactionCreateManyItemInputEnvelope
    connect?: InventoryTransactionWhereUniqueInput | InventoryTransactionWhereUniqueInput[]
  }

  export type TenantUpdateOneRequiredWithoutInventoryItemsNestedInput = {
    create?: XOR<TenantCreateWithoutInventoryItemsInput, TenantUncheckedCreateWithoutInventoryItemsInput>
    connectOrCreate?: TenantCreateOrConnectWithoutInventoryItemsInput
    upsert?: TenantUpsertWithoutInventoryItemsInput
    connect?: TenantWhereUniqueInput
    update?: XOR<XOR<TenantUpdateToOneWithWhereWithoutInventoryItemsInput, TenantUpdateWithoutInventoryItemsInput>, TenantUncheckedUpdateWithoutInventoryItemsInput>
  }

  export type InventoryTransactionUpdateManyWithoutItemNestedInput = {
    create?: XOR<InventoryTransactionCreateWithoutItemInput, InventoryTransactionUncheckedCreateWithoutItemInput> | InventoryTransactionCreateWithoutItemInput[] | InventoryTransactionUncheckedCreateWithoutItemInput[]
    connectOrCreate?: InventoryTransactionCreateOrConnectWithoutItemInput | InventoryTransactionCreateOrConnectWithoutItemInput[]
    upsert?: InventoryTransactionUpsertWithWhereUniqueWithoutItemInput | InventoryTransactionUpsertWithWhereUniqueWithoutItemInput[]
    createMany?: InventoryTransactionCreateManyItemInputEnvelope
    set?: InventoryTransactionWhereUniqueInput | InventoryTransactionWhereUniqueInput[]
    disconnect?: InventoryTransactionWhereUniqueInput | InventoryTransactionWhereUniqueInput[]
    delete?: InventoryTransactionWhereUniqueInput | InventoryTransactionWhereUniqueInput[]
    connect?: InventoryTransactionWhereUniqueInput | InventoryTransactionWhereUniqueInput[]
    update?: InventoryTransactionUpdateWithWhereUniqueWithoutItemInput | InventoryTransactionUpdateWithWhereUniqueWithoutItemInput[]
    updateMany?: InventoryTransactionUpdateManyWithWhereWithoutItemInput | InventoryTransactionUpdateManyWithWhereWithoutItemInput[]
    deleteMany?: InventoryTransactionScalarWhereInput | InventoryTransactionScalarWhereInput[]
  }

  export type InventoryTransactionUncheckedUpdateManyWithoutItemNestedInput = {
    create?: XOR<InventoryTransactionCreateWithoutItemInput, InventoryTransactionUncheckedCreateWithoutItemInput> | InventoryTransactionCreateWithoutItemInput[] | InventoryTransactionUncheckedCreateWithoutItemInput[]
    connectOrCreate?: InventoryTransactionCreateOrConnectWithoutItemInput | InventoryTransactionCreateOrConnectWithoutItemInput[]
    upsert?: InventoryTransactionUpsertWithWhereUniqueWithoutItemInput | InventoryTransactionUpsertWithWhereUniqueWithoutItemInput[]
    createMany?: InventoryTransactionCreateManyItemInputEnvelope
    set?: InventoryTransactionWhereUniqueInput | InventoryTransactionWhereUniqueInput[]
    disconnect?: InventoryTransactionWhereUniqueInput | InventoryTransactionWhereUniqueInput[]
    delete?: InventoryTransactionWhereUniqueInput | InventoryTransactionWhereUniqueInput[]
    connect?: InventoryTransactionWhereUniqueInput | InventoryTransactionWhereUniqueInput[]
    update?: InventoryTransactionUpdateWithWhereUniqueWithoutItemInput | InventoryTransactionUpdateWithWhereUniqueWithoutItemInput[]
    updateMany?: InventoryTransactionUpdateManyWithWhereWithoutItemInput | InventoryTransactionUpdateManyWithWhereWithoutItemInput[]
    deleteMany?: InventoryTransactionScalarWhereInput | InventoryTransactionScalarWhereInput[]
  }

  export type TenantCreateNestedOneWithoutInventoryTransactionsInput = {
    create?: XOR<TenantCreateWithoutInventoryTransactionsInput, TenantUncheckedCreateWithoutInventoryTransactionsInput>
    connectOrCreate?: TenantCreateOrConnectWithoutInventoryTransactionsInput
    connect?: TenantWhereUniqueInput
  }

  export type ItemCreateNestedOneWithoutTransactionsInput = {
    create?: XOR<ItemCreateWithoutTransactionsInput, ItemUncheckedCreateWithoutTransactionsInput>
    connectOrCreate?: ItemCreateOrConnectWithoutTransactionsInput
    connect?: ItemWhereUniqueInput
  }

  export type TenantUpdateOneRequiredWithoutInventoryTransactionsNestedInput = {
    create?: XOR<TenantCreateWithoutInventoryTransactionsInput, TenantUncheckedCreateWithoutInventoryTransactionsInput>
    connectOrCreate?: TenantCreateOrConnectWithoutInventoryTransactionsInput
    upsert?: TenantUpsertWithoutInventoryTransactionsInput
    connect?: TenantWhereUniqueInput
    update?: XOR<XOR<TenantUpdateToOneWithWhereWithoutInventoryTransactionsInput, TenantUpdateWithoutInventoryTransactionsInput>, TenantUncheckedUpdateWithoutInventoryTransactionsInput>
  }

  export type ItemUpdateOneRequiredWithoutTransactionsNestedInput = {
    create?: XOR<ItemCreateWithoutTransactionsInput, ItemUncheckedCreateWithoutTransactionsInput>
    connectOrCreate?: ItemCreateOrConnectWithoutTransactionsInput
    upsert?: ItemUpsertWithoutTransactionsInput
    connect?: ItemWhereUniqueInput
    update?: XOR<XOR<ItemUpdateToOneWithWhereWithoutTransactionsInput, ItemUpdateWithoutTransactionsInput>, ItemUncheckedUpdateWithoutTransactionsInput>
  }

  export type TenantCreateNestedOneWithoutSuppliersInput = {
    create?: XOR<TenantCreateWithoutSuppliersInput, TenantUncheckedCreateWithoutSuppliersInput>
    connectOrCreate?: TenantCreateOrConnectWithoutSuppliersInput
    connect?: TenantWhereUniqueInput
  }

  export type PurchaseOrderCreateNestedManyWithoutSupplierInput = {
    create?: XOR<PurchaseOrderCreateWithoutSupplierInput, PurchaseOrderUncheckedCreateWithoutSupplierInput> | PurchaseOrderCreateWithoutSupplierInput[] | PurchaseOrderUncheckedCreateWithoutSupplierInput[]
    connectOrCreate?: PurchaseOrderCreateOrConnectWithoutSupplierInput | PurchaseOrderCreateOrConnectWithoutSupplierInput[]
    createMany?: PurchaseOrderCreateManySupplierInputEnvelope
    connect?: PurchaseOrderWhereUniqueInput | PurchaseOrderWhereUniqueInput[]
  }

  export type PurchaseOrderUncheckedCreateNestedManyWithoutSupplierInput = {
    create?: XOR<PurchaseOrderCreateWithoutSupplierInput, PurchaseOrderUncheckedCreateWithoutSupplierInput> | PurchaseOrderCreateWithoutSupplierInput[] | PurchaseOrderUncheckedCreateWithoutSupplierInput[]
    connectOrCreate?: PurchaseOrderCreateOrConnectWithoutSupplierInput | PurchaseOrderCreateOrConnectWithoutSupplierInput[]
    createMany?: PurchaseOrderCreateManySupplierInputEnvelope
    connect?: PurchaseOrderWhereUniqueInput | PurchaseOrderWhereUniqueInput[]
  }

  export type TenantUpdateOneRequiredWithoutSuppliersNestedInput = {
    create?: XOR<TenantCreateWithoutSuppliersInput, TenantUncheckedCreateWithoutSuppliersInput>
    connectOrCreate?: TenantCreateOrConnectWithoutSuppliersInput
    upsert?: TenantUpsertWithoutSuppliersInput
    connect?: TenantWhereUniqueInput
    update?: XOR<XOR<TenantUpdateToOneWithWhereWithoutSuppliersInput, TenantUpdateWithoutSuppliersInput>, TenantUncheckedUpdateWithoutSuppliersInput>
  }

  export type PurchaseOrderUpdateManyWithoutSupplierNestedInput = {
    create?: XOR<PurchaseOrderCreateWithoutSupplierInput, PurchaseOrderUncheckedCreateWithoutSupplierInput> | PurchaseOrderCreateWithoutSupplierInput[] | PurchaseOrderUncheckedCreateWithoutSupplierInput[]
    connectOrCreate?: PurchaseOrderCreateOrConnectWithoutSupplierInput | PurchaseOrderCreateOrConnectWithoutSupplierInput[]
    upsert?: PurchaseOrderUpsertWithWhereUniqueWithoutSupplierInput | PurchaseOrderUpsertWithWhereUniqueWithoutSupplierInput[]
    createMany?: PurchaseOrderCreateManySupplierInputEnvelope
    set?: PurchaseOrderWhereUniqueInput | PurchaseOrderWhereUniqueInput[]
    disconnect?: PurchaseOrderWhereUniqueInput | PurchaseOrderWhereUniqueInput[]
    delete?: PurchaseOrderWhereUniqueInput | PurchaseOrderWhereUniqueInput[]
    connect?: PurchaseOrderWhereUniqueInput | PurchaseOrderWhereUniqueInput[]
    update?: PurchaseOrderUpdateWithWhereUniqueWithoutSupplierInput | PurchaseOrderUpdateWithWhereUniqueWithoutSupplierInput[]
    updateMany?: PurchaseOrderUpdateManyWithWhereWithoutSupplierInput | PurchaseOrderUpdateManyWithWhereWithoutSupplierInput[]
    deleteMany?: PurchaseOrderScalarWhereInput | PurchaseOrderScalarWhereInput[]
  }

  export type PurchaseOrderUncheckedUpdateManyWithoutSupplierNestedInput = {
    create?: XOR<PurchaseOrderCreateWithoutSupplierInput, PurchaseOrderUncheckedCreateWithoutSupplierInput> | PurchaseOrderCreateWithoutSupplierInput[] | PurchaseOrderUncheckedCreateWithoutSupplierInput[]
    connectOrCreate?: PurchaseOrderCreateOrConnectWithoutSupplierInput | PurchaseOrderCreateOrConnectWithoutSupplierInput[]
    upsert?: PurchaseOrderUpsertWithWhereUniqueWithoutSupplierInput | PurchaseOrderUpsertWithWhereUniqueWithoutSupplierInput[]
    createMany?: PurchaseOrderCreateManySupplierInputEnvelope
    set?: PurchaseOrderWhereUniqueInput | PurchaseOrderWhereUniqueInput[]
    disconnect?: PurchaseOrderWhereUniqueInput | PurchaseOrderWhereUniqueInput[]
    delete?: PurchaseOrderWhereUniqueInput | PurchaseOrderWhereUniqueInput[]
    connect?: PurchaseOrderWhereUniqueInput | PurchaseOrderWhereUniqueInput[]
    update?: PurchaseOrderUpdateWithWhereUniqueWithoutSupplierInput | PurchaseOrderUpdateWithWhereUniqueWithoutSupplierInput[]
    updateMany?: PurchaseOrderUpdateManyWithWhereWithoutSupplierInput | PurchaseOrderUpdateManyWithWhereWithoutSupplierInput[]
    deleteMany?: PurchaseOrderScalarWhereInput | PurchaseOrderScalarWhereInput[]
  }

  export type TenantCreateNestedOneWithoutPurchaseOrdersInput = {
    create?: XOR<TenantCreateWithoutPurchaseOrdersInput, TenantUncheckedCreateWithoutPurchaseOrdersInput>
    connectOrCreate?: TenantCreateOrConnectWithoutPurchaseOrdersInput
    connect?: TenantWhereUniqueInput
  }

  export type SupplierCreateNestedOneWithoutPurchaseOrdersInput = {
    create?: XOR<SupplierCreateWithoutPurchaseOrdersInput, SupplierUncheckedCreateWithoutPurchaseOrdersInput>
    connectOrCreate?: SupplierCreateOrConnectWithoutPurchaseOrdersInput
    connect?: SupplierWhereUniqueInput
  }

  export type TenantUpdateOneRequiredWithoutPurchaseOrdersNestedInput = {
    create?: XOR<TenantCreateWithoutPurchaseOrdersInput, TenantUncheckedCreateWithoutPurchaseOrdersInput>
    connectOrCreate?: TenantCreateOrConnectWithoutPurchaseOrdersInput
    upsert?: TenantUpsertWithoutPurchaseOrdersInput
    connect?: TenantWhereUniqueInput
    update?: XOR<XOR<TenantUpdateToOneWithWhereWithoutPurchaseOrdersInput, TenantUpdateWithoutPurchaseOrdersInput>, TenantUncheckedUpdateWithoutPurchaseOrdersInput>
  }

  export type SupplierUpdateOneRequiredWithoutPurchaseOrdersNestedInput = {
    create?: XOR<SupplierCreateWithoutPurchaseOrdersInput, SupplierUncheckedCreateWithoutPurchaseOrdersInput>
    connectOrCreate?: SupplierCreateOrConnectWithoutPurchaseOrdersInput
    upsert?: SupplierUpsertWithoutPurchaseOrdersInput
    connect?: SupplierWhereUniqueInput
    update?: XOR<XOR<SupplierUpdateToOneWithWhereWithoutPurchaseOrdersInput, SupplierUpdateWithoutPurchaseOrdersInput>, SupplierUncheckedUpdateWithoutPurchaseOrdersInput>
  }

  export type TenantCreateNestedOneWithoutBuildingsInput = {
    create?: XOR<TenantCreateWithoutBuildingsInput, TenantUncheckedCreateWithoutBuildingsInput>
    connectOrCreate?: TenantCreateOrConnectWithoutBuildingsInput
    connect?: TenantWhereUniqueInput
  }

  export type RoomCreateNestedManyWithoutBuildingInput = {
    create?: XOR<RoomCreateWithoutBuildingInput, RoomUncheckedCreateWithoutBuildingInput> | RoomCreateWithoutBuildingInput[] | RoomUncheckedCreateWithoutBuildingInput[]
    connectOrCreate?: RoomCreateOrConnectWithoutBuildingInput | RoomCreateOrConnectWithoutBuildingInput[]
    createMany?: RoomCreateManyBuildingInputEnvelope
    connect?: RoomWhereUniqueInput | RoomWhereUniqueInput[]
  }

  export type RoomUncheckedCreateNestedManyWithoutBuildingInput = {
    create?: XOR<RoomCreateWithoutBuildingInput, RoomUncheckedCreateWithoutBuildingInput> | RoomCreateWithoutBuildingInput[] | RoomUncheckedCreateWithoutBuildingInput[]
    connectOrCreate?: RoomCreateOrConnectWithoutBuildingInput | RoomCreateOrConnectWithoutBuildingInput[]
    createMany?: RoomCreateManyBuildingInputEnvelope
    connect?: RoomWhereUniqueInput | RoomWhereUniqueInput[]
  }

  export type TenantUpdateOneRequiredWithoutBuildingsNestedInput = {
    create?: XOR<TenantCreateWithoutBuildingsInput, TenantUncheckedCreateWithoutBuildingsInput>
    connectOrCreate?: TenantCreateOrConnectWithoutBuildingsInput
    upsert?: TenantUpsertWithoutBuildingsInput
    connect?: TenantWhereUniqueInput
    update?: XOR<XOR<TenantUpdateToOneWithWhereWithoutBuildingsInput, TenantUpdateWithoutBuildingsInput>, TenantUncheckedUpdateWithoutBuildingsInput>
  }

  export type RoomUpdateManyWithoutBuildingNestedInput = {
    create?: XOR<RoomCreateWithoutBuildingInput, RoomUncheckedCreateWithoutBuildingInput> | RoomCreateWithoutBuildingInput[] | RoomUncheckedCreateWithoutBuildingInput[]
    connectOrCreate?: RoomCreateOrConnectWithoutBuildingInput | RoomCreateOrConnectWithoutBuildingInput[]
    upsert?: RoomUpsertWithWhereUniqueWithoutBuildingInput | RoomUpsertWithWhereUniqueWithoutBuildingInput[]
    createMany?: RoomCreateManyBuildingInputEnvelope
    set?: RoomWhereUniqueInput | RoomWhereUniqueInput[]
    disconnect?: RoomWhereUniqueInput | RoomWhereUniqueInput[]
    delete?: RoomWhereUniqueInput | RoomWhereUniqueInput[]
    connect?: RoomWhereUniqueInput | RoomWhereUniqueInput[]
    update?: RoomUpdateWithWhereUniqueWithoutBuildingInput | RoomUpdateWithWhereUniqueWithoutBuildingInput[]
    updateMany?: RoomUpdateManyWithWhereWithoutBuildingInput | RoomUpdateManyWithWhereWithoutBuildingInput[]
    deleteMany?: RoomScalarWhereInput | RoomScalarWhereInput[]
  }

  export type RoomUncheckedUpdateManyWithoutBuildingNestedInput = {
    create?: XOR<RoomCreateWithoutBuildingInput, RoomUncheckedCreateWithoutBuildingInput> | RoomCreateWithoutBuildingInput[] | RoomUncheckedCreateWithoutBuildingInput[]
    connectOrCreate?: RoomCreateOrConnectWithoutBuildingInput | RoomCreateOrConnectWithoutBuildingInput[]
    upsert?: RoomUpsertWithWhereUniqueWithoutBuildingInput | RoomUpsertWithWhereUniqueWithoutBuildingInput[]
    createMany?: RoomCreateManyBuildingInputEnvelope
    set?: RoomWhereUniqueInput | RoomWhereUniqueInput[]
    disconnect?: RoomWhereUniqueInput | RoomWhereUniqueInput[]
    delete?: RoomWhereUniqueInput | RoomWhereUniqueInput[]
    connect?: RoomWhereUniqueInput | RoomWhereUniqueInput[]
    update?: RoomUpdateWithWhereUniqueWithoutBuildingInput | RoomUpdateWithWhereUniqueWithoutBuildingInput[]
    updateMany?: RoomUpdateManyWithWhereWithoutBuildingInput | RoomUpdateManyWithWhereWithoutBuildingInput[]
    deleteMany?: RoomScalarWhereInput | RoomScalarWhereInput[]
  }

  export type TenantCreateNestedOneWithoutRoomsInput = {
    create?: XOR<TenantCreateWithoutRoomsInput, TenantUncheckedCreateWithoutRoomsInput>
    connectOrCreate?: TenantCreateOrConnectWithoutRoomsInput
    connect?: TenantWhereUniqueInput
  }

  export type BuildingCreateNestedOneWithoutRoomsInput = {
    create?: XOR<BuildingCreateWithoutRoomsInput, BuildingUncheckedCreateWithoutRoomsInput>
    connectOrCreate?: BuildingCreateOrConnectWithoutRoomsInput
    connect?: BuildingWhereUniqueInput
  }

  export type RoomAssignmentCreateNestedManyWithoutRoomInput = {
    create?: XOR<RoomAssignmentCreateWithoutRoomInput, RoomAssignmentUncheckedCreateWithoutRoomInput> | RoomAssignmentCreateWithoutRoomInput[] | RoomAssignmentUncheckedCreateWithoutRoomInput[]
    connectOrCreate?: RoomAssignmentCreateOrConnectWithoutRoomInput | RoomAssignmentCreateOrConnectWithoutRoomInput[]
    createMany?: RoomAssignmentCreateManyRoomInputEnvelope
    connect?: RoomAssignmentWhereUniqueInput | RoomAssignmentWhereUniqueInput[]
  }

  export type MaintenanceTicketCreateNestedManyWithoutRoomInput = {
    create?: XOR<MaintenanceTicketCreateWithoutRoomInput, MaintenanceTicketUncheckedCreateWithoutRoomInput> | MaintenanceTicketCreateWithoutRoomInput[] | MaintenanceTicketUncheckedCreateWithoutRoomInput[]
    connectOrCreate?: MaintenanceTicketCreateOrConnectWithoutRoomInput | MaintenanceTicketCreateOrConnectWithoutRoomInput[]
    createMany?: MaintenanceTicketCreateManyRoomInputEnvelope
    connect?: MaintenanceTicketWhereUniqueInput | MaintenanceTicketWhereUniqueInput[]
  }

  export type RoomAssignmentUncheckedCreateNestedManyWithoutRoomInput = {
    create?: XOR<RoomAssignmentCreateWithoutRoomInput, RoomAssignmentUncheckedCreateWithoutRoomInput> | RoomAssignmentCreateWithoutRoomInput[] | RoomAssignmentUncheckedCreateWithoutRoomInput[]
    connectOrCreate?: RoomAssignmentCreateOrConnectWithoutRoomInput | RoomAssignmentCreateOrConnectWithoutRoomInput[]
    createMany?: RoomAssignmentCreateManyRoomInputEnvelope
    connect?: RoomAssignmentWhereUniqueInput | RoomAssignmentWhereUniqueInput[]
  }

  export type MaintenanceTicketUncheckedCreateNestedManyWithoutRoomInput = {
    create?: XOR<MaintenanceTicketCreateWithoutRoomInput, MaintenanceTicketUncheckedCreateWithoutRoomInput> | MaintenanceTicketCreateWithoutRoomInput[] | MaintenanceTicketUncheckedCreateWithoutRoomInput[]
    connectOrCreate?: MaintenanceTicketCreateOrConnectWithoutRoomInput | MaintenanceTicketCreateOrConnectWithoutRoomInput[]
    createMany?: MaintenanceTicketCreateManyRoomInputEnvelope
    connect?: MaintenanceTicketWhereUniqueInput | MaintenanceTicketWhereUniqueInput[]
  }

  export type TenantUpdateOneRequiredWithoutRoomsNestedInput = {
    create?: XOR<TenantCreateWithoutRoomsInput, TenantUncheckedCreateWithoutRoomsInput>
    connectOrCreate?: TenantCreateOrConnectWithoutRoomsInput
    upsert?: TenantUpsertWithoutRoomsInput
    connect?: TenantWhereUniqueInput
    update?: XOR<XOR<TenantUpdateToOneWithWhereWithoutRoomsInput, TenantUpdateWithoutRoomsInput>, TenantUncheckedUpdateWithoutRoomsInput>
  }

  export type BuildingUpdateOneRequiredWithoutRoomsNestedInput = {
    create?: XOR<BuildingCreateWithoutRoomsInput, BuildingUncheckedCreateWithoutRoomsInput>
    connectOrCreate?: BuildingCreateOrConnectWithoutRoomsInput
    upsert?: BuildingUpsertWithoutRoomsInput
    connect?: BuildingWhereUniqueInput
    update?: XOR<XOR<BuildingUpdateToOneWithWhereWithoutRoomsInput, BuildingUpdateWithoutRoomsInput>, BuildingUncheckedUpdateWithoutRoomsInput>
  }

  export type RoomAssignmentUpdateManyWithoutRoomNestedInput = {
    create?: XOR<RoomAssignmentCreateWithoutRoomInput, RoomAssignmentUncheckedCreateWithoutRoomInput> | RoomAssignmentCreateWithoutRoomInput[] | RoomAssignmentUncheckedCreateWithoutRoomInput[]
    connectOrCreate?: RoomAssignmentCreateOrConnectWithoutRoomInput | RoomAssignmentCreateOrConnectWithoutRoomInput[]
    upsert?: RoomAssignmentUpsertWithWhereUniqueWithoutRoomInput | RoomAssignmentUpsertWithWhereUniqueWithoutRoomInput[]
    createMany?: RoomAssignmentCreateManyRoomInputEnvelope
    set?: RoomAssignmentWhereUniqueInput | RoomAssignmentWhereUniqueInput[]
    disconnect?: RoomAssignmentWhereUniqueInput | RoomAssignmentWhereUniqueInput[]
    delete?: RoomAssignmentWhereUniqueInput | RoomAssignmentWhereUniqueInput[]
    connect?: RoomAssignmentWhereUniqueInput | RoomAssignmentWhereUniqueInput[]
    update?: RoomAssignmentUpdateWithWhereUniqueWithoutRoomInput | RoomAssignmentUpdateWithWhereUniqueWithoutRoomInput[]
    updateMany?: RoomAssignmentUpdateManyWithWhereWithoutRoomInput | RoomAssignmentUpdateManyWithWhereWithoutRoomInput[]
    deleteMany?: RoomAssignmentScalarWhereInput | RoomAssignmentScalarWhereInput[]
  }

  export type MaintenanceTicketUpdateManyWithoutRoomNestedInput = {
    create?: XOR<MaintenanceTicketCreateWithoutRoomInput, MaintenanceTicketUncheckedCreateWithoutRoomInput> | MaintenanceTicketCreateWithoutRoomInput[] | MaintenanceTicketUncheckedCreateWithoutRoomInput[]
    connectOrCreate?: MaintenanceTicketCreateOrConnectWithoutRoomInput | MaintenanceTicketCreateOrConnectWithoutRoomInput[]
    upsert?: MaintenanceTicketUpsertWithWhereUniqueWithoutRoomInput | MaintenanceTicketUpsertWithWhereUniqueWithoutRoomInput[]
    createMany?: MaintenanceTicketCreateManyRoomInputEnvelope
    set?: MaintenanceTicketWhereUniqueInput | MaintenanceTicketWhereUniqueInput[]
    disconnect?: MaintenanceTicketWhereUniqueInput | MaintenanceTicketWhereUniqueInput[]
    delete?: MaintenanceTicketWhereUniqueInput | MaintenanceTicketWhereUniqueInput[]
    connect?: MaintenanceTicketWhereUniqueInput | MaintenanceTicketWhereUniqueInput[]
    update?: MaintenanceTicketUpdateWithWhereUniqueWithoutRoomInput | MaintenanceTicketUpdateWithWhereUniqueWithoutRoomInput[]
    updateMany?: MaintenanceTicketUpdateManyWithWhereWithoutRoomInput | MaintenanceTicketUpdateManyWithWhereWithoutRoomInput[]
    deleteMany?: MaintenanceTicketScalarWhereInput | MaintenanceTicketScalarWhereInput[]
  }

  export type RoomAssignmentUncheckedUpdateManyWithoutRoomNestedInput = {
    create?: XOR<RoomAssignmentCreateWithoutRoomInput, RoomAssignmentUncheckedCreateWithoutRoomInput> | RoomAssignmentCreateWithoutRoomInput[] | RoomAssignmentUncheckedCreateWithoutRoomInput[]
    connectOrCreate?: RoomAssignmentCreateOrConnectWithoutRoomInput | RoomAssignmentCreateOrConnectWithoutRoomInput[]
    upsert?: RoomAssignmentUpsertWithWhereUniqueWithoutRoomInput | RoomAssignmentUpsertWithWhereUniqueWithoutRoomInput[]
    createMany?: RoomAssignmentCreateManyRoomInputEnvelope
    set?: RoomAssignmentWhereUniqueInput | RoomAssignmentWhereUniqueInput[]
    disconnect?: RoomAssignmentWhereUniqueInput | RoomAssignmentWhereUniqueInput[]
    delete?: RoomAssignmentWhereUniqueInput | RoomAssignmentWhereUniqueInput[]
    connect?: RoomAssignmentWhereUniqueInput | RoomAssignmentWhereUniqueInput[]
    update?: RoomAssignmentUpdateWithWhereUniqueWithoutRoomInput | RoomAssignmentUpdateWithWhereUniqueWithoutRoomInput[]
    updateMany?: RoomAssignmentUpdateManyWithWhereWithoutRoomInput | RoomAssignmentUpdateManyWithWhereWithoutRoomInput[]
    deleteMany?: RoomAssignmentScalarWhereInput | RoomAssignmentScalarWhereInput[]
  }

  export type MaintenanceTicketUncheckedUpdateManyWithoutRoomNestedInput = {
    create?: XOR<MaintenanceTicketCreateWithoutRoomInput, MaintenanceTicketUncheckedCreateWithoutRoomInput> | MaintenanceTicketCreateWithoutRoomInput[] | MaintenanceTicketUncheckedCreateWithoutRoomInput[]
    connectOrCreate?: MaintenanceTicketCreateOrConnectWithoutRoomInput | MaintenanceTicketCreateOrConnectWithoutRoomInput[]
    upsert?: MaintenanceTicketUpsertWithWhereUniqueWithoutRoomInput | MaintenanceTicketUpsertWithWhereUniqueWithoutRoomInput[]
    createMany?: MaintenanceTicketCreateManyRoomInputEnvelope
    set?: MaintenanceTicketWhereUniqueInput | MaintenanceTicketWhereUniqueInput[]
    disconnect?: MaintenanceTicketWhereUniqueInput | MaintenanceTicketWhereUniqueInput[]
    delete?: MaintenanceTicketWhereUniqueInput | MaintenanceTicketWhereUniqueInput[]
    connect?: MaintenanceTicketWhereUniqueInput | MaintenanceTicketWhereUniqueInput[]
    update?: MaintenanceTicketUpdateWithWhereUniqueWithoutRoomInput | MaintenanceTicketUpdateWithWhereUniqueWithoutRoomInput[]
    updateMany?: MaintenanceTicketUpdateManyWithWhereWithoutRoomInput | MaintenanceTicketUpdateManyWithWhereWithoutRoomInput[]
    deleteMany?: MaintenanceTicketScalarWhereInput | MaintenanceTicketScalarWhereInput[]
  }

  export type TenantCreateNestedOneWithoutRoomAssignmentsInput = {
    create?: XOR<TenantCreateWithoutRoomAssignmentsInput, TenantUncheckedCreateWithoutRoomAssignmentsInput>
    connectOrCreate?: TenantCreateOrConnectWithoutRoomAssignmentsInput
    connect?: TenantWhereUniqueInput
  }

  export type RoomCreateNestedOneWithoutAssignmentsInput = {
    create?: XOR<RoomCreateWithoutAssignmentsInput, RoomUncheckedCreateWithoutAssignmentsInput>
    connectOrCreate?: RoomCreateOrConnectWithoutAssignmentsInput
    connect?: RoomWhereUniqueInput
  }

  export type TenantUpdateOneRequiredWithoutRoomAssignmentsNestedInput = {
    create?: XOR<TenantCreateWithoutRoomAssignmentsInput, TenantUncheckedCreateWithoutRoomAssignmentsInput>
    connectOrCreate?: TenantCreateOrConnectWithoutRoomAssignmentsInput
    upsert?: TenantUpsertWithoutRoomAssignmentsInput
    connect?: TenantWhereUniqueInput
    update?: XOR<XOR<TenantUpdateToOneWithWhereWithoutRoomAssignmentsInput, TenantUpdateWithoutRoomAssignmentsInput>, TenantUncheckedUpdateWithoutRoomAssignmentsInput>
  }

  export type RoomUpdateOneRequiredWithoutAssignmentsNestedInput = {
    create?: XOR<RoomCreateWithoutAssignmentsInput, RoomUncheckedCreateWithoutAssignmentsInput>
    connectOrCreate?: RoomCreateOrConnectWithoutAssignmentsInput
    upsert?: RoomUpsertWithoutAssignmentsInput
    connect?: RoomWhereUniqueInput
    update?: XOR<XOR<RoomUpdateToOneWithWhereWithoutAssignmentsInput, RoomUpdateWithoutAssignmentsInput>, RoomUncheckedUpdateWithoutAssignmentsInput>
  }

  export type TenantCreateNestedOneWithoutMaintenanceTicketsInput = {
    create?: XOR<TenantCreateWithoutMaintenanceTicketsInput, TenantUncheckedCreateWithoutMaintenanceTicketsInput>
    connectOrCreate?: TenantCreateOrConnectWithoutMaintenanceTicketsInput
    connect?: TenantWhereUniqueInput
  }

  export type RoomCreateNestedOneWithoutTicketsInput = {
    create?: XOR<RoomCreateWithoutTicketsInput, RoomUncheckedCreateWithoutTicketsInput>
    connectOrCreate?: RoomCreateOrConnectWithoutTicketsInput
    connect?: RoomWhereUniqueInput
  }

  export type TenantUpdateOneRequiredWithoutMaintenanceTicketsNestedInput = {
    create?: XOR<TenantCreateWithoutMaintenanceTicketsInput, TenantUncheckedCreateWithoutMaintenanceTicketsInput>
    connectOrCreate?: TenantCreateOrConnectWithoutMaintenanceTicketsInput
    upsert?: TenantUpsertWithoutMaintenanceTicketsInput
    connect?: TenantWhereUniqueInput
    update?: XOR<XOR<TenantUpdateToOneWithWhereWithoutMaintenanceTicketsInput, TenantUpdateWithoutMaintenanceTicketsInput>, TenantUncheckedUpdateWithoutMaintenanceTicketsInput>
  }

  export type RoomUpdateOneRequiredWithoutTicketsNestedInput = {
    create?: XOR<RoomCreateWithoutTicketsInput, RoomUncheckedCreateWithoutTicketsInput>
    connectOrCreate?: RoomCreateOrConnectWithoutTicketsInput
    upsert?: RoomUpsertWithoutTicketsInput
    connect?: RoomWhereUniqueInput
    update?: XOR<XOR<RoomUpdateToOneWithWhereWithoutTicketsInput, RoomUpdateWithoutTicketsInput>, RoomUncheckedUpdateWithoutTicketsInput>
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedFloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type UserCreateWithoutTenantInput = {
    id?: string
    email: string
    passwordHash: string
    role?: string
    name: string
    phone?: string | null
    isActive?: boolean
    lastLogin?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    refreshTokens?: RefreshTokenCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutTenantInput = {
    id?: string
    email: string
    passwordHash: string
    role?: string
    name: string
    phone?: string | null
    isActive?: boolean
    lastLogin?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    refreshTokens?: RefreshTokenUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutTenantInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutTenantInput, UserUncheckedCreateWithoutTenantInput>
  }

  export type UserCreateManyTenantInputEnvelope = {
    data: UserCreateManyTenantInput | UserCreateManyTenantInput[]
  }

  export type SantriCreateWithoutTenantInput = {
    id?: string
    nisn?: string | null
    name: string
    gender: string
    dob?: Date | string | null
    kelas?: string | null
    room?: string | null
    contact?: string | null
    address?: string | null
    photo?: string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    walis?: SantriWaliCreateNestedManyWithoutSantriInput
    izin?: IzinCreateNestedManyWithoutSantriInput
    catatanHarian?: CatatanHarianCreateNestedManyWithoutSantriInput
    invoices?: InvoiceCreateNestedManyWithoutSantriInput
    pelanggaran?: PelanggaranCreateNestedManyWithoutSantriInput
    pembinaan?: PembinaanCreateNestedManyWithoutSantriInput
    kunjungan?: KunjunganCreateNestedManyWithoutSantriInput
    healthRecords?: HealthRecordCreateNestedManyWithoutSantriInput
    medications?: MedicationCreateNestedManyWithoutSantriInput
    tahfidz?: TahfidzCreateNestedManyWithoutSantriInput
    mutabaah?: MutabaahCreateNestedManyWithoutSantriInput
    wallet?: WalletCreateNestedOneWithoutSantriInput
    attendances?: AttendanceCreateNestedManyWithoutSantriInput
    grades?: GradeCreateNestedManyWithoutSantriInput
  }

  export type SantriUncheckedCreateWithoutTenantInput = {
    id?: string
    nisn?: string | null
    name: string
    gender: string
    dob?: Date | string | null
    kelas?: string | null
    room?: string | null
    contact?: string | null
    address?: string | null
    photo?: string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    walis?: SantriWaliUncheckedCreateNestedManyWithoutSantriInput
    izin?: IzinUncheckedCreateNestedManyWithoutSantriInput
    catatanHarian?: CatatanHarianUncheckedCreateNestedManyWithoutSantriInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutSantriInput
    pelanggaran?: PelanggaranUncheckedCreateNestedManyWithoutSantriInput
    pembinaan?: PembinaanUncheckedCreateNestedManyWithoutSantriInput
    kunjungan?: KunjunganUncheckedCreateNestedManyWithoutSantriInput
    healthRecords?: HealthRecordUncheckedCreateNestedManyWithoutSantriInput
    medications?: MedicationUncheckedCreateNestedManyWithoutSantriInput
    tahfidz?: TahfidzUncheckedCreateNestedManyWithoutSantriInput
    mutabaah?: MutabaahUncheckedCreateNestedManyWithoutSantriInput
    wallet?: WalletUncheckedCreateNestedOneWithoutSantriInput
    attendances?: AttendanceUncheckedCreateNestedManyWithoutSantriInput
    grades?: GradeUncheckedCreateNestedManyWithoutSantriInput
  }

  export type SantriCreateOrConnectWithoutTenantInput = {
    where: SantriWhereUniqueInput
    create: XOR<SantriCreateWithoutTenantInput, SantriUncheckedCreateWithoutTenantInput>
  }

  export type SantriCreateManyTenantInputEnvelope = {
    data: SantriCreateManyTenantInput | SantriCreateManyTenantInput[]
  }

  export type WaliCreateWithoutTenantInput = {
    id?: string
    name: string
    relation: string
    phone: string
    email?: string | null
    address?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    santris?: SantriWaliCreateNestedManyWithoutWaliInput
  }

  export type WaliUncheckedCreateWithoutTenantInput = {
    id?: string
    name: string
    relation: string
    phone: string
    email?: string | null
    address?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    santris?: SantriWaliUncheckedCreateNestedManyWithoutWaliInput
  }

  export type WaliCreateOrConnectWithoutTenantInput = {
    where: WaliWhereUniqueInput
    create: XOR<WaliCreateWithoutTenantInput, WaliUncheckedCreateWithoutTenantInput>
  }

  export type WaliCreateManyTenantInputEnvelope = {
    data: WaliCreateManyTenantInput | WaliCreateManyTenantInput[]
  }

  export type IzinCreateWithoutTenantInput = {
    id?: string
    type: string
    reason: string
    startAt: Date | string
    endAt: Date | string
    status?: string
    requestedBy: string
    approvedBy?: string | null
    approvedAt?: Date | string | null
    qrCodeData?: string | null
    checkoutAt?: Date | string | null
    checkoutBy?: string | null
    checkinAt?: Date | string | null
    checkinBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    santri: SantriCreateNestedOneWithoutIzinInput
  }

  export type IzinUncheckedCreateWithoutTenantInput = {
    id?: string
    santriId: string
    type: string
    reason: string
    startAt: Date | string
    endAt: Date | string
    status?: string
    requestedBy: string
    approvedBy?: string | null
    approvedAt?: Date | string | null
    qrCodeData?: string | null
    checkoutAt?: Date | string | null
    checkoutBy?: string | null
    checkinAt?: Date | string | null
    checkinBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type IzinCreateOrConnectWithoutTenantInput = {
    where: IzinWhereUniqueInput
    create: XOR<IzinCreateWithoutTenantInput, IzinUncheckedCreateWithoutTenantInput>
  }

  export type IzinCreateManyTenantInputEnvelope = {
    data: IzinCreateManyTenantInput | IzinCreateManyTenantInput[]
  }

  export type CatatanHarianCreateWithoutTenantInput = {
    id?: string
    authorId: string
    date?: Date | string
    content: string
    category: string
    attachments?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    santri: SantriCreateNestedOneWithoutCatatanHarianInput
  }

  export type CatatanHarianUncheckedCreateWithoutTenantInput = {
    id?: string
    santriId: string
    authorId: string
    date?: Date | string
    content: string
    category: string
    attachments?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CatatanHarianCreateOrConnectWithoutTenantInput = {
    where: CatatanHarianWhereUniqueInput
    create: XOR<CatatanHarianCreateWithoutTenantInput, CatatanHarianUncheckedCreateWithoutTenantInput>
  }

  export type CatatanHarianCreateManyTenantInputEnvelope = {
    data: CatatanHarianCreateManyTenantInput | CatatanHarianCreateManyTenantInput[]
  }

  export type PengumumanCreateWithoutTenantInput = {
    id?: string
    title: string
    content: string
    audience: string
    pinnedUntil?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PengumumanUncheckedCreateWithoutTenantInput = {
    id?: string
    title: string
    content: string
    audience: string
    pinnedUntil?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PengumumanCreateOrConnectWithoutTenantInput = {
    where: PengumumanWhereUniqueInput
    create: XOR<PengumumanCreateWithoutTenantInput, PengumumanUncheckedCreateWithoutTenantInput>
  }

  export type PengumumanCreateManyTenantInputEnvelope = {
    data: PengumumanCreateManyTenantInput | PengumumanCreateManyTenantInput[]
  }

  export type InvoiceCreateWithoutTenantInput = {
    id?: string
    amountDue: number
    dueDate: Date | string
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    santri: SantriCreateNestedOneWithoutInvoicesInput
    lines?: InvoiceLineCreateNestedManyWithoutInvoiceInput
    payments?: PaymentCreateNestedManyWithoutInvoiceInput
  }

  export type InvoiceUncheckedCreateWithoutTenantInput = {
    id?: string
    santriId: string
    amountDue: number
    dueDate: Date | string
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    lines?: InvoiceLineUncheckedCreateNestedManyWithoutInvoiceInput
    payments?: PaymentUncheckedCreateNestedManyWithoutInvoiceInput
  }

  export type InvoiceCreateOrConnectWithoutTenantInput = {
    where: InvoiceWhereUniqueInput
    create: XOR<InvoiceCreateWithoutTenantInput, InvoiceUncheckedCreateWithoutTenantInput>
  }

  export type InvoiceCreateManyTenantInputEnvelope = {
    data: InvoiceCreateManyTenantInput | InvoiceCreateManyTenantInput[]
  }

  export type PelanggaranCreateWithoutTenantInput = {
    id?: string
    recordedBy: string
    category: string
    severity: number
    points?: number
    description: string
    date?: Date | string
    resolved?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    santri: SantriCreateNestedOneWithoutPelanggaranInput
  }

  export type PelanggaranUncheckedCreateWithoutTenantInput = {
    id?: string
    santriId: string
    recordedBy: string
    category: string
    severity: number
    points?: number
    description: string
    date?: Date | string
    resolved?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PelanggaranCreateOrConnectWithoutTenantInput = {
    where: PelanggaranWhereUniqueInput
    create: XOR<PelanggaranCreateWithoutTenantInput, PelanggaranUncheckedCreateWithoutTenantInput>
  }

  export type PelanggaranCreateManyTenantInputEnvelope = {
    data: PelanggaranCreateManyTenantInput | PelanggaranCreateManyTenantInput[]
  }

  export type PembinaanCreateWithoutTenantInput = {
    id?: string
    plan: string
    targetDate: Date | string
    status?: string
    assignedTo: string
    createdAt?: Date | string
    updatedAt?: Date | string
    santri: SantriCreateNestedOneWithoutPembinaanInput
  }

  export type PembinaanUncheckedCreateWithoutTenantInput = {
    id?: string
    santriId: string
    plan: string
    targetDate: Date | string
    status?: string
    assignedTo: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PembinaanCreateOrConnectWithoutTenantInput = {
    where: PembinaanWhereUniqueInput
    create: XOR<PembinaanCreateWithoutTenantInput, PembinaanUncheckedCreateWithoutTenantInput>
  }

  export type PembinaanCreateManyTenantInputEnvelope = {
    data: PembinaanCreateManyTenantInput | PembinaanCreateManyTenantInput[]
  }

  export type KunjunganCreateWithoutTenantInput = {
    id?: string
    scheduledAt: Date | string
    slot: string
    visitorLimit?: number
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    santri: SantriCreateNestedOneWithoutKunjunganInput
    tamu?: TamuCreateNestedManyWithoutKunjunganInput
  }

  export type KunjunganUncheckedCreateWithoutTenantInput = {
    id?: string
    santriId: string
    scheduledAt: Date | string
    slot: string
    visitorLimit?: number
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    tamu?: TamuUncheckedCreateNestedManyWithoutKunjunganInput
  }

  export type KunjunganCreateOrConnectWithoutTenantInput = {
    where: KunjunganWhereUniqueInput
    create: XOR<KunjunganCreateWithoutTenantInput, KunjunganUncheckedCreateWithoutTenantInput>
  }

  export type KunjunganCreateManyTenantInputEnvelope = {
    data: KunjunganCreateManyTenantInput | KunjunganCreateManyTenantInput[]
  }

  export type HealthRecordCreateWithoutTenantInput = {
    id?: string
    recordedBy: string
    symptoms: string
    diagnosis?: string | null
    actionTaken?: string | null
    referred?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    santri: SantriCreateNestedOneWithoutHealthRecordsInput
  }

  export type HealthRecordUncheckedCreateWithoutTenantInput = {
    id?: string
    santriId: string
    recordedBy: string
    symptoms: string
    diagnosis?: string | null
    actionTaken?: string | null
    referred?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type HealthRecordCreateOrConnectWithoutTenantInput = {
    where: HealthRecordWhereUniqueInput
    create: XOR<HealthRecordCreateWithoutTenantInput, HealthRecordUncheckedCreateWithoutTenantInput>
  }

  export type HealthRecordCreateManyTenantInputEnvelope = {
    data: HealthRecordCreateManyTenantInput | HealthRecordCreateManyTenantInput[]
  }

  export type AuditLogCreateWithoutTenantInput = {
    id?: string
    action: string
    entity: string
    entityId: string
    oldValue?: string | null
    newValue?: string | null
    ip?: string | null
    createdAt?: Date | string
    user?: UserCreateNestedOneWithoutAuditLogsInput
  }

  export type AuditLogUncheckedCreateWithoutTenantInput = {
    id?: string
    userId?: string | null
    action: string
    entity: string
    entityId: string
    oldValue?: string | null
    newValue?: string | null
    ip?: string | null
    createdAt?: Date | string
  }

  export type AuditLogCreateOrConnectWithoutTenantInput = {
    where: AuditLogWhereUniqueInput
    create: XOR<AuditLogCreateWithoutTenantInput, AuditLogUncheckedCreateWithoutTenantInput>
  }

  export type AuditLogCreateManyTenantInputEnvelope = {
    data: AuditLogCreateManyTenantInput | AuditLogCreateManyTenantInput[]
  }

  export type NotificationCreateWithoutTenantInput = {
    id?: string
    type: string
    title: string
    body: string
    read?: boolean
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutNotificationsInput
  }

  export type NotificationUncheckedCreateWithoutTenantInput = {
    id?: string
    userId: string
    type: string
    title: string
    body: string
    read?: boolean
    createdAt?: Date | string
  }

  export type NotificationCreateOrConnectWithoutTenantInput = {
    where: NotificationWhereUniqueInput
    create: XOR<NotificationCreateWithoutTenantInput, NotificationUncheckedCreateWithoutTenantInput>
  }

  export type NotificationCreateManyTenantInputEnvelope = {
    data: NotificationCreateManyTenantInput | NotificationCreateManyTenantInput[]
  }

  export type WebhookEventCreateWithoutTenantInput = {
    id?: string
    eventType: string
    payload: string
    status?: string
    error?: string | null
    createdAt?: Date | string
    processedAt?: Date | string | null
  }

  export type WebhookEventUncheckedCreateWithoutTenantInput = {
    id?: string
    eventType: string
    payload: string
    status?: string
    error?: string | null
    createdAt?: Date | string
    processedAt?: Date | string | null
  }

  export type WebhookEventCreateOrConnectWithoutTenantInput = {
    where: WebhookEventWhereUniqueInput
    create: XOR<WebhookEventCreateWithoutTenantInput, WebhookEventUncheckedCreateWithoutTenantInput>
  }

  export type WebhookEventCreateManyTenantInputEnvelope = {
    data: WebhookEventCreateManyTenantInput | WebhookEventCreateManyTenantInput[]
  }

  export type TahfidzCreateWithoutTenantInput = {
    id?: string
    surah: string
    ayat?: string | null
    type?: string
    grade?: string | null
    notes?: string | null
    recordedBy: string
    date?: Date | string
    createdAt?: Date | string
    santri: SantriCreateNestedOneWithoutTahfidzInput
  }

  export type TahfidzUncheckedCreateWithoutTenantInput = {
    id?: string
    santriId: string
    surah: string
    ayat?: string | null
    type?: string
    grade?: string | null
    notes?: string | null
    recordedBy: string
    date?: Date | string
    createdAt?: Date | string
  }

  export type TahfidzCreateOrConnectWithoutTenantInput = {
    where: TahfidzWhereUniqueInput
    create: XOR<TahfidzCreateWithoutTenantInput, TahfidzUncheckedCreateWithoutTenantInput>
  }

  export type TahfidzCreateManyTenantInputEnvelope = {
    data: TahfidzCreateManyTenantInput | TahfidzCreateManyTenantInput[]
  }

  export type MutabaahCreateWithoutTenantInput = {
    id?: string
    date?: Date | string
    sholatWajib?: boolean
    tahajud?: boolean
    dhuha?: boolean
    puasaSunnah?: boolean
    bacaQuran?: boolean
    notes?: string | null
    recordedBy?: string | null
    createdAt?: Date | string
    santri: SantriCreateNestedOneWithoutMutabaahInput
  }

  export type MutabaahUncheckedCreateWithoutTenantInput = {
    id?: string
    santriId: string
    date?: Date | string
    sholatWajib?: boolean
    tahajud?: boolean
    dhuha?: boolean
    puasaSunnah?: boolean
    bacaQuran?: boolean
    notes?: string | null
    recordedBy?: string | null
    createdAt?: Date | string
  }

  export type MutabaahCreateOrConnectWithoutTenantInput = {
    where: MutabaahWhereUniqueInput
    create: XOR<MutabaahCreateWithoutTenantInput, MutabaahUncheckedCreateWithoutTenantInput>
  }

  export type MutabaahCreateManyTenantInputEnvelope = {
    data: MutabaahCreateManyTenantInput | MutabaahCreateManyTenantInput[]
  }

  export type WalletCreateWithoutTenantInput = {
    id?: string
    balance?: number
    pin?: string | null
    isActive?: boolean
    updatedAt?: Date | string
    santri: SantriCreateNestedOneWithoutWalletInput
    transactions?: WalletTransactionCreateNestedManyWithoutWalletInput
  }

  export type WalletUncheckedCreateWithoutTenantInput = {
    id?: string
    santriId: string
    balance?: number
    pin?: string | null
    isActive?: boolean
    updatedAt?: Date | string
    transactions?: WalletTransactionUncheckedCreateNestedManyWithoutWalletInput
  }

  export type WalletCreateOrConnectWithoutTenantInput = {
    where: WalletWhereUniqueInput
    create: XOR<WalletCreateWithoutTenantInput, WalletUncheckedCreateWithoutTenantInput>
  }

  export type WalletCreateManyTenantInputEnvelope = {
    data: WalletCreateManyTenantInput | WalletCreateManyTenantInput[]
  }

  export type EmployeeCreateWithoutTenantInput = {
    id?: string
    userId?: string | null
    nip?: string | null
    name: string
    position: string
    phone?: string | null
    address?: string | null
    joinDate?: Date | string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    payrolls?: PayrollCreateNestedManyWithoutEmployeeInput
  }

  export type EmployeeUncheckedCreateWithoutTenantInput = {
    id?: string
    userId?: string | null
    nip?: string | null
    name: string
    position: string
    phone?: string | null
    address?: string | null
    joinDate?: Date | string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    payrolls?: PayrollUncheckedCreateNestedManyWithoutEmployeeInput
  }

  export type EmployeeCreateOrConnectWithoutTenantInput = {
    where: EmployeeWhereUniqueInput
    create: XOR<EmployeeCreateWithoutTenantInput, EmployeeUncheckedCreateWithoutTenantInput>
  }

  export type EmployeeCreateManyTenantInputEnvelope = {
    data: EmployeeCreateManyTenantInput | EmployeeCreateManyTenantInput[]
  }

  export type PayrollCreateWithoutTenantInput = {
    id?: string
    month: number
    year: number
    baseSalary?: number
    allowances?: number
    deductions?: number
    netAmount: number
    status?: string
    paidAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    employee: EmployeeCreateNestedOneWithoutPayrollsInput
  }

  export type PayrollUncheckedCreateWithoutTenantInput = {
    id?: string
    employeeId: string
    month: number
    year: number
    baseSalary?: number
    allowances?: number
    deductions?: number
    netAmount: number
    status?: string
    paidAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PayrollCreateOrConnectWithoutTenantInput = {
    where: PayrollWhereUniqueInput
    create: XOR<PayrollCreateWithoutTenantInput, PayrollUncheckedCreateWithoutTenantInput>
  }

  export type PayrollCreateManyTenantInputEnvelope = {
    data: PayrollCreateManyTenantInput | PayrollCreateManyTenantInput[]
  }

  export type AcademicScheduleCreateWithoutTenantInput = {
    id?: string
    subject: string
    teacherId: string
    kelas: string
    dayOfWeek: number
    startTime: string
    endTime: string
    room?: string | null
    createdAt?: Date | string
  }

  export type AcademicScheduleUncheckedCreateWithoutTenantInput = {
    id?: string
    subject: string
    teacherId: string
    kelas: string
    dayOfWeek: number
    startTime: string
    endTime: string
    room?: string | null
    createdAt?: Date | string
  }

  export type AcademicScheduleCreateOrConnectWithoutTenantInput = {
    where: AcademicScheduleWhereUniqueInput
    create: XOR<AcademicScheduleCreateWithoutTenantInput, AcademicScheduleUncheckedCreateWithoutTenantInput>
  }

  export type AcademicScheduleCreateManyTenantInputEnvelope = {
    data: AcademicScheduleCreateManyTenantInput | AcademicScheduleCreateManyTenantInput[]
  }

  export type AttendanceCreateWithoutTenantInput = {
    id?: string
    scheduleId?: string | null
    date?: Date | string
    status: string
    notes?: string | null
    recordedBy?: string | null
    createdAt?: Date | string
    santri: SantriCreateNestedOneWithoutAttendancesInput
  }

  export type AttendanceUncheckedCreateWithoutTenantInput = {
    id?: string
    santriId: string
    scheduleId?: string | null
    date?: Date | string
    status: string
    notes?: string | null
    recordedBy?: string | null
    createdAt?: Date | string
  }

  export type AttendanceCreateOrConnectWithoutTenantInput = {
    where: AttendanceWhereUniqueInput
    create: XOR<AttendanceCreateWithoutTenantInput, AttendanceUncheckedCreateWithoutTenantInput>
  }

  export type AttendanceCreateManyTenantInputEnvelope = {
    data: AttendanceCreateManyTenantInput | AttendanceCreateManyTenantInput[]
  }

  export type GradeCreateWithoutTenantInput = {
    id?: string
    subject: string
    semester: string
    academicYear: string
    type: string
    score: number
    notes?: string | null
    createdAt?: Date | string
    santri: SantriCreateNestedOneWithoutGradesInput
  }

  export type GradeUncheckedCreateWithoutTenantInput = {
    id?: string
    santriId: string
    subject: string
    semester: string
    academicYear: string
    type: string
    score: number
    notes?: string | null
    createdAt?: Date | string
  }

  export type GradeCreateOrConnectWithoutTenantInput = {
    where: GradeWhereUniqueInput
    create: XOR<GradeCreateWithoutTenantInput, GradeUncheckedCreateWithoutTenantInput>
  }

  export type GradeCreateManyTenantInputEnvelope = {
    data: GradeCreateManyTenantInput | GradeCreateManyTenantInput[]
  }

  export type PpdbRegistrationCreateWithoutTenantInput = {
    id?: string
    registrationNumber: string
    fullName: string
    gender: string
    dob?: Date | string | null
    previousSchool?: string | null
    pathway?: string
    status?: string
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    documents?: PpdbDocumentCreateNestedManyWithoutRegistrationInput
    exams?: PpdbExamCreateNestedManyWithoutRegistrationInput
  }

  export type PpdbRegistrationUncheckedCreateWithoutTenantInput = {
    id?: string
    registrationNumber: string
    fullName: string
    gender: string
    dob?: Date | string | null
    previousSchool?: string | null
    pathway?: string
    status?: string
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    documents?: PpdbDocumentUncheckedCreateNestedManyWithoutRegistrationInput
    exams?: PpdbExamUncheckedCreateNestedManyWithoutRegistrationInput
  }

  export type PpdbRegistrationCreateOrConnectWithoutTenantInput = {
    where: PpdbRegistrationWhereUniqueInput
    create: XOR<PpdbRegistrationCreateWithoutTenantInput, PpdbRegistrationUncheckedCreateWithoutTenantInput>
  }

  export type PpdbRegistrationCreateManyTenantInputEnvelope = {
    data: PpdbRegistrationCreateManyTenantInput | PpdbRegistrationCreateManyTenantInput[]
  }

  export type PpdbDocumentCreateWithoutTenantInput = {
    id?: string
    documentType: string
    fileUrl: string
    isVerified?: boolean
    createdAt?: Date | string
    registration: PpdbRegistrationCreateNestedOneWithoutDocumentsInput
  }

  export type PpdbDocumentUncheckedCreateWithoutTenantInput = {
    id?: string
    registrationId: string
    documentType: string
    fileUrl: string
    isVerified?: boolean
    createdAt?: Date | string
  }

  export type PpdbDocumentCreateOrConnectWithoutTenantInput = {
    where: PpdbDocumentWhereUniqueInput
    create: XOR<PpdbDocumentCreateWithoutTenantInput, PpdbDocumentUncheckedCreateWithoutTenantInput>
  }

  export type PpdbDocumentCreateManyTenantInputEnvelope = {
    data: PpdbDocumentCreateManyTenantInput | PpdbDocumentCreateManyTenantInput[]
  }

  export type PpdbExamCreateWithoutTenantInput = {
    id?: string
    examType: string
    examDate: Date | string
    score?: number | null
    result?: string | null
    interviewer?: string | null
    createdAt?: Date | string
    registration: PpdbRegistrationCreateNestedOneWithoutExamsInput
  }

  export type PpdbExamUncheckedCreateWithoutTenantInput = {
    id?: string
    registrationId: string
    examType: string
    examDate: Date | string
    score?: number | null
    result?: string | null
    interviewer?: string | null
    createdAt?: Date | string
  }

  export type PpdbExamCreateOrConnectWithoutTenantInput = {
    where: PpdbExamWhereUniqueInput
    create: XOR<PpdbExamCreateWithoutTenantInput, PpdbExamUncheckedCreateWithoutTenantInput>
  }

  export type PpdbExamCreateManyTenantInputEnvelope = {
    data: PpdbExamCreateManyTenantInput | PpdbExamCreateManyTenantInput[]
  }

  export type ItemCreateWithoutTenantInput = {
    id?: string
    sku: string
    name: string
    description?: string | null
    category: string
    price: number
    costPrice?: number | null
    stock?: number
    minStock?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    transactions?: InventoryTransactionCreateNestedManyWithoutItemInput
  }

  export type ItemUncheckedCreateWithoutTenantInput = {
    id?: string
    sku: string
    name: string
    description?: string | null
    category: string
    price: number
    costPrice?: number | null
    stock?: number
    minStock?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    transactions?: InventoryTransactionUncheckedCreateNestedManyWithoutItemInput
  }

  export type ItemCreateOrConnectWithoutTenantInput = {
    where: ItemWhereUniqueInput
    create: XOR<ItemCreateWithoutTenantInput, ItemUncheckedCreateWithoutTenantInput>
  }

  export type ItemCreateManyTenantInputEnvelope = {
    data: ItemCreateManyTenantInput | ItemCreateManyTenantInput[]
  }

  export type InventoryTransactionCreateWithoutTenantInput = {
    id?: string
    type: string
    quantity: number
    reference?: string | null
    notes?: string | null
    handledBy?: string | null
    date?: Date | string
    item: ItemCreateNestedOneWithoutTransactionsInput
  }

  export type InventoryTransactionUncheckedCreateWithoutTenantInput = {
    id?: string
    itemId: string
    type: string
    quantity: number
    reference?: string | null
    notes?: string | null
    handledBy?: string | null
    date?: Date | string
  }

  export type InventoryTransactionCreateOrConnectWithoutTenantInput = {
    where: InventoryTransactionWhereUniqueInput
    create: XOR<InventoryTransactionCreateWithoutTenantInput, InventoryTransactionUncheckedCreateWithoutTenantInput>
  }

  export type InventoryTransactionCreateManyTenantInputEnvelope = {
    data: InventoryTransactionCreateManyTenantInput | InventoryTransactionCreateManyTenantInput[]
  }

  export type SupplierCreateWithoutTenantInput = {
    id?: string
    name: string
    contact?: string | null
    address?: string | null
    email?: string | null
    createdAt?: Date | string
    purchaseOrders?: PurchaseOrderCreateNestedManyWithoutSupplierInput
  }

  export type SupplierUncheckedCreateWithoutTenantInput = {
    id?: string
    name: string
    contact?: string | null
    address?: string | null
    email?: string | null
    createdAt?: Date | string
    purchaseOrders?: PurchaseOrderUncheckedCreateNestedManyWithoutSupplierInput
  }

  export type SupplierCreateOrConnectWithoutTenantInput = {
    where: SupplierWhereUniqueInput
    create: XOR<SupplierCreateWithoutTenantInput, SupplierUncheckedCreateWithoutTenantInput>
  }

  export type SupplierCreateManyTenantInputEnvelope = {
    data: SupplierCreateManyTenantInput | SupplierCreateManyTenantInput[]
  }

  export type PurchaseOrderCreateWithoutTenantInput = {
    id?: string
    poNumber: string
    totalCost: number
    status?: string
    orderDate?: Date | string
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    supplier: SupplierCreateNestedOneWithoutPurchaseOrdersInput
  }

  export type PurchaseOrderUncheckedCreateWithoutTenantInput = {
    id?: string
    supplierId: string
    poNumber: string
    totalCost: number
    status?: string
    orderDate?: Date | string
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PurchaseOrderCreateOrConnectWithoutTenantInput = {
    where: PurchaseOrderWhereUniqueInput
    create: XOR<PurchaseOrderCreateWithoutTenantInput, PurchaseOrderUncheckedCreateWithoutTenantInput>
  }

  export type PurchaseOrderCreateManyTenantInputEnvelope = {
    data: PurchaseOrderCreateManyTenantInput | PurchaseOrderCreateManyTenantInput[]
  }

  export type BuildingCreateWithoutTenantInput = {
    id?: string
    name: string
    description?: string | null
    gender: string
    capacity?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    rooms?: RoomCreateNestedManyWithoutBuildingInput
  }

  export type BuildingUncheckedCreateWithoutTenantInput = {
    id?: string
    name: string
    description?: string | null
    gender: string
    capacity?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    rooms?: RoomUncheckedCreateNestedManyWithoutBuildingInput
  }

  export type BuildingCreateOrConnectWithoutTenantInput = {
    where: BuildingWhereUniqueInput
    create: XOR<BuildingCreateWithoutTenantInput, BuildingUncheckedCreateWithoutTenantInput>
  }

  export type BuildingCreateManyTenantInputEnvelope = {
    data: BuildingCreateManyTenantInput | BuildingCreateManyTenantInput[]
  }

  export type RoomCreateWithoutTenantInput = {
    id?: string
    name: string
    capacity: number
    picName?: string | null
    createdAt?: Date | string
    building: BuildingCreateNestedOneWithoutRoomsInput
    assignments?: RoomAssignmentCreateNestedManyWithoutRoomInput
    tickets?: MaintenanceTicketCreateNestedManyWithoutRoomInput
  }

  export type RoomUncheckedCreateWithoutTenantInput = {
    id?: string
    buildingId: string
    name: string
    capacity: number
    picName?: string | null
    createdAt?: Date | string
    assignments?: RoomAssignmentUncheckedCreateNestedManyWithoutRoomInput
    tickets?: MaintenanceTicketUncheckedCreateNestedManyWithoutRoomInput
  }

  export type RoomCreateOrConnectWithoutTenantInput = {
    where: RoomWhereUniqueInput
    create: XOR<RoomCreateWithoutTenantInput, RoomUncheckedCreateWithoutTenantInput>
  }

  export type RoomCreateManyTenantInputEnvelope = {
    data: RoomCreateManyTenantInput | RoomCreateManyTenantInput[]
  }

  export type RoomAssignmentCreateWithoutTenantInput = {
    id?: string
    santriId: string
    startDate?: Date | string
    endDate?: Date | string | null
    status?: string
    room: RoomCreateNestedOneWithoutAssignmentsInput
  }

  export type RoomAssignmentUncheckedCreateWithoutTenantInput = {
    id?: string
    roomId: string
    santriId: string
    startDate?: Date | string
    endDate?: Date | string | null
    status?: string
  }

  export type RoomAssignmentCreateOrConnectWithoutTenantInput = {
    where: RoomAssignmentWhereUniqueInput
    create: XOR<RoomAssignmentCreateWithoutTenantInput, RoomAssignmentUncheckedCreateWithoutTenantInput>
  }

  export type RoomAssignmentCreateManyTenantInputEnvelope = {
    data: RoomAssignmentCreateManyTenantInput | RoomAssignmentCreateManyTenantInput[]
  }

  export type MaintenanceTicketCreateWithoutTenantInput = {
    id?: string
    title: string
    description: string
    priority?: string
    status?: string
    reportedBy: string
    resolvedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    room: RoomCreateNestedOneWithoutTicketsInput
  }

  export type MaintenanceTicketUncheckedCreateWithoutTenantInput = {
    id?: string
    roomId: string
    title: string
    description: string
    priority?: string
    status?: string
    reportedBy: string
    resolvedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MaintenanceTicketCreateOrConnectWithoutTenantInput = {
    where: MaintenanceTicketWhereUniqueInput
    create: XOR<MaintenanceTicketCreateWithoutTenantInput, MaintenanceTicketUncheckedCreateWithoutTenantInput>
  }

  export type MaintenanceTicketCreateManyTenantInputEnvelope = {
    data: MaintenanceTicketCreateManyTenantInput | MaintenanceTicketCreateManyTenantInput[]
  }

  export type UserUpsertWithWhereUniqueWithoutTenantInput = {
    where: UserWhereUniqueInput
    update: XOR<UserUpdateWithoutTenantInput, UserUncheckedUpdateWithoutTenantInput>
    create: XOR<UserCreateWithoutTenantInput, UserUncheckedCreateWithoutTenantInput>
  }

  export type UserUpdateWithWhereUniqueWithoutTenantInput = {
    where: UserWhereUniqueInput
    data: XOR<UserUpdateWithoutTenantInput, UserUncheckedUpdateWithoutTenantInput>
  }

  export type UserUpdateManyWithWhereWithoutTenantInput = {
    where: UserScalarWhereInput
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyWithoutTenantInput>
  }

  export type UserScalarWhereInput = {
    AND?: UserScalarWhereInput | UserScalarWhereInput[]
    OR?: UserScalarWhereInput[]
    NOT?: UserScalarWhereInput | UserScalarWhereInput[]
    id?: StringFilter<"User"> | string
    tenantId?: StringNullableFilter<"User"> | string | null
    email?: StringFilter<"User"> | string
    passwordHash?: StringFilter<"User"> | string
    role?: StringFilter<"User"> | string
    name?: StringFilter<"User"> | string
    phone?: StringNullableFilter<"User"> | string | null
    isActive?: BoolFilter<"User"> | boolean
    lastLogin?: DateTimeNullableFilter<"User"> | Date | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
  }

  export type SantriUpsertWithWhereUniqueWithoutTenantInput = {
    where: SantriWhereUniqueInput
    update: XOR<SantriUpdateWithoutTenantInput, SantriUncheckedUpdateWithoutTenantInput>
    create: XOR<SantriCreateWithoutTenantInput, SantriUncheckedCreateWithoutTenantInput>
  }

  export type SantriUpdateWithWhereUniqueWithoutTenantInput = {
    where: SantriWhereUniqueInput
    data: XOR<SantriUpdateWithoutTenantInput, SantriUncheckedUpdateWithoutTenantInput>
  }

  export type SantriUpdateManyWithWhereWithoutTenantInput = {
    where: SantriScalarWhereInput
    data: XOR<SantriUpdateManyMutationInput, SantriUncheckedUpdateManyWithoutTenantInput>
  }

  export type SantriScalarWhereInput = {
    AND?: SantriScalarWhereInput | SantriScalarWhereInput[]
    OR?: SantriScalarWhereInput[]
    NOT?: SantriScalarWhereInput | SantriScalarWhereInput[]
    id?: StringFilter<"Santri"> | string
    tenantId?: StringFilter<"Santri"> | string
    nisn?: StringNullableFilter<"Santri"> | string | null
    name?: StringFilter<"Santri"> | string
    gender?: StringFilter<"Santri"> | string
    dob?: DateTimeNullableFilter<"Santri"> | Date | string | null
    kelas?: StringNullableFilter<"Santri"> | string | null
    room?: StringNullableFilter<"Santri"> | string | null
    contact?: StringNullableFilter<"Santri"> | string | null
    address?: StringNullableFilter<"Santri"> | string | null
    photo?: StringNullableFilter<"Santri"> | string | null
    status?: StringFilter<"Santri"> | string
    createdAt?: DateTimeFilter<"Santri"> | Date | string
    updatedAt?: DateTimeFilter<"Santri"> | Date | string
  }

  export type WaliUpsertWithWhereUniqueWithoutTenantInput = {
    where: WaliWhereUniqueInput
    update: XOR<WaliUpdateWithoutTenantInput, WaliUncheckedUpdateWithoutTenantInput>
    create: XOR<WaliCreateWithoutTenantInput, WaliUncheckedCreateWithoutTenantInput>
  }

  export type WaliUpdateWithWhereUniqueWithoutTenantInput = {
    where: WaliWhereUniqueInput
    data: XOR<WaliUpdateWithoutTenantInput, WaliUncheckedUpdateWithoutTenantInput>
  }

  export type WaliUpdateManyWithWhereWithoutTenantInput = {
    where: WaliScalarWhereInput
    data: XOR<WaliUpdateManyMutationInput, WaliUncheckedUpdateManyWithoutTenantInput>
  }

  export type WaliScalarWhereInput = {
    AND?: WaliScalarWhereInput | WaliScalarWhereInput[]
    OR?: WaliScalarWhereInput[]
    NOT?: WaliScalarWhereInput | WaliScalarWhereInput[]
    id?: StringFilter<"Wali"> | string
    tenantId?: StringFilter<"Wali"> | string
    name?: StringFilter<"Wali"> | string
    relation?: StringFilter<"Wali"> | string
    phone?: StringFilter<"Wali"> | string
    email?: StringNullableFilter<"Wali"> | string | null
    address?: StringNullableFilter<"Wali"> | string | null
    createdAt?: DateTimeFilter<"Wali"> | Date | string
    updatedAt?: DateTimeFilter<"Wali"> | Date | string
  }

  export type IzinUpsertWithWhereUniqueWithoutTenantInput = {
    where: IzinWhereUniqueInput
    update: XOR<IzinUpdateWithoutTenantInput, IzinUncheckedUpdateWithoutTenantInput>
    create: XOR<IzinCreateWithoutTenantInput, IzinUncheckedCreateWithoutTenantInput>
  }

  export type IzinUpdateWithWhereUniqueWithoutTenantInput = {
    where: IzinWhereUniqueInput
    data: XOR<IzinUpdateWithoutTenantInput, IzinUncheckedUpdateWithoutTenantInput>
  }

  export type IzinUpdateManyWithWhereWithoutTenantInput = {
    where: IzinScalarWhereInput
    data: XOR<IzinUpdateManyMutationInput, IzinUncheckedUpdateManyWithoutTenantInput>
  }

  export type IzinScalarWhereInput = {
    AND?: IzinScalarWhereInput | IzinScalarWhereInput[]
    OR?: IzinScalarWhereInput[]
    NOT?: IzinScalarWhereInput | IzinScalarWhereInput[]
    id?: StringFilter<"Izin"> | string
    tenantId?: StringFilter<"Izin"> | string
    santriId?: StringFilter<"Izin"> | string
    type?: StringFilter<"Izin"> | string
    reason?: StringFilter<"Izin"> | string
    startAt?: DateTimeFilter<"Izin"> | Date | string
    endAt?: DateTimeFilter<"Izin"> | Date | string
    status?: StringFilter<"Izin"> | string
    requestedBy?: StringFilter<"Izin"> | string
    approvedBy?: StringNullableFilter<"Izin"> | string | null
    approvedAt?: DateTimeNullableFilter<"Izin"> | Date | string | null
    qrCodeData?: StringNullableFilter<"Izin"> | string | null
    checkoutAt?: DateTimeNullableFilter<"Izin"> | Date | string | null
    checkoutBy?: StringNullableFilter<"Izin"> | string | null
    checkinAt?: DateTimeNullableFilter<"Izin"> | Date | string | null
    checkinBy?: StringNullableFilter<"Izin"> | string | null
    createdAt?: DateTimeFilter<"Izin"> | Date | string
    updatedAt?: DateTimeFilter<"Izin"> | Date | string
  }

  export type CatatanHarianUpsertWithWhereUniqueWithoutTenantInput = {
    where: CatatanHarianWhereUniqueInput
    update: XOR<CatatanHarianUpdateWithoutTenantInput, CatatanHarianUncheckedUpdateWithoutTenantInput>
    create: XOR<CatatanHarianCreateWithoutTenantInput, CatatanHarianUncheckedCreateWithoutTenantInput>
  }

  export type CatatanHarianUpdateWithWhereUniqueWithoutTenantInput = {
    where: CatatanHarianWhereUniqueInput
    data: XOR<CatatanHarianUpdateWithoutTenantInput, CatatanHarianUncheckedUpdateWithoutTenantInput>
  }

  export type CatatanHarianUpdateManyWithWhereWithoutTenantInput = {
    where: CatatanHarianScalarWhereInput
    data: XOR<CatatanHarianUpdateManyMutationInput, CatatanHarianUncheckedUpdateManyWithoutTenantInput>
  }

  export type CatatanHarianScalarWhereInput = {
    AND?: CatatanHarianScalarWhereInput | CatatanHarianScalarWhereInput[]
    OR?: CatatanHarianScalarWhereInput[]
    NOT?: CatatanHarianScalarWhereInput | CatatanHarianScalarWhereInput[]
    id?: StringFilter<"CatatanHarian"> | string
    tenantId?: StringFilter<"CatatanHarian"> | string
    santriId?: StringFilter<"CatatanHarian"> | string
    authorId?: StringFilter<"CatatanHarian"> | string
    date?: DateTimeFilter<"CatatanHarian"> | Date | string
    content?: StringFilter<"CatatanHarian"> | string
    category?: StringFilter<"CatatanHarian"> | string
    attachments?: StringNullableFilter<"CatatanHarian"> | string | null
    createdAt?: DateTimeFilter<"CatatanHarian"> | Date | string
    updatedAt?: DateTimeFilter<"CatatanHarian"> | Date | string
  }

  export type PengumumanUpsertWithWhereUniqueWithoutTenantInput = {
    where: PengumumanWhereUniqueInput
    update: XOR<PengumumanUpdateWithoutTenantInput, PengumumanUncheckedUpdateWithoutTenantInput>
    create: XOR<PengumumanCreateWithoutTenantInput, PengumumanUncheckedCreateWithoutTenantInput>
  }

  export type PengumumanUpdateWithWhereUniqueWithoutTenantInput = {
    where: PengumumanWhereUniqueInput
    data: XOR<PengumumanUpdateWithoutTenantInput, PengumumanUncheckedUpdateWithoutTenantInput>
  }

  export type PengumumanUpdateManyWithWhereWithoutTenantInput = {
    where: PengumumanScalarWhereInput
    data: XOR<PengumumanUpdateManyMutationInput, PengumumanUncheckedUpdateManyWithoutTenantInput>
  }

  export type PengumumanScalarWhereInput = {
    AND?: PengumumanScalarWhereInput | PengumumanScalarWhereInput[]
    OR?: PengumumanScalarWhereInput[]
    NOT?: PengumumanScalarWhereInput | PengumumanScalarWhereInput[]
    id?: StringFilter<"Pengumuman"> | string
    tenantId?: StringFilter<"Pengumuman"> | string
    title?: StringFilter<"Pengumuman"> | string
    content?: StringFilter<"Pengumuman"> | string
    audience?: StringFilter<"Pengumuman"> | string
    pinnedUntil?: DateTimeNullableFilter<"Pengumuman"> | Date | string | null
    createdAt?: DateTimeFilter<"Pengumuman"> | Date | string
    updatedAt?: DateTimeFilter<"Pengumuman"> | Date | string
  }

  export type InvoiceUpsertWithWhereUniqueWithoutTenantInput = {
    where: InvoiceWhereUniqueInput
    update: XOR<InvoiceUpdateWithoutTenantInput, InvoiceUncheckedUpdateWithoutTenantInput>
    create: XOR<InvoiceCreateWithoutTenantInput, InvoiceUncheckedCreateWithoutTenantInput>
  }

  export type InvoiceUpdateWithWhereUniqueWithoutTenantInput = {
    where: InvoiceWhereUniqueInput
    data: XOR<InvoiceUpdateWithoutTenantInput, InvoiceUncheckedUpdateWithoutTenantInput>
  }

  export type InvoiceUpdateManyWithWhereWithoutTenantInput = {
    where: InvoiceScalarWhereInput
    data: XOR<InvoiceUpdateManyMutationInput, InvoiceUncheckedUpdateManyWithoutTenantInput>
  }

  export type InvoiceScalarWhereInput = {
    AND?: InvoiceScalarWhereInput | InvoiceScalarWhereInput[]
    OR?: InvoiceScalarWhereInput[]
    NOT?: InvoiceScalarWhereInput | InvoiceScalarWhereInput[]
    id?: StringFilter<"Invoice"> | string
    tenantId?: StringFilter<"Invoice"> | string
    santriId?: StringFilter<"Invoice"> | string
    amountDue?: FloatFilter<"Invoice"> | number
    dueDate?: DateTimeFilter<"Invoice"> | Date | string
    status?: StringFilter<"Invoice"> | string
    createdAt?: DateTimeFilter<"Invoice"> | Date | string
    updatedAt?: DateTimeFilter<"Invoice"> | Date | string
  }

  export type PelanggaranUpsertWithWhereUniqueWithoutTenantInput = {
    where: PelanggaranWhereUniqueInput
    update: XOR<PelanggaranUpdateWithoutTenantInput, PelanggaranUncheckedUpdateWithoutTenantInput>
    create: XOR<PelanggaranCreateWithoutTenantInput, PelanggaranUncheckedCreateWithoutTenantInput>
  }

  export type PelanggaranUpdateWithWhereUniqueWithoutTenantInput = {
    where: PelanggaranWhereUniqueInput
    data: XOR<PelanggaranUpdateWithoutTenantInput, PelanggaranUncheckedUpdateWithoutTenantInput>
  }

  export type PelanggaranUpdateManyWithWhereWithoutTenantInput = {
    where: PelanggaranScalarWhereInput
    data: XOR<PelanggaranUpdateManyMutationInput, PelanggaranUncheckedUpdateManyWithoutTenantInput>
  }

  export type PelanggaranScalarWhereInput = {
    AND?: PelanggaranScalarWhereInput | PelanggaranScalarWhereInput[]
    OR?: PelanggaranScalarWhereInput[]
    NOT?: PelanggaranScalarWhereInput | PelanggaranScalarWhereInput[]
    id?: StringFilter<"Pelanggaran"> | string
    tenantId?: StringFilter<"Pelanggaran"> | string
    santriId?: StringFilter<"Pelanggaran"> | string
    recordedBy?: StringFilter<"Pelanggaran"> | string
    category?: StringFilter<"Pelanggaran"> | string
    severity?: IntFilter<"Pelanggaran"> | number
    points?: IntFilter<"Pelanggaran"> | number
    description?: StringFilter<"Pelanggaran"> | string
    date?: DateTimeFilter<"Pelanggaran"> | Date | string
    resolved?: BoolFilter<"Pelanggaran"> | boolean
    createdAt?: DateTimeFilter<"Pelanggaran"> | Date | string
    updatedAt?: DateTimeFilter<"Pelanggaran"> | Date | string
  }

  export type PembinaanUpsertWithWhereUniqueWithoutTenantInput = {
    where: PembinaanWhereUniqueInput
    update: XOR<PembinaanUpdateWithoutTenantInput, PembinaanUncheckedUpdateWithoutTenantInput>
    create: XOR<PembinaanCreateWithoutTenantInput, PembinaanUncheckedCreateWithoutTenantInput>
  }

  export type PembinaanUpdateWithWhereUniqueWithoutTenantInput = {
    where: PembinaanWhereUniqueInput
    data: XOR<PembinaanUpdateWithoutTenantInput, PembinaanUncheckedUpdateWithoutTenantInput>
  }

  export type PembinaanUpdateManyWithWhereWithoutTenantInput = {
    where: PembinaanScalarWhereInput
    data: XOR<PembinaanUpdateManyMutationInput, PembinaanUncheckedUpdateManyWithoutTenantInput>
  }

  export type PembinaanScalarWhereInput = {
    AND?: PembinaanScalarWhereInput | PembinaanScalarWhereInput[]
    OR?: PembinaanScalarWhereInput[]
    NOT?: PembinaanScalarWhereInput | PembinaanScalarWhereInput[]
    id?: StringFilter<"Pembinaan"> | string
    tenantId?: StringFilter<"Pembinaan"> | string
    santriId?: StringFilter<"Pembinaan"> | string
    plan?: StringFilter<"Pembinaan"> | string
    targetDate?: DateTimeFilter<"Pembinaan"> | Date | string
    status?: StringFilter<"Pembinaan"> | string
    assignedTo?: StringFilter<"Pembinaan"> | string
    createdAt?: DateTimeFilter<"Pembinaan"> | Date | string
    updatedAt?: DateTimeFilter<"Pembinaan"> | Date | string
  }

  export type KunjunganUpsertWithWhereUniqueWithoutTenantInput = {
    where: KunjunganWhereUniqueInput
    update: XOR<KunjunganUpdateWithoutTenantInput, KunjunganUncheckedUpdateWithoutTenantInput>
    create: XOR<KunjunganCreateWithoutTenantInput, KunjunganUncheckedCreateWithoutTenantInput>
  }

  export type KunjunganUpdateWithWhereUniqueWithoutTenantInput = {
    where: KunjunganWhereUniqueInput
    data: XOR<KunjunganUpdateWithoutTenantInput, KunjunganUncheckedUpdateWithoutTenantInput>
  }

  export type KunjunganUpdateManyWithWhereWithoutTenantInput = {
    where: KunjunganScalarWhereInput
    data: XOR<KunjunganUpdateManyMutationInput, KunjunganUncheckedUpdateManyWithoutTenantInput>
  }

  export type KunjunganScalarWhereInput = {
    AND?: KunjunganScalarWhereInput | KunjunganScalarWhereInput[]
    OR?: KunjunganScalarWhereInput[]
    NOT?: KunjunganScalarWhereInput | KunjunganScalarWhereInput[]
    id?: StringFilter<"Kunjungan"> | string
    tenantId?: StringFilter<"Kunjungan"> | string
    santriId?: StringFilter<"Kunjungan"> | string
    scheduledAt?: DateTimeFilter<"Kunjungan"> | Date | string
    slot?: StringFilter<"Kunjungan"> | string
    visitorLimit?: IntFilter<"Kunjungan"> | number
    status?: StringFilter<"Kunjungan"> | string
    createdAt?: DateTimeFilter<"Kunjungan"> | Date | string
    updatedAt?: DateTimeFilter<"Kunjungan"> | Date | string
  }

  export type HealthRecordUpsertWithWhereUniqueWithoutTenantInput = {
    where: HealthRecordWhereUniqueInput
    update: XOR<HealthRecordUpdateWithoutTenantInput, HealthRecordUncheckedUpdateWithoutTenantInput>
    create: XOR<HealthRecordCreateWithoutTenantInput, HealthRecordUncheckedCreateWithoutTenantInput>
  }

  export type HealthRecordUpdateWithWhereUniqueWithoutTenantInput = {
    where: HealthRecordWhereUniqueInput
    data: XOR<HealthRecordUpdateWithoutTenantInput, HealthRecordUncheckedUpdateWithoutTenantInput>
  }

  export type HealthRecordUpdateManyWithWhereWithoutTenantInput = {
    where: HealthRecordScalarWhereInput
    data: XOR<HealthRecordUpdateManyMutationInput, HealthRecordUncheckedUpdateManyWithoutTenantInput>
  }

  export type HealthRecordScalarWhereInput = {
    AND?: HealthRecordScalarWhereInput | HealthRecordScalarWhereInput[]
    OR?: HealthRecordScalarWhereInput[]
    NOT?: HealthRecordScalarWhereInput | HealthRecordScalarWhereInput[]
    id?: StringFilter<"HealthRecord"> | string
    tenantId?: StringFilter<"HealthRecord"> | string
    santriId?: StringFilter<"HealthRecord"> | string
    recordedBy?: StringFilter<"HealthRecord"> | string
    symptoms?: StringFilter<"HealthRecord"> | string
    diagnosis?: StringNullableFilter<"HealthRecord"> | string | null
    actionTaken?: StringNullableFilter<"HealthRecord"> | string | null
    referred?: BoolFilter<"HealthRecord"> | boolean
    createdAt?: DateTimeFilter<"HealthRecord"> | Date | string
    updatedAt?: DateTimeFilter<"HealthRecord"> | Date | string
  }

  export type AuditLogUpsertWithWhereUniqueWithoutTenantInput = {
    where: AuditLogWhereUniqueInput
    update: XOR<AuditLogUpdateWithoutTenantInput, AuditLogUncheckedUpdateWithoutTenantInput>
    create: XOR<AuditLogCreateWithoutTenantInput, AuditLogUncheckedCreateWithoutTenantInput>
  }

  export type AuditLogUpdateWithWhereUniqueWithoutTenantInput = {
    where: AuditLogWhereUniqueInput
    data: XOR<AuditLogUpdateWithoutTenantInput, AuditLogUncheckedUpdateWithoutTenantInput>
  }

  export type AuditLogUpdateManyWithWhereWithoutTenantInput = {
    where: AuditLogScalarWhereInput
    data: XOR<AuditLogUpdateManyMutationInput, AuditLogUncheckedUpdateManyWithoutTenantInput>
  }

  export type AuditLogScalarWhereInput = {
    AND?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
    OR?: AuditLogScalarWhereInput[]
    NOT?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
    id?: StringFilter<"AuditLog"> | string
    tenantId?: StringNullableFilter<"AuditLog"> | string | null
    userId?: StringNullableFilter<"AuditLog"> | string | null
    action?: StringFilter<"AuditLog"> | string
    entity?: StringFilter<"AuditLog"> | string
    entityId?: StringFilter<"AuditLog"> | string
    oldValue?: StringNullableFilter<"AuditLog"> | string | null
    newValue?: StringNullableFilter<"AuditLog"> | string | null
    ip?: StringNullableFilter<"AuditLog"> | string | null
    createdAt?: DateTimeFilter<"AuditLog"> | Date | string
  }

  export type NotificationUpsertWithWhereUniqueWithoutTenantInput = {
    where: NotificationWhereUniqueInput
    update: XOR<NotificationUpdateWithoutTenantInput, NotificationUncheckedUpdateWithoutTenantInput>
    create: XOR<NotificationCreateWithoutTenantInput, NotificationUncheckedCreateWithoutTenantInput>
  }

  export type NotificationUpdateWithWhereUniqueWithoutTenantInput = {
    where: NotificationWhereUniqueInput
    data: XOR<NotificationUpdateWithoutTenantInput, NotificationUncheckedUpdateWithoutTenantInput>
  }

  export type NotificationUpdateManyWithWhereWithoutTenantInput = {
    where: NotificationScalarWhereInput
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyWithoutTenantInput>
  }

  export type NotificationScalarWhereInput = {
    AND?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
    OR?: NotificationScalarWhereInput[]
    NOT?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
    id?: StringFilter<"Notification"> | string
    tenantId?: StringFilter<"Notification"> | string
    userId?: StringFilter<"Notification"> | string
    type?: StringFilter<"Notification"> | string
    title?: StringFilter<"Notification"> | string
    body?: StringFilter<"Notification"> | string
    read?: BoolFilter<"Notification"> | boolean
    createdAt?: DateTimeFilter<"Notification"> | Date | string
  }

  export type WebhookEventUpsertWithWhereUniqueWithoutTenantInput = {
    where: WebhookEventWhereUniqueInput
    update: XOR<WebhookEventUpdateWithoutTenantInput, WebhookEventUncheckedUpdateWithoutTenantInput>
    create: XOR<WebhookEventCreateWithoutTenantInput, WebhookEventUncheckedCreateWithoutTenantInput>
  }

  export type WebhookEventUpdateWithWhereUniqueWithoutTenantInput = {
    where: WebhookEventWhereUniqueInput
    data: XOR<WebhookEventUpdateWithoutTenantInput, WebhookEventUncheckedUpdateWithoutTenantInput>
  }

  export type WebhookEventUpdateManyWithWhereWithoutTenantInput = {
    where: WebhookEventScalarWhereInput
    data: XOR<WebhookEventUpdateManyMutationInput, WebhookEventUncheckedUpdateManyWithoutTenantInput>
  }

  export type WebhookEventScalarWhereInput = {
    AND?: WebhookEventScalarWhereInput | WebhookEventScalarWhereInput[]
    OR?: WebhookEventScalarWhereInput[]
    NOT?: WebhookEventScalarWhereInput | WebhookEventScalarWhereInput[]
    id?: StringFilter<"WebhookEvent"> | string
    tenantId?: StringNullableFilter<"WebhookEvent"> | string | null
    eventType?: StringFilter<"WebhookEvent"> | string
    payload?: StringFilter<"WebhookEvent"> | string
    status?: StringFilter<"WebhookEvent"> | string
    error?: StringNullableFilter<"WebhookEvent"> | string | null
    createdAt?: DateTimeFilter<"WebhookEvent"> | Date | string
    processedAt?: DateTimeNullableFilter<"WebhookEvent"> | Date | string | null
  }

  export type TahfidzUpsertWithWhereUniqueWithoutTenantInput = {
    where: TahfidzWhereUniqueInput
    update: XOR<TahfidzUpdateWithoutTenantInput, TahfidzUncheckedUpdateWithoutTenantInput>
    create: XOR<TahfidzCreateWithoutTenantInput, TahfidzUncheckedCreateWithoutTenantInput>
  }

  export type TahfidzUpdateWithWhereUniqueWithoutTenantInput = {
    where: TahfidzWhereUniqueInput
    data: XOR<TahfidzUpdateWithoutTenantInput, TahfidzUncheckedUpdateWithoutTenantInput>
  }

  export type TahfidzUpdateManyWithWhereWithoutTenantInput = {
    where: TahfidzScalarWhereInput
    data: XOR<TahfidzUpdateManyMutationInput, TahfidzUncheckedUpdateManyWithoutTenantInput>
  }

  export type TahfidzScalarWhereInput = {
    AND?: TahfidzScalarWhereInput | TahfidzScalarWhereInput[]
    OR?: TahfidzScalarWhereInput[]
    NOT?: TahfidzScalarWhereInput | TahfidzScalarWhereInput[]
    id?: StringFilter<"Tahfidz"> | string
    tenantId?: StringFilter<"Tahfidz"> | string
    santriId?: StringFilter<"Tahfidz"> | string
    surah?: StringFilter<"Tahfidz"> | string
    ayat?: StringNullableFilter<"Tahfidz"> | string | null
    type?: StringFilter<"Tahfidz"> | string
    grade?: StringNullableFilter<"Tahfidz"> | string | null
    notes?: StringNullableFilter<"Tahfidz"> | string | null
    recordedBy?: StringFilter<"Tahfidz"> | string
    date?: DateTimeFilter<"Tahfidz"> | Date | string
    createdAt?: DateTimeFilter<"Tahfidz"> | Date | string
  }

  export type MutabaahUpsertWithWhereUniqueWithoutTenantInput = {
    where: MutabaahWhereUniqueInput
    update: XOR<MutabaahUpdateWithoutTenantInput, MutabaahUncheckedUpdateWithoutTenantInput>
    create: XOR<MutabaahCreateWithoutTenantInput, MutabaahUncheckedCreateWithoutTenantInput>
  }

  export type MutabaahUpdateWithWhereUniqueWithoutTenantInput = {
    where: MutabaahWhereUniqueInput
    data: XOR<MutabaahUpdateWithoutTenantInput, MutabaahUncheckedUpdateWithoutTenantInput>
  }

  export type MutabaahUpdateManyWithWhereWithoutTenantInput = {
    where: MutabaahScalarWhereInput
    data: XOR<MutabaahUpdateManyMutationInput, MutabaahUncheckedUpdateManyWithoutTenantInput>
  }

  export type MutabaahScalarWhereInput = {
    AND?: MutabaahScalarWhereInput | MutabaahScalarWhereInput[]
    OR?: MutabaahScalarWhereInput[]
    NOT?: MutabaahScalarWhereInput | MutabaahScalarWhereInput[]
    id?: StringFilter<"Mutabaah"> | string
    tenantId?: StringFilter<"Mutabaah"> | string
    santriId?: StringFilter<"Mutabaah"> | string
    date?: DateTimeFilter<"Mutabaah"> | Date | string
    sholatWajib?: BoolFilter<"Mutabaah"> | boolean
    tahajud?: BoolFilter<"Mutabaah"> | boolean
    dhuha?: BoolFilter<"Mutabaah"> | boolean
    puasaSunnah?: BoolFilter<"Mutabaah"> | boolean
    bacaQuran?: BoolFilter<"Mutabaah"> | boolean
    notes?: StringNullableFilter<"Mutabaah"> | string | null
    recordedBy?: StringNullableFilter<"Mutabaah"> | string | null
    createdAt?: DateTimeFilter<"Mutabaah"> | Date | string
  }

  export type WalletUpsertWithWhereUniqueWithoutTenantInput = {
    where: WalletWhereUniqueInput
    update: XOR<WalletUpdateWithoutTenantInput, WalletUncheckedUpdateWithoutTenantInput>
    create: XOR<WalletCreateWithoutTenantInput, WalletUncheckedCreateWithoutTenantInput>
  }

  export type WalletUpdateWithWhereUniqueWithoutTenantInput = {
    where: WalletWhereUniqueInput
    data: XOR<WalletUpdateWithoutTenantInput, WalletUncheckedUpdateWithoutTenantInput>
  }

  export type WalletUpdateManyWithWhereWithoutTenantInput = {
    where: WalletScalarWhereInput
    data: XOR<WalletUpdateManyMutationInput, WalletUncheckedUpdateManyWithoutTenantInput>
  }

  export type WalletScalarWhereInput = {
    AND?: WalletScalarWhereInput | WalletScalarWhereInput[]
    OR?: WalletScalarWhereInput[]
    NOT?: WalletScalarWhereInput | WalletScalarWhereInput[]
    id?: StringFilter<"Wallet"> | string
    tenantId?: StringFilter<"Wallet"> | string
    santriId?: StringFilter<"Wallet"> | string
    balance?: FloatFilter<"Wallet"> | number
    pin?: StringNullableFilter<"Wallet"> | string | null
    isActive?: BoolFilter<"Wallet"> | boolean
    updatedAt?: DateTimeFilter<"Wallet"> | Date | string
  }

  export type EmployeeUpsertWithWhereUniqueWithoutTenantInput = {
    where: EmployeeWhereUniqueInput
    update: XOR<EmployeeUpdateWithoutTenantInput, EmployeeUncheckedUpdateWithoutTenantInput>
    create: XOR<EmployeeCreateWithoutTenantInput, EmployeeUncheckedCreateWithoutTenantInput>
  }

  export type EmployeeUpdateWithWhereUniqueWithoutTenantInput = {
    where: EmployeeWhereUniqueInput
    data: XOR<EmployeeUpdateWithoutTenantInput, EmployeeUncheckedUpdateWithoutTenantInput>
  }

  export type EmployeeUpdateManyWithWhereWithoutTenantInput = {
    where: EmployeeScalarWhereInput
    data: XOR<EmployeeUpdateManyMutationInput, EmployeeUncheckedUpdateManyWithoutTenantInput>
  }

  export type EmployeeScalarWhereInput = {
    AND?: EmployeeScalarWhereInput | EmployeeScalarWhereInput[]
    OR?: EmployeeScalarWhereInput[]
    NOT?: EmployeeScalarWhereInput | EmployeeScalarWhereInput[]
    id?: StringFilter<"Employee"> | string
    tenantId?: StringFilter<"Employee"> | string
    userId?: StringNullableFilter<"Employee"> | string | null
    nip?: StringNullableFilter<"Employee"> | string | null
    name?: StringFilter<"Employee"> | string
    position?: StringFilter<"Employee"> | string
    phone?: StringNullableFilter<"Employee"> | string | null
    address?: StringNullableFilter<"Employee"> | string | null
    joinDate?: DateTimeNullableFilter<"Employee"> | Date | string | null
    status?: StringFilter<"Employee"> | string
    createdAt?: DateTimeFilter<"Employee"> | Date | string
    updatedAt?: DateTimeFilter<"Employee"> | Date | string
  }

  export type PayrollUpsertWithWhereUniqueWithoutTenantInput = {
    where: PayrollWhereUniqueInput
    update: XOR<PayrollUpdateWithoutTenantInput, PayrollUncheckedUpdateWithoutTenantInput>
    create: XOR<PayrollCreateWithoutTenantInput, PayrollUncheckedCreateWithoutTenantInput>
  }

  export type PayrollUpdateWithWhereUniqueWithoutTenantInput = {
    where: PayrollWhereUniqueInput
    data: XOR<PayrollUpdateWithoutTenantInput, PayrollUncheckedUpdateWithoutTenantInput>
  }

  export type PayrollUpdateManyWithWhereWithoutTenantInput = {
    where: PayrollScalarWhereInput
    data: XOR<PayrollUpdateManyMutationInput, PayrollUncheckedUpdateManyWithoutTenantInput>
  }

  export type PayrollScalarWhereInput = {
    AND?: PayrollScalarWhereInput | PayrollScalarWhereInput[]
    OR?: PayrollScalarWhereInput[]
    NOT?: PayrollScalarWhereInput | PayrollScalarWhereInput[]
    id?: StringFilter<"Payroll"> | string
    tenantId?: StringFilter<"Payroll"> | string
    employeeId?: StringFilter<"Payroll"> | string
    month?: IntFilter<"Payroll"> | number
    year?: IntFilter<"Payroll"> | number
    baseSalary?: FloatFilter<"Payroll"> | number
    allowances?: FloatFilter<"Payroll"> | number
    deductions?: FloatFilter<"Payroll"> | number
    netAmount?: FloatFilter<"Payroll"> | number
    status?: StringFilter<"Payroll"> | string
    paidAt?: DateTimeNullableFilter<"Payroll"> | Date | string | null
    createdAt?: DateTimeFilter<"Payroll"> | Date | string
    updatedAt?: DateTimeFilter<"Payroll"> | Date | string
  }

  export type AcademicScheduleUpsertWithWhereUniqueWithoutTenantInput = {
    where: AcademicScheduleWhereUniqueInput
    update: XOR<AcademicScheduleUpdateWithoutTenantInput, AcademicScheduleUncheckedUpdateWithoutTenantInput>
    create: XOR<AcademicScheduleCreateWithoutTenantInput, AcademicScheduleUncheckedCreateWithoutTenantInput>
  }

  export type AcademicScheduleUpdateWithWhereUniqueWithoutTenantInput = {
    where: AcademicScheduleWhereUniqueInput
    data: XOR<AcademicScheduleUpdateWithoutTenantInput, AcademicScheduleUncheckedUpdateWithoutTenantInput>
  }

  export type AcademicScheduleUpdateManyWithWhereWithoutTenantInput = {
    where: AcademicScheduleScalarWhereInput
    data: XOR<AcademicScheduleUpdateManyMutationInput, AcademicScheduleUncheckedUpdateManyWithoutTenantInput>
  }

  export type AcademicScheduleScalarWhereInput = {
    AND?: AcademicScheduleScalarWhereInput | AcademicScheduleScalarWhereInput[]
    OR?: AcademicScheduleScalarWhereInput[]
    NOT?: AcademicScheduleScalarWhereInput | AcademicScheduleScalarWhereInput[]
    id?: StringFilter<"AcademicSchedule"> | string
    tenantId?: StringFilter<"AcademicSchedule"> | string
    subject?: StringFilter<"AcademicSchedule"> | string
    teacherId?: StringFilter<"AcademicSchedule"> | string
    kelas?: StringFilter<"AcademicSchedule"> | string
    dayOfWeek?: IntFilter<"AcademicSchedule"> | number
    startTime?: StringFilter<"AcademicSchedule"> | string
    endTime?: StringFilter<"AcademicSchedule"> | string
    room?: StringNullableFilter<"AcademicSchedule"> | string | null
    createdAt?: DateTimeFilter<"AcademicSchedule"> | Date | string
  }

  export type AttendanceUpsertWithWhereUniqueWithoutTenantInput = {
    where: AttendanceWhereUniqueInput
    update: XOR<AttendanceUpdateWithoutTenantInput, AttendanceUncheckedUpdateWithoutTenantInput>
    create: XOR<AttendanceCreateWithoutTenantInput, AttendanceUncheckedCreateWithoutTenantInput>
  }

  export type AttendanceUpdateWithWhereUniqueWithoutTenantInput = {
    where: AttendanceWhereUniqueInput
    data: XOR<AttendanceUpdateWithoutTenantInput, AttendanceUncheckedUpdateWithoutTenantInput>
  }

  export type AttendanceUpdateManyWithWhereWithoutTenantInput = {
    where: AttendanceScalarWhereInput
    data: XOR<AttendanceUpdateManyMutationInput, AttendanceUncheckedUpdateManyWithoutTenantInput>
  }

  export type AttendanceScalarWhereInput = {
    AND?: AttendanceScalarWhereInput | AttendanceScalarWhereInput[]
    OR?: AttendanceScalarWhereInput[]
    NOT?: AttendanceScalarWhereInput | AttendanceScalarWhereInput[]
    id?: StringFilter<"Attendance"> | string
    tenantId?: StringFilter<"Attendance"> | string
    santriId?: StringFilter<"Attendance"> | string
    scheduleId?: StringNullableFilter<"Attendance"> | string | null
    date?: DateTimeFilter<"Attendance"> | Date | string
    status?: StringFilter<"Attendance"> | string
    notes?: StringNullableFilter<"Attendance"> | string | null
    recordedBy?: StringNullableFilter<"Attendance"> | string | null
    createdAt?: DateTimeFilter<"Attendance"> | Date | string
  }

  export type GradeUpsertWithWhereUniqueWithoutTenantInput = {
    where: GradeWhereUniqueInput
    update: XOR<GradeUpdateWithoutTenantInput, GradeUncheckedUpdateWithoutTenantInput>
    create: XOR<GradeCreateWithoutTenantInput, GradeUncheckedCreateWithoutTenantInput>
  }

  export type GradeUpdateWithWhereUniqueWithoutTenantInput = {
    where: GradeWhereUniqueInput
    data: XOR<GradeUpdateWithoutTenantInput, GradeUncheckedUpdateWithoutTenantInput>
  }

  export type GradeUpdateManyWithWhereWithoutTenantInput = {
    where: GradeScalarWhereInput
    data: XOR<GradeUpdateManyMutationInput, GradeUncheckedUpdateManyWithoutTenantInput>
  }

  export type GradeScalarWhereInput = {
    AND?: GradeScalarWhereInput | GradeScalarWhereInput[]
    OR?: GradeScalarWhereInput[]
    NOT?: GradeScalarWhereInput | GradeScalarWhereInput[]
    id?: StringFilter<"Grade"> | string
    tenantId?: StringFilter<"Grade"> | string
    santriId?: StringFilter<"Grade"> | string
    subject?: StringFilter<"Grade"> | string
    semester?: StringFilter<"Grade"> | string
    academicYear?: StringFilter<"Grade"> | string
    type?: StringFilter<"Grade"> | string
    score?: FloatFilter<"Grade"> | number
    notes?: StringNullableFilter<"Grade"> | string | null
    createdAt?: DateTimeFilter<"Grade"> | Date | string
  }

  export type PpdbRegistrationUpsertWithWhereUniqueWithoutTenantInput = {
    where: PpdbRegistrationWhereUniqueInput
    update: XOR<PpdbRegistrationUpdateWithoutTenantInput, PpdbRegistrationUncheckedUpdateWithoutTenantInput>
    create: XOR<PpdbRegistrationCreateWithoutTenantInput, PpdbRegistrationUncheckedCreateWithoutTenantInput>
  }

  export type PpdbRegistrationUpdateWithWhereUniqueWithoutTenantInput = {
    where: PpdbRegistrationWhereUniqueInput
    data: XOR<PpdbRegistrationUpdateWithoutTenantInput, PpdbRegistrationUncheckedUpdateWithoutTenantInput>
  }

  export type PpdbRegistrationUpdateManyWithWhereWithoutTenantInput = {
    where: PpdbRegistrationScalarWhereInput
    data: XOR<PpdbRegistrationUpdateManyMutationInput, PpdbRegistrationUncheckedUpdateManyWithoutTenantInput>
  }

  export type PpdbRegistrationScalarWhereInput = {
    AND?: PpdbRegistrationScalarWhereInput | PpdbRegistrationScalarWhereInput[]
    OR?: PpdbRegistrationScalarWhereInput[]
    NOT?: PpdbRegistrationScalarWhereInput | PpdbRegistrationScalarWhereInput[]
    id?: StringFilter<"PpdbRegistration"> | string
    tenantId?: StringFilter<"PpdbRegistration"> | string
    registrationNumber?: StringFilter<"PpdbRegistration"> | string
    fullName?: StringFilter<"PpdbRegistration"> | string
    gender?: StringFilter<"PpdbRegistration"> | string
    dob?: DateTimeNullableFilter<"PpdbRegistration"> | Date | string | null
    previousSchool?: StringNullableFilter<"PpdbRegistration"> | string | null
    pathway?: StringFilter<"PpdbRegistration"> | string
    status?: StringFilter<"PpdbRegistration"> | string
    notes?: StringNullableFilter<"PpdbRegistration"> | string | null
    createdAt?: DateTimeFilter<"PpdbRegistration"> | Date | string
    updatedAt?: DateTimeFilter<"PpdbRegistration"> | Date | string
  }

  export type PpdbDocumentUpsertWithWhereUniqueWithoutTenantInput = {
    where: PpdbDocumentWhereUniqueInput
    update: XOR<PpdbDocumentUpdateWithoutTenantInput, PpdbDocumentUncheckedUpdateWithoutTenantInput>
    create: XOR<PpdbDocumentCreateWithoutTenantInput, PpdbDocumentUncheckedCreateWithoutTenantInput>
  }

  export type PpdbDocumentUpdateWithWhereUniqueWithoutTenantInput = {
    where: PpdbDocumentWhereUniqueInput
    data: XOR<PpdbDocumentUpdateWithoutTenantInput, PpdbDocumentUncheckedUpdateWithoutTenantInput>
  }

  export type PpdbDocumentUpdateManyWithWhereWithoutTenantInput = {
    where: PpdbDocumentScalarWhereInput
    data: XOR<PpdbDocumentUpdateManyMutationInput, PpdbDocumentUncheckedUpdateManyWithoutTenantInput>
  }

  export type PpdbDocumentScalarWhereInput = {
    AND?: PpdbDocumentScalarWhereInput | PpdbDocumentScalarWhereInput[]
    OR?: PpdbDocumentScalarWhereInput[]
    NOT?: PpdbDocumentScalarWhereInput | PpdbDocumentScalarWhereInput[]
    id?: StringFilter<"PpdbDocument"> | string
    tenantId?: StringFilter<"PpdbDocument"> | string
    registrationId?: StringFilter<"PpdbDocument"> | string
    documentType?: StringFilter<"PpdbDocument"> | string
    fileUrl?: StringFilter<"PpdbDocument"> | string
    isVerified?: BoolFilter<"PpdbDocument"> | boolean
    createdAt?: DateTimeFilter<"PpdbDocument"> | Date | string
  }

  export type PpdbExamUpsertWithWhereUniqueWithoutTenantInput = {
    where: PpdbExamWhereUniqueInput
    update: XOR<PpdbExamUpdateWithoutTenantInput, PpdbExamUncheckedUpdateWithoutTenantInput>
    create: XOR<PpdbExamCreateWithoutTenantInput, PpdbExamUncheckedCreateWithoutTenantInput>
  }

  export type PpdbExamUpdateWithWhereUniqueWithoutTenantInput = {
    where: PpdbExamWhereUniqueInput
    data: XOR<PpdbExamUpdateWithoutTenantInput, PpdbExamUncheckedUpdateWithoutTenantInput>
  }

  export type PpdbExamUpdateManyWithWhereWithoutTenantInput = {
    where: PpdbExamScalarWhereInput
    data: XOR<PpdbExamUpdateManyMutationInput, PpdbExamUncheckedUpdateManyWithoutTenantInput>
  }

  export type PpdbExamScalarWhereInput = {
    AND?: PpdbExamScalarWhereInput | PpdbExamScalarWhereInput[]
    OR?: PpdbExamScalarWhereInput[]
    NOT?: PpdbExamScalarWhereInput | PpdbExamScalarWhereInput[]
    id?: StringFilter<"PpdbExam"> | string
    tenantId?: StringFilter<"PpdbExam"> | string
    registrationId?: StringFilter<"PpdbExam"> | string
    examType?: StringFilter<"PpdbExam"> | string
    examDate?: DateTimeFilter<"PpdbExam"> | Date | string
    score?: FloatNullableFilter<"PpdbExam"> | number | null
    result?: StringNullableFilter<"PpdbExam"> | string | null
    interviewer?: StringNullableFilter<"PpdbExam"> | string | null
    createdAt?: DateTimeFilter<"PpdbExam"> | Date | string
  }

  export type ItemUpsertWithWhereUniqueWithoutTenantInput = {
    where: ItemWhereUniqueInput
    update: XOR<ItemUpdateWithoutTenantInput, ItemUncheckedUpdateWithoutTenantInput>
    create: XOR<ItemCreateWithoutTenantInput, ItemUncheckedCreateWithoutTenantInput>
  }

  export type ItemUpdateWithWhereUniqueWithoutTenantInput = {
    where: ItemWhereUniqueInput
    data: XOR<ItemUpdateWithoutTenantInput, ItemUncheckedUpdateWithoutTenantInput>
  }

  export type ItemUpdateManyWithWhereWithoutTenantInput = {
    where: ItemScalarWhereInput
    data: XOR<ItemUpdateManyMutationInput, ItemUncheckedUpdateManyWithoutTenantInput>
  }

  export type ItemScalarWhereInput = {
    AND?: ItemScalarWhereInput | ItemScalarWhereInput[]
    OR?: ItemScalarWhereInput[]
    NOT?: ItemScalarWhereInput | ItemScalarWhereInput[]
    id?: StringFilter<"Item"> | string
    tenantId?: StringFilter<"Item"> | string
    sku?: StringFilter<"Item"> | string
    name?: StringFilter<"Item"> | string
    description?: StringNullableFilter<"Item"> | string | null
    category?: StringFilter<"Item"> | string
    price?: FloatFilter<"Item"> | number
    costPrice?: FloatNullableFilter<"Item"> | number | null
    stock?: IntFilter<"Item"> | number
    minStock?: IntFilter<"Item"> | number
    createdAt?: DateTimeFilter<"Item"> | Date | string
    updatedAt?: DateTimeFilter<"Item"> | Date | string
  }

  export type InventoryTransactionUpsertWithWhereUniqueWithoutTenantInput = {
    where: InventoryTransactionWhereUniqueInput
    update: XOR<InventoryTransactionUpdateWithoutTenantInput, InventoryTransactionUncheckedUpdateWithoutTenantInput>
    create: XOR<InventoryTransactionCreateWithoutTenantInput, InventoryTransactionUncheckedCreateWithoutTenantInput>
  }

  export type InventoryTransactionUpdateWithWhereUniqueWithoutTenantInput = {
    where: InventoryTransactionWhereUniqueInput
    data: XOR<InventoryTransactionUpdateWithoutTenantInput, InventoryTransactionUncheckedUpdateWithoutTenantInput>
  }

  export type InventoryTransactionUpdateManyWithWhereWithoutTenantInput = {
    where: InventoryTransactionScalarWhereInput
    data: XOR<InventoryTransactionUpdateManyMutationInput, InventoryTransactionUncheckedUpdateManyWithoutTenantInput>
  }

  export type InventoryTransactionScalarWhereInput = {
    AND?: InventoryTransactionScalarWhereInput | InventoryTransactionScalarWhereInput[]
    OR?: InventoryTransactionScalarWhereInput[]
    NOT?: InventoryTransactionScalarWhereInput | InventoryTransactionScalarWhereInput[]
    id?: StringFilter<"InventoryTransaction"> | string
    tenantId?: StringFilter<"InventoryTransaction"> | string
    itemId?: StringFilter<"InventoryTransaction"> | string
    type?: StringFilter<"InventoryTransaction"> | string
    quantity?: IntFilter<"InventoryTransaction"> | number
    reference?: StringNullableFilter<"InventoryTransaction"> | string | null
    notes?: StringNullableFilter<"InventoryTransaction"> | string | null
    handledBy?: StringNullableFilter<"InventoryTransaction"> | string | null
    date?: DateTimeFilter<"InventoryTransaction"> | Date | string
  }

  export type SupplierUpsertWithWhereUniqueWithoutTenantInput = {
    where: SupplierWhereUniqueInput
    update: XOR<SupplierUpdateWithoutTenantInput, SupplierUncheckedUpdateWithoutTenantInput>
    create: XOR<SupplierCreateWithoutTenantInput, SupplierUncheckedCreateWithoutTenantInput>
  }

  export type SupplierUpdateWithWhereUniqueWithoutTenantInput = {
    where: SupplierWhereUniqueInput
    data: XOR<SupplierUpdateWithoutTenantInput, SupplierUncheckedUpdateWithoutTenantInput>
  }

  export type SupplierUpdateManyWithWhereWithoutTenantInput = {
    where: SupplierScalarWhereInput
    data: XOR<SupplierUpdateManyMutationInput, SupplierUncheckedUpdateManyWithoutTenantInput>
  }

  export type SupplierScalarWhereInput = {
    AND?: SupplierScalarWhereInput | SupplierScalarWhereInput[]
    OR?: SupplierScalarWhereInput[]
    NOT?: SupplierScalarWhereInput | SupplierScalarWhereInput[]
    id?: StringFilter<"Supplier"> | string
    tenantId?: StringFilter<"Supplier"> | string
    name?: StringFilter<"Supplier"> | string
    contact?: StringNullableFilter<"Supplier"> | string | null
    address?: StringNullableFilter<"Supplier"> | string | null
    email?: StringNullableFilter<"Supplier"> | string | null
    createdAt?: DateTimeFilter<"Supplier"> | Date | string
  }

  export type PurchaseOrderUpsertWithWhereUniqueWithoutTenantInput = {
    where: PurchaseOrderWhereUniqueInput
    update: XOR<PurchaseOrderUpdateWithoutTenantInput, PurchaseOrderUncheckedUpdateWithoutTenantInput>
    create: XOR<PurchaseOrderCreateWithoutTenantInput, PurchaseOrderUncheckedCreateWithoutTenantInput>
  }

  export type PurchaseOrderUpdateWithWhereUniqueWithoutTenantInput = {
    where: PurchaseOrderWhereUniqueInput
    data: XOR<PurchaseOrderUpdateWithoutTenantInput, PurchaseOrderUncheckedUpdateWithoutTenantInput>
  }

  export type PurchaseOrderUpdateManyWithWhereWithoutTenantInput = {
    where: PurchaseOrderScalarWhereInput
    data: XOR<PurchaseOrderUpdateManyMutationInput, PurchaseOrderUncheckedUpdateManyWithoutTenantInput>
  }

  export type PurchaseOrderScalarWhereInput = {
    AND?: PurchaseOrderScalarWhereInput | PurchaseOrderScalarWhereInput[]
    OR?: PurchaseOrderScalarWhereInput[]
    NOT?: PurchaseOrderScalarWhereInput | PurchaseOrderScalarWhereInput[]
    id?: StringFilter<"PurchaseOrder"> | string
    tenantId?: StringFilter<"PurchaseOrder"> | string
    supplierId?: StringFilter<"PurchaseOrder"> | string
    poNumber?: StringFilter<"PurchaseOrder"> | string
    totalCost?: FloatFilter<"PurchaseOrder"> | number
    status?: StringFilter<"PurchaseOrder"> | string
    orderDate?: DateTimeFilter<"PurchaseOrder"> | Date | string
    notes?: StringNullableFilter<"PurchaseOrder"> | string | null
    createdAt?: DateTimeFilter<"PurchaseOrder"> | Date | string
    updatedAt?: DateTimeFilter<"PurchaseOrder"> | Date | string
  }

  export type BuildingUpsertWithWhereUniqueWithoutTenantInput = {
    where: BuildingWhereUniqueInput
    update: XOR<BuildingUpdateWithoutTenantInput, BuildingUncheckedUpdateWithoutTenantInput>
    create: XOR<BuildingCreateWithoutTenantInput, BuildingUncheckedCreateWithoutTenantInput>
  }

  export type BuildingUpdateWithWhereUniqueWithoutTenantInput = {
    where: BuildingWhereUniqueInput
    data: XOR<BuildingUpdateWithoutTenantInput, BuildingUncheckedUpdateWithoutTenantInput>
  }

  export type BuildingUpdateManyWithWhereWithoutTenantInput = {
    where: BuildingScalarWhereInput
    data: XOR<BuildingUpdateManyMutationInput, BuildingUncheckedUpdateManyWithoutTenantInput>
  }

  export type BuildingScalarWhereInput = {
    AND?: BuildingScalarWhereInput | BuildingScalarWhereInput[]
    OR?: BuildingScalarWhereInput[]
    NOT?: BuildingScalarWhereInput | BuildingScalarWhereInput[]
    id?: StringFilter<"Building"> | string
    tenantId?: StringFilter<"Building"> | string
    name?: StringFilter<"Building"> | string
    description?: StringNullableFilter<"Building"> | string | null
    gender?: StringFilter<"Building"> | string
    capacity?: IntFilter<"Building"> | number
    createdAt?: DateTimeFilter<"Building"> | Date | string
    updatedAt?: DateTimeFilter<"Building"> | Date | string
  }

  export type RoomUpsertWithWhereUniqueWithoutTenantInput = {
    where: RoomWhereUniqueInput
    update: XOR<RoomUpdateWithoutTenantInput, RoomUncheckedUpdateWithoutTenantInput>
    create: XOR<RoomCreateWithoutTenantInput, RoomUncheckedCreateWithoutTenantInput>
  }

  export type RoomUpdateWithWhereUniqueWithoutTenantInput = {
    where: RoomWhereUniqueInput
    data: XOR<RoomUpdateWithoutTenantInput, RoomUncheckedUpdateWithoutTenantInput>
  }

  export type RoomUpdateManyWithWhereWithoutTenantInput = {
    where: RoomScalarWhereInput
    data: XOR<RoomUpdateManyMutationInput, RoomUncheckedUpdateManyWithoutTenantInput>
  }

  export type RoomScalarWhereInput = {
    AND?: RoomScalarWhereInput | RoomScalarWhereInput[]
    OR?: RoomScalarWhereInput[]
    NOT?: RoomScalarWhereInput | RoomScalarWhereInput[]
    id?: StringFilter<"Room"> | string
    tenantId?: StringFilter<"Room"> | string
    buildingId?: StringFilter<"Room"> | string
    name?: StringFilter<"Room"> | string
    capacity?: IntFilter<"Room"> | number
    picName?: StringNullableFilter<"Room"> | string | null
    createdAt?: DateTimeFilter<"Room"> | Date | string
  }

  export type RoomAssignmentUpsertWithWhereUniqueWithoutTenantInput = {
    where: RoomAssignmentWhereUniqueInput
    update: XOR<RoomAssignmentUpdateWithoutTenantInput, RoomAssignmentUncheckedUpdateWithoutTenantInput>
    create: XOR<RoomAssignmentCreateWithoutTenantInput, RoomAssignmentUncheckedCreateWithoutTenantInput>
  }

  export type RoomAssignmentUpdateWithWhereUniqueWithoutTenantInput = {
    where: RoomAssignmentWhereUniqueInput
    data: XOR<RoomAssignmentUpdateWithoutTenantInput, RoomAssignmentUncheckedUpdateWithoutTenantInput>
  }

  export type RoomAssignmentUpdateManyWithWhereWithoutTenantInput = {
    where: RoomAssignmentScalarWhereInput
    data: XOR<RoomAssignmentUpdateManyMutationInput, RoomAssignmentUncheckedUpdateManyWithoutTenantInput>
  }

  export type RoomAssignmentScalarWhereInput = {
    AND?: RoomAssignmentScalarWhereInput | RoomAssignmentScalarWhereInput[]
    OR?: RoomAssignmentScalarWhereInput[]
    NOT?: RoomAssignmentScalarWhereInput | RoomAssignmentScalarWhereInput[]
    id?: StringFilter<"RoomAssignment"> | string
    tenantId?: StringFilter<"RoomAssignment"> | string
    roomId?: StringFilter<"RoomAssignment"> | string
    santriId?: StringFilter<"RoomAssignment"> | string
    startDate?: DateTimeFilter<"RoomAssignment"> | Date | string
    endDate?: DateTimeNullableFilter<"RoomAssignment"> | Date | string | null
    status?: StringFilter<"RoomAssignment"> | string
  }

  export type MaintenanceTicketUpsertWithWhereUniqueWithoutTenantInput = {
    where: MaintenanceTicketWhereUniqueInput
    update: XOR<MaintenanceTicketUpdateWithoutTenantInput, MaintenanceTicketUncheckedUpdateWithoutTenantInput>
    create: XOR<MaintenanceTicketCreateWithoutTenantInput, MaintenanceTicketUncheckedCreateWithoutTenantInput>
  }

  export type MaintenanceTicketUpdateWithWhereUniqueWithoutTenantInput = {
    where: MaintenanceTicketWhereUniqueInput
    data: XOR<MaintenanceTicketUpdateWithoutTenantInput, MaintenanceTicketUncheckedUpdateWithoutTenantInput>
  }

  export type MaintenanceTicketUpdateManyWithWhereWithoutTenantInput = {
    where: MaintenanceTicketScalarWhereInput
    data: XOR<MaintenanceTicketUpdateManyMutationInput, MaintenanceTicketUncheckedUpdateManyWithoutTenantInput>
  }

  export type MaintenanceTicketScalarWhereInput = {
    AND?: MaintenanceTicketScalarWhereInput | MaintenanceTicketScalarWhereInput[]
    OR?: MaintenanceTicketScalarWhereInput[]
    NOT?: MaintenanceTicketScalarWhereInput | MaintenanceTicketScalarWhereInput[]
    id?: StringFilter<"MaintenanceTicket"> | string
    tenantId?: StringFilter<"MaintenanceTicket"> | string
    roomId?: StringFilter<"MaintenanceTicket"> | string
    title?: StringFilter<"MaintenanceTicket"> | string
    description?: StringFilter<"MaintenanceTicket"> | string
    priority?: StringFilter<"MaintenanceTicket"> | string
    status?: StringFilter<"MaintenanceTicket"> | string
    reportedBy?: StringFilter<"MaintenanceTicket"> | string
    resolvedAt?: DateTimeNullableFilter<"MaintenanceTicket"> | Date | string | null
    createdAt?: DateTimeFilter<"MaintenanceTicket"> | Date | string
    updatedAt?: DateTimeFilter<"MaintenanceTicket"> | Date | string
  }

  export type TenantCreateWithoutUsersInput = {
    id?: string
    name: string
    address?: string | null
    phone?: string | null
    adminUserId?: string | null
    timezone?: string
    plan?: string
    billingContact?: string | null
    status?: string
    settings?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    santri?: SantriCreateNestedManyWithoutTenantInput
    wali?: WaliCreateNestedManyWithoutTenantInput
    izin?: IzinCreateNestedManyWithoutTenantInput
    catatanHarian?: CatatanHarianCreateNestedManyWithoutTenantInput
    pengumuman?: PengumumanCreateNestedManyWithoutTenantInput
    invoices?: InvoiceCreateNestedManyWithoutTenantInput
    pelanggaran?: PelanggaranCreateNestedManyWithoutTenantInput
    pembinaan?: PembinaanCreateNestedManyWithoutTenantInput
    kunjungan?: KunjunganCreateNestedManyWithoutTenantInput
    healthRecords?: HealthRecordCreateNestedManyWithoutTenantInput
    auditLogs?: AuditLogCreateNestedManyWithoutTenantInput
    notifications?: NotificationCreateNestedManyWithoutTenantInput
    webhookEvents?: WebhookEventCreateNestedManyWithoutTenantInput
    tahfidz?: TahfidzCreateNestedManyWithoutTenantInput
    mutabaah?: MutabaahCreateNestedManyWithoutTenantInput
    wallets?: WalletCreateNestedManyWithoutTenantInput
    employees?: EmployeeCreateNestedManyWithoutTenantInput
    payrolls?: PayrollCreateNestedManyWithoutTenantInput
    academicScheds?: AcademicScheduleCreateNestedManyWithoutTenantInput
    attendances?: AttendanceCreateNestedManyWithoutTenantInput
    grades?: GradeCreateNestedManyWithoutTenantInput
    ppdbRegistrations?: PpdbRegistrationCreateNestedManyWithoutTenantInput
    ppdbDocuments?: PpdbDocumentCreateNestedManyWithoutTenantInput
    ppdbExams?: PpdbExamCreateNestedManyWithoutTenantInput
    inventoryItems?: ItemCreateNestedManyWithoutTenantInput
    inventoryTransactions?: InventoryTransactionCreateNestedManyWithoutTenantInput
    suppliers?: SupplierCreateNestedManyWithoutTenantInput
    purchaseOrders?: PurchaseOrderCreateNestedManyWithoutTenantInput
    buildings?: BuildingCreateNestedManyWithoutTenantInput
    rooms?: RoomCreateNestedManyWithoutTenantInput
    roomAssignments?: RoomAssignmentCreateNestedManyWithoutTenantInput
    maintenanceTickets?: MaintenanceTicketCreateNestedManyWithoutTenantInput
  }

  export type TenantUncheckedCreateWithoutUsersInput = {
    id?: string
    name: string
    address?: string | null
    phone?: string | null
    adminUserId?: string | null
    timezone?: string
    plan?: string
    billingContact?: string | null
    status?: string
    settings?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    santri?: SantriUncheckedCreateNestedManyWithoutTenantInput
    wali?: WaliUncheckedCreateNestedManyWithoutTenantInput
    izin?: IzinUncheckedCreateNestedManyWithoutTenantInput
    catatanHarian?: CatatanHarianUncheckedCreateNestedManyWithoutTenantInput
    pengumuman?: PengumumanUncheckedCreateNestedManyWithoutTenantInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutTenantInput
    pelanggaran?: PelanggaranUncheckedCreateNestedManyWithoutTenantInput
    pembinaan?: PembinaanUncheckedCreateNestedManyWithoutTenantInput
    kunjungan?: KunjunganUncheckedCreateNestedManyWithoutTenantInput
    healthRecords?: HealthRecordUncheckedCreateNestedManyWithoutTenantInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutTenantInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutTenantInput
    webhookEvents?: WebhookEventUncheckedCreateNestedManyWithoutTenantInput
    tahfidz?: TahfidzUncheckedCreateNestedManyWithoutTenantInput
    mutabaah?: MutabaahUncheckedCreateNestedManyWithoutTenantInput
    wallets?: WalletUncheckedCreateNestedManyWithoutTenantInput
    employees?: EmployeeUncheckedCreateNestedManyWithoutTenantInput
    payrolls?: PayrollUncheckedCreateNestedManyWithoutTenantInput
    academicScheds?: AcademicScheduleUncheckedCreateNestedManyWithoutTenantInput
    attendances?: AttendanceUncheckedCreateNestedManyWithoutTenantInput
    grades?: GradeUncheckedCreateNestedManyWithoutTenantInput
    ppdbRegistrations?: PpdbRegistrationUncheckedCreateNestedManyWithoutTenantInput
    ppdbDocuments?: PpdbDocumentUncheckedCreateNestedManyWithoutTenantInput
    ppdbExams?: PpdbExamUncheckedCreateNestedManyWithoutTenantInput
    inventoryItems?: ItemUncheckedCreateNestedManyWithoutTenantInput
    inventoryTransactions?: InventoryTransactionUncheckedCreateNestedManyWithoutTenantInput
    suppliers?: SupplierUncheckedCreateNestedManyWithoutTenantInput
    purchaseOrders?: PurchaseOrderUncheckedCreateNestedManyWithoutTenantInput
    buildings?: BuildingUncheckedCreateNestedManyWithoutTenantInput
    rooms?: RoomUncheckedCreateNestedManyWithoutTenantInput
    roomAssignments?: RoomAssignmentUncheckedCreateNestedManyWithoutTenantInput
    maintenanceTickets?: MaintenanceTicketUncheckedCreateNestedManyWithoutTenantInput
  }

  export type TenantCreateOrConnectWithoutUsersInput = {
    where: TenantWhereUniqueInput
    create: XOR<TenantCreateWithoutUsersInput, TenantUncheckedCreateWithoutUsersInput>
  }

  export type RefreshTokenCreateWithoutUserInput = {
    id?: string
    token: string
    expiresAt: Date | string
    revoked?: boolean
    createdAt?: Date | string
  }

  export type RefreshTokenUncheckedCreateWithoutUserInput = {
    id?: string
    token: string
    expiresAt: Date | string
    revoked?: boolean
    createdAt?: Date | string
  }

  export type RefreshTokenCreateOrConnectWithoutUserInput = {
    where: RefreshTokenWhereUniqueInput
    create: XOR<RefreshTokenCreateWithoutUserInput, RefreshTokenUncheckedCreateWithoutUserInput>
  }

  export type RefreshTokenCreateManyUserInputEnvelope = {
    data: RefreshTokenCreateManyUserInput | RefreshTokenCreateManyUserInput[]
  }

  export type AuditLogCreateWithoutUserInput = {
    id?: string
    action: string
    entity: string
    entityId: string
    oldValue?: string | null
    newValue?: string | null
    ip?: string | null
    createdAt?: Date | string
    tenant?: TenantCreateNestedOneWithoutAuditLogsInput
  }

  export type AuditLogUncheckedCreateWithoutUserInput = {
    id?: string
    tenantId?: string | null
    action: string
    entity: string
    entityId: string
    oldValue?: string | null
    newValue?: string | null
    ip?: string | null
    createdAt?: Date | string
  }

  export type AuditLogCreateOrConnectWithoutUserInput = {
    where: AuditLogWhereUniqueInput
    create: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput>
  }

  export type AuditLogCreateManyUserInputEnvelope = {
    data: AuditLogCreateManyUserInput | AuditLogCreateManyUserInput[]
  }

  export type NotificationCreateWithoutUserInput = {
    id?: string
    type: string
    title: string
    body: string
    read?: boolean
    createdAt?: Date | string
    tenant: TenantCreateNestedOneWithoutNotificationsInput
  }

  export type NotificationUncheckedCreateWithoutUserInput = {
    id?: string
    tenantId: string
    type: string
    title: string
    body: string
    read?: boolean
    createdAt?: Date | string
  }

  export type NotificationCreateOrConnectWithoutUserInput = {
    where: NotificationWhereUniqueInput
    create: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput>
  }

  export type NotificationCreateManyUserInputEnvelope = {
    data: NotificationCreateManyUserInput | NotificationCreateManyUserInput[]
  }

  export type TenantUpsertWithoutUsersInput = {
    update: XOR<TenantUpdateWithoutUsersInput, TenantUncheckedUpdateWithoutUsersInput>
    create: XOR<TenantCreateWithoutUsersInput, TenantUncheckedCreateWithoutUsersInput>
    where?: TenantWhereInput
  }

  export type TenantUpdateToOneWithWhereWithoutUsersInput = {
    where?: TenantWhereInput
    data: XOR<TenantUpdateWithoutUsersInput, TenantUncheckedUpdateWithoutUsersInput>
  }

  export type TenantUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    adminUserId?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    plan?: StringFieldUpdateOperationsInput | string
    billingContact?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    settings?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    santri?: SantriUpdateManyWithoutTenantNestedInput
    wali?: WaliUpdateManyWithoutTenantNestedInput
    izin?: IzinUpdateManyWithoutTenantNestedInput
    catatanHarian?: CatatanHarianUpdateManyWithoutTenantNestedInput
    pengumuman?: PengumumanUpdateManyWithoutTenantNestedInput
    invoices?: InvoiceUpdateManyWithoutTenantNestedInput
    pelanggaran?: PelanggaranUpdateManyWithoutTenantNestedInput
    pembinaan?: PembinaanUpdateManyWithoutTenantNestedInput
    kunjungan?: KunjunganUpdateManyWithoutTenantNestedInput
    healthRecords?: HealthRecordUpdateManyWithoutTenantNestedInput
    auditLogs?: AuditLogUpdateManyWithoutTenantNestedInput
    notifications?: NotificationUpdateManyWithoutTenantNestedInput
    webhookEvents?: WebhookEventUpdateManyWithoutTenantNestedInput
    tahfidz?: TahfidzUpdateManyWithoutTenantNestedInput
    mutabaah?: MutabaahUpdateManyWithoutTenantNestedInput
    wallets?: WalletUpdateManyWithoutTenantNestedInput
    employees?: EmployeeUpdateManyWithoutTenantNestedInput
    payrolls?: PayrollUpdateManyWithoutTenantNestedInput
    academicScheds?: AcademicScheduleUpdateManyWithoutTenantNestedInput
    attendances?: AttendanceUpdateManyWithoutTenantNestedInput
    grades?: GradeUpdateManyWithoutTenantNestedInput
    ppdbRegistrations?: PpdbRegistrationUpdateManyWithoutTenantNestedInput
    ppdbDocuments?: PpdbDocumentUpdateManyWithoutTenantNestedInput
    ppdbExams?: PpdbExamUpdateManyWithoutTenantNestedInput
    inventoryItems?: ItemUpdateManyWithoutTenantNestedInput
    inventoryTransactions?: InventoryTransactionUpdateManyWithoutTenantNestedInput
    suppliers?: SupplierUpdateManyWithoutTenantNestedInput
    purchaseOrders?: PurchaseOrderUpdateManyWithoutTenantNestedInput
    buildings?: BuildingUpdateManyWithoutTenantNestedInput
    rooms?: RoomUpdateManyWithoutTenantNestedInput
    roomAssignments?: RoomAssignmentUpdateManyWithoutTenantNestedInput
    maintenanceTickets?: MaintenanceTicketUpdateManyWithoutTenantNestedInput
  }

  export type TenantUncheckedUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    adminUserId?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    plan?: StringFieldUpdateOperationsInput | string
    billingContact?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    settings?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    santri?: SantriUncheckedUpdateManyWithoutTenantNestedInput
    wali?: WaliUncheckedUpdateManyWithoutTenantNestedInput
    izin?: IzinUncheckedUpdateManyWithoutTenantNestedInput
    catatanHarian?: CatatanHarianUncheckedUpdateManyWithoutTenantNestedInput
    pengumuman?: PengumumanUncheckedUpdateManyWithoutTenantNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutTenantNestedInput
    pelanggaran?: PelanggaranUncheckedUpdateManyWithoutTenantNestedInput
    pembinaan?: PembinaanUncheckedUpdateManyWithoutTenantNestedInput
    kunjungan?: KunjunganUncheckedUpdateManyWithoutTenantNestedInput
    healthRecords?: HealthRecordUncheckedUpdateManyWithoutTenantNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutTenantNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutTenantNestedInput
    webhookEvents?: WebhookEventUncheckedUpdateManyWithoutTenantNestedInput
    tahfidz?: TahfidzUncheckedUpdateManyWithoutTenantNestedInput
    mutabaah?: MutabaahUncheckedUpdateManyWithoutTenantNestedInput
    wallets?: WalletUncheckedUpdateManyWithoutTenantNestedInput
    employees?: EmployeeUncheckedUpdateManyWithoutTenantNestedInput
    payrolls?: PayrollUncheckedUpdateManyWithoutTenantNestedInput
    academicScheds?: AcademicScheduleUncheckedUpdateManyWithoutTenantNestedInput
    attendances?: AttendanceUncheckedUpdateManyWithoutTenantNestedInput
    grades?: GradeUncheckedUpdateManyWithoutTenantNestedInput
    ppdbRegistrations?: PpdbRegistrationUncheckedUpdateManyWithoutTenantNestedInput
    ppdbDocuments?: PpdbDocumentUncheckedUpdateManyWithoutTenantNestedInput
    ppdbExams?: PpdbExamUncheckedUpdateManyWithoutTenantNestedInput
    inventoryItems?: ItemUncheckedUpdateManyWithoutTenantNestedInput
    inventoryTransactions?: InventoryTransactionUncheckedUpdateManyWithoutTenantNestedInput
    suppliers?: SupplierUncheckedUpdateManyWithoutTenantNestedInput
    purchaseOrders?: PurchaseOrderUncheckedUpdateManyWithoutTenantNestedInput
    buildings?: BuildingUncheckedUpdateManyWithoutTenantNestedInput
    rooms?: RoomUncheckedUpdateManyWithoutTenantNestedInput
    roomAssignments?: RoomAssignmentUncheckedUpdateManyWithoutTenantNestedInput
    maintenanceTickets?: MaintenanceTicketUncheckedUpdateManyWithoutTenantNestedInput
  }

  export type RefreshTokenUpsertWithWhereUniqueWithoutUserInput = {
    where: RefreshTokenWhereUniqueInput
    update: XOR<RefreshTokenUpdateWithoutUserInput, RefreshTokenUncheckedUpdateWithoutUserInput>
    create: XOR<RefreshTokenCreateWithoutUserInput, RefreshTokenUncheckedCreateWithoutUserInput>
  }

  export type RefreshTokenUpdateWithWhereUniqueWithoutUserInput = {
    where: RefreshTokenWhereUniqueInput
    data: XOR<RefreshTokenUpdateWithoutUserInput, RefreshTokenUncheckedUpdateWithoutUserInput>
  }

  export type RefreshTokenUpdateManyWithWhereWithoutUserInput = {
    where: RefreshTokenScalarWhereInput
    data: XOR<RefreshTokenUpdateManyMutationInput, RefreshTokenUncheckedUpdateManyWithoutUserInput>
  }

  export type RefreshTokenScalarWhereInput = {
    AND?: RefreshTokenScalarWhereInput | RefreshTokenScalarWhereInput[]
    OR?: RefreshTokenScalarWhereInput[]
    NOT?: RefreshTokenScalarWhereInput | RefreshTokenScalarWhereInput[]
    id?: StringFilter<"RefreshToken"> | string
    userId?: StringFilter<"RefreshToken"> | string
    token?: StringFilter<"RefreshToken"> | string
    expiresAt?: DateTimeFilter<"RefreshToken"> | Date | string
    revoked?: BoolFilter<"RefreshToken"> | boolean
    createdAt?: DateTimeFilter<"RefreshToken"> | Date | string
  }

  export type AuditLogUpsertWithWhereUniqueWithoutUserInput = {
    where: AuditLogWhereUniqueInput
    update: XOR<AuditLogUpdateWithoutUserInput, AuditLogUncheckedUpdateWithoutUserInput>
    create: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput>
  }

  export type AuditLogUpdateWithWhereUniqueWithoutUserInput = {
    where: AuditLogWhereUniqueInput
    data: XOR<AuditLogUpdateWithoutUserInput, AuditLogUncheckedUpdateWithoutUserInput>
  }

  export type AuditLogUpdateManyWithWhereWithoutUserInput = {
    where: AuditLogScalarWhereInput
    data: XOR<AuditLogUpdateManyMutationInput, AuditLogUncheckedUpdateManyWithoutUserInput>
  }

  export type NotificationUpsertWithWhereUniqueWithoutUserInput = {
    where: NotificationWhereUniqueInput
    update: XOR<NotificationUpdateWithoutUserInput, NotificationUncheckedUpdateWithoutUserInput>
    create: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput>
  }

  export type NotificationUpdateWithWhereUniqueWithoutUserInput = {
    where: NotificationWhereUniqueInput
    data: XOR<NotificationUpdateWithoutUserInput, NotificationUncheckedUpdateWithoutUserInput>
  }

  export type NotificationUpdateManyWithWhereWithoutUserInput = {
    where: NotificationScalarWhereInput
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyWithoutUserInput>
  }

  export type UserCreateWithoutRefreshTokensInput = {
    id?: string
    email: string
    passwordHash: string
    role?: string
    name: string
    phone?: string | null
    isActive?: boolean
    lastLogin?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant?: TenantCreateNestedOneWithoutUsersInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutRefreshTokensInput = {
    id?: string
    tenantId?: string | null
    email: string
    passwordHash: string
    role?: string
    name: string
    phone?: string | null
    isActive?: boolean
    lastLogin?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutRefreshTokensInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutRefreshTokensInput, UserUncheckedCreateWithoutRefreshTokensInput>
  }

  export type UserUpsertWithoutRefreshTokensInput = {
    update: XOR<UserUpdateWithoutRefreshTokensInput, UserUncheckedUpdateWithoutRefreshTokensInput>
    create: XOR<UserCreateWithoutRefreshTokensInput, UserUncheckedCreateWithoutRefreshTokensInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutRefreshTokensInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutRefreshTokensInput, UserUncheckedUpdateWithoutRefreshTokensInput>
  }

  export type UserUpdateWithoutRefreshTokensInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneWithoutUsersNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutRefreshTokensInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
  }

  export type TenantCreateWithoutSantriInput = {
    id?: string
    name: string
    address?: string | null
    phone?: string | null
    adminUserId?: string | null
    timezone?: string
    plan?: string
    billingContact?: string | null
    status?: string
    settings?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutTenantInput
    wali?: WaliCreateNestedManyWithoutTenantInput
    izin?: IzinCreateNestedManyWithoutTenantInput
    catatanHarian?: CatatanHarianCreateNestedManyWithoutTenantInput
    pengumuman?: PengumumanCreateNestedManyWithoutTenantInput
    invoices?: InvoiceCreateNestedManyWithoutTenantInput
    pelanggaran?: PelanggaranCreateNestedManyWithoutTenantInput
    pembinaan?: PembinaanCreateNestedManyWithoutTenantInput
    kunjungan?: KunjunganCreateNestedManyWithoutTenantInput
    healthRecords?: HealthRecordCreateNestedManyWithoutTenantInput
    auditLogs?: AuditLogCreateNestedManyWithoutTenantInput
    notifications?: NotificationCreateNestedManyWithoutTenantInput
    webhookEvents?: WebhookEventCreateNestedManyWithoutTenantInput
    tahfidz?: TahfidzCreateNestedManyWithoutTenantInput
    mutabaah?: MutabaahCreateNestedManyWithoutTenantInput
    wallets?: WalletCreateNestedManyWithoutTenantInput
    employees?: EmployeeCreateNestedManyWithoutTenantInput
    payrolls?: PayrollCreateNestedManyWithoutTenantInput
    academicScheds?: AcademicScheduleCreateNestedManyWithoutTenantInput
    attendances?: AttendanceCreateNestedManyWithoutTenantInput
    grades?: GradeCreateNestedManyWithoutTenantInput
    ppdbRegistrations?: PpdbRegistrationCreateNestedManyWithoutTenantInput
    ppdbDocuments?: PpdbDocumentCreateNestedManyWithoutTenantInput
    ppdbExams?: PpdbExamCreateNestedManyWithoutTenantInput
    inventoryItems?: ItemCreateNestedManyWithoutTenantInput
    inventoryTransactions?: InventoryTransactionCreateNestedManyWithoutTenantInput
    suppliers?: SupplierCreateNestedManyWithoutTenantInput
    purchaseOrders?: PurchaseOrderCreateNestedManyWithoutTenantInput
    buildings?: BuildingCreateNestedManyWithoutTenantInput
    rooms?: RoomCreateNestedManyWithoutTenantInput
    roomAssignments?: RoomAssignmentCreateNestedManyWithoutTenantInput
    maintenanceTickets?: MaintenanceTicketCreateNestedManyWithoutTenantInput
  }

  export type TenantUncheckedCreateWithoutSantriInput = {
    id?: string
    name: string
    address?: string | null
    phone?: string | null
    adminUserId?: string | null
    timezone?: string
    plan?: string
    billingContact?: string | null
    status?: string
    settings?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutTenantInput
    wali?: WaliUncheckedCreateNestedManyWithoutTenantInput
    izin?: IzinUncheckedCreateNestedManyWithoutTenantInput
    catatanHarian?: CatatanHarianUncheckedCreateNestedManyWithoutTenantInput
    pengumuman?: PengumumanUncheckedCreateNestedManyWithoutTenantInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutTenantInput
    pelanggaran?: PelanggaranUncheckedCreateNestedManyWithoutTenantInput
    pembinaan?: PembinaanUncheckedCreateNestedManyWithoutTenantInput
    kunjungan?: KunjunganUncheckedCreateNestedManyWithoutTenantInput
    healthRecords?: HealthRecordUncheckedCreateNestedManyWithoutTenantInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutTenantInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutTenantInput
    webhookEvents?: WebhookEventUncheckedCreateNestedManyWithoutTenantInput
    tahfidz?: TahfidzUncheckedCreateNestedManyWithoutTenantInput
    mutabaah?: MutabaahUncheckedCreateNestedManyWithoutTenantInput
    wallets?: WalletUncheckedCreateNestedManyWithoutTenantInput
    employees?: EmployeeUncheckedCreateNestedManyWithoutTenantInput
    payrolls?: PayrollUncheckedCreateNestedManyWithoutTenantInput
    academicScheds?: AcademicScheduleUncheckedCreateNestedManyWithoutTenantInput
    attendances?: AttendanceUncheckedCreateNestedManyWithoutTenantInput
    grades?: GradeUncheckedCreateNestedManyWithoutTenantInput
    ppdbRegistrations?: PpdbRegistrationUncheckedCreateNestedManyWithoutTenantInput
    ppdbDocuments?: PpdbDocumentUncheckedCreateNestedManyWithoutTenantInput
    ppdbExams?: PpdbExamUncheckedCreateNestedManyWithoutTenantInput
    inventoryItems?: ItemUncheckedCreateNestedManyWithoutTenantInput
    inventoryTransactions?: InventoryTransactionUncheckedCreateNestedManyWithoutTenantInput
    suppliers?: SupplierUncheckedCreateNestedManyWithoutTenantInput
    purchaseOrders?: PurchaseOrderUncheckedCreateNestedManyWithoutTenantInput
    buildings?: BuildingUncheckedCreateNestedManyWithoutTenantInput
    rooms?: RoomUncheckedCreateNestedManyWithoutTenantInput
    roomAssignments?: RoomAssignmentUncheckedCreateNestedManyWithoutTenantInput
    maintenanceTickets?: MaintenanceTicketUncheckedCreateNestedManyWithoutTenantInput
  }

  export type TenantCreateOrConnectWithoutSantriInput = {
    where: TenantWhereUniqueInput
    create: XOR<TenantCreateWithoutSantriInput, TenantUncheckedCreateWithoutSantriInput>
  }

  export type SantriWaliCreateWithoutSantriInput = {
    isPrimary?: boolean
    wali: WaliCreateNestedOneWithoutSantrisInput
  }

  export type SantriWaliUncheckedCreateWithoutSantriInput = {
    waliId: string
    isPrimary?: boolean
  }

  export type SantriWaliCreateOrConnectWithoutSantriInput = {
    where: SantriWaliWhereUniqueInput
    create: XOR<SantriWaliCreateWithoutSantriInput, SantriWaliUncheckedCreateWithoutSantriInput>
  }

  export type SantriWaliCreateManySantriInputEnvelope = {
    data: SantriWaliCreateManySantriInput | SantriWaliCreateManySantriInput[]
  }

  export type IzinCreateWithoutSantriInput = {
    id?: string
    type: string
    reason: string
    startAt: Date | string
    endAt: Date | string
    status?: string
    requestedBy: string
    approvedBy?: string | null
    approvedAt?: Date | string | null
    qrCodeData?: string | null
    checkoutAt?: Date | string | null
    checkoutBy?: string | null
    checkinAt?: Date | string | null
    checkinBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutIzinInput
  }

  export type IzinUncheckedCreateWithoutSantriInput = {
    id?: string
    tenantId: string
    type: string
    reason: string
    startAt: Date | string
    endAt: Date | string
    status?: string
    requestedBy: string
    approvedBy?: string | null
    approvedAt?: Date | string | null
    qrCodeData?: string | null
    checkoutAt?: Date | string | null
    checkoutBy?: string | null
    checkinAt?: Date | string | null
    checkinBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type IzinCreateOrConnectWithoutSantriInput = {
    where: IzinWhereUniqueInput
    create: XOR<IzinCreateWithoutSantriInput, IzinUncheckedCreateWithoutSantriInput>
  }

  export type IzinCreateManySantriInputEnvelope = {
    data: IzinCreateManySantriInput | IzinCreateManySantriInput[]
  }

  export type CatatanHarianCreateWithoutSantriInput = {
    id?: string
    authorId: string
    date?: Date | string
    content: string
    category: string
    attachments?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutCatatanHarianInput
  }

  export type CatatanHarianUncheckedCreateWithoutSantriInput = {
    id?: string
    tenantId: string
    authorId: string
    date?: Date | string
    content: string
    category: string
    attachments?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CatatanHarianCreateOrConnectWithoutSantriInput = {
    where: CatatanHarianWhereUniqueInput
    create: XOR<CatatanHarianCreateWithoutSantriInput, CatatanHarianUncheckedCreateWithoutSantriInput>
  }

  export type CatatanHarianCreateManySantriInputEnvelope = {
    data: CatatanHarianCreateManySantriInput | CatatanHarianCreateManySantriInput[]
  }

  export type InvoiceCreateWithoutSantriInput = {
    id?: string
    amountDue: number
    dueDate: Date | string
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutInvoicesInput
    lines?: InvoiceLineCreateNestedManyWithoutInvoiceInput
    payments?: PaymentCreateNestedManyWithoutInvoiceInput
  }

  export type InvoiceUncheckedCreateWithoutSantriInput = {
    id?: string
    tenantId: string
    amountDue: number
    dueDate: Date | string
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    lines?: InvoiceLineUncheckedCreateNestedManyWithoutInvoiceInput
    payments?: PaymentUncheckedCreateNestedManyWithoutInvoiceInput
  }

  export type InvoiceCreateOrConnectWithoutSantriInput = {
    where: InvoiceWhereUniqueInput
    create: XOR<InvoiceCreateWithoutSantriInput, InvoiceUncheckedCreateWithoutSantriInput>
  }

  export type InvoiceCreateManySantriInputEnvelope = {
    data: InvoiceCreateManySantriInput | InvoiceCreateManySantriInput[]
  }

  export type PelanggaranCreateWithoutSantriInput = {
    id?: string
    recordedBy: string
    category: string
    severity: number
    points?: number
    description: string
    date?: Date | string
    resolved?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutPelanggaranInput
  }

  export type PelanggaranUncheckedCreateWithoutSantriInput = {
    id?: string
    tenantId: string
    recordedBy: string
    category: string
    severity: number
    points?: number
    description: string
    date?: Date | string
    resolved?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PelanggaranCreateOrConnectWithoutSantriInput = {
    where: PelanggaranWhereUniqueInput
    create: XOR<PelanggaranCreateWithoutSantriInput, PelanggaranUncheckedCreateWithoutSantriInput>
  }

  export type PelanggaranCreateManySantriInputEnvelope = {
    data: PelanggaranCreateManySantriInput | PelanggaranCreateManySantriInput[]
  }

  export type PembinaanCreateWithoutSantriInput = {
    id?: string
    plan: string
    targetDate: Date | string
    status?: string
    assignedTo: string
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutPembinaanInput
  }

  export type PembinaanUncheckedCreateWithoutSantriInput = {
    id?: string
    tenantId: string
    plan: string
    targetDate: Date | string
    status?: string
    assignedTo: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PembinaanCreateOrConnectWithoutSantriInput = {
    where: PembinaanWhereUniqueInput
    create: XOR<PembinaanCreateWithoutSantriInput, PembinaanUncheckedCreateWithoutSantriInput>
  }

  export type PembinaanCreateManySantriInputEnvelope = {
    data: PembinaanCreateManySantriInput | PembinaanCreateManySantriInput[]
  }

  export type KunjunganCreateWithoutSantriInput = {
    id?: string
    scheduledAt: Date | string
    slot: string
    visitorLimit?: number
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutKunjunganInput
    tamu?: TamuCreateNestedManyWithoutKunjunganInput
  }

  export type KunjunganUncheckedCreateWithoutSantriInput = {
    id?: string
    tenantId: string
    scheduledAt: Date | string
    slot: string
    visitorLimit?: number
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    tamu?: TamuUncheckedCreateNestedManyWithoutKunjunganInput
  }

  export type KunjunganCreateOrConnectWithoutSantriInput = {
    where: KunjunganWhereUniqueInput
    create: XOR<KunjunganCreateWithoutSantriInput, KunjunganUncheckedCreateWithoutSantriInput>
  }

  export type KunjunganCreateManySantriInputEnvelope = {
    data: KunjunganCreateManySantriInput | KunjunganCreateManySantriInput[]
  }

  export type HealthRecordCreateWithoutSantriInput = {
    id?: string
    recordedBy: string
    symptoms: string
    diagnosis?: string | null
    actionTaken?: string | null
    referred?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutHealthRecordsInput
  }

  export type HealthRecordUncheckedCreateWithoutSantriInput = {
    id?: string
    tenantId: string
    recordedBy: string
    symptoms: string
    diagnosis?: string | null
    actionTaken?: string | null
    referred?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type HealthRecordCreateOrConnectWithoutSantriInput = {
    where: HealthRecordWhereUniqueInput
    create: XOR<HealthRecordCreateWithoutSantriInput, HealthRecordUncheckedCreateWithoutSantriInput>
  }

  export type HealthRecordCreateManySantriInputEnvelope = {
    data: HealthRecordCreateManySantriInput | HealthRecordCreateManySantriInput[]
  }

  export type MedicationCreateWithoutSantriInput = {
    id?: string
    medicineName: string
    dose: string
    schedule: string
    givenBy?: string | null
    givenAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MedicationUncheckedCreateWithoutSantriInput = {
    id?: string
    medicineName: string
    dose: string
    schedule: string
    givenBy?: string | null
    givenAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MedicationCreateOrConnectWithoutSantriInput = {
    where: MedicationWhereUniqueInput
    create: XOR<MedicationCreateWithoutSantriInput, MedicationUncheckedCreateWithoutSantriInput>
  }

  export type MedicationCreateManySantriInputEnvelope = {
    data: MedicationCreateManySantriInput | MedicationCreateManySantriInput[]
  }

  export type TahfidzCreateWithoutSantriInput = {
    id?: string
    surah: string
    ayat?: string | null
    type?: string
    grade?: string | null
    notes?: string | null
    recordedBy: string
    date?: Date | string
    createdAt?: Date | string
    tenant: TenantCreateNestedOneWithoutTahfidzInput
  }

  export type TahfidzUncheckedCreateWithoutSantriInput = {
    id?: string
    tenantId: string
    surah: string
    ayat?: string | null
    type?: string
    grade?: string | null
    notes?: string | null
    recordedBy: string
    date?: Date | string
    createdAt?: Date | string
  }

  export type TahfidzCreateOrConnectWithoutSantriInput = {
    where: TahfidzWhereUniqueInput
    create: XOR<TahfidzCreateWithoutSantriInput, TahfidzUncheckedCreateWithoutSantriInput>
  }

  export type TahfidzCreateManySantriInputEnvelope = {
    data: TahfidzCreateManySantriInput | TahfidzCreateManySantriInput[]
  }

  export type MutabaahCreateWithoutSantriInput = {
    id?: string
    date?: Date | string
    sholatWajib?: boolean
    tahajud?: boolean
    dhuha?: boolean
    puasaSunnah?: boolean
    bacaQuran?: boolean
    notes?: string | null
    recordedBy?: string | null
    createdAt?: Date | string
    tenant: TenantCreateNestedOneWithoutMutabaahInput
  }

  export type MutabaahUncheckedCreateWithoutSantriInput = {
    id?: string
    tenantId: string
    date?: Date | string
    sholatWajib?: boolean
    tahajud?: boolean
    dhuha?: boolean
    puasaSunnah?: boolean
    bacaQuran?: boolean
    notes?: string | null
    recordedBy?: string | null
    createdAt?: Date | string
  }

  export type MutabaahCreateOrConnectWithoutSantriInput = {
    where: MutabaahWhereUniqueInput
    create: XOR<MutabaahCreateWithoutSantriInput, MutabaahUncheckedCreateWithoutSantriInput>
  }

  export type MutabaahCreateManySantriInputEnvelope = {
    data: MutabaahCreateManySantriInput | MutabaahCreateManySantriInput[]
  }

  export type WalletCreateWithoutSantriInput = {
    id?: string
    balance?: number
    pin?: string | null
    isActive?: boolean
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutWalletsInput
    transactions?: WalletTransactionCreateNestedManyWithoutWalletInput
  }

  export type WalletUncheckedCreateWithoutSantriInput = {
    id?: string
    tenantId: string
    balance?: number
    pin?: string | null
    isActive?: boolean
    updatedAt?: Date | string
    transactions?: WalletTransactionUncheckedCreateNestedManyWithoutWalletInput
  }

  export type WalletCreateOrConnectWithoutSantriInput = {
    where: WalletWhereUniqueInput
    create: XOR<WalletCreateWithoutSantriInput, WalletUncheckedCreateWithoutSantriInput>
  }

  export type AttendanceCreateWithoutSantriInput = {
    id?: string
    scheduleId?: string | null
    date?: Date | string
    status: string
    notes?: string | null
    recordedBy?: string | null
    createdAt?: Date | string
    tenant: TenantCreateNestedOneWithoutAttendancesInput
  }

  export type AttendanceUncheckedCreateWithoutSantriInput = {
    id?: string
    tenantId: string
    scheduleId?: string | null
    date?: Date | string
    status: string
    notes?: string | null
    recordedBy?: string | null
    createdAt?: Date | string
  }

  export type AttendanceCreateOrConnectWithoutSantriInput = {
    where: AttendanceWhereUniqueInput
    create: XOR<AttendanceCreateWithoutSantriInput, AttendanceUncheckedCreateWithoutSantriInput>
  }

  export type AttendanceCreateManySantriInputEnvelope = {
    data: AttendanceCreateManySantriInput | AttendanceCreateManySantriInput[]
  }

  export type GradeCreateWithoutSantriInput = {
    id?: string
    subject: string
    semester: string
    academicYear: string
    type: string
    score: number
    notes?: string | null
    createdAt?: Date | string
    tenant: TenantCreateNestedOneWithoutGradesInput
  }

  export type GradeUncheckedCreateWithoutSantriInput = {
    id?: string
    tenantId: string
    subject: string
    semester: string
    academicYear: string
    type: string
    score: number
    notes?: string | null
    createdAt?: Date | string
  }

  export type GradeCreateOrConnectWithoutSantriInput = {
    where: GradeWhereUniqueInput
    create: XOR<GradeCreateWithoutSantriInput, GradeUncheckedCreateWithoutSantriInput>
  }

  export type GradeCreateManySantriInputEnvelope = {
    data: GradeCreateManySantriInput | GradeCreateManySantriInput[]
  }

  export type TenantUpsertWithoutSantriInput = {
    update: XOR<TenantUpdateWithoutSantriInput, TenantUncheckedUpdateWithoutSantriInput>
    create: XOR<TenantCreateWithoutSantriInput, TenantUncheckedCreateWithoutSantriInput>
    where?: TenantWhereInput
  }

  export type TenantUpdateToOneWithWhereWithoutSantriInput = {
    where?: TenantWhereInput
    data: XOR<TenantUpdateWithoutSantriInput, TenantUncheckedUpdateWithoutSantriInput>
  }

  export type TenantUpdateWithoutSantriInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    adminUserId?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    plan?: StringFieldUpdateOperationsInput | string
    billingContact?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    settings?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutTenantNestedInput
    wali?: WaliUpdateManyWithoutTenantNestedInput
    izin?: IzinUpdateManyWithoutTenantNestedInput
    catatanHarian?: CatatanHarianUpdateManyWithoutTenantNestedInput
    pengumuman?: PengumumanUpdateManyWithoutTenantNestedInput
    invoices?: InvoiceUpdateManyWithoutTenantNestedInput
    pelanggaran?: PelanggaranUpdateManyWithoutTenantNestedInput
    pembinaan?: PembinaanUpdateManyWithoutTenantNestedInput
    kunjungan?: KunjunganUpdateManyWithoutTenantNestedInput
    healthRecords?: HealthRecordUpdateManyWithoutTenantNestedInput
    auditLogs?: AuditLogUpdateManyWithoutTenantNestedInput
    notifications?: NotificationUpdateManyWithoutTenantNestedInput
    webhookEvents?: WebhookEventUpdateManyWithoutTenantNestedInput
    tahfidz?: TahfidzUpdateManyWithoutTenantNestedInput
    mutabaah?: MutabaahUpdateManyWithoutTenantNestedInput
    wallets?: WalletUpdateManyWithoutTenantNestedInput
    employees?: EmployeeUpdateManyWithoutTenantNestedInput
    payrolls?: PayrollUpdateManyWithoutTenantNestedInput
    academicScheds?: AcademicScheduleUpdateManyWithoutTenantNestedInput
    attendances?: AttendanceUpdateManyWithoutTenantNestedInput
    grades?: GradeUpdateManyWithoutTenantNestedInput
    ppdbRegistrations?: PpdbRegistrationUpdateManyWithoutTenantNestedInput
    ppdbDocuments?: PpdbDocumentUpdateManyWithoutTenantNestedInput
    ppdbExams?: PpdbExamUpdateManyWithoutTenantNestedInput
    inventoryItems?: ItemUpdateManyWithoutTenantNestedInput
    inventoryTransactions?: InventoryTransactionUpdateManyWithoutTenantNestedInput
    suppliers?: SupplierUpdateManyWithoutTenantNestedInput
    purchaseOrders?: PurchaseOrderUpdateManyWithoutTenantNestedInput
    buildings?: BuildingUpdateManyWithoutTenantNestedInput
    rooms?: RoomUpdateManyWithoutTenantNestedInput
    roomAssignments?: RoomAssignmentUpdateManyWithoutTenantNestedInput
    maintenanceTickets?: MaintenanceTicketUpdateManyWithoutTenantNestedInput
  }

  export type TenantUncheckedUpdateWithoutSantriInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    adminUserId?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    plan?: StringFieldUpdateOperationsInput | string
    billingContact?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    settings?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutTenantNestedInput
    wali?: WaliUncheckedUpdateManyWithoutTenantNestedInput
    izin?: IzinUncheckedUpdateManyWithoutTenantNestedInput
    catatanHarian?: CatatanHarianUncheckedUpdateManyWithoutTenantNestedInput
    pengumuman?: PengumumanUncheckedUpdateManyWithoutTenantNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutTenantNestedInput
    pelanggaran?: PelanggaranUncheckedUpdateManyWithoutTenantNestedInput
    pembinaan?: PembinaanUncheckedUpdateManyWithoutTenantNestedInput
    kunjungan?: KunjunganUncheckedUpdateManyWithoutTenantNestedInput
    healthRecords?: HealthRecordUncheckedUpdateManyWithoutTenantNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutTenantNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutTenantNestedInput
    webhookEvents?: WebhookEventUncheckedUpdateManyWithoutTenantNestedInput
    tahfidz?: TahfidzUncheckedUpdateManyWithoutTenantNestedInput
    mutabaah?: MutabaahUncheckedUpdateManyWithoutTenantNestedInput
    wallets?: WalletUncheckedUpdateManyWithoutTenantNestedInput
    employees?: EmployeeUncheckedUpdateManyWithoutTenantNestedInput
    payrolls?: PayrollUncheckedUpdateManyWithoutTenantNestedInput
    academicScheds?: AcademicScheduleUncheckedUpdateManyWithoutTenantNestedInput
    attendances?: AttendanceUncheckedUpdateManyWithoutTenantNestedInput
    grades?: GradeUncheckedUpdateManyWithoutTenantNestedInput
    ppdbRegistrations?: PpdbRegistrationUncheckedUpdateManyWithoutTenantNestedInput
    ppdbDocuments?: PpdbDocumentUncheckedUpdateManyWithoutTenantNestedInput
    ppdbExams?: PpdbExamUncheckedUpdateManyWithoutTenantNestedInput
    inventoryItems?: ItemUncheckedUpdateManyWithoutTenantNestedInput
    inventoryTransactions?: InventoryTransactionUncheckedUpdateManyWithoutTenantNestedInput
    suppliers?: SupplierUncheckedUpdateManyWithoutTenantNestedInput
    purchaseOrders?: PurchaseOrderUncheckedUpdateManyWithoutTenantNestedInput
    buildings?: BuildingUncheckedUpdateManyWithoutTenantNestedInput
    rooms?: RoomUncheckedUpdateManyWithoutTenantNestedInput
    roomAssignments?: RoomAssignmentUncheckedUpdateManyWithoutTenantNestedInput
    maintenanceTickets?: MaintenanceTicketUncheckedUpdateManyWithoutTenantNestedInput
  }

  export type SantriWaliUpsertWithWhereUniqueWithoutSantriInput = {
    where: SantriWaliWhereUniqueInput
    update: XOR<SantriWaliUpdateWithoutSantriInput, SantriWaliUncheckedUpdateWithoutSantriInput>
    create: XOR<SantriWaliCreateWithoutSantriInput, SantriWaliUncheckedCreateWithoutSantriInput>
  }

  export type SantriWaliUpdateWithWhereUniqueWithoutSantriInput = {
    where: SantriWaliWhereUniqueInput
    data: XOR<SantriWaliUpdateWithoutSantriInput, SantriWaliUncheckedUpdateWithoutSantriInput>
  }

  export type SantriWaliUpdateManyWithWhereWithoutSantriInput = {
    where: SantriWaliScalarWhereInput
    data: XOR<SantriWaliUpdateManyMutationInput, SantriWaliUncheckedUpdateManyWithoutSantriInput>
  }

  export type SantriWaliScalarWhereInput = {
    AND?: SantriWaliScalarWhereInput | SantriWaliScalarWhereInput[]
    OR?: SantriWaliScalarWhereInput[]
    NOT?: SantriWaliScalarWhereInput | SantriWaliScalarWhereInput[]
    santriId?: StringFilter<"SantriWali"> | string
    waliId?: StringFilter<"SantriWali"> | string
    isPrimary?: BoolFilter<"SantriWali"> | boolean
  }

  export type IzinUpsertWithWhereUniqueWithoutSantriInput = {
    where: IzinWhereUniqueInput
    update: XOR<IzinUpdateWithoutSantriInput, IzinUncheckedUpdateWithoutSantriInput>
    create: XOR<IzinCreateWithoutSantriInput, IzinUncheckedCreateWithoutSantriInput>
  }

  export type IzinUpdateWithWhereUniqueWithoutSantriInput = {
    where: IzinWhereUniqueInput
    data: XOR<IzinUpdateWithoutSantriInput, IzinUncheckedUpdateWithoutSantriInput>
  }

  export type IzinUpdateManyWithWhereWithoutSantriInput = {
    where: IzinScalarWhereInput
    data: XOR<IzinUpdateManyMutationInput, IzinUncheckedUpdateManyWithoutSantriInput>
  }

  export type CatatanHarianUpsertWithWhereUniqueWithoutSantriInput = {
    where: CatatanHarianWhereUniqueInput
    update: XOR<CatatanHarianUpdateWithoutSantriInput, CatatanHarianUncheckedUpdateWithoutSantriInput>
    create: XOR<CatatanHarianCreateWithoutSantriInput, CatatanHarianUncheckedCreateWithoutSantriInput>
  }

  export type CatatanHarianUpdateWithWhereUniqueWithoutSantriInput = {
    where: CatatanHarianWhereUniqueInput
    data: XOR<CatatanHarianUpdateWithoutSantriInput, CatatanHarianUncheckedUpdateWithoutSantriInput>
  }

  export type CatatanHarianUpdateManyWithWhereWithoutSantriInput = {
    where: CatatanHarianScalarWhereInput
    data: XOR<CatatanHarianUpdateManyMutationInput, CatatanHarianUncheckedUpdateManyWithoutSantriInput>
  }

  export type InvoiceUpsertWithWhereUniqueWithoutSantriInput = {
    where: InvoiceWhereUniqueInput
    update: XOR<InvoiceUpdateWithoutSantriInput, InvoiceUncheckedUpdateWithoutSantriInput>
    create: XOR<InvoiceCreateWithoutSantriInput, InvoiceUncheckedCreateWithoutSantriInput>
  }

  export type InvoiceUpdateWithWhereUniqueWithoutSantriInput = {
    where: InvoiceWhereUniqueInput
    data: XOR<InvoiceUpdateWithoutSantriInput, InvoiceUncheckedUpdateWithoutSantriInput>
  }

  export type InvoiceUpdateManyWithWhereWithoutSantriInput = {
    where: InvoiceScalarWhereInput
    data: XOR<InvoiceUpdateManyMutationInput, InvoiceUncheckedUpdateManyWithoutSantriInput>
  }

  export type PelanggaranUpsertWithWhereUniqueWithoutSantriInput = {
    where: PelanggaranWhereUniqueInput
    update: XOR<PelanggaranUpdateWithoutSantriInput, PelanggaranUncheckedUpdateWithoutSantriInput>
    create: XOR<PelanggaranCreateWithoutSantriInput, PelanggaranUncheckedCreateWithoutSantriInput>
  }

  export type PelanggaranUpdateWithWhereUniqueWithoutSantriInput = {
    where: PelanggaranWhereUniqueInput
    data: XOR<PelanggaranUpdateWithoutSantriInput, PelanggaranUncheckedUpdateWithoutSantriInput>
  }

  export type PelanggaranUpdateManyWithWhereWithoutSantriInput = {
    where: PelanggaranScalarWhereInput
    data: XOR<PelanggaranUpdateManyMutationInput, PelanggaranUncheckedUpdateManyWithoutSantriInput>
  }

  export type PembinaanUpsertWithWhereUniqueWithoutSantriInput = {
    where: PembinaanWhereUniqueInput
    update: XOR<PembinaanUpdateWithoutSantriInput, PembinaanUncheckedUpdateWithoutSantriInput>
    create: XOR<PembinaanCreateWithoutSantriInput, PembinaanUncheckedCreateWithoutSantriInput>
  }

  export type PembinaanUpdateWithWhereUniqueWithoutSantriInput = {
    where: PembinaanWhereUniqueInput
    data: XOR<PembinaanUpdateWithoutSantriInput, PembinaanUncheckedUpdateWithoutSantriInput>
  }

  export type PembinaanUpdateManyWithWhereWithoutSantriInput = {
    where: PembinaanScalarWhereInput
    data: XOR<PembinaanUpdateManyMutationInput, PembinaanUncheckedUpdateManyWithoutSantriInput>
  }

  export type KunjunganUpsertWithWhereUniqueWithoutSantriInput = {
    where: KunjunganWhereUniqueInput
    update: XOR<KunjunganUpdateWithoutSantriInput, KunjunganUncheckedUpdateWithoutSantriInput>
    create: XOR<KunjunganCreateWithoutSantriInput, KunjunganUncheckedCreateWithoutSantriInput>
  }

  export type KunjunganUpdateWithWhereUniqueWithoutSantriInput = {
    where: KunjunganWhereUniqueInput
    data: XOR<KunjunganUpdateWithoutSantriInput, KunjunganUncheckedUpdateWithoutSantriInput>
  }

  export type KunjunganUpdateManyWithWhereWithoutSantriInput = {
    where: KunjunganScalarWhereInput
    data: XOR<KunjunganUpdateManyMutationInput, KunjunganUncheckedUpdateManyWithoutSantriInput>
  }

  export type HealthRecordUpsertWithWhereUniqueWithoutSantriInput = {
    where: HealthRecordWhereUniqueInput
    update: XOR<HealthRecordUpdateWithoutSantriInput, HealthRecordUncheckedUpdateWithoutSantriInput>
    create: XOR<HealthRecordCreateWithoutSantriInput, HealthRecordUncheckedCreateWithoutSantriInput>
  }

  export type HealthRecordUpdateWithWhereUniqueWithoutSantriInput = {
    where: HealthRecordWhereUniqueInput
    data: XOR<HealthRecordUpdateWithoutSantriInput, HealthRecordUncheckedUpdateWithoutSantriInput>
  }

  export type HealthRecordUpdateManyWithWhereWithoutSantriInput = {
    where: HealthRecordScalarWhereInput
    data: XOR<HealthRecordUpdateManyMutationInput, HealthRecordUncheckedUpdateManyWithoutSantriInput>
  }

  export type MedicationUpsertWithWhereUniqueWithoutSantriInput = {
    where: MedicationWhereUniqueInput
    update: XOR<MedicationUpdateWithoutSantriInput, MedicationUncheckedUpdateWithoutSantriInput>
    create: XOR<MedicationCreateWithoutSantriInput, MedicationUncheckedCreateWithoutSantriInput>
  }

  export type MedicationUpdateWithWhereUniqueWithoutSantriInput = {
    where: MedicationWhereUniqueInput
    data: XOR<MedicationUpdateWithoutSantriInput, MedicationUncheckedUpdateWithoutSantriInput>
  }

  export type MedicationUpdateManyWithWhereWithoutSantriInput = {
    where: MedicationScalarWhereInput
    data: XOR<MedicationUpdateManyMutationInput, MedicationUncheckedUpdateManyWithoutSantriInput>
  }

  export type MedicationScalarWhereInput = {
    AND?: MedicationScalarWhereInput | MedicationScalarWhereInput[]
    OR?: MedicationScalarWhereInput[]
    NOT?: MedicationScalarWhereInput | MedicationScalarWhereInput[]
    id?: StringFilter<"Medication"> | string
    santriId?: StringFilter<"Medication"> | string
    medicineName?: StringFilter<"Medication"> | string
    dose?: StringFilter<"Medication"> | string
    schedule?: StringFilter<"Medication"> | string
    givenBy?: StringNullableFilter<"Medication"> | string | null
    givenAt?: DateTimeNullableFilter<"Medication"> | Date | string | null
    createdAt?: DateTimeFilter<"Medication"> | Date | string
    updatedAt?: DateTimeFilter<"Medication"> | Date | string
  }

  export type TahfidzUpsertWithWhereUniqueWithoutSantriInput = {
    where: TahfidzWhereUniqueInput
    update: XOR<TahfidzUpdateWithoutSantriInput, TahfidzUncheckedUpdateWithoutSantriInput>
    create: XOR<TahfidzCreateWithoutSantriInput, TahfidzUncheckedCreateWithoutSantriInput>
  }

  export type TahfidzUpdateWithWhereUniqueWithoutSantriInput = {
    where: TahfidzWhereUniqueInput
    data: XOR<TahfidzUpdateWithoutSantriInput, TahfidzUncheckedUpdateWithoutSantriInput>
  }

  export type TahfidzUpdateManyWithWhereWithoutSantriInput = {
    where: TahfidzScalarWhereInput
    data: XOR<TahfidzUpdateManyMutationInput, TahfidzUncheckedUpdateManyWithoutSantriInput>
  }

  export type MutabaahUpsertWithWhereUniqueWithoutSantriInput = {
    where: MutabaahWhereUniqueInput
    update: XOR<MutabaahUpdateWithoutSantriInput, MutabaahUncheckedUpdateWithoutSantriInput>
    create: XOR<MutabaahCreateWithoutSantriInput, MutabaahUncheckedCreateWithoutSantriInput>
  }

  export type MutabaahUpdateWithWhereUniqueWithoutSantriInput = {
    where: MutabaahWhereUniqueInput
    data: XOR<MutabaahUpdateWithoutSantriInput, MutabaahUncheckedUpdateWithoutSantriInput>
  }

  export type MutabaahUpdateManyWithWhereWithoutSantriInput = {
    where: MutabaahScalarWhereInput
    data: XOR<MutabaahUpdateManyMutationInput, MutabaahUncheckedUpdateManyWithoutSantriInput>
  }

  export type WalletUpsertWithoutSantriInput = {
    update: XOR<WalletUpdateWithoutSantriInput, WalletUncheckedUpdateWithoutSantriInput>
    create: XOR<WalletCreateWithoutSantriInput, WalletUncheckedCreateWithoutSantriInput>
    where?: WalletWhereInput
  }

  export type WalletUpdateToOneWithWhereWithoutSantriInput = {
    where?: WalletWhereInput
    data: XOR<WalletUpdateWithoutSantriInput, WalletUncheckedUpdateWithoutSantriInput>
  }

  export type WalletUpdateWithoutSantriInput = {
    id?: StringFieldUpdateOperationsInput | string
    balance?: FloatFieldUpdateOperationsInput | number
    pin?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutWalletsNestedInput
    transactions?: WalletTransactionUpdateManyWithoutWalletNestedInput
  }

  export type WalletUncheckedUpdateWithoutSantriInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    balance?: FloatFieldUpdateOperationsInput | number
    pin?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transactions?: WalletTransactionUncheckedUpdateManyWithoutWalletNestedInput
  }

  export type AttendanceUpsertWithWhereUniqueWithoutSantriInput = {
    where: AttendanceWhereUniqueInput
    update: XOR<AttendanceUpdateWithoutSantriInput, AttendanceUncheckedUpdateWithoutSantriInput>
    create: XOR<AttendanceCreateWithoutSantriInput, AttendanceUncheckedCreateWithoutSantriInput>
  }

  export type AttendanceUpdateWithWhereUniqueWithoutSantriInput = {
    where: AttendanceWhereUniqueInput
    data: XOR<AttendanceUpdateWithoutSantriInput, AttendanceUncheckedUpdateWithoutSantriInput>
  }

  export type AttendanceUpdateManyWithWhereWithoutSantriInput = {
    where: AttendanceScalarWhereInput
    data: XOR<AttendanceUpdateManyMutationInput, AttendanceUncheckedUpdateManyWithoutSantriInput>
  }

  export type GradeUpsertWithWhereUniqueWithoutSantriInput = {
    where: GradeWhereUniqueInput
    update: XOR<GradeUpdateWithoutSantriInput, GradeUncheckedUpdateWithoutSantriInput>
    create: XOR<GradeCreateWithoutSantriInput, GradeUncheckedCreateWithoutSantriInput>
  }

  export type GradeUpdateWithWhereUniqueWithoutSantriInput = {
    where: GradeWhereUniqueInput
    data: XOR<GradeUpdateWithoutSantriInput, GradeUncheckedUpdateWithoutSantriInput>
  }

  export type GradeUpdateManyWithWhereWithoutSantriInput = {
    where: GradeScalarWhereInput
    data: XOR<GradeUpdateManyMutationInput, GradeUncheckedUpdateManyWithoutSantriInput>
  }

  export type TenantCreateWithoutWaliInput = {
    id?: string
    name: string
    address?: string | null
    phone?: string | null
    adminUserId?: string | null
    timezone?: string
    plan?: string
    billingContact?: string | null
    status?: string
    settings?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutTenantInput
    santri?: SantriCreateNestedManyWithoutTenantInput
    izin?: IzinCreateNestedManyWithoutTenantInput
    catatanHarian?: CatatanHarianCreateNestedManyWithoutTenantInput
    pengumuman?: PengumumanCreateNestedManyWithoutTenantInput
    invoices?: InvoiceCreateNestedManyWithoutTenantInput
    pelanggaran?: PelanggaranCreateNestedManyWithoutTenantInput
    pembinaan?: PembinaanCreateNestedManyWithoutTenantInput
    kunjungan?: KunjunganCreateNestedManyWithoutTenantInput
    healthRecords?: HealthRecordCreateNestedManyWithoutTenantInput
    auditLogs?: AuditLogCreateNestedManyWithoutTenantInput
    notifications?: NotificationCreateNestedManyWithoutTenantInput
    webhookEvents?: WebhookEventCreateNestedManyWithoutTenantInput
    tahfidz?: TahfidzCreateNestedManyWithoutTenantInput
    mutabaah?: MutabaahCreateNestedManyWithoutTenantInput
    wallets?: WalletCreateNestedManyWithoutTenantInput
    employees?: EmployeeCreateNestedManyWithoutTenantInput
    payrolls?: PayrollCreateNestedManyWithoutTenantInput
    academicScheds?: AcademicScheduleCreateNestedManyWithoutTenantInput
    attendances?: AttendanceCreateNestedManyWithoutTenantInput
    grades?: GradeCreateNestedManyWithoutTenantInput
    ppdbRegistrations?: PpdbRegistrationCreateNestedManyWithoutTenantInput
    ppdbDocuments?: PpdbDocumentCreateNestedManyWithoutTenantInput
    ppdbExams?: PpdbExamCreateNestedManyWithoutTenantInput
    inventoryItems?: ItemCreateNestedManyWithoutTenantInput
    inventoryTransactions?: InventoryTransactionCreateNestedManyWithoutTenantInput
    suppliers?: SupplierCreateNestedManyWithoutTenantInput
    purchaseOrders?: PurchaseOrderCreateNestedManyWithoutTenantInput
    buildings?: BuildingCreateNestedManyWithoutTenantInput
    rooms?: RoomCreateNestedManyWithoutTenantInput
    roomAssignments?: RoomAssignmentCreateNestedManyWithoutTenantInput
    maintenanceTickets?: MaintenanceTicketCreateNestedManyWithoutTenantInput
  }

  export type TenantUncheckedCreateWithoutWaliInput = {
    id?: string
    name: string
    address?: string | null
    phone?: string | null
    adminUserId?: string | null
    timezone?: string
    plan?: string
    billingContact?: string | null
    status?: string
    settings?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutTenantInput
    santri?: SantriUncheckedCreateNestedManyWithoutTenantInput
    izin?: IzinUncheckedCreateNestedManyWithoutTenantInput
    catatanHarian?: CatatanHarianUncheckedCreateNestedManyWithoutTenantInput
    pengumuman?: PengumumanUncheckedCreateNestedManyWithoutTenantInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutTenantInput
    pelanggaran?: PelanggaranUncheckedCreateNestedManyWithoutTenantInput
    pembinaan?: PembinaanUncheckedCreateNestedManyWithoutTenantInput
    kunjungan?: KunjunganUncheckedCreateNestedManyWithoutTenantInput
    healthRecords?: HealthRecordUncheckedCreateNestedManyWithoutTenantInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutTenantInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutTenantInput
    webhookEvents?: WebhookEventUncheckedCreateNestedManyWithoutTenantInput
    tahfidz?: TahfidzUncheckedCreateNestedManyWithoutTenantInput
    mutabaah?: MutabaahUncheckedCreateNestedManyWithoutTenantInput
    wallets?: WalletUncheckedCreateNestedManyWithoutTenantInput
    employees?: EmployeeUncheckedCreateNestedManyWithoutTenantInput
    payrolls?: PayrollUncheckedCreateNestedManyWithoutTenantInput
    academicScheds?: AcademicScheduleUncheckedCreateNestedManyWithoutTenantInput
    attendances?: AttendanceUncheckedCreateNestedManyWithoutTenantInput
    grades?: GradeUncheckedCreateNestedManyWithoutTenantInput
    ppdbRegistrations?: PpdbRegistrationUncheckedCreateNestedManyWithoutTenantInput
    ppdbDocuments?: PpdbDocumentUncheckedCreateNestedManyWithoutTenantInput
    ppdbExams?: PpdbExamUncheckedCreateNestedManyWithoutTenantInput
    inventoryItems?: ItemUncheckedCreateNestedManyWithoutTenantInput
    inventoryTransactions?: InventoryTransactionUncheckedCreateNestedManyWithoutTenantInput
    suppliers?: SupplierUncheckedCreateNestedManyWithoutTenantInput
    purchaseOrders?: PurchaseOrderUncheckedCreateNestedManyWithoutTenantInput
    buildings?: BuildingUncheckedCreateNestedManyWithoutTenantInput
    rooms?: RoomUncheckedCreateNestedManyWithoutTenantInput
    roomAssignments?: RoomAssignmentUncheckedCreateNestedManyWithoutTenantInput
    maintenanceTickets?: MaintenanceTicketUncheckedCreateNestedManyWithoutTenantInput
  }

  export type TenantCreateOrConnectWithoutWaliInput = {
    where: TenantWhereUniqueInput
    create: XOR<TenantCreateWithoutWaliInput, TenantUncheckedCreateWithoutWaliInput>
  }

  export type SantriWaliCreateWithoutWaliInput = {
    isPrimary?: boolean
    santri: SantriCreateNestedOneWithoutWalisInput
  }

  export type SantriWaliUncheckedCreateWithoutWaliInput = {
    santriId: string
    isPrimary?: boolean
  }

  export type SantriWaliCreateOrConnectWithoutWaliInput = {
    where: SantriWaliWhereUniqueInput
    create: XOR<SantriWaliCreateWithoutWaliInput, SantriWaliUncheckedCreateWithoutWaliInput>
  }

  export type SantriWaliCreateManyWaliInputEnvelope = {
    data: SantriWaliCreateManyWaliInput | SantriWaliCreateManyWaliInput[]
  }

  export type TenantUpsertWithoutWaliInput = {
    update: XOR<TenantUpdateWithoutWaliInput, TenantUncheckedUpdateWithoutWaliInput>
    create: XOR<TenantCreateWithoutWaliInput, TenantUncheckedCreateWithoutWaliInput>
    where?: TenantWhereInput
  }

  export type TenantUpdateToOneWithWhereWithoutWaliInput = {
    where?: TenantWhereInput
    data: XOR<TenantUpdateWithoutWaliInput, TenantUncheckedUpdateWithoutWaliInput>
  }

  export type TenantUpdateWithoutWaliInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    adminUserId?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    plan?: StringFieldUpdateOperationsInput | string
    billingContact?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    settings?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutTenantNestedInput
    santri?: SantriUpdateManyWithoutTenantNestedInput
    izin?: IzinUpdateManyWithoutTenantNestedInput
    catatanHarian?: CatatanHarianUpdateManyWithoutTenantNestedInput
    pengumuman?: PengumumanUpdateManyWithoutTenantNestedInput
    invoices?: InvoiceUpdateManyWithoutTenantNestedInput
    pelanggaran?: PelanggaranUpdateManyWithoutTenantNestedInput
    pembinaan?: PembinaanUpdateManyWithoutTenantNestedInput
    kunjungan?: KunjunganUpdateManyWithoutTenantNestedInput
    healthRecords?: HealthRecordUpdateManyWithoutTenantNestedInput
    auditLogs?: AuditLogUpdateManyWithoutTenantNestedInput
    notifications?: NotificationUpdateManyWithoutTenantNestedInput
    webhookEvents?: WebhookEventUpdateManyWithoutTenantNestedInput
    tahfidz?: TahfidzUpdateManyWithoutTenantNestedInput
    mutabaah?: MutabaahUpdateManyWithoutTenantNestedInput
    wallets?: WalletUpdateManyWithoutTenantNestedInput
    employees?: EmployeeUpdateManyWithoutTenantNestedInput
    payrolls?: PayrollUpdateManyWithoutTenantNestedInput
    academicScheds?: AcademicScheduleUpdateManyWithoutTenantNestedInput
    attendances?: AttendanceUpdateManyWithoutTenantNestedInput
    grades?: GradeUpdateManyWithoutTenantNestedInput
    ppdbRegistrations?: PpdbRegistrationUpdateManyWithoutTenantNestedInput
    ppdbDocuments?: PpdbDocumentUpdateManyWithoutTenantNestedInput
    ppdbExams?: PpdbExamUpdateManyWithoutTenantNestedInput
    inventoryItems?: ItemUpdateManyWithoutTenantNestedInput
    inventoryTransactions?: InventoryTransactionUpdateManyWithoutTenantNestedInput
    suppliers?: SupplierUpdateManyWithoutTenantNestedInput
    purchaseOrders?: PurchaseOrderUpdateManyWithoutTenantNestedInput
    buildings?: BuildingUpdateManyWithoutTenantNestedInput
    rooms?: RoomUpdateManyWithoutTenantNestedInput
    roomAssignments?: RoomAssignmentUpdateManyWithoutTenantNestedInput
    maintenanceTickets?: MaintenanceTicketUpdateManyWithoutTenantNestedInput
  }

  export type TenantUncheckedUpdateWithoutWaliInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    adminUserId?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    plan?: StringFieldUpdateOperationsInput | string
    billingContact?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    settings?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutTenantNestedInput
    santri?: SantriUncheckedUpdateManyWithoutTenantNestedInput
    izin?: IzinUncheckedUpdateManyWithoutTenantNestedInput
    catatanHarian?: CatatanHarianUncheckedUpdateManyWithoutTenantNestedInput
    pengumuman?: PengumumanUncheckedUpdateManyWithoutTenantNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutTenantNestedInput
    pelanggaran?: PelanggaranUncheckedUpdateManyWithoutTenantNestedInput
    pembinaan?: PembinaanUncheckedUpdateManyWithoutTenantNestedInput
    kunjungan?: KunjunganUncheckedUpdateManyWithoutTenantNestedInput
    healthRecords?: HealthRecordUncheckedUpdateManyWithoutTenantNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutTenantNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutTenantNestedInput
    webhookEvents?: WebhookEventUncheckedUpdateManyWithoutTenantNestedInput
    tahfidz?: TahfidzUncheckedUpdateManyWithoutTenantNestedInput
    mutabaah?: MutabaahUncheckedUpdateManyWithoutTenantNestedInput
    wallets?: WalletUncheckedUpdateManyWithoutTenantNestedInput
    employees?: EmployeeUncheckedUpdateManyWithoutTenantNestedInput
    payrolls?: PayrollUncheckedUpdateManyWithoutTenantNestedInput
    academicScheds?: AcademicScheduleUncheckedUpdateManyWithoutTenantNestedInput
    attendances?: AttendanceUncheckedUpdateManyWithoutTenantNestedInput
    grades?: GradeUncheckedUpdateManyWithoutTenantNestedInput
    ppdbRegistrations?: PpdbRegistrationUncheckedUpdateManyWithoutTenantNestedInput
    ppdbDocuments?: PpdbDocumentUncheckedUpdateManyWithoutTenantNestedInput
    ppdbExams?: PpdbExamUncheckedUpdateManyWithoutTenantNestedInput
    inventoryItems?: ItemUncheckedUpdateManyWithoutTenantNestedInput
    inventoryTransactions?: InventoryTransactionUncheckedUpdateManyWithoutTenantNestedInput
    suppliers?: SupplierUncheckedUpdateManyWithoutTenantNestedInput
    purchaseOrders?: PurchaseOrderUncheckedUpdateManyWithoutTenantNestedInput
    buildings?: BuildingUncheckedUpdateManyWithoutTenantNestedInput
    rooms?: RoomUncheckedUpdateManyWithoutTenantNestedInput
    roomAssignments?: RoomAssignmentUncheckedUpdateManyWithoutTenantNestedInput
    maintenanceTickets?: MaintenanceTicketUncheckedUpdateManyWithoutTenantNestedInput
  }

  export type SantriWaliUpsertWithWhereUniqueWithoutWaliInput = {
    where: SantriWaliWhereUniqueInput
    update: XOR<SantriWaliUpdateWithoutWaliInput, SantriWaliUncheckedUpdateWithoutWaliInput>
    create: XOR<SantriWaliCreateWithoutWaliInput, SantriWaliUncheckedCreateWithoutWaliInput>
  }

  export type SantriWaliUpdateWithWhereUniqueWithoutWaliInput = {
    where: SantriWaliWhereUniqueInput
    data: XOR<SantriWaliUpdateWithoutWaliInput, SantriWaliUncheckedUpdateWithoutWaliInput>
  }

  export type SantriWaliUpdateManyWithWhereWithoutWaliInput = {
    where: SantriWaliScalarWhereInput
    data: XOR<SantriWaliUpdateManyMutationInput, SantriWaliUncheckedUpdateManyWithoutWaliInput>
  }

  export type SantriCreateWithoutWalisInput = {
    id?: string
    nisn?: string | null
    name: string
    gender: string
    dob?: Date | string | null
    kelas?: string | null
    room?: string | null
    contact?: string | null
    address?: string | null
    photo?: string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutSantriInput
    izin?: IzinCreateNestedManyWithoutSantriInput
    catatanHarian?: CatatanHarianCreateNestedManyWithoutSantriInput
    invoices?: InvoiceCreateNestedManyWithoutSantriInput
    pelanggaran?: PelanggaranCreateNestedManyWithoutSantriInput
    pembinaan?: PembinaanCreateNestedManyWithoutSantriInput
    kunjungan?: KunjunganCreateNestedManyWithoutSantriInput
    healthRecords?: HealthRecordCreateNestedManyWithoutSantriInput
    medications?: MedicationCreateNestedManyWithoutSantriInput
    tahfidz?: TahfidzCreateNestedManyWithoutSantriInput
    mutabaah?: MutabaahCreateNestedManyWithoutSantriInput
    wallet?: WalletCreateNestedOneWithoutSantriInput
    attendances?: AttendanceCreateNestedManyWithoutSantriInput
    grades?: GradeCreateNestedManyWithoutSantriInput
  }

  export type SantriUncheckedCreateWithoutWalisInput = {
    id?: string
    tenantId: string
    nisn?: string | null
    name: string
    gender: string
    dob?: Date | string | null
    kelas?: string | null
    room?: string | null
    contact?: string | null
    address?: string | null
    photo?: string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    izin?: IzinUncheckedCreateNestedManyWithoutSantriInput
    catatanHarian?: CatatanHarianUncheckedCreateNestedManyWithoutSantriInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutSantriInput
    pelanggaran?: PelanggaranUncheckedCreateNestedManyWithoutSantriInput
    pembinaan?: PembinaanUncheckedCreateNestedManyWithoutSantriInput
    kunjungan?: KunjunganUncheckedCreateNestedManyWithoutSantriInput
    healthRecords?: HealthRecordUncheckedCreateNestedManyWithoutSantriInput
    medications?: MedicationUncheckedCreateNestedManyWithoutSantriInput
    tahfidz?: TahfidzUncheckedCreateNestedManyWithoutSantriInput
    mutabaah?: MutabaahUncheckedCreateNestedManyWithoutSantriInput
    wallet?: WalletUncheckedCreateNestedOneWithoutSantriInput
    attendances?: AttendanceUncheckedCreateNestedManyWithoutSantriInput
    grades?: GradeUncheckedCreateNestedManyWithoutSantriInput
  }

  export type SantriCreateOrConnectWithoutWalisInput = {
    where: SantriWhereUniqueInput
    create: XOR<SantriCreateWithoutWalisInput, SantriUncheckedCreateWithoutWalisInput>
  }

  export type WaliCreateWithoutSantrisInput = {
    id?: string
    name: string
    relation: string
    phone: string
    email?: string | null
    address?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutWaliInput
  }

  export type WaliUncheckedCreateWithoutSantrisInput = {
    id?: string
    tenantId: string
    name: string
    relation: string
    phone: string
    email?: string | null
    address?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WaliCreateOrConnectWithoutSantrisInput = {
    where: WaliWhereUniqueInput
    create: XOR<WaliCreateWithoutSantrisInput, WaliUncheckedCreateWithoutSantrisInput>
  }

  export type SantriUpsertWithoutWalisInput = {
    update: XOR<SantriUpdateWithoutWalisInput, SantriUncheckedUpdateWithoutWalisInput>
    create: XOR<SantriCreateWithoutWalisInput, SantriUncheckedCreateWithoutWalisInput>
    where?: SantriWhereInput
  }

  export type SantriUpdateToOneWithWhereWithoutWalisInput = {
    where?: SantriWhereInput
    data: XOR<SantriUpdateWithoutWalisInput, SantriUncheckedUpdateWithoutWalisInput>
  }

  export type SantriUpdateWithoutWalisInput = {
    id?: StringFieldUpdateOperationsInput | string
    nisn?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    gender?: StringFieldUpdateOperationsInput | string
    dob?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    kelas?: NullableStringFieldUpdateOperationsInput | string | null
    room?: NullableStringFieldUpdateOperationsInput | string | null
    contact?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutSantriNestedInput
    izin?: IzinUpdateManyWithoutSantriNestedInput
    catatanHarian?: CatatanHarianUpdateManyWithoutSantriNestedInput
    invoices?: InvoiceUpdateManyWithoutSantriNestedInput
    pelanggaran?: PelanggaranUpdateManyWithoutSantriNestedInput
    pembinaan?: PembinaanUpdateManyWithoutSantriNestedInput
    kunjungan?: KunjunganUpdateManyWithoutSantriNestedInput
    healthRecords?: HealthRecordUpdateManyWithoutSantriNestedInput
    medications?: MedicationUpdateManyWithoutSantriNestedInput
    tahfidz?: TahfidzUpdateManyWithoutSantriNestedInput
    mutabaah?: MutabaahUpdateManyWithoutSantriNestedInput
    wallet?: WalletUpdateOneWithoutSantriNestedInput
    attendances?: AttendanceUpdateManyWithoutSantriNestedInput
    grades?: GradeUpdateManyWithoutSantriNestedInput
  }

  export type SantriUncheckedUpdateWithoutWalisInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    nisn?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    gender?: StringFieldUpdateOperationsInput | string
    dob?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    kelas?: NullableStringFieldUpdateOperationsInput | string | null
    room?: NullableStringFieldUpdateOperationsInput | string | null
    contact?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    izin?: IzinUncheckedUpdateManyWithoutSantriNestedInput
    catatanHarian?: CatatanHarianUncheckedUpdateManyWithoutSantriNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutSantriNestedInput
    pelanggaran?: PelanggaranUncheckedUpdateManyWithoutSantriNestedInput
    pembinaan?: PembinaanUncheckedUpdateManyWithoutSantriNestedInput
    kunjungan?: KunjunganUncheckedUpdateManyWithoutSantriNestedInput
    healthRecords?: HealthRecordUncheckedUpdateManyWithoutSantriNestedInput
    medications?: MedicationUncheckedUpdateManyWithoutSantriNestedInput
    tahfidz?: TahfidzUncheckedUpdateManyWithoutSantriNestedInput
    mutabaah?: MutabaahUncheckedUpdateManyWithoutSantriNestedInput
    wallet?: WalletUncheckedUpdateOneWithoutSantriNestedInput
    attendances?: AttendanceUncheckedUpdateManyWithoutSantriNestedInput
    grades?: GradeUncheckedUpdateManyWithoutSantriNestedInput
  }

  export type WaliUpsertWithoutSantrisInput = {
    update: XOR<WaliUpdateWithoutSantrisInput, WaliUncheckedUpdateWithoutSantrisInput>
    create: XOR<WaliCreateWithoutSantrisInput, WaliUncheckedCreateWithoutSantrisInput>
    where?: WaliWhereInput
  }

  export type WaliUpdateToOneWithWhereWithoutSantrisInput = {
    where?: WaliWhereInput
    data: XOR<WaliUpdateWithoutSantrisInput, WaliUncheckedUpdateWithoutSantrisInput>
  }

  export type WaliUpdateWithoutSantrisInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    relation?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutWaliNestedInput
  }

  export type WaliUncheckedUpdateWithoutSantrisInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    relation?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TenantCreateWithoutIzinInput = {
    id?: string
    name: string
    address?: string | null
    phone?: string | null
    adminUserId?: string | null
    timezone?: string
    plan?: string
    billingContact?: string | null
    status?: string
    settings?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutTenantInput
    santri?: SantriCreateNestedManyWithoutTenantInput
    wali?: WaliCreateNestedManyWithoutTenantInput
    catatanHarian?: CatatanHarianCreateNestedManyWithoutTenantInput
    pengumuman?: PengumumanCreateNestedManyWithoutTenantInput
    invoices?: InvoiceCreateNestedManyWithoutTenantInput
    pelanggaran?: PelanggaranCreateNestedManyWithoutTenantInput
    pembinaan?: PembinaanCreateNestedManyWithoutTenantInput
    kunjungan?: KunjunganCreateNestedManyWithoutTenantInput
    healthRecords?: HealthRecordCreateNestedManyWithoutTenantInput
    auditLogs?: AuditLogCreateNestedManyWithoutTenantInput
    notifications?: NotificationCreateNestedManyWithoutTenantInput
    webhookEvents?: WebhookEventCreateNestedManyWithoutTenantInput
    tahfidz?: TahfidzCreateNestedManyWithoutTenantInput
    mutabaah?: MutabaahCreateNestedManyWithoutTenantInput
    wallets?: WalletCreateNestedManyWithoutTenantInput
    employees?: EmployeeCreateNestedManyWithoutTenantInput
    payrolls?: PayrollCreateNestedManyWithoutTenantInput
    academicScheds?: AcademicScheduleCreateNestedManyWithoutTenantInput
    attendances?: AttendanceCreateNestedManyWithoutTenantInput
    grades?: GradeCreateNestedManyWithoutTenantInput
    ppdbRegistrations?: PpdbRegistrationCreateNestedManyWithoutTenantInput
    ppdbDocuments?: PpdbDocumentCreateNestedManyWithoutTenantInput
    ppdbExams?: PpdbExamCreateNestedManyWithoutTenantInput
    inventoryItems?: ItemCreateNestedManyWithoutTenantInput
    inventoryTransactions?: InventoryTransactionCreateNestedManyWithoutTenantInput
    suppliers?: SupplierCreateNestedManyWithoutTenantInput
    purchaseOrders?: PurchaseOrderCreateNestedManyWithoutTenantInput
    buildings?: BuildingCreateNestedManyWithoutTenantInput
    rooms?: RoomCreateNestedManyWithoutTenantInput
    roomAssignments?: RoomAssignmentCreateNestedManyWithoutTenantInput
    maintenanceTickets?: MaintenanceTicketCreateNestedManyWithoutTenantInput
  }

  export type TenantUncheckedCreateWithoutIzinInput = {
    id?: string
    name: string
    address?: string | null
    phone?: string | null
    adminUserId?: string | null
    timezone?: string
    plan?: string
    billingContact?: string | null
    status?: string
    settings?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutTenantInput
    santri?: SantriUncheckedCreateNestedManyWithoutTenantInput
    wali?: WaliUncheckedCreateNestedManyWithoutTenantInput
    catatanHarian?: CatatanHarianUncheckedCreateNestedManyWithoutTenantInput
    pengumuman?: PengumumanUncheckedCreateNestedManyWithoutTenantInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutTenantInput
    pelanggaran?: PelanggaranUncheckedCreateNestedManyWithoutTenantInput
    pembinaan?: PembinaanUncheckedCreateNestedManyWithoutTenantInput
    kunjungan?: KunjunganUncheckedCreateNestedManyWithoutTenantInput
    healthRecords?: HealthRecordUncheckedCreateNestedManyWithoutTenantInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutTenantInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutTenantInput
    webhookEvents?: WebhookEventUncheckedCreateNestedManyWithoutTenantInput
    tahfidz?: TahfidzUncheckedCreateNestedManyWithoutTenantInput
    mutabaah?: MutabaahUncheckedCreateNestedManyWithoutTenantInput
    wallets?: WalletUncheckedCreateNestedManyWithoutTenantInput
    employees?: EmployeeUncheckedCreateNestedManyWithoutTenantInput
    payrolls?: PayrollUncheckedCreateNestedManyWithoutTenantInput
    academicScheds?: AcademicScheduleUncheckedCreateNestedManyWithoutTenantInput
    attendances?: AttendanceUncheckedCreateNestedManyWithoutTenantInput
    grades?: GradeUncheckedCreateNestedManyWithoutTenantInput
    ppdbRegistrations?: PpdbRegistrationUncheckedCreateNestedManyWithoutTenantInput
    ppdbDocuments?: PpdbDocumentUncheckedCreateNestedManyWithoutTenantInput
    ppdbExams?: PpdbExamUncheckedCreateNestedManyWithoutTenantInput
    inventoryItems?: ItemUncheckedCreateNestedManyWithoutTenantInput
    inventoryTransactions?: InventoryTransactionUncheckedCreateNestedManyWithoutTenantInput
    suppliers?: SupplierUncheckedCreateNestedManyWithoutTenantInput
    purchaseOrders?: PurchaseOrderUncheckedCreateNestedManyWithoutTenantInput
    buildings?: BuildingUncheckedCreateNestedManyWithoutTenantInput
    rooms?: RoomUncheckedCreateNestedManyWithoutTenantInput
    roomAssignments?: RoomAssignmentUncheckedCreateNestedManyWithoutTenantInput
    maintenanceTickets?: MaintenanceTicketUncheckedCreateNestedManyWithoutTenantInput
  }

  export type TenantCreateOrConnectWithoutIzinInput = {
    where: TenantWhereUniqueInput
    create: XOR<TenantCreateWithoutIzinInput, TenantUncheckedCreateWithoutIzinInput>
  }

  export type SantriCreateWithoutIzinInput = {
    id?: string
    nisn?: string | null
    name: string
    gender: string
    dob?: Date | string | null
    kelas?: string | null
    room?: string | null
    contact?: string | null
    address?: string | null
    photo?: string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutSantriInput
    walis?: SantriWaliCreateNestedManyWithoutSantriInput
    catatanHarian?: CatatanHarianCreateNestedManyWithoutSantriInput
    invoices?: InvoiceCreateNestedManyWithoutSantriInput
    pelanggaran?: PelanggaranCreateNestedManyWithoutSantriInput
    pembinaan?: PembinaanCreateNestedManyWithoutSantriInput
    kunjungan?: KunjunganCreateNestedManyWithoutSantriInput
    healthRecords?: HealthRecordCreateNestedManyWithoutSantriInput
    medications?: MedicationCreateNestedManyWithoutSantriInput
    tahfidz?: TahfidzCreateNestedManyWithoutSantriInput
    mutabaah?: MutabaahCreateNestedManyWithoutSantriInput
    wallet?: WalletCreateNestedOneWithoutSantriInput
    attendances?: AttendanceCreateNestedManyWithoutSantriInput
    grades?: GradeCreateNestedManyWithoutSantriInput
  }

  export type SantriUncheckedCreateWithoutIzinInput = {
    id?: string
    tenantId: string
    nisn?: string | null
    name: string
    gender: string
    dob?: Date | string | null
    kelas?: string | null
    room?: string | null
    contact?: string | null
    address?: string | null
    photo?: string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    walis?: SantriWaliUncheckedCreateNestedManyWithoutSantriInput
    catatanHarian?: CatatanHarianUncheckedCreateNestedManyWithoutSantriInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutSantriInput
    pelanggaran?: PelanggaranUncheckedCreateNestedManyWithoutSantriInput
    pembinaan?: PembinaanUncheckedCreateNestedManyWithoutSantriInput
    kunjungan?: KunjunganUncheckedCreateNestedManyWithoutSantriInput
    healthRecords?: HealthRecordUncheckedCreateNestedManyWithoutSantriInput
    medications?: MedicationUncheckedCreateNestedManyWithoutSantriInput
    tahfidz?: TahfidzUncheckedCreateNestedManyWithoutSantriInput
    mutabaah?: MutabaahUncheckedCreateNestedManyWithoutSantriInput
    wallet?: WalletUncheckedCreateNestedOneWithoutSantriInput
    attendances?: AttendanceUncheckedCreateNestedManyWithoutSantriInput
    grades?: GradeUncheckedCreateNestedManyWithoutSantriInput
  }

  export type SantriCreateOrConnectWithoutIzinInput = {
    where: SantriWhereUniqueInput
    create: XOR<SantriCreateWithoutIzinInput, SantriUncheckedCreateWithoutIzinInput>
  }

  export type TenantUpsertWithoutIzinInput = {
    update: XOR<TenantUpdateWithoutIzinInput, TenantUncheckedUpdateWithoutIzinInput>
    create: XOR<TenantCreateWithoutIzinInput, TenantUncheckedCreateWithoutIzinInput>
    where?: TenantWhereInput
  }

  export type TenantUpdateToOneWithWhereWithoutIzinInput = {
    where?: TenantWhereInput
    data: XOR<TenantUpdateWithoutIzinInput, TenantUncheckedUpdateWithoutIzinInput>
  }

  export type TenantUpdateWithoutIzinInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    adminUserId?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    plan?: StringFieldUpdateOperationsInput | string
    billingContact?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    settings?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutTenantNestedInput
    santri?: SantriUpdateManyWithoutTenantNestedInput
    wali?: WaliUpdateManyWithoutTenantNestedInput
    catatanHarian?: CatatanHarianUpdateManyWithoutTenantNestedInput
    pengumuman?: PengumumanUpdateManyWithoutTenantNestedInput
    invoices?: InvoiceUpdateManyWithoutTenantNestedInput
    pelanggaran?: PelanggaranUpdateManyWithoutTenantNestedInput
    pembinaan?: PembinaanUpdateManyWithoutTenantNestedInput
    kunjungan?: KunjunganUpdateManyWithoutTenantNestedInput
    healthRecords?: HealthRecordUpdateManyWithoutTenantNestedInput
    auditLogs?: AuditLogUpdateManyWithoutTenantNestedInput
    notifications?: NotificationUpdateManyWithoutTenantNestedInput
    webhookEvents?: WebhookEventUpdateManyWithoutTenantNestedInput
    tahfidz?: TahfidzUpdateManyWithoutTenantNestedInput
    mutabaah?: MutabaahUpdateManyWithoutTenantNestedInput
    wallets?: WalletUpdateManyWithoutTenantNestedInput
    employees?: EmployeeUpdateManyWithoutTenantNestedInput
    payrolls?: PayrollUpdateManyWithoutTenantNestedInput
    academicScheds?: AcademicScheduleUpdateManyWithoutTenantNestedInput
    attendances?: AttendanceUpdateManyWithoutTenantNestedInput
    grades?: GradeUpdateManyWithoutTenantNestedInput
    ppdbRegistrations?: PpdbRegistrationUpdateManyWithoutTenantNestedInput
    ppdbDocuments?: PpdbDocumentUpdateManyWithoutTenantNestedInput
    ppdbExams?: PpdbExamUpdateManyWithoutTenantNestedInput
    inventoryItems?: ItemUpdateManyWithoutTenantNestedInput
    inventoryTransactions?: InventoryTransactionUpdateManyWithoutTenantNestedInput
    suppliers?: SupplierUpdateManyWithoutTenantNestedInput
    purchaseOrders?: PurchaseOrderUpdateManyWithoutTenantNestedInput
    buildings?: BuildingUpdateManyWithoutTenantNestedInput
    rooms?: RoomUpdateManyWithoutTenantNestedInput
    roomAssignments?: RoomAssignmentUpdateManyWithoutTenantNestedInput
    maintenanceTickets?: MaintenanceTicketUpdateManyWithoutTenantNestedInput
  }

  export type TenantUncheckedUpdateWithoutIzinInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    adminUserId?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    plan?: StringFieldUpdateOperationsInput | string
    billingContact?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    settings?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutTenantNestedInput
    santri?: SantriUncheckedUpdateManyWithoutTenantNestedInput
    wali?: WaliUncheckedUpdateManyWithoutTenantNestedInput
    catatanHarian?: CatatanHarianUncheckedUpdateManyWithoutTenantNestedInput
    pengumuman?: PengumumanUncheckedUpdateManyWithoutTenantNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutTenantNestedInput
    pelanggaran?: PelanggaranUncheckedUpdateManyWithoutTenantNestedInput
    pembinaan?: PembinaanUncheckedUpdateManyWithoutTenantNestedInput
    kunjungan?: KunjunganUncheckedUpdateManyWithoutTenantNestedInput
    healthRecords?: HealthRecordUncheckedUpdateManyWithoutTenantNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutTenantNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutTenantNestedInput
    webhookEvents?: WebhookEventUncheckedUpdateManyWithoutTenantNestedInput
    tahfidz?: TahfidzUncheckedUpdateManyWithoutTenantNestedInput
    mutabaah?: MutabaahUncheckedUpdateManyWithoutTenantNestedInput
    wallets?: WalletUncheckedUpdateManyWithoutTenantNestedInput
    employees?: EmployeeUncheckedUpdateManyWithoutTenantNestedInput
    payrolls?: PayrollUncheckedUpdateManyWithoutTenantNestedInput
    academicScheds?: AcademicScheduleUncheckedUpdateManyWithoutTenantNestedInput
    attendances?: AttendanceUncheckedUpdateManyWithoutTenantNestedInput
    grades?: GradeUncheckedUpdateManyWithoutTenantNestedInput
    ppdbRegistrations?: PpdbRegistrationUncheckedUpdateManyWithoutTenantNestedInput
    ppdbDocuments?: PpdbDocumentUncheckedUpdateManyWithoutTenantNestedInput
    ppdbExams?: PpdbExamUncheckedUpdateManyWithoutTenantNestedInput
    inventoryItems?: ItemUncheckedUpdateManyWithoutTenantNestedInput
    inventoryTransactions?: InventoryTransactionUncheckedUpdateManyWithoutTenantNestedInput
    suppliers?: SupplierUncheckedUpdateManyWithoutTenantNestedInput
    purchaseOrders?: PurchaseOrderUncheckedUpdateManyWithoutTenantNestedInput
    buildings?: BuildingUncheckedUpdateManyWithoutTenantNestedInput
    rooms?: RoomUncheckedUpdateManyWithoutTenantNestedInput
    roomAssignments?: RoomAssignmentUncheckedUpdateManyWithoutTenantNestedInput
    maintenanceTickets?: MaintenanceTicketUncheckedUpdateManyWithoutTenantNestedInput
  }

  export type SantriUpsertWithoutIzinInput = {
    update: XOR<SantriUpdateWithoutIzinInput, SantriUncheckedUpdateWithoutIzinInput>
    create: XOR<SantriCreateWithoutIzinInput, SantriUncheckedCreateWithoutIzinInput>
    where?: SantriWhereInput
  }

  export type SantriUpdateToOneWithWhereWithoutIzinInput = {
    where?: SantriWhereInput
    data: XOR<SantriUpdateWithoutIzinInput, SantriUncheckedUpdateWithoutIzinInput>
  }

  export type SantriUpdateWithoutIzinInput = {
    id?: StringFieldUpdateOperationsInput | string
    nisn?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    gender?: StringFieldUpdateOperationsInput | string
    dob?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    kelas?: NullableStringFieldUpdateOperationsInput | string | null
    room?: NullableStringFieldUpdateOperationsInput | string | null
    contact?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutSantriNestedInput
    walis?: SantriWaliUpdateManyWithoutSantriNestedInput
    catatanHarian?: CatatanHarianUpdateManyWithoutSantriNestedInput
    invoices?: InvoiceUpdateManyWithoutSantriNestedInput
    pelanggaran?: PelanggaranUpdateManyWithoutSantriNestedInput
    pembinaan?: PembinaanUpdateManyWithoutSantriNestedInput
    kunjungan?: KunjunganUpdateManyWithoutSantriNestedInput
    healthRecords?: HealthRecordUpdateManyWithoutSantriNestedInput
    medications?: MedicationUpdateManyWithoutSantriNestedInput
    tahfidz?: TahfidzUpdateManyWithoutSantriNestedInput
    mutabaah?: MutabaahUpdateManyWithoutSantriNestedInput
    wallet?: WalletUpdateOneWithoutSantriNestedInput
    attendances?: AttendanceUpdateManyWithoutSantriNestedInput
    grades?: GradeUpdateManyWithoutSantriNestedInput
  }

  export type SantriUncheckedUpdateWithoutIzinInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    nisn?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    gender?: StringFieldUpdateOperationsInput | string
    dob?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    kelas?: NullableStringFieldUpdateOperationsInput | string | null
    room?: NullableStringFieldUpdateOperationsInput | string | null
    contact?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    walis?: SantriWaliUncheckedUpdateManyWithoutSantriNestedInput
    catatanHarian?: CatatanHarianUncheckedUpdateManyWithoutSantriNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutSantriNestedInput
    pelanggaran?: PelanggaranUncheckedUpdateManyWithoutSantriNestedInput
    pembinaan?: PembinaanUncheckedUpdateManyWithoutSantriNestedInput
    kunjungan?: KunjunganUncheckedUpdateManyWithoutSantriNestedInput
    healthRecords?: HealthRecordUncheckedUpdateManyWithoutSantriNestedInput
    medications?: MedicationUncheckedUpdateManyWithoutSantriNestedInput
    tahfidz?: TahfidzUncheckedUpdateManyWithoutSantriNestedInput
    mutabaah?: MutabaahUncheckedUpdateManyWithoutSantriNestedInput
    wallet?: WalletUncheckedUpdateOneWithoutSantriNestedInput
    attendances?: AttendanceUncheckedUpdateManyWithoutSantriNestedInput
    grades?: GradeUncheckedUpdateManyWithoutSantriNestedInput
  }

  export type TenantCreateWithoutCatatanHarianInput = {
    id?: string
    name: string
    address?: string | null
    phone?: string | null
    adminUserId?: string | null
    timezone?: string
    plan?: string
    billingContact?: string | null
    status?: string
    settings?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutTenantInput
    santri?: SantriCreateNestedManyWithoutTenantInput
    wali?: WaliCreateNestedManyWithoutTenantInput
    izin?: IzinCreateNestedManyWithoutTenantInput
    pengumuman?: PengumumanCreateNestedManyWithoutTenantInput
    invoices?: InvoiceCreateNestedManyWithoutTenantInput
    pelanggaran?: PelanggaranCreateNestedManyWithoutTenantInput
    pembinaan?: PembinaanCreateNestedManyWithoutTenantInput
    kunjungan?: KunjunganCreateNestedManyWithoutTenantInput
    healthRecords?: HealthRecordCreateNestedManyWithoutTenantInput
    auditLogs?: AuditLogCreateNestedManyWithoutTenantInput
    notifications?: NotificationCreateNestedManyWithoutTenantInput
    webhookEvents?: WebhookEventCreateNestedManyWithoutTenantInput
    tahfidz?: TahfidzCreateNestedManyWithoutTenantInput
    mutabaah?: MutabaahCreateNestedManyWithoutTenantInput
    wallets?: WalletCreateNestedManyWithoutTenantInput
    employees?: EmployeeCreateNestedManyWithoutTenantInput
    payrolls?: PayrollCreateNestedManyWithoutTenantInput
    academicScheds?: AcademicScheduleCreateNestedManyWithoutTenantInput
    attendances?: AttendanceCreateNestedManyWithoutTenantInput
    grades?: GradeCreateNestedManyWithoutTenantInput
    ppdbRegistrations?: PpdbRegistrationCreateNestedManyWithoutTenantInput
    ppdbDocuments?: PpdbDocumentCreateNestedManyWithoutTenantInput
    ppdbExams?: PpdbExamCreateNestedManyWithoutTenantInput
    inventoryItems?: ItemCreateNestedManyWithoutTenantInput
    inventoryTransactions?: InventoryTransactionCreateNestedManyWithoutTenantInput
    suppliers?: SupplierCreateNestedManyWithoutTenantInput
    purchaseOrders?: PurchaseOrderCreateNestedManyWithoutTenantInput
    buildings?: BuildingCreateNestedManyWithoutTenantInput
    rooms?: RoomCreateNestedManyWithoutTenantInput
    roomAssignments?: RoomAssignmentCreateNestedManyWithoutTenantInput
    maintenanceTickets?: MaintenanceTicketCreateNestedManyWithoutTenantInput
  }

  export type TenantUncheckedCreateWithoutCatatanHarianInput = {
    id?: string
    name: string
    address?: string | null
    phone?: string | null
    adminUserId?: string | null
    timezone?: string
    plan?: string
    billingContact?: string | null
    status?: string
    settings?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutTenantInput
    santri?: SantriUncheckedCreateNestedManyWithoutTenantInput
    wali?: WaliUncheckedCreateNestedManyWithoutTenantInput
    izin?: IzinUncheckedCreateNestedManyWithoutTenantInput
    pengumuman?: PengumumanUncheckedCreateNestedManyWithoutTenantInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutTenantInput
    pelanggaran?: PelanggaranUncheckedCreateNestedManyWithoutTenantInput
    pembinaan?: PembinaanUncheckedCreateNestedManyWithoutTenantInput
    kunjungan?: KunjunganUncheckedCreateNestedManyWithoutTenantInput
    healthRecords?: HealthRecordUncheckedCreateNestedManyWithoutTenantInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutTenantInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutTenantInput
    webhookEvents?: WebhookEventUncheckedCreateNestedManyWithoutTenantInput
    tahfidz?: TahfidzUncheckedCreateNestedManyWithoutTenantInput
    mutabaah?: MutabaahUncheckedCreateNestedManyWithoutTenantInput
    wallets?: WalletUncheckedCreateNestedManyWithoutTenantInput
    employees?: EmployeeUncheckedCreateNestedManyWithoutTenantInput
    payrolls?: PayrollUncheckedCreateNestedManyWithoutTenantInput
    academicScheds?: AcademicScheduleUncheckedCreateNestedManyWithoutTenantInput
    attendances?: AttendanceUncheckedCreateNestedManyWithoutTenantInput
    grades?: GradeUncheckedCreateNestedManyWithoutTenantInput
    ppdbRegistrations?: PpdbRegistrationUncheckedCreateNestedManyWithoutTenantInput
    ppdbDocuments?: PpdbDocumentUncheckedCreateNestedManyWithoutTenantInput
    ppdbExams?: PpdbExamUncheckedCreateNestedManyWithoutTenantInput
    inventoryItems?: ItemUncheckedCreateNestedManyWithoutTenantInput
    inventoryTransactions?: InventoryTransactionUncheckedCreateNestedManyWithoutTenantInput
    suppliers?: SupplierUncheckedCreateNestedManyWithoutTenantInput
    purchaseOrders?: PurchaseOrderUncheckedCreateNestedManyWithoutTenantInput
    buildings?: BuildingUncheckedCreateNestedManyWithoutTenantInput
    rooms?: RoomUncheckedCreateNestedManyWithoutTenantInput
    roomAssignments?: RoomAssignmentUncheckedCreateNestedManyWithoutTenantInput
    maintenanceTickets?: MaintenanceTicketUncheckedCreateNestedManyWithoutTenantInput
  }

  export type TenantCreateOrConnectWithoutCatatanHarianInput = {
    where: TenantWhereUniqueInput
    create: XOR<TenantCreateWithoutCatatanHarianInput, TenantUncheckedCreateWithoutCatatanHarianInput>
  }

  export type SantriCreateWithoutCatatanHarianInput = {
    id?: string
    nisn?: string | null
    name: string
    gender: string
    dob?: Date | string | null
    kelas?: string | null
    room?: string | null
    contact?: string | null
    address?: string | null
    photo?: string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutSantriInput
    walis?: SantriWaliCreateNestedManyWithoutSantriInput
    izin?: IzinCreateNestedManyWithoutSantriInput
    invoices?: InvoiceCreateNestedManyWithoutSantriInput
    pelanggaran?: PelanggaranCreateNestedManyWithoutSantriInput
    pembinaan?: PembinaanCreateNestedManyWithoutSantriInput
    kunjungan?: KunjunganCreateNestedManyWithoutSantriInput
    healthRecords?: HealthRecordCreateNestedManyWithoutSantriInput
    medications?: MedicationCreateNestedManyWithoutSantriInput
    tahfidz?: TahfidzCreateNestedManyWithoutSantriInput
    mutabaah?: MutabaahCreateNestedManyWithoutSantriInput
    wallet?: WalletCreateNestedOneWithoutSantriInput
    attendances?: AttendanceCreateNestedManyWithoutSantriInput
    grades?: GradeCreateNestedManyWithoutSantriInput
  }

  export type SantriUncheckedCreateWithoutCatatanHarianInput = {
    id?: string
    tenantId: string
    nisn?: string | null
    name: string
    gender: string
    dob?: Date | string | null
    kelas?: string | null
    room?: string | null
    contact?: string | null
    address?: string | null
    photo?: string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    walis?: SantriWaliUncheckedCreateNestedManyWithoutSantriInput
    izin?: IzinUncheckedCreateNestedManyWithoutSantriInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutSantriInput
    pelanggaran?: PelanggaranUncheckedCreateNestedManyWithoutSantriInput
    pembinaan?: PembinaanUncheckedCreateNestedManyWithoutSantriInput
    kunjungan?: KunjunganUncheckedCreateNestedManyWithoutSantriInput
    healthRecords?: HealthRecordUncheckedCreateNestedManyWithoutSantriInput
    medications?: MedicationUncheckedCreateNestedManyWithoutSantriInput
    tahfidz?: TahfidzUncheckedCreateNestedManyWithoutSantriInput
    mutabaah?: MutabaahUncheckedCreateNestedManyWithoutSantriInput
    wallet?: WalletUncheckedCreateNestedOneWithoutSantriInput
    attendances?: AttendanceUncheckedCreateNestedManyWithoutSantriInput
    grades?: GradeUncheckedCreateNestedManyWithoutSantriInput
  }

  export type SantriCreateOrConnectWithoutCatatanHarianInput = {
    where: SantriWhereUniqueInput
    create: XOR<SantriCreateWithoutCatatanHarianInput, SantriUncheckedCreateWithoutCatatanHarianInput>
  }

  export type TenantUpsertWithoutCatatanHarianInput = {
    update: XOR<TenantUpdateWithoutCatatanHarianInput, TenantUncheckedUpdateWithoutCatatanHarianInput>
    create: XOR<TenantCreateWithoutCatatanHarianInput, TenantUncheckedCreateWithoutCatatanHarianInput>
    where?: TenantWhereInput
  }

  export type TenantUpdateToOneWithWhereWithoutCatatanHarianInput = {
    where?: TenantWhereInput
    data: XOR<TenantUpdateWithoutCatatanHarianInput, TenantUncheckedUpdateWithoutCatatanHarianInput>
  }

  export type TenantUpdateWithoutCatatanHarianInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    adminUserId?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    plan?: StringFieldUpdateOperationsInput | string
    billingContact?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    settings?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutTenantNestedInput
    santri?: SantriUpdateManyWithoutTenantNestedInput
    wali?: WaliUpdateManyWithoutTenantNestedInput
    izin?: IzinUpdateManyWithoutTenantNestedInput
    pengumuman?: PengumumanUpdateManyWithoutTenantNestedInput
    invoices?: InvoiceUpdateManyWithoutTenantNestedInput
    pelanggaran?: PelanggaranUpdateManyWithoutTenantNestedInput
    pembinaan?: PembinaanUpdateManyWithoutTenantNestedInput
    kunjungan?: KunjunganUpdateManyWithoutTenantNestedInput
    healthRecords?: HealthRecordUpdateManyWithoutTenantNestedInput
    auditLogs?: AuditLogUpdateManyWithoutTenantNestedInput
    notifications?: NotificationUpdateManyWithoutTenantNestedInput
    webhookEvents?: WebhookEventUpdateManyWithoutTenantNestedInput
    tahfidz?: TahfidzUpdateManyWithoutTenantNestedInput
    mutabaah?: MutabaahUpdateManyWithoutTenantNestedInput
    wallets?: WalletUpdateManyWithoutTenantNestedInput
    employees?: EmployeeUpdateManyWithoutTenantNestedInput
    payrolls?: PayrollUpdateManyWithoutTenantNestedInput
    academicScheds?: AcademicScheduleUpdateManyWithoutTenantNestedInput
    attendances?: AttendanceUpdateManyWithoutTenantNestedInput
    grades?: GradeUpdateManyWithoutTenantNestedInput
    ppdbRegistrations?: PpdbRegistrationUpdateManyWithoutTenantNestedInput
    ppdbDocuments?: PpdbDocumentUpdateManyWithoutTenantNestedInput
    ppdbExams?: PpdbExamUpdateManyWithoutTenantNestedInput
    inventoryItems?: ItemUpdateManyWithoutTenantNestedInput
    inventoryTransactions?: InventoryTransactionUpdateManyWithoutTenantNestedInput
    suppliers?: SupplierUpdateManyWithoutTenantNestedInput
    purchaseOrders?: PurchaseOrderUpdateManyWithoutTenantNestedInput
    buildings?: BuildingUpdateManyWithoutTenantNestedInput
    rooms?: RoomUpdateManyWithoutTenantNestedInput
    roomAssignments?: RoomAssignmentUpdateManyWithoutTenantNestedInput
    maintenanceTickets?: MaintenanceTicketUpdateManyWithoutTenantNestedInput
  }

  export type TenantUncheckedUpdateWithoutCatatanHarianInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    adminUserId?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    plan?: StringFieldUpdateOperationsInput | string
    billingContact?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    settings?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutTenantNestedInput
    santri?: SantriUncheckedUpdateManyWithoutTenantNestedInput
    wali?: WaliUncheckedUpdateManyWithoutTenantNestedInput
    izin?: IzinUncheckedUpdateManyWithoutTenantNestedInput
    pengumuman?: PengumumanUncheckedUpdateManyWithoutTenantNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutTenantNestedInput
    pelanggaran?: PelanggaranUncheckedUpdateManyWithoutTenantNestedInput
    pembinaan?: PembinaanUncheckedUpdateManyWithoutTenantNestedInput
    kunjungan?: KunjunganUncheckedUpdateManyWithoutTenantNestedInput
    healthRecords?: HealthRecordUncheckedUpdateManyWithoutTenantNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutTenantNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutTenantNestedInput
    webhookEvents?: WebhookEventUncheckedUpdateManyWithoutTenantNestedInput
    tahfidz?: TahfidzUncheckedUpdateManyWithoutTenantNestedInput
    mutabaah?: MutabaahUncheckedUpdateManyWithoutTenantNestedInput
    wallets?: WalletUncheckedUpdateManyWithoutTenantNestedInput
    employees?: EmployeeUncheckedUpdateManyWithoutTenantNestedInput
    payrolls?: PayrollUncheckedUpdateManyWithoutTenantNestedInput
    academicScheds?: AcademicScheduleUncheckedUpdateManyWithoutTenantNestedInput
    attendances?: AttendanceUncheckedUpdateManyWithoutTenantNestedInput
    grades?: GradeUncheckedUpdateManyWithoutTenantNestedInput
    ppdbRegistrations?: PpdbRegistrationUncheckedUpdateManyWithoutTenantNestedInput
    ppdbDocuments?: PpdbDocumentUncheckedUpdateManyWithoutTenantNestedInput
    ppdbExams?: PpdbExamUncheckedUpdateManyWithoutTenantNestedInput
    inventoryItems?: ItemUncheckedUpdateManyWithoutTenantNestedInput
    inventoryTransactions?: InventoryTransactionUncheckedUpdateManyWithoutTenantNestedInput
    suppliers?: SupplierUncheckedUpdateManyWithoutTenantNestedInput
    purchaseOrders?: PurchaseOrderUncheckedUpdateManyWithoutTenantNestedInput
    buildings?: BuildingUncheckedUpdateManyWithoutTenantNestedInput
    rooms?: RoomUncheckedUpdateManyWithoutTenantNestedInput
    roomAssignments?: RoomAssignmentUncheckedUpdateManyWithoutTenantNestedInput
    maintenanceTickets?: MaintenanceTicketUncheckedUpdateManyWithoutTenantNestedInput
  }

  export type SantriUpsertWithoutCatatanHarianInput = {
    update: XOR<SantriUpdateWithoutCatatanHarianInput, SantriUncheckedUpdateWithoutCatatanHarianInput>
    create: XOR<SantriCreateWithoutCatatanHarianInput, SantriUncheckedCreateWithoutCatatanHarianInput>
    where?: SantriWhereInput
  }

  export type SantriUpdateToOneWithWhereWithoutCatatanHarianInput = {
    where?: SantriWhereInput
    data: XOR<SantriUpdateWithoutCatatanHarianInput, SantriUncheckedUpdateWithoutCatatanHarianInput>
  }

  export type SantriUpdateWithoutCatatanHarianInput = {
    id?: StringFieldUpdateOperationsInput | string
    nisn?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    gender?: StringFieldUpdateOperationsInput | string
    dob?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    kelas?: NullableStringFieldUpdateOperationsInput | string | null
    room?: NullableStringFieldUpdateOperationsInput | string | null
    contact?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutSantriNestedInput
    walis?: SantriWaliUpdateManyWithoutSantriNestedInput
    izin?: IzinUpdateManyWithoutSantriNestedInput
    invoices?: InvoiceUpdateManyWithoutSantriNestedInput
    pelanggaran?: PelanggaranUpdateManyWithoutSantriNestedInput
    pembinaan?: PembinaanUpdateManyWithoutSantriNestedInput
    kunjungan?: KunjunganUpdateManyWithoutSantriNestedInput
    healthRecords?: HealthRecordUpdateManyWithoutSantriNestedInput
    medications?: MedicationUpdateManyWithoutSantriNestedInput
    tahfidz?: TahfidzUpdateManyWithoutSantriNestedInput
    mutabaah?: MutabaahUpdateManyWithoutSantriNestedInput
    wallet?: WalletUpdateOneWithoutSantriNestedInput
    attendances?: AttendanceUpdateManyWithoutSantriNestedInput
    grades?: GradeUpdateManyWithoutSantriNestedInput
  }

  export type SantriUncheckedUpdateWithoutCatatanHarianInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    nisn?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    gender?: StringFieldUpdateOperationsInput | string
    dob?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    kelas?: NullableStringFieldUpdateOperationsInput | string | null
    room?: NullableStringFieldUpdateOperationsInput | string | null
    contact?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    walis?: SantriWaliUncheckedUpdateManyWithoutSantriNestedInput
    izin?: IzinUncheckedUpdateManyWithoutSantriNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutSantriNestedInput
    pelanggaran?: PelanggaranUncheckedUpdateManyWithoutSantriNestedInput
    pembinaan?: PembinaanUncheckedUpdateManyWithoutSantriNestedInput
    kunjungan?: KunjunganUncheckedUpdateManyWithoutSantriNestedInput
    healthRecords?: HealthRecordUncheckedUpdateManyWithoutSantriNestedInput
    medications?: MedicationUncheckedUpdateManyWithoutSantriNestedInput
    tahfidz?: TahfidzUncheckedUpdateManyWithoutSantriNestedInput
    mutabaah?: MutabaahUncheckedUpdateManyWithoutSantriNestedInput
    wallet?: WalletUncheckedUpdateOneWithoutSantriNestedInput
    attendances?: AttendanceUncheckedUpdateManyWithoutSantriNestedInput
    grades?: GradeUncheckedUpdateManyWithoutSantriNestedInput
  }

  export type TenantCreateWithoutPengumumanInput = {
    id?: string
    name: string
    address?: string | null
    phone?: string | null
    adminUserId?: string | null
    timezone?: string
    plan?: string
    billingContact?: string | null
    status?: string
    settings?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutTenantInput
    santri?: SantriCreateNestedManyWithoutTenantInput
    wali?: WaliCreateNestedManyWithoutTenantInput
    izin?: IzinCreateNestedManyWithoutTenantInput
    catatanHarian?: CatatanHarianCreateNestedManyWithoutTenantInput
    invoices?: InvoiceCreateNestedManyWithoutTenantInput
    pelanggaran?: PelanggaranCreateNestedManyWithoutTenantInput
    pembinaan?: PembinaanCreateNestedManyWithoutTenantInput
    kunjungan?: KunjunganCreateNestedManyWithoutTenantInput
    healthRecords?: HealthRecordCreateNestedManyWithoutTenantInput
    auditLogs?: AuditLogCreateNestedManyWithoutTenantInput
    notifications?: NotificationCreateNestedManyWithoutTenantInput
    webhookEvents?: WebhookEventCreateNestedManyWithoutTenantInput
    tahfidz?: TahfidzCreateNestedManyWithoutTenantInput
    mutabaah?: MutabaahCreateNestedManyWithoutTenantInput
    wallets?: WalletCreateNestedManyWithoutTenantInput
    employees?: EmployeeCreateNestedManyWithoutTenantInput
    payrolls?: PayrollCreateNestedManyWithoutTenantInput
    academicScheds?: AcademicScheduleCreateNestedManyWithoutTenantInput
    attendances?: AttendanceCreateNestedManyWithoutTenantInput
    grades?: GradeCreateNestedManyWithoutTenantInput
    ppdbRegistrations?: PpdbRegistrationCreateNestedManyWithoutTenantInput
    ppdbDocuments?: PpdbDocumentCreateNestedManyWithoutTenantInput
    ppdbExams?: PpdbExamCreateNestedManyWithoutTenantInput
    inventoryItems?: ItemCreateNestedManyWithoutTenantInput
    inventoryTransactions?: InventoryTransactionCreateNestedManyWithoutTenantInput
    suppliers?: SupplierCreateNestedManyWithoutTenantInput
    purchaseOrders?: PurchaseOrderCreateNestedManyWithoutTenantInput
    buildings?: BuildingCreateNestedManyWithoutTenantInput
    rooms?: RoomCreateNestedManyWithoutTenantInput
    roomAssignments?: RoomAssignmentCreateNestedManyWithoutTenantInput
    maintenanceTickets?: MaintenanceTicketCreateNestedManyWithoutTenantInput
  }

  export type TenantUncheckedCreateWithoutPengumumanInput = {
    id?: string
    name: string
    address?: string | null
    phone?: string | null
    adminUserId?: string | null
    timezone?: string
    plan?: string
    billingContact?: string | null
    status?: string
    settings?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutTenantInput
    santri?: SantriUncheckedCreateNestedManyWithoutTenantInput
    wali?: WaliUncheckedCreateNestedManyWithoutTenantInput
    izin?: IzinUncheckedCreateNestedManyWithoutTenantInput
    catatanHarian?: CatatanHarianUncheckedCreateNestedManyWithoutTenantInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutTenantInput
    pelanggaran?: PelanggaranUncheckedCreateNestedManyWithoutTenantInput
    pembinaan?: PembinaanUncheckedCreateNestedManyWithoutTenantInput
    kunjungan?: KunjunganUncheckedCreateNestedManyWithoutTenantInput
    healthRecords?: HealthRecordUncheckedCreateNestedManyWithoutTenantInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutTenantInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutTenantInput
    webhookEvents?: WebhookEventUncheckedCreateNestedManyWithoutTenantInput
    tahfidz?: TahfidzUncheckedCreateNestedManyWithoutTenantInput
    mutabaah?: MutabaahUncheckedCreateNestedManyWithoutTenantInput
    wallets?: WalletUncheckedCreateNestedManyWithoutTenantInput
    employees?: EmployeeUncheckedCreateNestedManyWithoutTenantInput
    payrolls?: PayrollUncheckedCreateNestedManyWithoutTenantInput
    academicScheds?: AcademicScheduleUncheckedCreateNestedManyWithoutTenantInput
    attendances?: AttendanceUncheckedCreateNestedManyWithoutTenantInput
    grades?: GradeUncheckedCreateNestedManyWithoutTenantInput
    ppdbRegistrations?: PpdbRegistrationUncheckedCreateNestedManyWithoutTenantInput
    ppdbDocuments?: PpdbDocumentUncheckedCreateNestedManyWithoutTenantInput
    ppdbExams?: PpdbExamUncheckedCreateNestedManyWithoutTenantInput
    inventoryItems?: ItemUncheckedCreateNestedManyWithoutTenantInput
    inventoryTransactions?: InventoryTransactionUncheckedCreateNestedManyWithoutTenantInput
    suppliers?: SupplierUncheckedCreateNestedManyWithoutTenantInput
    purchaseOrders?: PurchaseOrderUncheckedCreateNestedManyWithoutTenantInput
    buildings?: BuildingUncheckedCreateNestedManyWithoutTenantInput
    rooms?: RoomUncheckedCreateNestedManyWithoutTenantInput
    roomAssignments?: RoomAssignmentUncheckedCreateNestedManyWithoutTenantInput
    maintenanceTickets?: MaintenanceTicketUncheckedCreateNestedManyWithoutTenantInput
  }

  export type TenantCreateOrConnectWithoutPengumumanInput = {
    where: TenantWhereUniqueInput
    create: XOR<TenantCreateWithoutPengumumanInput, TenantUncheckedCreateWithoutPengumumanInput>
  }

  export type TenantUpsertWithoutPengumumanInput = {
    update: XOR<TenantUpdateWithoutPengumumanInput, TenantUncheckedUpdateWithoutPengumumanInput>
    create: XOR<TenantCreateWithoutPengumumanInput, TenantUncheckedCreateWithoutPengumumanInput>
    where?: TenantWhereInput
  }

  export type TenantUpdateToOneWithWhereWithoutPengumumanInput = {
    where?: TenantWhereInput
    data: XOR<TenantUpdateWithoutPengumumanInput, TenantUncheckedUpdateWithoutPengumumanInput>
  }

  export type TenantUpdateWithoutPengumumanInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    adminUserId?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    plan?: StringFieldUpdateOperationsInput | string
    billingContact?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    settings?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutTenantNestedInput
    santri?: SantriUpdateManyWithoutTenantNestedInput
    wali?: WaliUpdateManyWithoutTenantNestedInput
    izin?: IzinUpdateManyWithoutTenantNestedInput
    catatanHarian?: CatatanHarianUpdateManyWithoutTenantNestedInput
    invoices?: InvoiceUpdateManyWithoutTenantNestedInput
    pelanggaran?: PelanggaranUpdateManyWithoutTenantNestedInput
    pembinaan?: PembinaanUpdateManyWithoutTenantNestedInput
    kunjungan?: KunjunganUpdateManyWithoutTenantNestedInput
    healthRecords?: HealthRecordUpdateManyWithoutTenantNestedInput
    auditLogs?: AuditLogUpdateManyWithoutTenantNestedInput
    notifications?: NotificationUpdateManyWithoutTenantNestedInput
    webhookEvents?: WebhookEventUpdateManyWithoutTenantNestedInput
    tahfidz?: TahfidzUpdateManyWithoutTenantNestedInput
    mutabaah?: MutabaahUpdateManyWithoutTenantNestedInput
    wallets?: WalletUpdateManyWithoutTenantNestedInput
    employees?: EmployeeUpdateManyWithoutTenantNestedInput
    payrolls?: PayrollUpdateManyWithoutTenantNestedInput
    academicScheds?: AcademicScheduleUpdateManyWithoutTenantNestedInput
    attendances?: AttendanceUpdateManyWithoutTenantNestedInput
    grades?: GradeUpdateManyWithoutTenantNestedInput
    ppdbRegistrations?: PpdbRegistrationUpdateManyWithoutTenantNestedInput
    ppdbDocuments?: PpdbDocumentUpdateManyWithoutTenantNestedInput
    ppdbExams?: PpdbExamUpdateManyWithoutTenantNestedInput
    inventoryItems?: ItemUpdateManyWithoutTenantNestedInput
    inventoryTransactions?: InventoryTransactionUpdateManyWithoutTenantNestedInput
    suppliers?: SupplierUpdateManyWithoutTenantNestedInput
    purchaseOrders?: PurchaseOrderUpdateManyWithoutTenantNestedInput
    buildings?: BuildingUpdateManyWithoutTenantNestedInput
    rooms?: RoomUpdateManyWithoutTenantNestedInput
    roomAssignments?: RoomAssignmentUpdateManyWithoutTenantNestedInput
    maintenanceTickets?: MaintenanceTicketUpdateManyWithoutTenantNestedInput
  }

  export type TenantUncheckedUpdateWithoutPengumumanInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    adminUserId?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    plan?: StringFieldUpdateOperationsInput | string
    billingContact?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    settings?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutTenantNestedInput
    santri?: SantriUncheckedUpdateManyWithoutTenantNestedInput
    wali?: WaliUncheckedUpdateManyWithoutTenantNestedInput
    izin?: IzinUncheckedUpdateManyWithoutTenantNestedInput
    catatanHarian?: CatatanHarianUncheckedUpdateManyWithoutTenantNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutTenantNestedInput
    pelanggaran?: PelanggaranUncheckedUpdateManyWithoutTenantNestedInput
    pembinaan?: PembinaanUncheckedUpdateManyWithoutTenantNestedInput
    kunjungan?: KunjunganUncheckedUpdateManyWithoutTenantNestedInput
    healthRecords?: HealthRecordUncheckedUpdateManyWithoutTenantNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutTenantNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutTenantNestedInput
    webhookEvents?: WebhookEventUncheckedUpdateManyWithoutTenantNestedInput
    tahfidz?: TahfidzUncheckedUpdateManyWithoutTenantNestedInput
    mutabaah?: MutabaahUncheckedUpdateManyWithoutTenantNestedInput
    wallets?: WalletUncheckedUpdateManyWithoutTenantNestedInput
    employees?: EmployeeUncheckedUpdateManyWithoutTenantNestedInput
    payrolls?: PayrollUncheckedUpdateManyWithoutTenantNestedInput
    academicScheds?: AcademicScheduleUncheckedUpdateManyWithoutTenantNestedInput
    attendances?: AttendanceUncheckedUpdateManyWithoutTenantNestedInput
    grades?: GradeUncheckedUpdateManyWithoutTenantNestedInput
    ppdbRegistrations?: PpdbRegistrationUncheckedUpdateManyWithoutTenantNestedInput
    ppdbDocuments?: PpdbDocumentUncheckedUpdateManyWithoutTenantNestedInput
    ppdbExams?: PpdbExamUncheckedUpdateManyWithoutTenantNestedInput
    inventoryItems?: ItemUncheckedUpdateManyWithoutTenantNestedInput
    inventoryTransactions?: InventoryTransactionUncheckedUpdateManyWithoutTenantNestedInput
    suppliers?: SupplierUncheckedUpdateManyWithoutTenantNestedInput
    purchaseOrders?: PurchaseOrderUncheckedUpdateManyWithoutTenantNestedInput
    buildings?: BuildingUncheckedUpdateManyWithoutTenantNestedInput
    rooms?: RoomUncheckedUpdateManyWithoutTenantNestedInput
    roomAssignments?: RoomAssignmentUncheckedUpdateManyWithoutTenantNestedInput
    maintenanceTickets?: MaintenanceTicketUncheckedUpdateManyWithoutTenantNestedInput
  }

  export type TenantCreateWithoutInvoicesInput = {
    id?: string
    name: string
    address?: string | null
    phone?: string | null
    adminUserId?: string | null
    timezone?: string
    plan?: string
    billingContact?: string | null
    status?: string
    settings?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutTenantInput
    santri?: SantriCreateNestedManyWithoutTenantInput
    wali?: WaliCreateNestedManyWithoutTenantInput
    izin?: IzinCreateNestedManyWithoutTenantInput
    catatanHarian?: CatatanHarianCreateNestedManyWithoutTenantInput
    pengumuman?: PengumumanCreateNestedManyWithoutTenantInput
    pelanggaran?: PelanggaranCreateNestedManyWithoutTenantInput
    pembinaan?: PembinaanCreateNestedManyWithoutTenantInput
    kunjungan?: KunjunganCreateNestedManyWithoutTenantInput
    healthRecords?: HealthRecordCreateNestedManyWithoutTenantInput
    auditLogs?: AuditLogCreateNestedManyWithoutTenantInput
    notifications?: NotificationCreateNestedManyWithoutTenantInput
    webhookEvents?: WebhookEventCreateNestedManyWithoutTenantInput
    tahfidz?: TahfidzCreateNestedManyWithoutTenantInput
    mutabaah?: MutabaahCreateNestedManyWithoutTenantInput
    wallets?: WalletCreateNestedManyWithoutTenantInput
    employees?: EmployeeCreateNestedManyWithoutTenantInput
    payrolls?: PayrollCreateNestedManyWithoutTenantInput
    academicScheds?: AcademicScheduleCreateNestedManyWithoutTenantInput
    attendances?: AttendanceCreateNestedManyWithoutTenantInput
    grades?: GradeCreateNestedManyWithoutTenantInput
    ppdbRegistrations?: PpdbRegistrationCreateNestedManyWithoutTenantInput
    ppdbDocuments?: PpdbDocumentCreateNestedManyWithoutTenantInput
    ppdbExams?: PpdbExamCreateNestedManyWithoutTenantInput
    inventoryItems?: ItemCreateNestedManyWithoutTenantInput
    inventoryTransactions?: InventoryTransactionCreateNestedManyWithoutTenantInput
    suppliers?: SupplierCreateNestedManyWithoutTenantInput
    purchaseOrders?: PurchaseOrderCreateNestedManyWithoutTenantInput
    buildings?: BuildingCreateNestedManyWithoutTenantInput
    rooms?: RoomCreateNestedManyWithoutTenantInput
    roomAssignments?: RoomAssignmentCreateNestedManyWithoutTenantInput
    maintenanceTickets?: MaintenanceTicketCreateNestedManyWithoutTenantInput
  }

  export type TenantUncheckedCreateWithoutInvoicesInput = {
    id?: string
    name: string
    address?: string | null
    phone?: string | null
    adminUserId?: string | null
    timezone?: string
    plan?: string
    billingContact?: string | null
    status?: string
    settings?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutTenantInput
    santri?: SantriUncheckedCreateNestedManyWithoutTenantInput
    wali?: WaliUncheckedCreateNestedManyWithoutTenantInput
    izin?: IzinUncheckedCreateNestedManyWithoutTenantInput
    catatanHarian?: CatatanHarianUncheckedCreateNestedManyWithoutTenantInput
    pengumuman?: PengumumanUncheckedCreateNestedManyWithoutTenantInput
    pelanggaran?: PelanggaranUncheckedCreateNestedManyWithoutTenantInput
    pembinaan?: PembinaanUncheckedCreateNestedManyWithoutTenantInput
    kunjungan?: KunjunganUncheckedCreateNestedManyWithoutTenantInput
    healthRecords?: HealthRecordUncheckedCreateNestedManyWithoutTenantInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutTenantInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutTenantInput
    webhookEvents?: WebhookEventUncheckedCreateNestedManyWithoutTenantInput
    tahfidz?: TahfidzUncheckedCreateNestedManyWithoutTenantInput
    mutabaah?: MutabaahUncheckedCreateNestedManyWithoutTenantInput
    wallets?: WalletUncheckedCreateNestedManyWithoutTenantInput
    employees?: EmployeeUncheckedCreateNestedManyWithoutTenantInput
    payrolls?: PayrollUncheckedCreateNestedManyWithoutTenantInput
    academicScheds?: AcademicScheduleUncheckedCreateNestedManyWithoutTenantInput
    attendances?: AttendanceUncheckedCreateNestedManyWithoutTenantInput
    grades?: GradeUncheckedCreateNestedManyWithoutTenantInput
    ppdbRegistrations?: PpdbRegistrationUncheckedCreateNestedManyWithoutTenantInput
    ppdbDocuments?: PpdbDocumentUncheckedCreateNestedManyWithoutTenantInput
    ppdbExams?: PpdbExamUncheckedCreateNestedManyWithoutTenantInput
    inventoryItems?: ItemUncheckedCreateNestedManyWithoutTenantInput
    inventoryTransactions?: InventoryTransactionUncheckedCreateNestedManyWithoutTenantInput
    suppliers?: SupplierUncheckedCreateNestedManyWithoutTenantInput
    purchaseOrders?: PurchaseOrderUncheckedCreateNestedManyWithoutTenantInput
    buildings?: BuildingUncheckedCreateNestedManyWithoutTenantInput
    rooms?: RoomUncheckedCreateNestedManyWithoutTenantInput
    roomAssignments?: RoomAssignmentUncheckedCreateNestedManyWithoutTenantInput
    maintenanceTickets?: MaintenanceTicketUncheckedCreateNestedManyWithoutTenantInput
  }

  export type TenantCreateOrConnectWithoutInvoicesInput = {
    where: TenantWhereUniqueInput
    create: XOR<TenantCreateWithoutInvoicesInput, TenantUncheckedCreateWithoutInvoicesInput>
  }

  export type SantriCreateWithoutInvoicesInput = {
    id?: string
    nisn?: string | null
    name: string
    gender: string
    dob?: Date | string | null
    kelas?: string | null
    room?: string | null
    contact?: string | null
    address?: string | null
    photo?: string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutSantriInput
    walis?: SantriWaliCreateNestedManyWithoutSantriInput
    izin?: IzinCreateNestedManyWithoutSantriInput
    catatanHarian?: CatatanHarianCreateNestedManyWithoutSantriInput
    pelanggaran?: PelanggaranCreateNestedManyWithoutSantriInput
    pembinaan?: PembinaanCreateNestedManyWithoutSantriInput
    kunjungan?: KunjunganCreateNestedManyWithoutSantriInput
    healthRecords?: HealthRecordCreateNestedManyWithoutSantriInput
    medications?: MedicationCreateNestedManyWithoutSantriInput
    tahfidz?: TahfidzCreateNestedManyWithoutSantriInput
    mutabaah?: MutabaahCreateNestedManyWithoutSantriInput
    wallet?: WalletCreateNestedOneWithoutSantriInput
    attendances?: AttendanceCreateNestedManyWithoutSantriInput
    grades?: GradeCreateNestedManyWithoutSantriInput
  }

  export type SantriUncheckedCreateWithoutInvoicesInput = {
    id?: string
    tenantId: string
    nisn?: string | null
    name: string
    gender: string
    dob?: Date | string | null
    kelas?: string | null
    room?: string | null
    contact?: string | null
    address?: string | null
    photo?: string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    walis?: SantriWaliUncheckedCreateNestedManyWithoutSantriInput
    izin?: IzinUncheckedCreateNestedManyWithoutSantriInput
    catatanHarian?: CatatanHarianUncheckedCreateNestedManyWithoutSantriInput
    pelanggaran?: PelanggaranUncheckedCreateNestedManyWithoutSantriInput
    pembinaan?: PembinaanUncheckedCreateNestedManyWithoutSantriInput
    kunjungan?: KunjunganUncheckedCreateNestedManyWithoutSantriInput
    healthRecords?: HealthRecordUncheckedCreateNestedManyWithoutSantriInput
    medications?: MedicationUncheckedCreateNestedManyWithoutSantriInput
    tahfidz?: TahfidzUncheckedCreateNestedManyWithoutSantriInput
    mutabaah?: MutabaahUncheckedCreateNestedManyWithoutSantriInput
    wallet?: WalletUncheckedCreateNestedOneWithoutSantriInput
    attendances?: AttendanceUncheckedCreateNestedManyWithoutSantriInput
    grades?: GradeUncheckedCreateNestedManyWithoutSantriInput
  }

  export type SantriCreateOrConnectWithoutInvoicesInput = {
    where: SantriWhereUniqueInput
    create: XOR<SantriCreateWithoutInvoicesInput, SantriUncheckedCreateWithoutInvoicesInput>
  }

  export type InvoiceLineCreateWithoutInvoiceInput = {
    id?: string
    description: string
    amount: number
    type: string
  }

  export type InvoiceLineUncheckedCreateWithoutInvoiceInput = {
    id?: string
    description: string
    amount: number
    type: string
  }

  export type InvoiceLineCreateOrConnectWithoutInvoiceInput = {
    where: InvoiceLineWhereUniqueInput
    create: XOR<InvoiceLineCreateWithoutInvoiceInput, InvoiceLineUncheckedCreateWithoutInvoiceInput>
  }

  export type InvoiceLineCreateManyInvoiceInputEnvelope = {
    data: InvoiceLineCreateManyInvoiceInput | InvoiceLineCreateManyInvoiceInput[]
  }

  export type PaymentCreateWithoutInvoiceInput = {
    id?: string
    method: string
    amount: number
    status?: string
    transactionRef?: string | null
    paidAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PaymentUncheckedCreateWithoutInvoiceInput = {
    id?: string
    method: string
    amount: number
    status?: string
    transactionRef?: string | null
    paidAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PaymentCreateOrConnectWithoutInvoiceInput = {
    where: PaymentWhereUniqueInput
    create: XOR<PaymentCreateWithoutInvoiceInput, PaymentUncheckedCreateWithoutInvoiceInput>
  }

  export type PaymentCreateManyInvoiceInputEnvelope = {
    data: PaymentCreateManyInvoiceInput | PaymentCreateManyInvoiceInput[]
  }

  export type TenantUpsertWithoutInvoicesInput = {
    update: XOR<TenantUpdateWithoutInvoicesInput, TenantUncheckedUpdateWithoutInvoicesInput>
    create: XOR<TenantCreateWithoutInvoicesInput, TenantUncheckedCreateWithoutInvoicesInput>
    where?: TenantWhereInput
  }

  export type TenantUpdateToOneWithWhereWithoutInvoicesInput = {
    where?: TenantWhereInput
    data: XOR<TenantUpdateWithoutInvoicesInput, TenantUncheckedUpdateWithoutInvoicesInput>
  }

  export type TenantUpdateWithoutInvoicesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    adminUserId?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    plan?: StringFieldUpdateOperationsInput | string
    billingContact?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    settings?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutTenantNestedInput
    santri?: SantriUpdateManyWithoutTenantNestedInput
    wali?: WaliUpdateManyWithoutTenantNestedInput
    izin?: IzinUpdateManyWithoutTenantNestedInput
    catatanHarian?: CatatanHarianUpdateManyWithoutTenantNestedInput
    pengumuman?: PengumumanUpdateManyWithoutTenantNestedInput
    pelanggaran?: PelanggaranUpdateManyWithoutTenantNestedInput
    pembinaan?: PembinaanUpdateManyWithoutTenantNestedInput
    kunjungan?: KunjunganUpdateManyWithoutTenantNestedInput
    healthRecords?: HealthRecordUpdateManyWithoutTenantNestedInput
    auditLogs?: AuditLogUpdateManyWithoutTenantNestedInput
    notifications?: NotificationUpdateManyWithoutTenantNestedInput
    webhookEvents?: WebhookEventUpdateManyWithoutTenantNestedInput
    tahfidz?: TahfidzUpdateManyWithoutTenantNestedInput
    mutabaah?: MutabaahUpdateManyWithoutTenantNestedInput
    wallets?: WalletUpdateManyWithoutTenantNestedInput
    employees?: EmployeeUpdateManyWithoutTenantNestedInput
    payrolls?: PayrollUpdateManyWithoutTenantNestedInput
    academicScheds?: AcademicScheduleUpdateManyWithoutTenantNestedInput
    attendances?: AttendanceUpdateManyWithoutTenantNestedInput
    grades?: GradeUpdateManyWithoutTenantNestedInput
    ppdbRegistrations?: PpdbRegistrationUpdateManyWithoutTenantNestedInput
    ppdbDocuments?: PpdbDocumentUpdateManyWithoutTenantNestedInput
    ppdbExams?: PpdbExamUpdateManyWithoutTenantNestedInput
    inventoryItems?: ItemUpdateManyWithoutTenantNestedInput
    inventoryTransactions?: InventoryTransactionUpdateManyWithoutTenantNestedInput
    suppliers?: SupplierUpdateManyWithoutTenantNestedInput
    purchaseOrders?: PurchaseOrderUpdateManyWithoutTenantNestedInput
    buildings?: BuildingUpdateManyWithoutTenantNestedInput
    rooms?: RoomUpdateManyWithoutTenantNestedInput
    roomAssignments?: RoomAssignmentUpdateManyWithoutTenantNestedInput
    maintenanceTickets?: MaintenanceTicketUpdateManyWithoutTenantNestedInput
  }

  export type TenantUncheckedUpdateWithoutInvoicesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    adminUserId?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    plan?: StringFieldUpdateOperationsInput | string
    billingContact?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    settings?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutTenantNestedInput
    santri?: SantriUncheckedUpdateManyWithoutTenantNestedInput
    wali?: WaliUncheckedUpdateManyWithoutTenantNestedInput
    izin?: IzinUncheckedUpdateManyWithoutTenantNestedInput
    catatanHarian?: CatatanHarianUncheckedUpdateManyWithoutTenantNestedInput
    pengumuman?: PengumumanUncheckedUpdateManyWithoutTenantNestedInput
    pelanggaran?: PelanggaranUncheckedUpdateManyWithoutTenantNestedInput
    pembinaan?: PembinaanUncheckedUpdateManyWithoutTenantNestedInput
    kunjungan?: KunjunganUncheckedUpdateManyWithoutTenantNestedInput
    healthRecords?: HealthRecordUncheckedUpdateManyWithoutTenantNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutTenantNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutTenantNestedInput
    webhookEvents?: WebhookEventUncheckedUpdateManyWithoutTenantNestedInput
    tahfidz?: TahfidzUncheckedUpdateManyWithoutTenantNestedInput
    mutabaah?: MutabaahUncheckedUpdateManyWithoutTenantNestedInput
    wallets?: WalletUncheckedUpdateManyWithoutTenantNestedInput
    employees?: EmployeeUncheckedUpdateManyWithoutTenantNestedInput
    payrolls?: PayrollUncheckedUpdateManyWithoutTenantNestedInput
    academicScheds?: AcademicScheduleUncheckedUpdateManyWithoutTenantNestedInput
    attendances?: AttendanceUncheckedUpdateManyWithoutTenantNestedInput
    grades?: GradeUncheckedUpdateManyWithoutTenantNestedInput
    ppdbRegistrations?: PpdbRegistrationUncheckedUpdateManyWithoutTenantNestedInput
    ppdbDocuments?: PpdbDocumentUncheckedUpdateManyWithoutTenantNestedInput
    ppdbExams?: PpdbExamUncheckedUpdateManyWithoutTenantNestedInput
    inventoryItems?: ItemUncheckedUpdateManyWithoutTenantNestedInput
    inventoryTransactions?: InventoryTransactionUncheckedUpdateManyWithoutTenantNestedInput
    suppliers?: SupplierUncheckedUpdateManyWithoutTenantNestedInput
    purchaseOrders?: PurchaseOrderUncheckedUpdateManyWithoutTenantNestedInput
    buildings?: BuildingUncheckedUpdateManyWithoutTenantNestedInput
    rooms?: RoomUncheckedUpdateManyWithoutTenantNestedInput
    roomAssignments?: RoomAssignmentUncheckedUpdateManyWithoutTenantNestedInput
    maintenanceTickets?: MaintenanceTicketUncheckedUpdateManyWithoutTenantNestedInput
  }

  export type SantriUpsertWithoutInvoicesInput = {
    update: XOR<SantriUpdateWithoutInvoicesInput, SantriUncheckedUpdateWithoutInvoicesInput>
    create: XOR<SantriCreateWithoutInvoicesInput, SantriUncheckedCreateWithoutInvoicesInput>
    where?: SantriWhereInput
  }

  export type SantriUpdateToOneWithWhereWithoutInvoicesInput = {
    where?: SantriWhereInput
    data: XOR<SantriUpdateWithoutInvoicesInput, SantriUncheckedUpdateWithoutInvoicesInput>
  }

  export type SantriUpdateWithoutInvoicesInput = {
    id?: StringFieldUpdateOperationsInput | string
    nisn?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    gender?: StringFieldUpdateOperationsInput | string
    dob?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    kelas?: NullableStringFieldUpdateOperationsInput | string | null
    room?: NullableStringFieldUpdateOperationsInput | string | null
    contact?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutSantriNestedInput
    walis?: SantriWaliUpdateManyWithoutSantriNestedInput
    izin?: IzinUpdateManyWithoutSantriNestedInput
    catatanHarian?: CatatanHarianUpdateManyWithoutSantriNestedInput
    pelanggaran?: PelanggaranUpdateManyWithoutSantriNestedInput
    pembinaan?: PembinaanUpdateManyWithoutSantriNestedInput
    kunjungan?: KunjunganUpdateManyWithoutSantriNestedInput
    healthRecords?: HealthRecordUpdateManyWithoutSantriNestedInput
    medications?: MedicationUpdateManyWithoutSantriNestedInput
    tahfidz?: TahfidzUpdateManyWithoutSantriNestedInput
    mutabaah?: MutabaahUpdateManyWithoutSantriNestedInput
    wallet?: WalletUpdateOneWithoutSantriNestedInput
    attendances?: AttendanceUpdateManyWithoutSantriNestedInput
    grades?: GradeUpdateManyWithoutSantriNestedInput
  }

  export type SantriUncheckedUpdateWithoutInvoicesInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    nisn?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    gender?: StringFieldUpdateOperationsInput | string
    dob?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    kelas?: NullableStringFieldUpdateOperationsInput | string | null
    room?: NullableStringFieldUpdateOperationsInput | string | null
    contact?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    walis?: SantriWaliUncheckedUpdateManyWithoutSantriNestedInput
    izin?: IzinUncheckedUpdateManyWithoutSantriNestedInput
    catatanHarian?: CatatanHarianUncheckedUpdateManyWithoutSantriNestedInput
    pelanggaran?: PelanggaranUncheckedUpdateManyWithoutSantriNestedInput
    pembinaan?: PembinaanUncheckedUpdateManyWithoutSantriNestedInput
    kunjungan?: KunjunganUncheckedUpdateManyWithoutSantriNestedInput
    healthRecords?: HealthRecordUncheckedUpdateManyWithoutSantriNestedInput
    medications?: MedicationUncheckedUpdateManyWithoutSantriNestedInput
    tahfidz?: TahfidzUncheckedUpdateManyWithoutSantriNestedInput
    mutabaah?: MutabaahUncheckedUpdateManyWithoutSantriNestedInput
    wallet?: WalletUncheckedUpdateOneWithoutSantriNestedInput
    attendances?: AttendanceUncheckedUpdateManyWithoutSantriNestedInput
    grades?: GradeUncheckedUpdateManyWithoutSantriNestedInput
  }

  export type InvoiceLineUpsertWithWhereUniqueWithoutInvoiceInput = {
    where: InvoiceLineWhereUniqueInput
    update: XOR<InvoiceLineUpdateWithoutInvoiceInput, InvoiceLineUncheckedUpdateWithoutInvoiceInput>
    create: XOR<InvoiceLineCreateWithoutInvoiceInput, InvoiceLineUncheckedCreateWithoutInvoiceInput>
  }

  export type InvoiceLineUpdateWithWhereUniqueWithoutInvoiceInput = {
    where: InvoiceLineWhereUniqueInput
    data: XOR<InvoiceLineUpdateWithoutInvoiceInput, InvoiceLineUncheckedUpdateWithoutInvoiceInput>
  }

  export type InvoiceLineUpdateManyWithWhereWithoutInvoiceInput = {
    where: InvoiceLineScalarWhereInput
    data: XOR<InvoiceLineUpdateManyMutationInput, InvoiceLineUncheckedUpdateManyWithoutInvoiceInput>
  }

  export type InvoiceLineScalarWhereInput = {
    AND?: InvoiceLineScalarWhereInput | InvoiceLineScalarWhereInput[]
    OR?: InvoiceLineScalarWhereInput[]
    NOT?: InvoiceLineScalarWhereInput | InvoiceLineScalarWhereInput[]
    id?: StringFilter<"InvoiceLine"> | string
    invoiceId?: StringFilter<"InvoiceLine"> | string
    description?: StringFilter<"InvoiceLine"> | string
    amount?: FloatFilter<"InvoiceLine"> | number
    type?: StringFilter<"InvoiceLine"> | string
  }

  export type PaymentUpsertWithWhereUniqueWithoutInvoiceInput = {
    where: PaymentWhereUniqueInput
    update: XOR<PaymentUpdateWithoutInvoiceInput, PaymentUncheckedUpdateWithoutInvoiceInput>
    create: XOR<PaymentCreateWithoutInvoiceInput, PaymentUncheckedCreateWithoutInvoiceInput>
  }

  export type PaymentUpdateWithWhereUniqueWithoutInvoiceInput = {
    where: PaymentWhereUniqueInput
    data: XOR<PaymentUpdateWithoutInvoiceInput, PaymentUncheckedUpdateWithoutInvoiceInput>
  }

  export type PaymentUpdateManyWithWhereWithoutInvoiceInput = {
    where: PaymentScalarWhereInput
    data: XOR<PaymentUpdateManyMutationInput, PaymentUncheckedUpdateManyWithoutInvoiceInput>
  }

  export type PaymentScalarWhereInput = {
    AND?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
    OR?: PaymentScalarWhereInput[]
    NOT?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
    id?: StringFilter<"Payment"> | string
    invoiceId?: StringFilter<"Payment"> | string
    method?: StringFilter<"Payment"> | string
    amount?: FloatFilter<"Payment"> | number
    status?: StringFilter<"Payment"> | string
    transactionRef?: StringNullableFilter<"Payment"> | string | null
    paidAt?: DateTimeNullableFilter<"Payment"> | Date | string | null
    createdAt?: DateTimeFilter<"Payment"> | Date | string
    updatedAt?: DateTimeFilter<"Payment"> | Date | string
  }

  export type InvoiceCreateWithoutLinesInput = {
    id?: string
    amountDue: number
    dueDate: Date | string
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutInvoicesInput
    santri: SantriCreateNestedOneWithoutInvoicesInput
    payments?: PaymentCreateNestedManyWithoutInvoiceInput
  }

  export type InvoiceUncheckedCreateWithoutLinesInput = {
    id?: string
    tenantId: string
    santriId: string
    amountDue: number
    dueDate: Date | string
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    payments?: PaymentUncheckedCreateNestedManyWithoutInvoiceInput
  }

  export type InvoiceCreateOrConnectWithoutLinesInput = {
    where: InvoiceWhereUniqueInput
    create: XOR<InvoiceCreateWithoutLinesInput, InvoiceUncheckedCreateWithoutLinesInput>
  }

  export type InvoiceUpsertWithoutLinesInput = {
    update: XOR<InvoiceUpdateWithoutLinesInput, InvoiceUncheckedUpdateWithoutLinesInput>
    create: XOR<InvoiceCreateWithoutLinesInput, InvoiceUncheckedCreateWithoutLinesInput>
    where?: InvoiceWhereInput
  }

  export type InvoiceUpdateToOneWithWhereWithoutLinesInput = {
    where?: InvoiceWhereInput
    data: XOR<InvoiceUpdateWithoutLinesInput, InvoiceUncheckedUpdateWithoutLinesInput>
  }

  export type InvoiceUpdateWithoutLinesInput = {
    id?: StringFieldUpdateOperationsInput | string
    amountDue?: FloatFieldUpdateOperationsInput | number
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutInvoicesNestedInput
    santri?: SantriUpdateOneRequiredWithoutInvoicesNestedInput
    payments?: PaymentUpdateManyWithoutInvoiceNestedInput
  }

  export type InvoiceUncheckedUpdateWithoutLinesInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    santriId?: StringFieldUpdateOperationsInput | string
    amountDue?: FloatFieldUpdateOperationsInput | number
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    payments?: PaymentUncheckedUpdateManyWithoutInvoiceNestedInput
  }

  export type InvoiceCreateWithoutPaymentsInput = {
    id?: string
    amountDue: number
    dueDate: Date | string
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutInvoicesInput
    santri: SantriCreateNestedOneWithoutInvoicesInput
    lines?: InvoiceLineCreateNestedManyWithoutInvoiceInput
  }

  export type InvoiceUncheckedCreateWithoutPaymentsInput = {
    id?: string
    tenantId: string
    santriId: string
    amountDue: number
    dueDate: Date | string
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    lines?: InvoiceLineUncheckedCreateNestedManyWithoutInvoiceInput
  }

  export type InvoiceCreateOrConnectWithoutPaymentsInput = {
    where: InvoiceWhereUniqueInput
    create: XOR<InvoiceCreateWithoutPaymentsInput, InvoiceUncheckedCreateWithoutPaymentsInput>
  }

  export type InvoiceUpsertWithoutPaymentsInput = {
    update: XOR<InvoiceUpdateWithoutPaymentsInput, InvoiceUncheckedUpdateWithoutPaymentsInput>
    create: XOR<InvoiceCreateWithoutPaymentsInput, InvoiceUncheckedCreateWithoutPaymentsInput>
    where?: InvoiceWhereInput
  }

  export type InvoiceUpdateToOneWithWhereWithoutPaymentsInput = {
    where?: InvoiceWhereInput
    data: XOR<InvoiceUpdateWithoutPaymentsInput, InvoiceUncheckedUpdateWithoutPaymentsInput>
  }

  export type InvoiceUpdateWithoutPaymentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    amountDue?: FloatFieldUpdateOperationsInput | number
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutInvoicesNestedInput
    santri?: SantriUpdateOneRequiredWithoutInvoicesNestedInput
    lines?: InvoiceLineUpdateManyWithoutInvoiceNestedInput
  }

  export type InvoiceUncheckedUpdateWithoutPaymentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    santriId?: StringFieldUpdateOperationsInput | string
    amountDue?: FloatFieldUpdateOperationsInput | number
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lines?: InvoiceLineUncheckedUpdateManyWithoutInvoiceNestedInput
  }

  export type TenantCreateWithoutPelanggaranInput = {
    id?: string
    name: string
    address?: string | null
    phone?: string | null
    adminUserId?: string | null
    timezone?: string
    plan?: string
    billingContact?: string | null
    status?: string
    settings?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutTenantInput
    santri?: SantriCreateNestedManyWithoutTenantInput
    wali?: WaliCreateNestedManyWithoutTenantInput
    izin?: IzinCreateNestedManyWithoutTenantInput
    catatanHarian?: CatatanHarianCreateNestedManyWithoutTenantInput
    pengumuman?: PengumumanCreateNestedManyWithoutTenantInput
    invoices?: InvoiceCreateNestedManyWithoutTenantInput
    pembinaan?: PembinaanCreateNestedManyWithoutTenantInput
    kunjungan?: KunjunganCreateNestedManyWithoutTenantInput
    healthRecords?: HealthRecordCreateNestedManyWithoutTenantInput
    auditLogs?: AuditLogCreateNestedManyWithoutTenantInput
    notifications?: NotificationCreateNestedManyWithoutTenantInput
    webhookEvents?: WebhookEventCreateNestedManyWithoutTenantInput
    tahfidz?: TahfidzCreateNestedManyWithoutTenantInput
    mutabaah?: MutabaahCreateNestedManyWithoutTenantInput
    wallets?: WalletCreateNestedManyWithoutTenantInput
    employees?: EmployeeCreateNestedManyWithoutTenantInput
    payrolls?: PayrollCreateNestedManyWithoutTenantInput
    academicScheds?: AcademicScheduleCreateNestedManyWithoutTenantInput
    attendances?: AttendanceCreateNestedManyWithoutTenantInput
    grades?: GradeCreateNestedManyWithoutTenantInput
    ppdbRegistrations?: PpdbRegistrationCreateNestedManyWithoutTenantInput
    ppdbDocuments?: PpdbDocumentCreateNestedManyWithoutTenantInput
    ppdbExams?: PpdbExamCreateNestedManyWithoutTenantInput
    inventoryItems?: ItemCreateNestedManyWithoutTenantInput
    inventoryTransactions?: InventoryTransactionCreateNestedManyWithoutTenantInput
    suppliers?: SupplierCreateNestedManyWithoutTenantInput
    purchaseOrders?: PurchaseOrderCreateNestedManyWithoutTenantInput
    buildings?: BuildingCreateNestedManyWithoutTenantInput
    rooms?: RoomCreateNestedManyWithoutTenantInput
    roomAssignments?: RoomAssignmentCreateNestedManyWithoutTenantInput
    maintenanceTickets?: MaintenanceTicketCreateNestedManyWithoutTenantInput
  }

  export type TenantUncheckedCreateWithoutPelanggaranInput = {
    id?: string
    name: string
    address?: string | null
    phone?: string | null
    adminUserId?: string | null
    timezone?: string
    plan?: string
    billingContact?: string | null
    status?: string
    settings?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutTenantInput
    santri?: SantriUncheckedCreateNestedManyWithoutTenantInput
    wali?: WaliUncheckedCreateNestedManyWithoutTenantInput
    izin?: IzinUncheckedCreateNestedManyWithoutTenantInput
    catatanHarian?: CatatanHarianUncheckedCreateNestedManyWithoutTenantInput
    pengumuman?: PengumumanUncheckedCreateNestedManyWithoutTenantInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutTenantInput
    pembinaan?: PembinaanUncheckedCreateNestedManyWithoutTenantInput
    kunjungan?: KunjunganUncheckedCreateNestedManyWithoutTenantInput
    healthRecords?: HealthRecordUncheckedCreateNestedManyWithoutTenantInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutTenantInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutTenantInput
    webhookEvents?: WebhookEventUncheckedCreateNestedManyWithoutTenantInput
    tahfidz?: TahfidzUncheckedCreateNestedManyWithoutTenantInput
    mutabaah?: MutabaahUncheckedCreateNestedManyWithoutTenantInput
    wallets?: WalletUncheckedCreateNestedManyWithoutTenantInput
    employees?: EmployeeUncheckedCreateNestedManyWithoutTenantInput
    payrolls?: PayrollUncheckedCreateNestedManyWithoutTenantInput
    academicScheds?: AcademicScheduleUncheckedCreateNestedManyWithoutTenantInput
    attendances?: AttendanceUncheckedCreateNestedManyWithoutTenantInput
    grades?: GradeUncheckedCreateNestedManyWithoutTenantInput
    ppdbRegistrations?: PpdbRegistrationUncheckedCreateNestedManyWithoutTenantInput
    ppdbDocuments?: PpdbDocumentUncheckedCreateNestedManyWithoutTenantInput
    ppdbExams?: PpdbExamUncheckedCreateNestedManyWithoutTenantInput
    inventoryItems?: ItemUncheckedCreateNestedManyWithoutTenantInput
    inventoryTransactions?: InventoryTransactionUncheckedCreateNestedManyWithoutTenantInput
    suppliers?: SupplierUncheckedCreateNestedManyWithoutTenantInput
    purchaseOrders?: PurchaseOrderUncheckedCreateNestedManyWithoutTenantInput
    buildings?: BuildingUncheckedCreateNestedManyWithoutTenantInput
    rooms?: RoomUncheckedCreateNestedManyWithoutTenantInput
    roomAssignments?: RoomAssignmentUncheckedCreateNestedManyWithoutTenantInput
    maintenanceTickets?: MaintenanceTicketUncheckedCreateNestedManyWithoutTenantInput
  }

  export type TenantCreateOrConnectWithoutPelanggaranInput = {
    where: TenantWhereUniqueInput
    create: XOR<TenantCreateWithoutPelanggaranInput, TenantUncheckedCreateWithoutPelanggaranInput>
  }

  export type SantriCreateWithoutPelanggaranInput = {
    id?: string
    nisn?: string | null
    name: string
    gender: string
    dob?: Date | string | null
    kelas?: string | null
    room?: string | null
    contact?: string | null
    address?: string | null
    photo?: string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutSantriInput
    walis?: SantriWaliCreateNestedManyWithoutSantriInput
    izin?: IzinCreateNestedManyWithoutSantriInput
    catatanHarian?: CatatanHarianCreateNestedManyWithoutSantriInput
    invoices?: InvoiceCreateNestedManyWithoutSantriInput
    pembinaan?: PembinaanCreateNestedManyWithoutSantriInput
    kunjungan?: KunjunganCreateNestedManyWithoutSantriInput
    healthRecords?: HealthRecordCreateNestedManyWithoutSantriInput
    medications?: MedicationCreateNestedManyWithoutSantriInput
    tahfidz?: TahfidzCreateNestedManyWithoutSantriInput
    mutabaah?: MutabaahCreateNestedManyWithoutSantriInput
    wallet?: WalletCreateNestedOneWithoutSantriInput
    attendances?: AttendanceCreateNestedManyWithoutSantriInput
    grades?: GradeCreateNestedManyWithoutSantriInput
  }

  export type SantriUncheckedCreateWithoutPelanggaranInput = {
    id?: string
    tenantId: string
    nisn?: string | null
    name: string
    gender: string
    dob?: Date | string | null
    kelas?: string | null
    room?: string | null
    contact?: string | null
    address?: string | null
    photo?: string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    walis?: SantriWaliUncheckedCreateNestedManyWithoutSantriInput
    izin?: IzinUncheckedCreateNestedManyWithoutSantriInput
    catatanHarian?: CatatanHarianUncheckedCreateNestedManyWithoutSantriInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutSantriInput
    pembinaan?: PembinaanUncheckedCreateNestedManyWithoutSantriInput
    kunjungan?: KunjunganUncheckedCreateNestedManyWithoutSantriInput
    healthRecords?: HealthRecordUncheckedCreateNestedManyWithoutSantriInput
    medications?: MedicationUncheckedCreateNestedManyWithoutSantriInput
    tahfidz?: TahfidzUncheckedCreateNestedManyWithoutSantriInput
    mutabaah?: MutabaahUncheckedCreateNestedManyWithoutSantriInput
    wallet?: WalletUncheckedCreateNestedOneWithoutSantriInput
    attendances?: AttendanceUncheckedCreateNestedManyWithoutSantriInput
    grades?: GradeUncheckedCreateNestedManyWithoutSantriInput
  }

  export type SantriCreateOrConnectWithoutPelanggaranInput = {
    where: SantriWhereUniqueInput
    create: XOR<SantriCreateWithoutPelanggaranInput, SantriUncheckedCreateWithoutPelanggaranInput>
  }

  export type TenantUpsertWithoutPelanggaranInput = {
    update: XOR<TenantUpdateWithoutPelanggaranInput, TenantUncheckedUpdateWithoutPelanggaranInput>
    create: XOR<TenantCreateWithoutPelanggaranInput, TenantUncheckedCreateWithoutPelanggaranInput>
    where?: TenantWhereInput
  }

  export type TenantUpdateToOneWithWhereWithoutPelanggaranInput = {
    where?: TenantWhereInput
    data: XOR<TenantUpdateWithoutPelanggaranInput, TenantUncheckedUpdateWithoutPelanggaranInput>
  }

  export type TenantUpdateWithoutPelanggaranInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    adminUserId?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    plan?: StringFieldUpdateOperationsInput | string
    billingContact?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    settings?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutTenantNestedInput
    santri?: SantriUpdateManyWithoutTenantNestedInput
    wali?: WaliUpdateManyWithoutTenantNestedInput
    izin?: IzinUpdateManyWithoutTenantNestedInput
    catatanHarian?: CatatanHarianUpdateManyWithoutTenantNestedInput
    pengumuman?: PengumumanUpdateManyWithoutTenantNestedInput
    invoices?: InvoiceUpdateManyWithoutTenantNestedInput
    pembinaan?: PembinaanUpdateManyWithoutTenantNestedInput
    kunjungan?: KunjunganUpdateManyWithoutTenantNestedInput
    healthRecords?: HealthRecordUpdateManyWithoutTenantNestedInput
    auditLogs?: AuditLogUpdateManyWithoutTenantNestedInput
    notifications?: NotificationUpdateManyWithoutTenantNestedInput
    webhookEvents?: WebhookEventUpdateManyWithoutTenantNestedInput
    tahfidz?: TahfidzUpdateManyWithoutTenantNestedInput
    mutabaah?: MutabaahUpdateManyWithoutTenantNestedInput
    wallets?: WalletUpdateManyWithoutTenantNestedInput
    employees?: EmployeeUpdateManyWithoutTenantNestedInput
    payrolls?: PayrollUpdateManyWithoutTenantNestedInput
    academicScheds?: AcademicScheduleUpdateManyWithoutTenantNestedInput
    attendances?: AttendanceUpdateManyWithoutTenantNestedInput
    grades?: GradeUpdateManyWithoutTenantNestedInput
    ppdbRegistrations?: PpdbRegistrationUpdateManyWithoutTenantNestedInput
    ppdbDocuments?: PpdbDocumentUpdateManyWithoutTenantNestedInput
    ppdbExams?: PpdbExamUpdateManyWithoutTenantNestedInput
    inventoryItems?: ItemUpdateManyWithoutTenantNestedInput
    inventoryTransactions?: InventoryTransactionUpdateManyWithoutTenantNestedInput
    suppliers?: SupplierUpdateManyWithoutTenantNestedInput
    purchaseOrders?: PurchaseOrderUpdateManyWithoutTenantNestedInput
    buildings?: BuildingUpdateManyWithoutTenantNestedInput
    rooms?: RoomUpdateManyWithoutTenantNestedInput
    roomAssignments?: RoomAssignmentUpdateManyWithoutTenantNestedInput
    maintenanceTickets?: MaintenanceTicketUpdateManyWithoutTenantNestedInput
  }

  export type TenantUncheckedUpdateWithoutPelanggaranInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    adminUserId?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    plan?: StringFieldUpdateOperationsInput | string
    billingContact?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    settings?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutTenantNestedInput
    santri?: SantriUncheckedUpdateManyWithoutTenantNestedInput
    wali?: WaliUncheckedUpdateManyWithoutTenantNestedInput
    izin?: IzinUncheckedUpdateManyWithoutTenantNestedInput
    catatanHarian?: CatatanHarianUncheckedUpdateManyWithoutTenantNestedInput
    pengumuman?: PengumumanUncheckedUpdateManyWithoutTenantNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutTenantNestedInput
    pembinaan?: PembinaanUncheckedUpdateManyWithoutTenantNestedInput
    kunjungan?: KunjunganUncheckedUpdateManyWithoutTenantNestedInput
    healthRecords?: HealthRecordUncheckedUpdateManyWithoutTenantNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutTenantNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutTenantNestedInput
    webhookEvents?: WebhookEventUncheckedUpdateManyWithoutTenantNestedInput
    tahfidz?: TahfidzUncheckedUpdateManyWithoutTenantNestedInput
    mutabaah?: MutabaahUncheckedUpdateManyWithoutTenantNestedInput
    wallets?: WalletUncheckedUpdateManyWithoutTenantNestedInput
    employees?: EmployeeUncheckedUpdateManyWithoutTenantNestedInput
    payrolls?: PayrollUncheckedUpdateManyWithoutTenantNestedInput
    academicScheds?: AcademicScheduleUncheckedUpdateManyWithoutTenantNestedInput
    attendances?: AttendanceUncheckedUpdateManyWithoutTenantNestedInput
    grades?: GradeUncheckedUpdateManyWithoutTenantNestedInput
    ppdbRegistrations?: PpdbRegistrationUncheckedUpdateManyWithoutTenantNestedInput
    ppdbDocuments?: PpdbDocumentUncheckedUpdateManyWithoutTenantNestedInput
    ppdbExams?: PpdbExamUncheckedUpdateManyWithoutTenantNestedInput
    inventoryItems?: ItemUncheckedUpdateManyWithoutTenantNestedInput
    inventoryTransactions?: InventoryTransactionUncheckedUpdateManyWithoutTenantNestedInput
    suppliers?: SupplierUncheckedUpdateManyWithoutTenantNestedInput
    purchaseOrders?: PurchaseOrderUncheckedUpdateManyWithoutTenantNestedInput
    buildings?: BuildingUncheckedUpdateManyWithoutTenantNestedInput
    rooms?: RoomUncheckedUpdateManyWithoutTenantNestedInput
    roomAssignments?: RoomAssignmentUncheckedUpdateManyWithoutTenantNestedInput
    maintenanceTickets?: MaintenanceTicketUncheckedUpdateManyWithoutTenantNestedInput
  }

  export type SantriUpsertWithoutPelanggaranInput = {
    update: XOR<SantriUpdateWithoutPelanggaranInput, SantriUncheckedUpdateWithoutPelanggaranInput>
    create: XOR<SantriCreateWithoutPelanggaranInput, SantriUncheckedCreateWithoutPelanggaranInput>
    where?: SantriWhereInput
  }

  export type SantriUpdateToOneWithWhereWithoutPelanggaranInput = {
    where?: SantriWhereInput
    data: XOR<SantriUpdateWithoutPelanggaranInput, SantriUncheckedUpdateWithoutPelanggaranInput>
  }

  export type SantriUpdateWithoutPelanggaranInput = {
    id?: StringFieldUpdateOperationsInput | string
    nisn?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    gender?: StringFieldUpdateOperationsInput | string
    dob?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    kelas?: NullableStringFieldUpdateOperationsInput | string | null
    room?: NullableStringFieldUpdateOperationsInput | string | null
    contact?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutSantriNestedInput
    walis?: SantriWaliUpdateManyWithoutSantriNestedInput
    izin?: IzinUpdateManyWithoutSantriNestedInput
    catatanHarian?: CatatanHarianUpdateManyWithoutSantriNestedInput
    invoices?: InvoiceUpdateManyWithoutSantriNestedInput
    pembinaan?: PembinaanUpdateManyWithoutSantriNestedInput
    kunjungan?: KunjunganUpdateManyWithoutSantriNestedInput
    healthRecords?: HealthRecordUpdateManyWithoutSantriNestedInput
    medications?: MedicationUpdateManyWithoutSantriNestedInput
    tahfidz?: TahfidzUpdateManyWithoutSantriNestedInput
    mutabaah?: MutabaahUpdateManyWithoutSantriNestedInput
    wallet?: WalletUpdateOneWithoutSantriNestedInput
    attendances?: AttendanceUpdateManyWithoutSantriNestedInput
    grades?: GradeUpdateManyWithoutSantriNestedInput
  }

  export type SantriUncheckedUpdateWithoutPelanggaranInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    nisn?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    gender?: StringFieldUpdateOperationsInput | string
    dob?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    kelas?: NullableStringFieldUpdateOperationsInput | string | null
    room?: NullableStringFieldUpdateOperationsInput | string | null
    contact?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    walis?: SantriWaliUncheckedUpdateManyWithoutSantriNestedInput
    izin?: IzinUncheckedUpdateManyWithoutSantriNestedInput
    catatanHarian?: CatatanHarianUncheckedUpdateManyWithoutSantriNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutSantriNestedInput
    pembinaan?: PembinaanUncheckedUpdateManyWithoutSantriNestedInput
    kunjungan?: KunjunganUncheckedUpdateManyWithoutSantriNestedInput
    healthRecords?: HealthRecordUncheckedUpdateManyWithoutSantriNestedInput
    medications?: MedicationUncheckedUpdateManyWithoutSantriNestedInput
    tahfidz?: TahfidzUncheckedUpdateManyWithoutSantriNestedInput
    mutabaah?: MutabaahUncheckedUpdateManyWithoutSantriNestedInput
    wallet?: WalletUncheckedUpdateOneWithoutSantriNestedInput
    attendances?: AttendanceUncheckedUpdateManyWithoutSantriNestedInput
    grades?: GradeUncheckedUpdateManyWithoutSantriNestedInput
  }

  export type TenantCreateWithoutPembinaanInput = {
    id?: string
    name: string
    address?: string | null
    phone?: string | null
    adminUserId?: string | null
    timezone?: string
    plan?: string
    billingContact?: string | null
    status?: string
    settings?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutTenantInput
    santri?: SantriCreateNestedManyWithoutTenantInput
    wali?: WaliCreateNestedManyWithoutTenantInput
    izin?: IzinCreateNestedManyWithoutTenantInput
    catatanHarian?: CatatanHarianCreateNestedManyWithoutTenantInput
    pengumuman?: PengumumanCreateNestedManyWithoutTenantInput
    invoices?: InvoiceCreateNestedManyWithoutTenantInput
    pelanggaran?: PelanggaranCreateNestedManyWithoutTenantInput
    kunjungan?: KunjunganCreateNestedManyWithoutTenantInput
    healthRecords?: HealthRecordCreateNestedManyWithoutTenantInput
    auditLogs?: AuditLogCreateNestedManyWithoutTenantInput
    notifications?: NotificationCreateNestedManyWithoutTenantInput
    webhookEvents?: WebhookEventCreateNestedManyWithoutTenantInput
    tahfidz?: TahfidzCreateNestedManyWithoutTenantInput
    mutabaah?: MutabaahCreateNestedManyWithoutTenantInput
    wallets?: WalletCreateNestedManyWithoutTenantInput
    employees?: EmployeeCreateNestedManyWithoutTenantInput
    payrolls?: PayrollCreateNestedManyWithoutTenantInput
    academicScheds?: AcademicScheduleCreateNestedManyWithoutTenantInput
    attendances?: AttendanceCreateNestedManyWithoutTenantInput
    grades?: GradeCreateNestedManyWithoutTenantInput
    ppdbRegistrations?: PpdbRegistrationCreateNestedManyWithoutTenantInput
    ppdbDocuments?: PpdbDocumentCreateNestedManyWithoutTenantInput
    ppdbExams?: PpdbExamCreateNestedManyWithoutTenantInput
    inventoryItems?: ItemCreateNestedManyWithoutTenantInput
    inventoryTransactions?: InventoryTransactionCreateNestedManyWithoutTenantInput
    suppliers?: SupplierCreateNestedManyWithoutTenantInput
    purchaseOrders?: PurchaseOrderCreateNestedManyWithoutTenantInput
    buildings?: BuildingCreateNestedManyWithoutTenantInput
    rooms?: RoomCreateNestedManyWithoutTenantInput
    roomAssignments?: RoomAssignmentCreateNestedManyWithoutTenantInput
    maintenanceTickets?: MaintenanceTicketCreateNestedManyWithoutTenantInput
  }

  export type TenantUncheckedCreateWithoutPembinaanInput = {
    id?: string
    name: string
    address?: string | null
    phone?: string | null
    adminUserId?: string | null
    timezone?: string
    plan?: string
    billingContact?: string | null
    status?: string
    settings?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutTenantInput
    santri?: SantriUncheckedCreateNestedManyWithoutTenantInput
    wali?: WaliUncheckedCreateNestedManyWithoutTenantInput
    izin?: IzinUncheckedCreateNestedManyWithoutTenantInput
    catatanHarian?: CatatanHarianUncheckedCreateNestedManyWithoutTenantInput
    pengumuman?: PengumumanUncheckedCreateNestedManyWithoutTenantInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutTenantInput
    pelanggaran?: PelanggaranUncheckedCreateNestedManyWithoutTenantInput
    kunjungan?: KunjunganUncheckedCreateNestedManyWithoutTenantInput
    healthRecords?: HealthRecordUncheckedCreateNestedManyWithoutTenantInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutTenantInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutTenantInput
    webhookEvents?: WebhookEventUncheckedCreateNestedManyWithoutTenantInput
    tahfidz?: TahfidzUncheckedCreateNestedManyWithoutTenantInput
    mutabaah?: MutabaahUncheckedCreateNestedManyWithoutTenantInput
    wallets?: WalletUncheckedCreateNestedManyWithoutTenantInput
    employees?: EmployeeUncheckedCreateNestedManyWithoutTenantInput
    payrolls?: PayrollUncheckedCreateNestedManyWithoutTenantInput
    academicScheds?: AcademicScheduleUncheckedCreateNestedManyWithoutTenantInput
    attendances?: AttendanceUncheckedCreateNestedManyWithoutTenantInput
    grades?: GradeUncheckedCreateNestedManyWithoutTenantInput
    ppdbRegistrations?: PpdbRegistrationUncheckedCreateNestedManyWithoutTenantInput
    ppdbDocuments?: PpdbDocumentUncheckedCreateNestedManyWithoutTenantInput
    ppdbExams?: PpdbExamUncheckedCreateNestedManyWithoutTenantInput
    inventoryItems?: ItemUncheckedCreateNestedManyWithoutTenantInput
    inventoryTransactions?: InventoryTransactionUncheckedCreateNestedManyWithoutTenantInput
    suppliers?: SupplierUncheckedCreateNestedManyWithoutTenantInput
    purchaseOrders?: PurchaseOrderUncheckedCreateNestedManyWithoutTenantInput
    buildings?: BuildingUncheckedCreateNestedManyWithoutTenantInput
    rooms?: RoomUncheckedCreateNestedManyWithoutTenantInput
    roomAssignments?: RoomAssignmentUncheckedCreateNestedManyWithoutTenantInput
    maintenanceTickets?: MaintenanceTicketUncheckedCreateNestedManyWithoutTenantInput
  }

  export type TenantCreateOrConnectWithoutPembinaanInput = {
    where: TenantWhereUniqueInput
    create: XOR<TenantCreateWithoutPembinaanInput, TenantUncheckedCreateWithoutPembinaanInput>
  }

  export type SantriCreateWithoutPembinaanInput = {
    id?: string
    nisn?: string | null
    name: string
    gender: string
    dob?: Date | string | null
    kelas?: string | null
    room?: string | null
    contact?: string | null
    address?: string | null
    photo?: string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutSantriInput
    walis?: SantriWaliCreateNestedManyWithoutSantriInput
    izin?: IzinCreateNestedManyWithoutSantriInput
    catatanHarian?: CatatanHarianCreateNestedManyWithoutSantriInput
    invoices?: InvoiceCreateNestedManyWithoutSantriInput
    pelanggaran?: PelanggaranCreateNestedManyWithoutSantriInput
    kunjungan?: KunjunganCreateNestedManyWithoutSantriInput
    healthRecords?: HealthRecordCreateNestedManyWithoutSantriInput
    medications?: MedicationCreateNestedManyWithoutSantriInput
    tahfidz?: TahfidzCreateNestedManyWithoutSantriInput
    mutabaah?: MutabaahCreateNestedManyWithoutSantriInput
    wallet?: WalletCreateNestedOneWithoutSantriInput
    attendances?: AttendanceCreateNestedManyWithoutSantriInput
    grades?: GradeCreateNestedManyWithoutSantriInput
  }

  export type SantriUncheckedCreateWithoutPembinaanInput = {
    id?: string
    tenantId: string
    nisn?: string | null
    name: string
    gender: string
    dob?: Date | string | null
    kelas?: string | null
    room?: string | null
    contact?: string | null
    address?: string | null
    photo?: string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    walis?: SantriWaliUncheckedCreateNestedManyWithoutSantriInput
    izin?: IzinUncheckedCreateNestedManyWithoutSantriInput
    catatanHarian?: CatatanHarianUncheckedCreateNestedManyWithoutSantriInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutSantriInput
    pelanggaran?: PelanggaranUncheckedCreateNestedManyWithoutSantriInput
    kunjungan?: KunjunganUncheckedCreateNestedManyWithoutSantriInput
    healthRecords?: HealthRecordUncheckedCreateNestedManyWithoutSantriInput
    medications?: MedicationUncheckedCreateNestedManyWithoutSantriInput
    tahfidz?: TahfidzUncheckedCreateNestedManyWithoutSantriInput
    mutabaah?: MutabaahUncheckedCreateNestedManyWithoutSantriInput
    wallet?: WalletUncheckedCreateNestedOneWithoutSantriInput
    attendances?: AttendanceUncheckedCreateNestedManyWithoutSantriInput
    grades?: GradeUncheckedCreateNestedManyWithoutSantriInput
  }

  export type SantriCreateOrConnectWithoutPembinaanInput = {
    where: SantriWhereUniqueInput
    create: XOR<SantriCreateWithoutPembinaanInput, SantriUncheckedCreateWithoutPembinaanInput>
  }

  export type TenantUpsertWithoutPembinaanInput = {
    update: XOR<TenantUpdateWithoutPembinaanInput, TenantUncheckedUpdateWithoutPembinaanInput>
    create: XOR<TenantCreateWithoutPembinaanInput, TenantUncheckedCreateWithoutPembinaanInput>
    where?: TenantWhereInput
  }

  export type TenantUpdateToOneWithWhereWithoutPembinaanInput = {
    where?: TenantWhereInput
    data: XOR<TenantUpdateWithoutPembinaanInput, TenantUncheckedUpdateWithoutPembinaanInput>
  }

  export type TenantUpdateWithoutPembinaanInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    adminUserId?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    plan?: StringFieldUpdateOperationsInput | string
    billingContact?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    settings?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutTenantNestedInput
    santri?: SantriUpdateManyWithoutTenantNestedInput
    wali?: WaliUpdateManyWithoutTenantNestedInput
    izin?: IzinUpdateManyWithoutTenantNestedInput
    catatanHarian?: CatatanHarianUpdateManyWithoutTenantNestedInput
    pengumuman?: PengumumanUpdateManyWithoutTenantNestedInput
    invoices?: InvoiceUpdateManyWithoutTenantNestedInput
    pelanggaran?: PelanggaranUpdateManyWithoutTenantNestedInput
    kunjungan?: KunjunganUpdateManyWithoutTenantNestedInput
    healthRecords?: HealthRecordUpdateManyWithoutTenantNestedInput
    auditLogs?: AuditLogUpdateManyWithoutTenantNestedInput
    notifications?: NotificationUpdateManyWithoutTenantNestedInput
    webhookEvents?: WebhookEventUpdateManyWithoutTenantNestedInput
    tahfidz?: TahfidzUpdateManyWithoutTenantNestedInput
    mutabaah?: MutabaahUpdateManyWithoutTenantNestedInput
    wallets?: WalletUpdateManyWithoutTenantNestedInput
    employees?: EmployeeUpdateManyWithoutTenantNestedInput
    payrolls?: PayrollUpdateManyWithoutTenantNestedInput
    academicScheds?: AcademicScheduleUpdateManyWithoutTenantNestedInput
    attendances?: AttendanceUpdateManyWithoutTenantNestedInput
    grades?: GradeUpdateManyWithoutTenantNestedInput
    ppdbRegistrations?: PpdbRegistrationUpdateManyWithoutTenantNestedInput
    ppdbDocuments?: PpdbDocumentUpdateManyWithoutTenantNestedInput
    ppdbExams?: PpdbExamUpdateManyWithoutTenantNestedInput
    inventoryItems?: ItemUpdateManyWithoutTenantNestedInput
    inventoryTransactions?: InventoryTransactionUpdateManyWithoutTenantNestedInput
    suppliers?: SupplierUpdateManyWithoutTenantNestedInput
    purchaseOrders?: PurchaseOrderUpdateManyWithoutTenantNestedInput
    buildings?: BuildingUpdateManyWithoutTenantNestedInput
    rooms?: RoomUpdateManyWithoutTenantNestedInput
    roomAssignments?: RoomAssignmentUpdateManyWithoutTenantNestedInput
    maintenanceTickets?: MaintenanceTicketUpdateManyWithoutTenantNestedInput
  }

  export type TenantUncheckedUpdateWithoutPembinaanInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    adminUserId?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    plan?: StringFieldUpdateOperationsInput | string
    billingContact?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    settings?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutTenantNestedInput
    santri?: SantriUncheckedUpdateManyWithoutTenantNestedInput
    wali?: WaliUncheckedUpdateManyWithoutTenantNestedInput
    izin?: IzinUncheckedUpdateManyWithoutTenantNestedInput
    catatanHarian?: CatatanHarianUncheckedUpdateManyWithoutTenantNestedInput
    pengumuman?: PengumumanUncheckedUpdateManyWithoutTenantNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutTenantNestedInput
    pelanggaran?: PelanggaranUncheckedUpdateManyWithoutTenantNestedInput
    kunjungan?: KunjunganUncheckedUpdateManyWithoutTenantNestedInput
    healthRecords?: HealthRecordUncheckedUpdateManyWithoutTenantNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutTenantNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutTenantNestedInput
    webhookEvents?: WebhookEventUncheckedUpdateManyWithoutTenantNestedInput
    tahfidz?: TahfidzUncheckedUpdateManyWithoutTenantNestedInput
    mutabaah?: MutabaahUncheckedUpdateManyWithoutTenantNestedInput
    wallets?: WalletUncheckedUpdateManyWithoutTenantNestedInput
    employees?: EmployeeUncheckedUpdateManyWithoutTenantNestedInput
    payrolls?: PayrollUncheckedUpdateManyWithoutTenantNestedInput
    academicScheds?: AcademicScheduleUncheckedUpdateManyWithoutTenantNestedInput
    attendances?: AttendanceUncheckedUpdateManyWithoutTenantNestedInput
    grades?: GradeUncheckedUpdateManyWithoutTenantNestedInput
    ppdbRegistrations?: PpdbRegistrationUncheckedUpdateManyWithoutTenantNestedInput
    ppdbDocuments?: PpdbDocumentUncheckedUpdateManyWithoutTenantNestedInput
    ppdbExams?: PpdbExamUncheckedUpdateManyWithoutTenantNestedInput
    inventoryItems?: ItemUncheckedUpdateManyWithoutTenantNestedInput
    inventoryTransactions?: InventoryTransactionUncheckedUpdateManyWithoutTenantNestedInput
    suppliers?: SupplierUncheckedUpdateManyWithoutTenantNestedInput
    purchaseOrders?: PurchaseOrderUncheckedUpdateManyWithoutTenantNestedInput
    buildings?: BuildingUncheckedUpdateManyWithoutTenantNestedInput
    rooms?: RoomUncheckedUpdateManyWithoutTenantNestedInput
    roomAssignments?: RoomAssignmentUncheckedUpdateManyWithoutTenantNestedInput
    maintenanceTickets?: MaintenanceTicketUncheckedUpdateManyWithoutTenantNestedInput
  }

  export type SantriUpsertWithoutPembinaanInput = {
    update: XOR<SantriUpdateWithoutPembinaanInput, SantriUncheckedUpdateWithoutPembinaanInput>
    create: XOR<SantriCreateWithoutPembinaanInput, SantriUncheckedCreateWithoutPembinaanInput>
    where?: SantriWhereInput
  }

  export type SantriUpdateToOneWithWhereWithoutPembinaanInput = {
    where?: SantriWhereInput
    data: XOR<SantriUpdateWithoutPembinaanInput, SantriUncheckedUpdateWithoutPembinaanInput>
  }

  export type SantriUpdateWithoutPembinaanInput = {
    id?: StringFieldUpdateOperationsInput | string
    nisn?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    gender?: StringFieldUpdateOperationsInput | string
    dob?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    kelas?: NullableStringFieldUpdateOperationsInput | string | null
    room?: NullableStringFieldUpdateOperationsInput | string | null
    contact?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutSantriNestedInput
    walis?: SantriWaliUpdateManyWithoutSantriNestedInput
    izin?: IzinUpdateManyWithoutSantriNestedInput
    catatanHarian?: CatatanHarianUpdateManyWithoutSantriNestedInput
    invoices?: InvoiceUpdateManyWithoutSantriNestedInput
    pelanggaran?: PelanggaranUpdateManyWithoutSantriNestedInput
    kunjungan?: KunjunganUpdateManyWithoutSantriNestedInput
    healthRecords?: HealthRecordUpdateManyWithoutSantriNestedInput
    medications?: MedicationUpdateManyWithoutSantriNestedInput
    tahfidz?: TahfidzUpdateManyWithoutSantriNestedInput
    mutabaah?: MutabaahUpdateManyWithoutSantriNestedInput
    wallet?: WalletUpdateOneWithoutSantriNestedInput
    attendances?: AttendanceUpdateManyWithoutSantriNestedInput
    grades?: GradeUpdateManyWithoutSantriNestedInput
  }

  export type SantriUncheckedUpdateWithoutPembinaanInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    nisn?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    gender?: StringFieldUpdateOperationsInput | string
    dob?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    kelas?: NullableStringFieldUpdateOperationsInput | string | null
    room?: NullableStringFieldUpdateOperationsInput | string | null
    contact?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    walis?: SantriWaliUncheckedUpdateManyWithoutSantriNestedInput
    izin?: IzinUncheckedUpdateManyWithoutSantriNestedInput
    catatanHarian?: CatatanHarianUncheckedUpdateManyWithoutSantriNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutSantriNestedInput
    pelanggaran?: PelanggaranUncheckedUpdateManyWithoutSantriNestedInput
    kunjungan?: KunjunganUncheckedUpdateManyWithoutSantriNestedInput
    healthRecords?: HealthRecordUncheckedUpdateManyWithoutSantriNestedInput
    medications?: MedicationUncheckedUpdateManyWithoutSantriNestedInput
    tahfidz?: TahfidzUncheckedUpdateManyWithoutSantriNestedInput
    mutabaah?: MutabaahUncheckedUpdateManyWithoutSantriNestedInput
    wallet?: WalletUncheckedUpdateOneWithoutSantriNestedInput
    attendances?: AttendanceUncheckedUpdateManyWithoutSantriNestedInput
    grades?: GradeUncheckedUpdateManyWithoutSantriNestedInput
  }

  export type TenantCreateWithoutKunjunganInput = {
    id?: string
    name: string
    address?: string | null
    phone?: string | null
    adminUserId?: string | null
    timezone?: string
    plan?: string
    billingContact?: string | null
    status?: string
    settings?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutTenantInput
    santri?: SantriCreateNestedManyWithoutTenantInput
    wali?: WaliCreateNestedManyWithoutTenantInput
    izin?: IzinCreateNestedManyWithoutTenantInput
    catatanHarian?: CatatanHarianCreateNestedManyWithoutTenantInput
    pengumuman?: PengumumanCreateNestedManyWithoutTenantInput
    invoices?: InvoiceCreateNestedManyWithoutTenantInput
    pelanggaran?: PelanggaranCreateNestedManyWithoutTenantInput
    pembinaan?: PembinaanCreateNestedManyWithoutTenantInput
    healthRecords?: HealthRecordCreateNestedManyWithoutTenantInput
    auditLogs?: AuditLogCreateNestedManyWithoutTenantInput
    notifications?: NotificationCreateNestedManyWithoutTenantInput
    webhookEvents?: WebhookEventCreateNestedManyWithoutTenantInput
    tahfidz?: TahfidzCreateNestedManyWithoutTenantInput
    mutabaah?: MutabaahCreateNestedManyWithoutTenantInput
    wallets?: WalletCreateNestedManyWithoutTenantInput
    employees?: EmployeeCreateNestedManyWithoutTenantInput
    payrolls?: PayrollCreateNestedManyWithoutTenantInput
    academicScheds?: AcademicScheduleCreateNestedManyWithoutTenantInput
    attendances?: AttendanceCreateNestedManyWithoutTenantInput
    grades?: GradeCreateNestedManyWithoutTenantInput
    ppdbRegistrations?: PpdbRegistrationCreateNestedManyWithoutTenantInput
    ppdbDocuments?: PpdbDocumentCreateNestedManyWithoutTenantInput
    ppdbExams?: PpdbExamCreateNestedManyWithoutTenantInput
    inventoryItems?: ItemCreateNestedManyWithoutTenantInput
    inventoryTransactions?: InventoryTransactionCreateNestedManyWithoutTenantInput
    suppliers?: SupplierCreateNestedManyWithoutTenantInput
    purchaseOrders?: PurchaseOrderCreateNestedManyWithoutTenantInput
    buildings?: BuildingCreateNestedManyWithoutTenantInput
    rooms?: RoomCreateNestedManyWithoutTenantInput
    roomAssignments?: RoomAssignmentCreateNestedManyWithoutTenantInput
    maintenanceTickets?: MaintenanceTicketCreateNestedManyWithoutTenantInput
  }

  export type TenantUncheckedCreateWithoutKunjunganInput = {
    id?: string
    name: string
    address?: string | null
    phone?: string | null
    adminUserId?: string | null
    timezone?: string
    plan?: string
    billingContact?: string | null
    status?: string
    settings?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutTenantInput
    santri?: SantriUncheckedCreateNestedManyWithoutTenantInput
    wali?: WaliUncheckedCreateNestedManyWithoutTenantInput
    izin?: IzinUncheckedCreateNestedManyWithoutTenantInput
    catatanHarian?: CatatanHarianUncheckedCreateNestedManyWithoutTenantInput
    pengumuman?: PengumumanUncheckedCreateNestedManyWithoutTenantInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutTenantInput
    pelanggaran?: PelanggaranUncheckedCreateNestedManyWithoutTenantInput
    pembinaan?: PembinaanUncheckedCreateNestedManyWithoutTenantInput
    healthRecords?: HealthRecordUncheckedCreateNestedManyWithoutTenantInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutTenantInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutTenantInput
    webhookEvents?: WebhookEventUncheckedCreateNestedManyWithoutTenantInput
    tahfidz?: TahfidzUncheckedCreateNestedManyWithoutTenantInput
    mutabaah?: MutabaahUncheckedCreateNestedManyWithoutTenantInput
    wallets?: WalletUncheckedCreateNestedManyWithoutTenantInput
    employees?: EmployeeUncheckedCreateNestedManyWithoutTenantInput
    payrolls?: PayrollUncheckedCreateNestedManyWithoutTenantInput
    academicScheds?: AcademicScheduleUncheckedCreateNestedManyWithoutTenantInput
    attendances?: AttendanceUncheckedCreateNestedManyWithoutTenantInput
    grades?: GradeUncheckedCreateNestedManyWithoutTenantInput
    ppdbRegistrations?: PpdbRegistrationUncheckedCreateNestedManyWithoutTenantInput
    ppdbDocuments?: PpdbDocumentUncheckedCreateNestedManyWithoutTenantInput
    ppdbExams?: PpdbExamUncheckedCreateNestedManyWithoutTenantInput
    inventoryItems?: ItemUncheckedCreateNestedManyWithoutTenantInput
    inventoryTransactions?: InventoryTransactionUncheckedCreateNestedManyWithoutTenantInput
    suppliers?: SupplierUncheckedCreateNestedManyWithoutTenantInput
    purchaseOrders?: PurchaseOrderUncheckedCreateNestedManyWithoutTenantInput
    buildings?: BuildingUncheckedCreateNestedManyWithoutTenantInput
    rooms?: RoomUncheckedCreateNestedManyWithoutTenantInput
    roomAssignments?: RoomAssignmentUncheckedCreateNestedManyWithoutTenantInput
    maintenanceTickets?: MaintenanceTicketUncheckedCreateNestedManyWithoutTenantInput
  }

  export type TenantCreateOrConnectWithoutKunjunganInput = {
    where: TenantWhereUniqueInput
    create: XOR<TenantCreateWithoutKunjunganInput, TenantUncheckedCreateWithoutKunjunganInput>
  }

  export type SantriCreateWithoutKunjunganInput = {
    id?: string
    nisn?: string | null
    name: string
    gender: string
    dob?: Date | string | null
    kelas?: string | null
    room?: string | null
    contact?: string | null
    address?: string | null
    photo?: string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutSantriInput
    walis?: SantriWaliCreateNestedManyWithoutSantriInput
    izin?: IzinCreateNestedManyWithoutSantriInput
    catatanHarian?: CatatanHarianCreateNestedManyWithoutSantriInput
    invoices?: InvoiceCreateNestedManyWithoutSantriInput
    pelanggaran?: PelanggaranCreateNestedManyWithoutSantriInput
    pembinaan?: PembinaanCreateNestedManyWithoutSantriInput
    healthRecords?: HealthRecordCreateNestedManyWithoutSantriInput
    medications?: MedicationCreateNestedManyWithoutSantriInput
    tahfidz?: TahfidzCreateNestedManyWithoutSantriInput
    mutabaah?: MutabaahCreateNestedManyWithoutSantriInput
    wallet?: WalletCreateNestedOneWithoutSantriInput
    attendances?: AttendanceCreateNestedManyWithoutSantriInput
    grades?: GradeCreateNestedManyWithoutSantriInput
  }

  export type SantriUncheckedCreateWithoutKunjunganInput = {
    id?: string
    tenantId: string
    nisn?: string | null
    name: string
    gender: string
    dob?: Date | string | null
    kelas?: string | null
    room?: string | null
    contact?: string | null
    address?: string | null
    photo?: string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    walis?: SantriWaliUncheckedCreateNestedManyWithoutSantriInput
    izin?: IzinUncheckedCreateNestedManyWithoutSantriInput
    catatanHarian?: CatatanHarianUncheckedCreateNestedManyWithoutSantriInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutSantriInput
    pelanggaran?: PelanggaranUncheckedCreateNestedManyWithoutSantriInput
    pembinaan?: PembinaanUncheckedCreateNestedManyWithoutSantriInput
    healthRecords?: HealthRecordUncheckedCreateNestedManyWithoutSantriInput
    medications?: MedicationUncheckedCreateNestedManyWithoutSantriInput
    tahfidz?: TahfidzUncheckedCreateNestedManyWithoutSantriInput
    mutabaah?: MutabaahUncheckedCreateNestedManyWithoutSantriInput
    wallet?: WalletUncheckedCreateNestedOneWithoutSantriInput
    attendances?: AttendanceUncheckedCreateNestedManyWithoutSantriInput
    grades?: GradeUncheckedCreateNestedManyWithoutSantriInput
  }

  export type SantriCreateOrConnectWithoutKunjunganInput = {
    where: SantriWhereUniqueInput
    create: XOR<SantriCreateWithoutKunjunganInput, SantriUncheckedCreateWithoutKunjunganInput>
  }

  export type TamuCreateWithoutKunjunganInput = {
    id?: string
    name: string
    phone?: string | null
    idNumber?: string | null
    checkinAt?: Date | string | null
    createdAt?: Date | string
  }

  export type TamuUncheckedCreateWithoutKunjunganInput = {
    id?: string
    name: string
    phone?: string | null
    idNumber?: string | null
    checkinAt?: Date | string | null
    createdAt?: Date | string
  }

  export type TamuCreateOrConnectWithoutKunjunganInput = {
    where: TamuWhereUniqueInput
    create: XOR<TamuCreateWithoutKunjunganInput, TamuUncheckedCreateWithoutKunjunganInput>
  }

  export type TamuCreateManyKunjunganInputEnvelope = {
    data: TamuCreateManyKunjunganInput | TamuCreateManyKunjunganInput[]
  }

  export type TenantUpsertWithoutKunjunganInput = {
    update: XOR<TenantUpdateWithoutKunjunganInput, TenantUncheckedUpdateWithoutKunjunganInput>
    create: XOR<TenantCreateWithoutKunjunganInput, TenantUncheckedCreateWithoutKunjunganInput>
    where?: TenantWhereInput
  }

  export type TenantUpdateToOneWithWhereWithoutKunjunganInput = {
    where?: TenantWhereInput
    data: XOR<TenantUpdateWithoutKunjunganInput, TenantUncheckedUpdateWithoutKunjunganInput>
  }

  export type TenantUpdateWithoutKunjunganInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    adminUserId?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    plan?: StringFieldUpdateOperationsInput | string
    billingContact?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    settings?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutTenantNestedInput
    santri?: SantriUpdateManyWithoutTenantNestedInput
    wali?: WaliUpdateManyWithoutTenantNestedInput
    izin?: IzinUpdateManyWithoutTenantNestedInput
    catatanHarian?: CatatanHarianUpdateManyWithoutTenantNestedInput
    pengumuman?: PengumumanUpdateManyWithoutTenantNestedInput
    invoices?: InvoiceUpdateManyWithoutTenantNestedInput
    pelanggaran?: PelanggaranUpdateManyWithoutTenantNestedInput
    pembinaan?: PembinaanUpdateManyWithoutTenantNestedInput
    healthRecords?: HealthRecordUpdateManyWithoutTenantNestedInput
    auditLogs?: AuditLogUpdateManyWithoutTenantNestedInput
    notifications?: NotificationUpdateManyWithoutTenantNestedInput
    webhookEvents?: WebhookEventUpdateManyWithoutTenantNestedInput
    tahfidz?: TahfidzUpdateManyWithoutTenantNestedInput
    mutabaah?: MutabaahUpdateManyWithoutTenantNestedInput
    wallets?: WalletUpdateManyWithoutTenantNestedInput
    employees?: EmployeeUpdateManyWithoutTenantNestedInput
    payrolls?: PayrollUpdateManyWithoutTenantNestedInput
    academicScheds?: AcademicScheduleUpdateManyWithoutTenantNestedInput
    attendances?: AttendanceUpdateManyWithoutTenantNestedInput
    grades?: GradeUpdateManyWithoutTenantNestedInput
    ppdbRegistrations?: PpdbRegistrationUpdateManyWithoutTenantNestedInput
    ppdbDocuments?: PpdbDocumentUpdateManyWithoutTenantNestedInput
    ppdbExams?: PpdbExamUpdateManyWithoutTenantNestedInput
    inventoryItems?: ItemUpdateManyWithoutTenantNestedInput
    inventoryTransactions?: InventoryTransactionUpdateManyWithoutTenantNestedInput
    suppliers?: SupplierUpdateManyWithoutTenantNestedInput
    purchaseOrders?: PurchaseOrderUpdateManyWithoutTenantNestedInput
    buildings?: BuildingUpdateManyWithoutTenantNestedInput
    rooms?: RoomUpdateManyWithoutTenantNestedInput
    roomAssignments?: RoomAssignmentUpdateManyWithoutTenantNestedInput
    maintenanceTickets?: MaintenanceTicketUpdateManyWithoutTenantNestedInput
  }

  export type TenantUncheckedUpdateWithoutKunjunganInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    adminUserId?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    plan?: StringFieldUpdateOperationsInput | string
    billingContact?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    settings?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutTenantNestedInput
    santri?: SantriUncheckedUpdateManyWithoutTenantNestedInput
    wali?: WaliUncheckedUpdateManyWithoutTenantNestedInput
    izin?: IzinUncheckedUpdateManyWithoutTenantNestedInput
    catatanHarian?: CatatanHarianUncheckedUpdateManyWithoutTenantNestedInput
    pengumuman?: PengumumanUncheckedUpdateManyWithoutTenantNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutTenantNestedInput
    pelanggaran?: PelanggaranUncheckedUpdateManyWithoutTenantNestedInput
    pembinaan?: PembinaanUncheckedUpdateManyWithoutTenantNestedInput
    healthRecords?: HealthRecordUncheckedUpdateManyWithoutTenantNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutTenantNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutTenantNestedInput
    webhookEvents?: WebhookEventUncheckedUpdateManyWithoutTenantNestedInput
    tahfidz?: TahfidzUncheckedUpdateManyWithoutTenantNestedInput
    mutabaah?: MutabaahUncheckedUpdateManyWithoutTenantNestedInput
    wallets?: WalletUncheckedUpdateManyWithoutTenantNestedInput
    employees?: EmployeeUncheckedUpdateManyWithoutTenantNestedInput
    payrolls?: PayrollUncheckedUpdateManyWithoutTenantNestedInput
    academicScheds?: AcademicScheduleUncheckedUpdateManyWithoutTenantNestedInput
    attendances?: AttendanceUncheckedUpdateManyWithoutTenantNestedInput
    grades?: GradeUncheckedUpdateManyWithoutTenantNestedInput
    ppdbRegistrations?: PpdbRegistrationUncheckedUpdateManyWithoutTenantNestedInput
    ppdbDocuments?: PpdbDocumentUncheckedUpdateManyWithoutTenantNestedInput
    ppdbExams?: PpdbExamUncheckedUpdateManyWithoutTenantNestedInput
    inventoryItems?: ItemUncheckedUpdateManyWithoutTenantNestedInput
    inventoryTransactions?: InventoryTransactionUncheckedUpdateManyWithoutTenantNestedInput
    suppliers?: SupplierUncheckedUpdateManyWithoutTenantNestedInput
    purchaseOrders?: PurchaseOrderUncheckedUpdateManyWithoutTenantNestedInput
    buildings?: BuildingUncheckedUpdateManyWithoutTenantNestedInput
    rooms?: RoomUncheckedUpdateManyWithoutTenantNestedInput
    roomAssignments?: RoomAssignmentUncheckedUpdateManyWithoutTenantNestedInput
    maintenanceTickets?: MaintenanceTicketUncheckedUpdateManyWithoutTenantNestedInput
  }

  export type SantriUpsertWithoutKunjunganInput = {
    update: XOR<SantriUpdateWithoutKunjunganInput, SantriUncheckedUpdateWithoutKunjunganInput>
    create: XOR<SantriCreateWithoutKunjunganInput, SantriUncheckedCreateWithoutKunjunganInput>
    where?: SantriWhereInput
  }

  export type SantriUpdateToOneWithWhereWithoutKunjunganInput = {
    where?: SantriWhereInput
    data: XOR<SantriUpdateWithoutKunjunganInput, SantriUncheckedUpdateWithoutKunjunganInput>
  }

  export type SantriUpdateWithoutKunjunganInput = {
    id?: StringFieldUpdateOperationsInput | string
    nisn?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    gender?: StringFieldUpdateOperationsInput | string
    dob?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    kelas?: NullableStringFieldUpdateOperationsInput | string | null
    room?: NullableStringFieldUpdateOperationsInput | string | null
    contact?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutSantriNestedInput
    walis?: SantriWaliUpdateManyWithoutSantriNestedInput
    izin?: IzinUpdateManyWithoutSantriNestedInput
    catatanHarian?: CatatanHarianUpdateManyWithoutSantriNestedInput
    invoices?: InvoiceUpdateManyWithoutSantriNestedInput
    pelanggaran?: PelanggaranUpdateManyWithoutSantriNestedInput
    pembinaan?: PembinaanUpdateManyWithoutSantriNestedInput
    healthRecords?: HealthRecordUpdateManyWithoutSantriNestedInput
    medications?: MedicationUpdateManyWithoutSantriNestedInput
    tahfidz?: TahfidzUpdateManyWithoutSantriNestedInput
    mutabaah?: MutabaahUpdateManyWithoutSantriNestedInput
    wallet?: WalletUpdateOneWithoutSantriNestedInput
    attendances?: AttendanceUpdateManyWithoutSantriNestedInput
    grades?: GradeUpdateManyWithoutSantriNestedInput
  }

  export type SantriUncheckedUpdateWithoutKunjunganInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    nisn?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    gender?: StringFieldUpdateOperationsInput | string
    dob?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    kelas?: NullableStringFieldUpdateOperationsInput | string | null
    room?: NullableStringFieldUpdateOperationsInput | string | null
    contact?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    walis?: SantriWaliUncheckedUpdateManyWithoutSantriNestedInput
    izin?: IzinUncheckedUpdateManyWithoutSantriNestedInput
    catatanHarian?: CatatanHarianUncheckedUpdateManyWithoutSantriNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutSantriNestedInput
    pelanggaran?: PelanggaranUncheckedUpdateManyWithoutSantriNestedInput
    pembinaan?: PembinaanUncheckedUpdateManyWithoutSantriNestedInput
    healthRecords?: HealthRecordUncheckedUpdateManyWithoutSantriNestedInput
    medications?: MedicationUncheckedUpdateManyWithoutSantriNestedInput
    tahfidz?: TahfidzUncheckedUpdateManyWithoutSantriNestedInput
    mutabaah?: MutabaahUncheckedUpdateManyWithoutSantriNestedInput
    wallet?: WalletUncheckedUpdateOneWithoutSantriNestedInput
    attendances?: AttendanceUncheckedUpdateManyWithoutSantriNestedInput
    grades?: GradeUncheckedUpdateManyWithoutSantriNestedInput
  }

  export type TamuUpsertWithWhereUniqueWithoutKunjunganInput = {
    where: TamuWhereUniqueInput
    update: XOR<TamuUpdateWithoutKunjunganInput, TamuUncheckedUpdateWithoutKunjunganInput>
    create: XOR<TamuCreateWithoutKunjunganInput, TamuUncheckedCreateWithoutKunjunganInput>
  }

  export type TamuUpdateWithWhereUniqueWithoutKunjunganInput = {
    where: TamuWhereUniqueInput
    data: XOR<TamuUpdateWithoutKunjunganInput, TamuUncheckedUpdateWithoutKunjunganInput>
  }

  export type TamuUpdateManyWithWhereWithoutKunjunganInput = {
    where: TamuScalarWhereInput
    data: XOR<TamuUpdateManyMutationInput, TamuUncheckedUpdateManyWithoutKunjunganInput>
  }

  export type TamuScalarWhereInput = {
    AND?: TamuScalarWhereInput | TamuScalarWhereInput[]
    OR?: TamuScalarWhereInput[]
    NOT?: TamuScalarWhereInput | TamuScalarWhereInput[]
    id?: StringFilter<"Tamu"> | string
    kunjunganId?: StringFilter<"Tamu"> | string
    name?: StringFilter<"Tamu"> | string
    phone?: StringNullableFilter<"Tamu"> | string | null
    idNumber?: StringNullableFilter<"Tamu"> | string | null
    checkinAt?: DateTimeNullableFilter<"Tamu"> | Date | string | null
    createdAt?: DateTimeFilter<"Tamu"> | Date | string
  }

  export type KunjunganCreateWithoutTamuInput = {
    id?: string
    scheduledAt: Date | string
    slot: string
    visitorLimit?: number
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutKunjunganInput
    santri: SantriCreateNestedOneWithoutKunjunganInput
  }

  export type KunjunganUncheckedCreateWithoutTamuInput = {
    id?: string
    tenantId: string
    santriId: string
    scheduledAt: Date | string
    slot: string
    visitorLimit?: number
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type KunjunganCreateOrConnectWithoutTamuInput = {
    where: KunjunganWhereUniqueInput
    create: XOR<KunjunganCreateWithoutTamuInput, KunjunganUncheckedCreateWithoutTamuInput>
  }

  export type KunjunganUpsertWithoutTamuInput = {
    update: XOR<KunjunganUpdateWithoutTamuInput, KunjunganUncheckedUpdateWithoutTamuInput>
    create: XOR<KunjunganCreateWithoutTamuInput, KunjunganUncheckedCreateWithoutTamuInput>
    where?: KunjunganWhereInput
  }

  export type KunjunganUpdateToOneWithWhereWithoutTamuInput = {
    where?: KunjunganWhereInput
    data: XOR<KunjunganUpdateWithoutTamuInput, KunjunganUncheckedUpdateWithoutTamuInput>
  }

  export type KunjunganUpdateWithoutTamuInput = {
    id?: StringFieldUpdateOperationsInput | string
    scheduledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    slot?: StringFieldUpdateOperationsInput | string
    visitorLimit?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutKunjunganNestedInput
    santri?: SantriUpdateOneRequiredWithoutKunjunganNestedInput
  }

  export type KunjunganUncheckedUpdateWithoutTamuInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    santriId?: StringFieldUpdateOperationsInput | string
    scheduledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    slot?: StringFieldUpdateOperationsInput | string
    visitorLimit?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TenantCreateWithoutHealthRecordsInput = {
    id?: string
    name: string
    address?: string | null
    phone?: string | null
    adminUserId?: string | null
    timezone?: string
    plan?: string
    billingContact?: string | null
    status?: string
    settings?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutTenantInput
    santri?: SantriCreateNestedManyWithoutTenantInput
    wali?: WaliCreateNestedManyWithoutTenantInput
    izin?: IzinCreateNestedManyWithoutTenantInput
    catatanHarian?: CatatanHarianCreateNestedManyWithoutTenantInput
    pengumuman?: PengumumanCreateNestedManyWithoutTenantInput
    invoices?: InvoiceCreateNestedManyWithoutTenantInput
    pelanggaran?: PelanggaranCreateNestedManyWithoutTenantInput
    pembinaan?: PembinaanCreateNestedManyWithoutTenantInput
    kunjungan?: KunjunganCreateNestedManyWithoutTenantInput
    auditLogs?: AuditLogCreateNestedManyWithoutTenantInput
    notifications?: NotificationCreateNestedManyWithoutTenantInput
    webhookEvents?: WebhookEventCreateNestedManyWithoutTenantInput
    tahfidz?: TahfidzCreateNestedManyWithoutTenantInput
    mutabaah?: MutabaahCreateNestedManyWithoutTenantInput
    wallets?: WalletCreateNestedManyWithoutTenantInput
    employees?: EmployeeCreateNestedManyWithoutTenantInput
    payrolls?: PayrollCreateNestedManyWithoutTenantInput
    academicScheds?: AcademicScheduleCreateNestedManyWithoutTenantInput
    attendances?: AttendanceCreateNestedManyWithoutTenantInput
    grades?: GradeCreateNestedManyWithoutTenantInput
    ppdbRegistrations?: PpdbRegistrationCreateNestedManyWithoutTenantInput
    ppdbDocuments?: PpdbDocumentCreateNestedManyWithoutTenantInput
    ppdbExams?: PpdbExamCreateNestedManyWithoutTenantInput
    inventoryItems?: ItemCreateNestedManyWithoutTenantInput
    inventoryTransactions?: InventoryTransactionCreateNestedManyWithoutTenantInput
    suppliers?: SupplierCreateNestedManyWithoutTenantInput
    purchaseOrders?: PurchaseOrderCreateNestedManyWithoutTenantInput
    buildings?: BuildingCreateNestedManyWithoutTenantInput
    rooms?: RoomCreateNestedManyWithoutTenantInput
    roomAssignments?: RoomAssignmentCreateNestedManyWithoutTenantInput
    maintenanceTickets?: MaintenanceTicketCreateNestedManyWithoutTenantInput
  }

  export type TenantUncheckedCreateWithoutHealthRecordsInput = {
    id?: string
    name: string
    address?: string | null
    phone?: string | null
    adminUserId?: string | null
    timezone?: string
    plan?: string
    billingContact?: string | null
    status?: string
    settings?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutTenantInput
    santri?: SantriUncheckedCreateNestedManyWithoutTenantInput
    wali?: WaliUncheckedCreateNestedManyWithoutTenantInput
    izin?: IzinUncheckedCreateNestedManyWithoutTenantInput
    catatanHarian?: CatatanHarianUncheckedCreateNestedManyWithoutTenantInput
    pengumuman?: PengumumanUncheckedCreateNestedManyWithoutTenantInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutTenantInput
    pelanggaran?: PelanggaranUncheckedCreateNestedManyWithoutTenantInput
    pembinaan?: PembinaanUncheckedCreateNestedManyWithoutTenantInput
    kunjungan?: KunjunganUncheckedCreateNestedManyWithoutTenantInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutTenantInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutTenantInput
    webhookEvents?: WebhookEventUncheckedCreateNestedManyWithoutTenantInput
    tahfidz?: TahfidzUncheckedCreateNestedManyWithoutTenantInput
    mutabaah?: MutabaahUncheckedCreateNestedManyWithoutTenantInput
    wallets?: WalletUncheckedCreateNestedManyWithoutTenantInput
    employees?: EmployeeUncheckedCreateNestedManyWithoutTenantInput
    payrolls?: PayrollUncheckedCreateNestedManyWithoutTenantInput
    academicScheds?: AcademicScheduleUncheckedCreateNestedManyWithoutTenantInput
    attendances?: AttendanceUncheckedCreateNestedManyWithoutTenantInput
    grades?: GradeUncheckedCreateNestedManyWithoutTenantInput
    ppdbRegistrations?: PpdbRegistrationUncheckedCreateNestedManyWithoutTenantInput
    ppdbDocuments?: PpdbDocumentUncheckedCreateNestedManyWithoutTenantInput
    ppdbExams?: PpdbExamUncheckedCreateNestedManyWithoutTenantInput
    inventoryItems?: ItemUncheckedCreateNestedManyWithoutTenantInput
    inventoryTransactions?: InventoryTransactionUncheckedCreateNestedManyWithoutTenantInput
    suppliers?: SupplierUncheckedCreateNestedManyWithoutTenantInput
    purchaseOrders?: PurchaseOrderUncheckedCreateNestedManyWithoutTenantInput
    buildings?: BuildingUncheckedCreateNestedManyWithoutTenantInput
    rooms?: RoomUncheckedCreateNestedManyWithoutTenantInput
    roomAssignments?: RoomAssignmentUncheckedCreateNestedManyWithoutTenantInput
    maintenanceTickets?: MaintenanceTicketUncheckedCreateNestedManyWithoutTenantInput
  }

  export type TenantCreateOrConnectWithoutHealthRecordsInput = {
    where: TenantWhereUniqueInput
    create: XOR<TenantCreateWithoutHealthRecordsInput, TenantUncheckedCreateWithoutHealthRecordsInput>
  }

  export type SantriCreateWithoutHealthRecordsInput = {
    id?: string
    nisn?: string | null
    name: string
    gender: string
    dob?: Date | string | null
    kelas?: string | null
    room?: string | null
    contact?: string | null
    address?: string | null
    photo?: string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutSantriInput
    walis?: SantriWaliCreateNestedManyWithoutSantriInput
    izin?: IzinCreateNestedManyWithoutSantriInput
    catatanHarian?: CatatanHarianCreateNestedManyWithoutSantriInput
    invoices?: InvoiceCreateNestedManyWithoutSantriInput
    pelanggaran?: PelanggaranCreateNestedManyWithoutSantriInput
    pembinaan?: PembinaanCreateNestedManyWithoutSantriInput
    kunjungan?: KunjunganCreateNestedManyWithoutSantriInput
    medications?: MedicationCreateNestedManyWithoutSantriInput
    tahfidz?: TahfidzCreateNestedManyWithoutSantriInput
    mutabaah?: MutabaahCreateNestedManyWithoutSantriInput
    wallet?: WalletCreateNestedOneWithoutSantriInput
    attendances?: AttendanceCreateNestedManyWithoutSantriInput
    grades?: GradeCreateNestedManyWithoutSantriInput
  }

  export type SantriUncheckedCreateWithoutHealthRecordsInput = {
    id?: string
    tenantId: string
    nisn?: string | null
    name: string
    gender: string
    dob?: Date | string | null
    kelas?: string | null
    room?: string | null
    contact?: string | null
    address?: string | null
    photo?: string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    walis?: SantriWaliUncheckedCreateNestedManyWithoutSantriInput
    izin?: IzinUncheckedCreateNestedManyWithoutSantriInput
    catatanHarian?: CatatanHarianUncheckedCreateNestedManyWithoutSantriInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutSantriInput
    pelanggaran?: PelanggaranUncheckedCreateNestedManyWithoutSantriInput
    pembinaan?: PembinaanUncheckedCreateNestedManyWithoutSantriInput
    kunjungan?: KunjunganUncheckedCreateNestedManyWithoutSantriInput
    medications?: MedicationUncheckedCreateNestedManyWithoutSantriInput
    tahfidz?: TahfidzUncheckedCreateNestedManyWithoutSantriInput
    mutabaah?: MutabaahUncheckedCreateNestedManyWithoutSantriInput
    wallet?: WalletUncheckedCreateNestedOneWithoutSantriInput
    attendances?: AttendanceUncheckedCreateNestedManyWithoutSantriInput
    grades?: GradeUncheckedCreateNestedManyWithoutSantriInput
  }

  export type SantriCreateOrConnectWithoutHealthRecordsInput = {
    where: SantriWhereUniqueInput
    create: XOR<SantriCreateWithoutHealthRecordsInput, SantriUncheckedCreateWithoutHealthRecordsInput>
  }

  export type TenantUpsertWithoutHealthRecordsInput = {
    update: XOR<TenantUpdateWithoutHealthRecordsInput, TenantUncheckedUpdateWithoutHealthRecordsInput>
    create: XOR<TenantCreateWithoutHealthRecordsInput, TenantUncheckedCreateWithoutHealthRecordsInput>
    where?: TenantWhereInput
  }

  export type TenantUpdateToOneWithWhereWithoutHealthRecordsInput = {
    where?: TenantWhereInput
    data: XOR<TenantUpdateWithoutHealthRecordsInput, TenantUncheckedUpdateWithoutHealthRecordsInput>
  }

  export type TenantUpdateWithoutHealthRecordsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    adminUserId?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    plan?: StringFieldUpdateOperationsInput | string
    billingContact?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    settings?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutTenantNestedInput
    santri?: SantriUpdateManyWithoutTenantNestedInput
    wali?: WaliUpdateManyWithoutTenantNestedInput
    izin?: IzinUpdateManyWithoutTenantNestedInput
    catatanHarian?: CatatanHarianUpdateManyWithoutTenantNestedInput
    pengumuman?: PengumumanUpdateManyWithoutTenantNestedInput
    invoices?: InvoiceUpdateManyWithoutTenantNestedInput
    pelanggaran?: PelanggaranUpdateManyWithoutTenantNestedInput
    pembinaan?: PembinaanUpdateManyWithoutTenantNestedInput
    kunjungan?: KunjunganUpdateManyWithoutTenantNestedInput
    auditLogs?: AuditLogUpdateManyWithoutTenantNestedInput
    notifications?: NotificationUpdateManyWithoutTenantNestedInput
    webhookEvents?: WebhookEventUpdateManyWithoutTenantNestedInput
    tahfidz?: TahfidzUpdateManyWithoutTenantNestedInput
    mutabaah?: MutabaahUpdateManyWithoutTenantNestedInput
    wallets?: WalletUpdateManyWithoutTenantNestedInput
    employees?: EmployeeUpdateManyWithoutTenantNestedInput
    payrolls?: PayrollUpdateManyWithoutTenantNestedInput
    academicScheds?: AcademicScheduleUpdateManyWithoutTenantNestedInput
    attendances?: AttendanceUpdateManyWithoutTenantNestedInput
    grades?: GradeUpdateManyWithoutTenantNestedInput
    ppdbRegistrations?: PpdbRegistrationUpdateManyWithoutTenantNestedInput
    ppdbDocuments?: PpdbDocumentUpdateManyWithoutTenantNestedInput
    ppdbExams?: PpdbExamUpdateManyWithoutTenantNestedInput
    inventoryItems?: ItemUpdateManyWithoutTenantNestedInput
    inventoryTransactions?: InventoryTransactionUpdateManyWithoutTenantNestedInput
    suppliers?: SupplierUpdateManyWithoutTenantNestedInput
    purchaseOrders?: PurchaseOrderUpdateManyWithoutTenantNestedInput
    buildings?: BuildingUpdateManyWithoutTenantNestedInput
    rooms?: RoomUpdateManyWithoutTenantNestedInput
    roomAssignments?: RoomAssignmentUpdateManyWithoutTenantNestedInput
    maintenanceTickets?: MaintenanceTicketUpdateManyWithoutTenantNestedInput
  }

  export type TenantUncheckedUpdateWithoutHealthRecordsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    adminUserId?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    plan?: StringFieldUpdateOperationsInput | string
    billingContact?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    settings?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutTenantNestedInput
    santri?: SantriUncheckedUpdateManyWithoutTenantNestedInput
    wali?: WaliUncheckedUpdateManyWithoutTenantNestedInput
    izin?: IzinUncheckedUpdateManyWithoutTenantNestedInput
    catatanHarian?: CatatanHarianUncheckedUpdateManyWithoutTenantNestedInput
    pengumuman?: PengumumanUncheckedUpdateManyWithoutTenantNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutTenantNestedInput
    pelanggaran?: PelanggaranUncheckedUpdateManyWithoutTenantNestedInput
    pembinaan?: PembinaanUncheckedUpdateManyWithoutTenantNestedInput
    kunjungan?: KunjunganUncheckedUpdateManyWithoutTenantNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutTenantNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutTenantNestedInput
    webhookEvents?: WebhookEventUncheckedUpdateManyWithoutTenantNestedInput
    tahfidz?: TahfidzUncheckedUpdateManyWithoutTenantNestedInput
    mutabaah?: MutabaahUncheckedUpdateManyWithoutTenantNestedInput
    wallets?: WalletUncheckedUpdateManyWithoutTenantNestedInput
    employees?: EmployeeUncheckedUpdateManyWithoutTenantNestedInput
    payrolls?: PayrollUncheckedUpdateManyWithoutTenantNestedInput
    academicScheds?: AcademicScheduleUncheckedUpdateManyWithoutTenantNestedInput
    attendances?: AttendanceUncheckedUpdateManyWithoutTenantNestedInput
    grades?: GradeUncheckedUpdateManyWithoutTenantNestedInput
    ppdbRegistrations?: PpdbRegistrationUncheckedUpdateManyWithoutTenantNestedInput
    ppdbDocuments?: PpdbDocumentUncheckedUpdateManyWithoutTenantNestedInput
    ppdbExams?: PpdbExamUncheckedUpdateManyWithoutTenantNestedInput
    inventoryItems?: ItemUncheckedUpdateManyWithoutTenantNestedInput
    inventoryTransactions?: InventoryTransactionUncheckedUpdateManyWithoutTenantNestedInput
    suppliers?: SupplierUncheckedUpdateManyWithoutTenantNestedInput
    purchaseOrders?: PurchaseOrderUncheckedUpdateManyWithoutTenantNestedInput
    buildings?: BuildingUncheckedUpdateManyWithoutTenantNestedInput
    rooms?: RoomUncheckedUpdateManyWithoutTenantNestedInput
    roomAssignments?: RoomAssignmentUncheckedUpdateManyWithoutTenantNestedInput
    maintenanceTickets?: MaintenanceTicketUncheckedUpdateManyWithoutTenantNestedInput
  }

  export type SantriUpsertWithoutHealthRecordsInput = {
    update: XOR<SantriUpdateWithoutHealthRecordsInput, SantriUncheckedUpdateWithoutHealthRecordsInput>
    create: XOR<SantriCreateWithoutHealthRecordsInput, SantriUncheckedCreateWithoutHealthRecordsInput>
    where?: SantriWhereInput
  }

  export type SantriUpdateToOneWithWhereWithoutHealthRecordsInput = {
    where?: SantriWhereInput
    data: XOR<SantriUpdateWithoutHealthRecordsInput, SantriUncheckedUpdateWithoutHealthRecordsInput>
  }

  export type SantriUpdateWithoutHealthRecordsInput = {
    id?: StringFieldUpdateOperationsInput | string
    nisn?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    gender?: StringFieldUpdateOperationsInput | string
    dob?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    kelas?: NullableStringFieldUpdateOperationsInput | string | null
    room?: NullableStringFieldUpdateOperationsInput | string | null
    contact?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutSantriNestedInput
    walis?: SantriWaliUpdateManyWithoutSantriNestedInput
    izin?: IzinUpdateManyWithoutSantriNestedInput
    catatanHarian?: CatatanHarianUpdateManyWithoutSantriNestedInput
    invoices?: InvoiceUpdateManyWithoutSantriNestedInput
    pelanggaran?: PelanggaranUpdateManyWithoutSantriNestedInput
    pembinaan?: PembinaanUpdateManyWithoutSantriNestedInput
    kunjungan?: KunjunganUpdateManyWithoutSantriNestedInput
    medications?: MedicationUpdateManyWithoutSantriNestedInput
    tahfidz?: TahfidzUpdateManyWithoutSantriNestedInput
    mutabaah?: MutabaahUpdateManyWithoutSantriNestedInput
    wallet?: WalletUpdateOneWithoutSantriNestedInput
    attendances?: AttendanceUpdateManyWithoutSantriNestedInput
    grades?: GradeUpdateManyWithoutSantriNestedInput
  }

  export type SantriUncheckedUpdateWithoutHealthRecordsInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    nisn?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    gender?: StringFieldUpdateOperationsInput | string
    dob?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    kelas?: NullableStringFieldUpdateOperationsInput | string | null
    room?: NullableStringFieldUpdateOperationsInput | string | null
    contact?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    walis?: SantriWaliUncheckedUpdateManyWithoutSantriNestedInput
    izin?: IzinUncheckedUpdateManyWithoutSantriNestedInput
    catatanHarian?: CatatanHarianUncheckedUpdateManyWithoutSantriNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutSantriNestedInput
    pelanggaran?: PelanggaranUncheckedUpdateManyWithoutSantriNestedInput
    pembinaan?: PembinaanUncheckedUpdateManyWithoutSantriNestedInput
    kunjungan?: KunjunganUncheckedUpdateManyWithoutSantriNestedInput
    medications?: MedicationUncheckedUpdateManyWithoutSantriNestedInput
    tahfidz?: TahfidzUncheckedUpdateManyWithoutSantriNestedInput
    mutabaah?: MutabaahUncheckedUpdateManyWithoutSantriNestedInput
    wallet?: WalletUncheckedUpdateOneWithoutSantriNestedInput
    attendances?: AttendanceUncheckedUpdateManyWithoutSantriNestedInput
    grades?: GradeUncheckedUpdateManyWithoutSantriNestedInput
  }

  export type SantriCreateWithoutMedicationsInput = {
    id?: string
    nisn?: string | null
    name: string
    gender: string
    dob?: Date | string | null
    kelas?: string | null
    room?: string | null
    contact?: string | null
    address?: string | null
    photo?: string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutSantriInput
    walis?: SantriWaliCreateNestedManyWithoutSantriInput
    izin?: IzinCreateNestedManyWithoutSantriInput
    catatanHarian?: CatatanHarianCreateNestedManyWithoutSantriInput
    invoices?: InvoiceCreateNestedManyWithoutSantriInput
    pelanggaran?: PelanggaranCreateNestedManyWithoutSantriInput
    pembinaan?: PembinaanCreateNestedManyWithoutSantriInput
    kunjungan?: KunjunganCreateNestedManyWithoutSantriInput
    healthRecords?: HealthRecordCreateNestedManyWithoutSantriInput
    tahfidz?: TahfidzCreateNestedManyWithoutSantriInput
    mutabaah?: MutabaahCreateNestedManyWithoutSantriInput
    wallet?: WalletCreateNestedOneWithoutSantriInput
    attendances?: AttendanceCreateNestedManyWithoutSantriInput
    grades?: GradeCreateNestedManyWithoutSantriInput
  }

  export type SantriUncheckedCreateWithoutMedicationsInput = {
    id?: string
    tenantId: string
    nisn?: string | null
    name: string
    gender: string
    dob?: Date | string | null
    kelas?: string | null
    room?: string | null
    contact?: string | null
    address?: string | null
    photo?: string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    walis?: SantriWaliUncheckedCreateNestedManyWithoutSantriInput
    izin?: IzinUncheckedCreateNestedManyWithoutSantriInput
    catatanHarian?: CatatanHarianUncheckedCreateNestedManyWithoutSantriInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutSantriInput
    pelanggaran?: PelanggaranUncheckedCreateNestedManyWithoutSantriInput
    pembinaan?: PembinaanUncheckedCreateNestedManyWithoutSantriInput
    kunjungan?: KunjunganUncheckedCreateNestedManyWithoutSantriInput
    healthRecords?: HealthRecordUncheckedCreateNestedManyWithoutSantriInput
    tahfidz?: TahfidzUncheckedCreateNestedManyWithoutSantriInput
    mutabaah?: MutabaahUncheckedCreateNestedManyWithoutSantriInput
    wallet?: WalletUncheckedCreateNestedOneWithoutSantriInput
    attendances?: AttendanceUncheckedCreateNestedManyWithoutSantriInput
    grades?: GradeUncheckedCreateNestedManyWithoutSantriInput
  }

  export type SantriCreateOrConnectWithoutMedicationsInput = {
    where: SantriWhereUniqueInput
    create: XOR<SantriCreateWithoutMedicationsInput, SantriUncheckedCreateWithoutMedicationsInput>
  }

  export type SantriUpsertWithoutMedicationsInput = {
    update: XOR<SantriUpdateWithoutMedicationsInput, SantriUncheckedUpdateWithoutMedicationsInput>
    create: XOR<SantriCreateWithoutMedicationsInput, SantriUncheckedCreateWithoutMedicationsInput>
    where?: SantriWhereInput
  }

  export type SantriUpdateToOneWithWhereWithoutMedicationsInput = {
    where?: SantriWhereInput
    data: XOR<SantriUpdateWithoutMedicationsInput, SantriUncheckedUpdateWithoutMedicationsInput>
  }

  export type SantriUpdateWithoutMedicationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    nisn?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    gender?: StringFieldUpdateOperationsInput | string
    dob?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    kelas?: NullableStringFieldUpdateOperationsInput | string | null
    room?: NullableStringFieldUpdateOperationsInput | string | null
    contact?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutSantriNestedInput
    walis?: SantriWaliUpdateManyWithoutSantriNestedInput
    izin?: IzinUpdateManyWithoutSantriNestedInput
    catatanHarian?: CatatanHarianUpdateManyWithoutSantriNestedInput
    invoices?: InvoiceUpdateManyWithoutSantriNestedInput
    pelanggaran?: PelanggaranUpdateManyWithoutSantriNestedInput
    pembinaan?: PembinaanUpdateManyWithoutSantriNestedInput
    kunjungan?: KunjunganUpdateManyWithoutSantriNestedInput
    healthRecords?: HealthRecordUpdateManyWithoutSantriNestedInput
    tahfidz?: TahfidzUpdateManyWithoutSantriNestedInput
    mutabaah?: MutabaahUpdateManyWithoutSantriNestedInput
    wallet?: WalletUpdateOneWithoutSantriNestedInput
    attendances?: AttendanceUpdateManyWithoutSantriNestedInput
    grades?: GradeUpdateManyWithoutSantriNestedInput
  }

  export type SantriUncheckedUpdateWithoutMedicationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    nisn?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    gender?: StringFieldUpdateOperationsInput | string
    dob?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    kelas?: NullableStringFieldUpdateOperationsInput | string | null
    room?: NullableStringFieldUpdateOperationsInput | string | null
    contact?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    walis?: SantriWaliUncheckedUpdateManyWithoutSantriNestedInput
    izin?: IzinUncheckedUpdateManyWithoutSantriNestedInput
    catatanHarian?: CatatanHarianUncheckedUpdateManyWithoutSantriNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutSantriNestedInput
    pelanggaran?: PelanggaranUncheckedUpdateManyWithoutSantriNestedInput
    pembinaan?: PembinaanUncheckedUpdateManyWithoutSantriNestedInput
    kunjungan?: KunjunganUncheckedUpdateManyWithoutSantriNestedInput
    healthRecords?: HealthRecordUncheckedUpdateManyWithoutSantriNestedInput
    tahfidz?: TahfidzUncheckedUpdateManyWithoutSantriNestedInput
    mutabaah?: MutabaahUncheckedUpdateManyWithoutSantriNestedInput
    wallet?: WalletUncheckedUpdateOneWithoutSantriNestedInput
    attendances?: AttendanceUncheckedUpdateManyWithoutSantriNestedInput
    grades?: GradeUncheckedUpdateManyWithoutSantriNestedInput
  }

  export type TenantCreateWithoutAuditLogsInput = {
    id?: string
    name: string
    address?: string | null
    phone?: string | null
    adminUserId?: string | null
    timezone?: string
    plan?: string
    billingContact?: string | null
    status?: string
    settings?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutTenantInput
    santri?: SantriCreateNestedManyWithoutTenantInput
    wali?: WaliCreateNestedManyWithoutTenantInput
    izin?: IzinCreateNestedManyWithoutTenantInput
    catatanHarian?: CatatanHarianCreateNestedManyWithoutTenantInput
    pengumuman?: PengumumanCreateNestedManyWithoutTenantInput
    invoices?: InvoiceCreateNestedManyWithoutTenantInput
    pelanggaran?: PelanggaranCreateNestedManyWithoutTenantInput
    pembinaan?: PembinaanCreateNestedManyWithoutTenantInput
    kunjungan?: KunjunganCreateNestedManyWithoutTenantInput
    healthRecords?: HealthRecordCreateNestedManyWithoutTenantInput
    notifications?: NotificationCreateNestedManyWithoutTenantInput
    webhookEvents?: WebhookEventCreateNestedManyWithoutTenantInput
    tahfidz?: TahfidzCreateNestedManyWithoutTenantInput
    mutabaah?: MutabaahCreateNestedManyWithoutTenantInput
    wallets?: WalletCreateNestedManyWithoutTenantInput
    employees?: EmployeeCreateNestedManyWithoutTenantInput
    payrolls?: PayrollCreateNestedManyWithoutTenantInput
    academicScheds?: AcademicScheduleCreateNestedManyWithoutTenantInput
    attendances?: AttendanceCreateNestedManyWithoutTenantInput
    grades?: GradeCreateNestedManyWithoutTenantInput
    ppdbRegistrations?: PpdbRegistrationCreateNestedManyWithoutTenantInput
    ppdbDocuments?: PpdbDocumentCreateNestedManyWithoutTenantInput
    ppdbExams?: PpdbExamCreateNestedManyWithoutTenantInput
    inventoryItems?: ItemCreateNestedManyWithoutTenantInput
    inventoryTransactions?: InventoryTransactionCreateNestedManyWithoutTenantInput
    suppliers?: SupplierCreateNestedManyWithoutTenantInput
    purchaseOrders?: PurchaseOrderCreateNestedManyWithoutTenantInput
    buildings?: BuildingCreateNestedManyWithoutTenantInput
    rooms?: RoomCreateNestedManyWithoutTenantInput
    roomAssignments?: RoomAssignmentCreateNestedManyWithoutTenantInput
    maintenanceTickets?: MaintenanceTicketCreateNestedManyWithoutTenantInput
  }

  export type TenantUncheckedCreateWithoutAuditLogsInput = {
    id?: string
    name: string
    address?: string | null
    phone?: string | null
    adminUserId?: string | null
    timezone?: string
    plan?: string
    billingContact?: string | null
    status?: string
    settings?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutTenantInput
    santri?: SantriUncheckedCreateNestedManyWithoutTenantInput
    wali?: WaliUncheckedCreateNestedManyWithoutTenantInput
    izin?: IzinUncheckedCreateNestedManyWithoutTenantInput
    catatanHarian?: CatatanHarianUncheckedCreateNestedManyWithoutTenantInput
    pengumuman?: PengumumanUncheckedCreateNestedManyWithoutTenantInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutTenantInput
    pelanggaran?: PelanggaranUncheckedCreateNestedManyWithoutTenantInput
    pembinaan?: PembinaanUncheckedCreateNestedManyWithoutTenantInput
    kunjungan?: KunjunganUncheckedCreateNestedManyWithoutTenantInput
    healthRecords?: HealthRecordUncheckedCreateNestedManyWithoutTenantInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutTenantInput
    webhookEvents?: WebhookEventUncheckedCreateNestedManyWithoutTenantInput
    tahfidz?: TahfidzUncheckedCreateNestedManyWithoutTenantInput
    mutabaah?: MutabaahUncheckedCreateNestedManyWithoutTenantInput
    wallets?: WalletUncheckedCreateNestedManyWithoutTenantInput
    employees?: EmployeeUncheckedCreateNestedManyWithoutTenantInput
    payrolls?: PayrollUncheckedCreateNestedManyWithoutTenantInput
    academicScheds?: AcademicScheduleUncheckedCreateNestedManyWithoutTenantInput
    attendances?: AttendanceUncheckedCreateNestedManyWithoutTenantInput
    grades?: GradeUncheckedCreateNestedManyWithoutTenantInput
    ppdbRegistrations?: PpdbRegistrationUncheckedCreateNestedManyWithoutTenantInput
    ppdbDocuments?: PpdbDocumentUncheckedCreateNestedManyWithoutTenantInput
    ppdbExams?: PpdbExamUncheckedCreateNestedManyWithoutTenantInput
    inventoryItems?: ItemUncheckedCreateNestedManyWithoutTenantInput
    inventoryTransactions?: InventoryTransactionUncheckedCreateNestedManyWithoutTenantInput
    suppliers?: SupplierUncheckedCreateNestedManyWithoutTenantInput
    purchaseOrders?: PurchaseOrderUncheckedCreateNestedManyWithoutTenantInput
    buildings?: BuildingUncheckedCreateNestedManyWithoutTenantInput
    rooms?: RoomUncheckedCreateNestedManyWithoutTenantInput
    roomAssignments?: RoomAssignmentUncheckedCreateNestedManyWithoutTenantInput
    maintenanceTickets?: MaintenanceTicketUncheckedCreateNestedManyWithoutTenantInput
  }

  export type TenantCreateOrConnectWithoutAuditLogsInput = {
    where: TenantWhereUniqueInput
    create: XOR<TenantCreateWithoutAuditLogsInput, TenantUncheckedCreateWithoutAuditLogsInput>
  }

  export type UserCreateWithoutAuditLogsInput = {
    id?: string
    email: string
    passwordHash: string
    role?: string
    name: string
    phone?: string | null
    isActive?: boolean
    lastLogin?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant?: TenantCreateNestedOneWithoutUsersInput
    refreshTokens?: RefreshTokenCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutAuditLogsInput = {
    id?: string
    tenantId?: string | null
    email: string
    passwordHash: string
    role?: string
    name: string
    phone?: string | null
    isActive?: boolean
    lastLogin?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    refreshTokens?: RefreshTokenUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutAuditLogsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAuditLogsInput, UserUncheckedCreateWithoutAuditLogsInput>
  }

  export type TenantUpsertWithoutAuditLogsInput = {
    update: XOR<TenantUpdateWithoutAuditLogsInput, TenantUncheckedUpdateWithoutAuditLogsInput>
    create: XOR<TenantCreateWithoutAuditLogsInput, TenantUncheckedCreateWithoutAuditLogsInput>
    where?: TenantWhereInput
  }

  export type TenantUpdateToOneWithWhereWithoutAuditLogsInput = {
    where?: TenantWhereInput
    data: XOR<TenantUpdateWithoutAuditLogsInput, TenantUncheckedUpdateWithoutAuditLogsInput>
  }

  export type TenantUpdateWithoutAuditLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    adminUserId?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    plan?: StringFieldUpdateOperationsInput | string
    billingContact?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    settings?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutTenantNestedInput
    santri?: SantriUpdateManyWithoutTenantNestedInput
    wali?: WaliUpdateManyWithoutTenantNestedInput
    izin?: IzinUpdateManyWithoutTenantNestedInput
    catatanHarian?: CatatanHarianUpdateManyWithoutTenantNestedInput
    pengumuman?: PengumumanUpdateManyWithoutTenantNestedInput
    invoices?: InvoiceUpdateManyWithoutTenantNestedInput
    pelanggaran?: PelanggaranUpdateManyWithoutTenantNestedInput
    pembinaan?: PembinaanUpdateManyWithoutTenantNestedInput
    kunjungan?: KunjunganUpdateManyWithoutTenantNestedInput
    healthRecords?: HealthRecordUpdateManyWithoutTenantNestedInput
    notifications?: NotificationUpdateManyWithoutTenantNestedInput
    webhookEvents?: WebhookEventUpdateManyWithoutTenantNestedInput
    tahfidz?: TahfidzUpdateManyWithoutTenantNestedInput
    mutabaah?: MutabaahUpdateManyWithoutTenantNestedInput
    wallets?: WalletUpdateManyWithoutTenantNestedInput
    employees?: EmployeeUpdateManyWithoutTenantNestedInput
    payrolls?: PayrollUpdateManyWithoutTenantNestedInput
    academicScheds?: AcademicScheduleUpdateManyWithoutTenantNestedInput
    attendances?: AttendanceUpdateManyWithoutTenantNestedInput
    grades?: GradeUpdateManyWithoutTenantNestedInput
    ppdbRegistrations?: PpdbRegistrationUpdateManyWithoutTenantNestedInput
    ppdbDocuments?: PpdbDocumentUpdateManyWithoutTenantNestedInput
    ppdbExams?: PpdbExamUpdateManyWithoutTenantNestedInput
    inventoryItems?: ItemUpdateManyWithoutTenantNestedInput
    inventoryTransactions?: InventoryTransactionUpdateManyWithoutTenantNestedInput
    suppliers?: SupplierUpdateManyWithoutTenantNestedInput
    purchaseOrders?: PurchaseOrderUpdateManyWithoutTenantNestedInput
    buildings?: BuildingUpdateManyWithoutTenantNestedInput
    rooms?: RoomUpdateManyWithoutTenantNestedInput
    roomAssignments?: RoomAssignmentUpdateManyWithoutTenantNestedInput
    maintenanceTickets?: MaintenanceTicketUpdateManyWithoutTenantNestedInput
  }

  export type TenantUncheckedUpdateWithoutAuditLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    adminUserId?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    plan?: StringFieldUpdateOperationsInput | string
    billingContact?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    settings?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutTenantNestedInput
    santri?: SantriUncheckedUpdateManyWithoutTenantNestedInput
    wali?: WaliUncheckedUpdateManyWithoutTenantNestedInput
    izin?: IzinUncheckedUpdateManyWithoutTenantNestedInput
    catatanHarian?: CatatanHarianUncheckedUpdateManyWithoutTenantNestedInput
    pengumuman?: PengumumanUncheckedUpdateManyWithoutTenantNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutTenantNestedInput
    pelanggaran?: PelanggaranUncheckedUpdateManyWithoutTenantNestedInput
    pembinaan?: PembinaanUncheckedUpdateManyWithoutTenantNestedInput
    kunjungan?: KunjunganUncheckedUpdateManyWithoutTenantNestedInput
    healthRecords?: HealthRecordUncheckedUpdateManyWithoutTenantNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutTenantNestedInput
    webhookEvents?: WebhookEventUncheckedUpdateManyWithoutTenantNestedInput
    tahfidz?: TahfidzUncheckedUpdateManyWithoutTenantNestedInput
    mutabaah?: MutabaahUncheckedUpdateManyWithoutTenantNestedInput
    wallets?: WalletUncheckedUpdateManyWithoutTenantNestedInput
    employees?: EmployeeUncheckedUpdateManyWithoutTenantNestedInput
    payrolls?: PayrollUncheckedUpdateManyWithoutTenantNestedInput
    academicScheds?: AcademicScheduleUncheckedUpdateManyWithoutTenantNestedInput
    attendances?: AttendanceUncheckedUpdateManyWithoutTenantNestedInput
    grades?: GradeUncheckedUpdateManyWithoutTenantNestedInput
    ppdbRegistrations?: PpdbRegistrationUncheckedUpdateManyWithoutTenantNestedInput
    ppdbDocuments?: PpdbDocumentUncheckedUpdateManyWithoutTenantNestedInput
    ppdbExams?: PpdbExamUncheckedUpdateManyWithoutTenantNestedInput
    inventoryItems?: ItemUncheckedUpdateManyWithoutTenantNestedInput
    inventoryTransactions?: InventoryTransactionUncheckedUpdateManyWithoutTenantNestedInput
    suppliers?: SupplierUncheckedUpdateManyWithoutTenantNestedInput
    purchaseOrders?: PurchaseOrderUncheckedUpdateManyWithoutTenantNestedInput
    buildings?: BuildingUncheckedUpdateManyWithoutTenantNestedInput
    rooms?: RoomUncheckedUpdateManyWithoutTenantNestedInput
    roomAssignments?: RoomAssignmentUncheckedUpdateManyWithoutTenantNestedInput
    maintenanceTickets?: MaintenanceTicketUncheckedUpdateManyWithoutTenantNestedInput
  }

  export type UserUpsertWithoutAuditLogsInput = {
    update: XOR<UserUpdateWithoutAuditLogsInput, UserUncheckedUpdateWithoutAuditLogsInput>
    create: XOR<UserCreateWithoutAuditLogsInput, UserUncheckedCreateWithoutAuditLogsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAuditLogsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAuditLogsInput, UserUncheckedUpdateWithoutAuditLogsInput>
  }

  export type UserUpdateWithoutAuditLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneWithoutUsersNestedInput
    refreshTokens?: RefreshTokenUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutAuditLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    refreshTokens?: RefreshTokenUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
  }

  export type TenantCreateWithoutNotificationsInput = {
    id?: string
    name: string
    address?: string | null
    phone?: string | null
    adminUserId?: string | null
    timezone?: string
    plan?: string
    billingContact?: string | null
    status?: string
    settings?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutTenantInput
    santri?: SantriCreateNestedManyWithoutTenantInput
    wali?: WaliCreateNestedManyWithoutTenantInput
    izin?: IzinCreateNestedManyWithoutTenantInput
    catatanHarian?: CatatanHarianCreateNestedManyWithoutTenantInput
    pengumuman?: PengumumanCreateNestedManyWithoutTenantInput
    invoices?: InvoiceCreateNestedManyWithoutTenantInput
    pelanggaran?: PelanggaranCreateNestedManyWithoutTenantInput
    pembinaan?: PembinaanCreateNestedManyWithoutTenantInput
    kunjungan?: KunjunganCreateNestedManyWithoutTenantInput
    healthRecords?: HealthRecordCreateNestedManyWithoutTenantInput
    auditLogs?: AuditLogCreateNestedManyWithoutTenantInput
    webhookEvents?: WebhookEventCreateNestedManyWithoutTenantInput
    tahfidz?: TahfidzCreateNestedManyWithoutTenantInput
    mutabaah?: MutabaahCreateNestedManyWithoutTenantInput
    wallets?: WalletCreateNestedManyWithoutTenantInput
    employees?: EmployeeCreateNestedManyWithoutTenantInput
    payrolls?: PayrollCreateNestedManyWithoutTenantInput
    academicScheds?: AcademicScheduleCreateNestedManyWithoutTenantInput
    attendances?: AttendanceCreateNestedManyWithoutTenantInput
    grades?: GradeCreateNestedManyWithoutTenantInput
    ppdbRegistrations?: PpdbRegistrationCreateNestedManyWithoutTenantInput
    ppdbDocuments?: PpdbDocumentCreateNestedManyWithoutTenantInput
    ppdbExams?: PpdbExamCreateNestedManyWithoutTenantInput
    inventoryItems?: ItemCreateNestedManyWithoutTenantInput
    inventoryTransactions?: InventoryTransactionCreateNestedManyWithoutTenantInput
    suppliers?: SupplierCreateNestedManyWithoutTenantInput
    purchaseOrders?: PurchaseOrderCreateNestedManyWithoutTenantInput
    buildings?: BuildingCreateNestedManyWithoutTenantInput
    rooms?: RoomCreateNestedManyWithoutTenantInput
    roomAssignments?: RoomAssignmentCreateNestedManyWithoutTenantInput
    maintenanceTickets?: MaintenanceTicketCreateNestedManyWithoutTenantInput
  }

  export type TenantUncheckedCreateWithoutNotificationsInput = {
    id?: string
    name: string
    address?: string | null
    phone?: string | null
    adminUserId?: string | null
    timezone?: string
    plan?: string
    billingContact?: string | null
    status?: string
    settings?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutTenantInput
    santri?: SantriUncheckedCreateNestedManyWithoutTenantInput
    wali?: WaliUncheckedCreateNestedManyWithoutTenantInput
    izin?: IzinUncheckedCreateNestedManyWithoutTenantInput
    catatanHarian?: CatatanHarianUncheckedCreateNestedManyWithoutTenantInput
    pengumuman?: PengumumanUncheckedCreateNestedManyWithoutTenantInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutTenantInput
    pelanggaran?: PelanggaranUncheckedCreateNestedManyWithoutTenantInput
    pembinaan?: PembinaanUncheckedCreateNestedManyWithoutTenantInput
    kunjungan?: KunjunganUncheckedCreateNestedManyWithoutTenantInput
    healthRecords?: HealthRecordUncheckedCreateNestedManyWithoutTenantInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutTenantInput
    webhookEvents?: WebhookEventUncheckedCreateNestedManyWithoutTenantInput
    tahfidz?: TahfidzUncheckedCreateNestedManyWithoutTenantInput
    mutabaah?: MutabaahUncheckedCreateNestedManyWithoutTenantInput
    wallets?: WalletUncheckedCreateNestedManyWithoutTenantInput
    employees?: EmployeeUncheckedCreateNestedManyWithoutTenantInput
    payrolls?: PayrollUncheckedCreateNestedManyWithoutTenantInput
    academicScheds?: AcademicScheduleUncheckedCreateNestedManyWithoutTenantInput
    attendances?: AttendanceUncheckedCreateNestedManyWithoutTenantInput
    grades?: GradeUncheckedCreateNestedManyWithoutTenantInput
    ppdbRegistrations?: PpdbRegistrationUncheckedCreateNestedManyWithoutTenantInput
    ppdbDocuments?: PpdbDocumentUncheckedCreateNestedManyWithoutTenantInput
    ppdbExams?: PpdbExamUncheckedCreateNestedManyWithoutTenantInput
    inventoryItems?: ItemUncheckedCreateNestedManyWithoutTenantInput
    inventoryTransactions?: InventoryTransactionUncheckedCreateNestedManyWithoutTenantInput
    suppliers?: SupplierUncheckedCreateNestedManyWithoutTenantInput
    purchaseOrders?: PurchaseOrderUncheckedCreateNestedManyWithoutTenantInput
    buildings?: BuildingUncheckedCreateNestedManyWithoutTenantInput
    rooms?: RoomUncheckedCreateNestedManyWithoutTenantInput
    roomAssignments?: RoomAssignmentUncheckedCreateNestedManyWithoutTenantInput
    maintenanceTickets?: MaintenanceTicketUncheckedCreateNestedManyWithoutTenantInput
  }

  export type TenantCreateOrConnectWithoutNotificationsInput = {
    where: TenantWhereUniqueInput
    create: XOR<TenantCreateWithoutNotificationsInput, TenantUncheckedCreateWithoutNotificationsInput>
  }

  export type UserCreateWithoutNotificationsInput = {
    id?: string
    email: string
    passwordHash: string
    role?: string
    name: string
    phone?: string | null
    isActive?: boolean
    lastLogin?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant?: TenantCreateNestedOneWithoutUsersInput
    refreshTokens?: RefreshTokenCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutNotificationsInput = {
    id?: string
    tenantId?: string | null
    email: string
    passwordHash: string
    role?: string
    name: string
    phone?: string | null
    isActive?: boolean
    lastLogin?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    refreshTokens?: RefreshTokenUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutNotificationsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
  }

  export type TenantUpsertWithoutNotificationsInput = {
    update: XOR<TenantUpdateWithoutNotificationsInput, TenantUncheckedUpdateWithoutNotificationsInput>
    create: XOR<TenantCreateWithoutNotificationsInput, TenantUncheckedCreateWithoutNotificationsInput>
    where?: TenantWhereInput
  }

  export type TenantUpdateToOneWithWhereWithoutNotificationsInput = {
    where?: TenantWhereInput
    data: XOR<TenantUpdateWithoutNotificationsInput, TenantUncheckedUpdateWithoutNotificationsInput>
  }

  export type TenantUpdateWithoutNotificationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    adminUserId?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    plan?: StringFieldUpdateOperationsInput | string
    billingContact?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    settings?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutTenantNestedInput
    santri?: SantriUpdateManyWithoutTenantNestedInput
    wali?: WaliUpdateManyWithoutTenantNestedInput
    izin?: IzinUpdateManyWithoutTenantNestedInput
    catatanHarian?: CatatanHarianUpdateManyWithoutTenantNestedInput
    pengumuman?: PengumumanUpdateManyWithoutTenantNestedInput
    invoices?: InvoiceUpdateManyWithoutTenantNestedInput
    pelanggaran?: PelanggaranUpdateManyWithoutTenantNestedInput
    pembinaan?: PembinaanUpdateManyWithoutTenantNestedInput
    kunjungan?: KunjunganUpdateManyWithoutTenantNestedInput
    healthRecords?: HealthRecordUpdateManyWithoutTenantNestedInput
    auditLogs?: AuditLogUpdateManyWithoutTenantNestedInput
    webhookEvents?: WebhookEventUpdateManyWithoutTenantNestedInput
    tahfidz?: TahfidzUpdateManyWithoutTenantNestedInput
    mutabaah?: MutabaahUpdateManyWithoutTenantNestedInput
    wallets?: WalletUpdateManyWithoutTenantNestedInput
    employees?: EmployeeUpdateManyWithoutTenantNestedInput
    payrolls?: PayrollUpdateManyWithoutTenantNestedInput
    academicScheds?: AcademicScheduleUpdateManyWithoutTenantNestedInput
    attendances?: AttendanceUpdateManyWithoutTenantNestedInput
    grades?: GradeUpdateManyWithoutTenantNestedInput
    ppdbRegistrations?: PpdbRegistrationUpdateManyWithoutTenantNestedInput
    ppdbDocuments?: PpdbDocumentUpdateManyWithoutTenantNestedInput
    ppdbExams?: PpdbExamUpdateManyWithoutTenantNestedInput
    inventoryItems?: ItemUpdateManyWithoutTenantNestedInput
    inventoryTransactions?: InventoryTransactionUpdateManyWithoutTenantNestedInput
    suppliers?: SupplierUpdateManyWithoutTenantNestedInput
    purchaseOrders?: PurchaseOrderUpdateManyWithoutTenantNestedInput
    buildings?: BuildingUpdateManyWithoutTenantNestedInput
    rooms?: RoomUpdateManyWithoutTenantNestedInput
    roomAssignments?: RoomAssignmentUpdateManyWithoutTenantNestedInput
    maintenanceTickets?: MaintenanceTicketUpdateManyWithoutTenantNestedInput
  }

  export type TenantUncheckedUpdateWithoutNotificationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    adminUserId?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    plan?: StringFieldUpdateOperationsInput | string
    billingContact?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    settings?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutTenantNestedInput
    santri?: SantriUncheckedUpdateManyWithoutTenantNestedInput
    wali?: WaliUncheckedUpdateManyWithoutTenantNestedInput
    izin?: IzinUncheckedUpdateManyWithoutTenantNestedInput
    catatanHarian?: CatatanHarianUncheckedUpdateManyWithoutTenantNestedInput
    pengumuman?: PengumumanUncheckedUpdateManyWithoutTenantNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutTenantNestedInput
    pelanggaran?: PelanggaranUncheckedUpdateManyWithoutTenantNestedInput
    pembinaan?: PembinaanUncheckedUpdateManyWithoutTenantNestedInput
    kunjungan?: KunjunganUncheckedUpdateManyWithoutTenantNestedInput
    healthRecords?: HealthRecordUncheckedUpdateManyWithoutTenantNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutTenantNestedInput
    webhookEvents?: WebhookEventUncheckedUpdateManyWithoutTenantNestedInput
    tahfidz?: TahfidzUncheckedUpdateManyWithoutTenantNestedInput
    mutabaah?: MutabaahUncheckedUpdateManyWithoutTenantNestedInput
    wallets?: WalletUncheckedUpdateManyWithoutTenantNestedInput
    employees?: EmployeeUncheckedUpdateManyWithoutTenantNestedInput
    payrolls?: PayrollUncheckedUpdateManyWithoutTenantNestedInput
    academicScheds?: AcademicScheduleUncheckedUpdateManyWithoutTenantNestedInput
    attendances?: AttendanceUncheckedUpdateManyWithoutTenantNestedInput
    grades?: GradeUncheckedUpdateManyWithoutTenantNestedInput
    ppdbRegistrations?: PpdbRegistrationUncheckedUpdateManyWithoutTenantNestedInput
    ppdbDocuments?: PpdbDocumentUncheckedUpdateManyWithoutTenantNestedInput
    ppdbExams?: PpdbExamUncheckedUpdateManyWithoutTenantNestedInput
    inventoryItems?: ItemUncheckedUpdateManyWithoutTenantNestedInput
    inventoryTransactions?: InventoryTransactionUncheckedUpdateManyWithoutTenantNestedInput
    suppliers?: SupplierUncheckedUpdateManyWithoutTenantNestedInput
    purchaseOrders?: PurchaseOrderUncheckedUpdateManyWithoutTenantNestedInput
    buildings?: BuildingUncheckedUpdateManyWithoutTenantNestedInput
    rooms?: RoomUncheckedUpdateManyWithoutTenantNestedInput
    roomAssignments?: RoomAssignmentUncheckedUpdateManyWithoutTenantNestedInput
    maintenanceTickets?: MaintenanceTicketUncheckedUpdateManyWithoutTenantNestedInput
  }

  export type UserUpsertWithoutNotificationsInput = {
    update: XOR<UserUpdateWithoutNotificationsInput, UserUncheckedUpdateWithoutNotificationsInput>
    create: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutNotificationsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutNotificationsInput, UserUncheckedUpdateWithoutNotificationsInput>
  }

  export type UserUpdateWithoutNotificationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneWithoutUsersNestedInput
    refreshTokens?: RefreshTokenUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutNotificationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    refreshTokens?: RefreshTokenUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
  }

  export type TenantCreateWithoutWebhookEventsInput = {
    id?: string
    name: string
    address?: string | null
    phone?: string | null
    adminUserId?: string | null
    timezone?: string
    plan?: string
    billingContact?: string | null
    status?: string
    settings?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutTenantInput
    santri?: SantriCreateNestedManyWithoutTenantInput
    wali?: WaliCreateNestedManyWithoutTenantInput
    izin?: IzinCreateNestedManyWithoutTenantInput
    catatanHarian?: CatatanHarianCreateNestedManyWithoutTenantInput
    pengumuman?: PengumumanCreateNestedManyWithoutTenantInput
    invoices?: InvoiceCreateNestedManyWithoutTenantInput
    pelanggaran?: PelanggaranCreateNestedManyWithoutTenantInput
    pembinaan?: PembinaanCreateNestedManyWithoutTenantInput
    kunjungan?: KunjunganCreateNestedManyWithoutTenantInput
    healthRecords?: HealthRecordCreateNestedManyWithoutTenantInput
    auditLogs?: AuditLogCreateNestedManyWithoutTenantInput
    notifications?: NotificationCreateNestedManyWithoutTenantInput
    tahfidz?: TahfidzCreateNestedManyWithoutTenantInput
    mutabaah?: MutabaahCreateNestedManyWithoutTenantInput
    wallets?: WalletCreateNestedManyWithoutTenantInput
    employees?: EmployeeCreateNestedManyWithoutTenantInput
    payrolls?: PayrollCreateNestedManyWithoutTenantInput
    academicScheds?: AcademicScheduleCreateNestedManyWithoutTenantInput
    attendances?: AttendanceCreateNestedManyWithoutTenantInput
    grades?: GradeCreateNestedManyWithoutTenantInput
    ppdbRegistrations?: PpdbRegistrationCreateNestedManyWithoutTenantInput
    ppdbDocuments?: PpdbDocumentCreateNestedManyWithoutTenantInput
    ppdbExams?: PpdbExamCreateNestedManyWithoutTenantInput
    inventoryItems?: ItemCreateNestedManyWithoutTenantInput
    inventoryTransactions?: InventoryTransactionCreateNestedManyWithoutTenantInput
    suppliers?: SupplierCreateNestedManyWithoutTenantInput
    purchaseOrders?: PurchaseOrderCreateNestedManyWithoutTenantInput
    buildings?: BuildingCreateNestedManyWithoutTenantInput
    rooms?: RoomCreateNestedManyWithoutTenantInput
    roomAssignments?: RoomAssignmentCreateNestedManyWithoutTenantInput
    maintenanceTickets?: MaintenanceTicketCreateNestedManyWithoutTenantInput
  }

  export type TenantUncheckedCreateWithoutWebhookEventsInput = {
    id?: string
    name: string
    address?: string | null
    phone?: string | null
    adminUserId?: string | null
    timezone?: string
    plan?: string
    billingContact?: string | null
    status?: string
    settings?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutTenantInput
    santri?: SantriUncheckedCreateNestedManyWithoutTenantInput
    wali?: WaliUncheckedCreateNestedManyWithoutTenantInput
    izin?: IzinUncheckedCreateNestedManyWithoutTenantInput
    catatanHarian?: CatatanHarianUncheckedCreateNestedManyWithoutTenantInput
    pengumuman?: PengumumanUncheckedCreateNestedManyWithoutTenantInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutTenantInput
    pelanggaran?: PelanggaranUncheckedCreateNestedManyWithoutTenantInput
    pembinaan?: PembinaanUncheckedCreateNestedManyWithoutTenantInput
    kunjungan?: KunjunganUncheckedCreateNestedManyWithoutTenantInput
    healthRecords?: HealthRecordUncheckedCreateNestedManyWithoutTenantInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutTenantInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutTenantInput
    tahfidz?: TahfidzUncheckedCreateNestedManyWithoutTenantInput
    mutabaah?: MutabaahUncheckedCreateNestedManyWithoutTenantInput
    wallets?: WalletUncheckedCreateNestedManyWithoutTenantInput
    employees?: EmployeeUncheckedCreateNestedManyWithoutTenantInput
    payrolls?: PayrollUncheckedCreateNestedManyWithoutTenantInput
    academicScheds?: AcademicScheduleUncheckedCreateNestedManyWithoutTenantInput
    attendances?: AttendanceUncheckedCreateNestedManyWithoutTenantInput
    grades?: GradeUncheckedCreateNestedManyWithoutTenantInput
    ppdbRegistrations?: PpdbRegistrationUncheckedCreateNestedManyWithoutTenantInput
    ppdbDocuments?: PpdbDocumentUncheckedCreateNestedManyWithoutTenantInput
    ppdbExams?: PpdbExamUncheckedCreateNestedManyWithoutTenantInput
    inventoryItems?: ItemUncheckedCreateNestedManyWithoutTenantInput
    inventoryTransactions?: InventoryTransactionUncheckedCreateNestedManyWithoutTenantInput
    suppliers?: SupplierUncheckedCreateNestedManyWithoutTenantInput
    purchaseOrders?: PurchaseOrderUncheckedCreateNestedManyWithoutTenantInput
    buildings?: BuildingUncheckedCreateNestedManyWithoutTenantInput
    rooms?: RoomUncheckedCreateNestedManyWithoutTenantInput
    roomAssignments?: RoomAssignmentUncheckedCreateNestedManyWithoutTenantInput
    maintenanceTickets?: MaintenanceTicketUncheckedCreateNestedManyWithoutTenantInput
  }

  export type TenantCreateOrConnectWithoutWebhookEventsInput = {
    where: TenantWhereUniqueInput
    create: XOR<TenantCreateWithoutWebhookEventsInput, TenantUncheckedCreateWithoutWebhookEventsInput>
  }

  export type TenantUpsertWithoutWebhookEventsInput = {
    update: XOR<TenantUpdateWithoutWebhookEventsInput, TenantUncheckedUpdateWithoutWebhookEventsInput>
    create: XOR<TenantCreateWithoutWebhookEventsInput, TenantUncheckedCreateWithoutWebhookEventsInput>
    where?: TenantWhereInput
  }

  export type TenantUpdateToOneWithWhereWithoutWebhookEventsInput = {
    where?: TenantWhereInput
    data: XOR<TenantUpdateWithoutWebhookEventsInput, TenantUncheckedUpdateWithoutWebhookEventsInput>
  }

  export type TenantUpdateWithoutWebhookEventsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    adminUserId?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    plan?: StringFieldUpdateOperationsInput | string
    billingContact?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    settings?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutTenantNestedInput
    santri?: SantriUpdateManyWithoutTenantNestedInput
    wali?: WaliUpdateManyWithoutTenantNestedInput
    izin?: IzinUpdateManyWithoutTenantNestedInput
    catatanHarian?: CatatanHarianUpdateManyWithoutTenantNestedInput
    pengumuman?: PengumumanUpdateManyWithoutTenantNestedInput
    invoices?: InvoiceUpdateManyWithoutTenantNestedInput
    pelanggaran?: PelanggaranUpdateManyWithoutTenantNestedInput
    pembinaan?: PembinaanUpdateManyWithoutTenantNestedInput
    kunjungan?: KunjunganUpdateManyWithoutTenantNestedInput
    healthRecords?: HealthRecordUpdateManyWithoutTenantNestedInput
    auditLogs?: AuditLogUpdateManyWithoutTenantNestedInput
    notifications?: NotificationUpdateManyWithoutTenantNestedInput
    tahfidz?: TahfidzUpdateManyWithoutTenantNestedInput
    mutabaah?: MutabaahUpdateManyWithoutTenantNestedInput
    wallets?: WalletUpdateManyWithoutTenantNestedInput
    employees?: EmployeeUpdateManyWithoutTenantNestedInput
    payrolls?: PayrollUpdateManyWithoutTenantNestedInput
    academicScheds?: AcademicScheduleUpdateManyWithoutTenantNestedInput
    attendances?: AttendanceUpdateManyWithoutTenantNestedInput
    grades?: GradeUpdateManyWithoutTenantNestedInput
    ppdbRegistrations?: PpdbRegistrationUpdateManyWithoutTenantNestedInput
    ppdbDocuments?: PpdbDocumentUpdateManyWithoutTenantNestedInput
    ppdbExams?: PpdbExamUpdateManyWithoutTenantNestedInput
    inventoryItems?: ItemUpdateManyWithoutTenantNestedInput
    inventoryTransactions?: InventoryTransactionUpdateManyWithoutTenantNestedInput
    suppliers?: SupplierUpdateManyWithoutTenantNestedInput
    purchaseOrders?: PurchaseOrderUpdateManyWithoutTenantNestedInput
    buildings?: BuildingUpdateManyWithoutTenantNestedInput
    rooms?: RoomUpdateManyWithoutTenantNestedInput
    roomAssignments?: RoomAssignmentUpdateManyWithoutTenantNestedInput
    maintenanceTickets?: MaintenanceTicketUpdateManyWithoutTenantNestedInput
  }

  export type TenantUncheckedUpdateWithoutWebhookEventsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    adminUserId?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    plan?: StringFieldUpdateOperationsInput | string
    billingContact?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    settings?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutTenantNestedInput
    santri?: SantriUncheckedUpdateManyWithoutTenantNestedInput
    wali?: WaliUncheckedUpdateManyWithoutTenantNestedInput
    izin?: IzinUncheckedUpdateManyWithoutTenantNestedInput
    catatanHarian?: CatatanHarianUncheckedUpdateManyWithoutTenantNestedInput
    pengumuman?: PengumumanUncheckedUpdateManyWithoutTenantNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutTenantNestedInput
    pelanggaran?: PelanggaranUncheckedUpdateManyWithoutTenantNestedInput
    pembinaan?: PembinaanUncheckedUpdateManyWithoutTenantNestedInput
    kunjungan?: KunjunganUncheckedUpdateManyWithoutTenantNestedInput
    healthRecords?: HealthRecordUncheckedUpdateManyWithoutTenantNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutTenantNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutTenantNestedInput
    tahfidz?: TahfidzUncheckedUpdateManyWithoutTenantNestedInput
    mutabaah?: MutabaahUncheckedUpdateManyWithoutTenantNestedInput
    wallets?: WalletUncheckedUpdateManyWithoutTenantNestedInput
    employees?: EmployeeUncheckedUpdateManyWithoutTenantNestedInput
    payrolls?: PayrollUncheckedUpdateManyWithoutTenantNestedInput
    academicScheds?: AcademicScheduleUncheckedUpdateManyWithoutTenantNestedInput
    attendances?: AttendanceUncheckedUpdateManyWithoutTenantNestedInput
    grades?: GradeUncheckedUpdateManyWithoutTenantNestedInput
    ppdbRegistrations?: PpdbRegistrationUncheckedUpdateManyWithoutTenantNestedInput
    ppdbDocuments?: PpdbDocumentUncheckedUpdateManyWithoutTenantNestedInput
    ppdbExams?: PpdbExamUncheckedUpdateManyWithoutTenantNestedInput
    inventoryItems?: ItemUncheckedUpdateManyWithoutTenantNestedInput
    inventoryTransactions?: InventoryTransactionUncheckedUpdateManyWithoutTenantNestedInput
    suppliers?: SupplierUncheckedUpdateManyWithoutTenantNestedInput
    purchaseOrders?: PurchaseOrderUncheckedUpdateManyWithoutTenantNestedInput
    buildings?: BuildingUncheckedUpdateManyWithoutTenantNestedInput
    rooms?: RoomUncheckedUpdateManyWithoutTenantNestedInput
    roomAssignments?: RoomAssignmentUncheckedUpdateManyWithoutTenantNestedInput
    maintenanceTickets?: MaintenanceTicketUncheckedUpdateManyWithoutTenantNestedInput
  }

  export type TenantCreateWithoutTahfidzInput = {
    id?: string
    name: string
    address?: string | null
    phone?: string | null
    adminUserId?: string | null
    timezone?: string
    plan?: string
    billingContact?: string | null
    status?: string
    settings?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutTenantInput
    santri?: SantriCreateNestedManyWithoutTenantInput
    wali?: WaliCreateNestedManyWithoutTenantInput
    izin?: IzinCreateNestedManyWithoutTenantInput
    catatanHarian?: CatatanHarianCreateNestedManyWithoutTenantInput
    pengumuman?: PengumumanCreateNestedManyWithoutTenantInput
    invoices?: InvoiceCreateNestedManyWithoutTenantInput
    pelanggaran?: PelanggaranCreateNestedManyWithoutTenantInput
    pembinaan?: PembinaanCreateNestedManyWithoutTenantInput
    kunjungan?: KunjunganCreateNestedManyWithoutTenantInput
    healthRecords?: HealthRecordCreateNestedManyWithoutTenantInput
    auditLogs?: AuditLogCreateNestedManyWithoutTenantInput
    notifications?: NotificationCreateNestedManyWithoutTenantInput
    webhookEvents?: WebhookEventCreateNestedManyWithoutTenantInput
    mutabaah?: MutabaahCreateNestedManyWithoutTenantInput
    wallets?: WalletCreateNestedManyWithoutTenantInput
    employees?: EmployeeCreateNestedManyWithoutTenantInput
    payrolls?: PayrollCreateNestedManyWithoutTenantInput
    academicScheds?: AcademicScheduleCreateNestedManyWithoutTenantInput
    attendances?: AttendanceCreateNestedManyWithoutTenantInput
    grades?: GradeCreateNestedManyWithoutTenantInput
    ppdbRegistrations?: PpdbRegistrationCreateNestedManyWithoutTenantInput
    ppdbDocuments?: PpdbDocumentCreateNestedManyWithoutTenantInput
    ppdbExams?: PpdbExamCreateNestedManyWithoutTenantInput
    inventoryItems?: ItemCreateNestedManyWithoutTenantInput
    inventoryTransactions?: InventoryTransactionCreateNestedManyWithoutTenantInput
    suppliers?: SupplierCreateNestedManyWithoutTenantInput
    purchaseOrders?: PurchaseOrderCreateNestedManyWithoutTenantInput
    buildings?: BuildingCreateNestedManyWithoutTenantInput
    rooms?: RoomCreateNestedManyWithoutTenantInput
    roomAssignments?: RoomAssignmentCreateNestedManyWithoutTenantInput
    maintenanceTickets?: MaintenanceTicketCreateNestedManyWithoutTenantInput
  }

  export type TenantUncheckedCreateWithoutTahfidzInput = {
    id?: string
    name: string
    address?: string | null
    phone?: string | null
    adminUserId?: string | null
    timezone?: string
    plan?: string
    billingContact?: string | null
    status?: string
    settings?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutTenantInput
    santri?: SantriUncheckedCreateNestedManyWithoutTenantInput
    wali?: WaliUncheckedCreateNestedManyWithoutTenantInput
    izin?: IzinUncheckedCreateNestedManyWithoutTenantInput
    catatanHarian?: CatatanHarianUncheckedCreateNestedManyWithoutTenantInput
    pengumuman?: PengumumanUncheckedCreateNestedManyWithoutTenantInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutTenantInput
    pelanggaran?: PelanggaranUncheckedCreateNestedManyWithoutTenantInput
    pembinaan?: PembinaanUncheckedCreateNestedManyWithoutTenantInput
    kunjungan?: KunjunganUncheckedCreateNestedManyWithoutTenantInput
    healthRecords?: HealthRecordUncheckedCreateNestedManyWithoutTenantInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutTenantInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutTenantInput
    webhookEvents?: WebhookEventUncheckedCreateNestedManyWithoutTenantInput
    mutabaah?: MutabaahUncheckedCreateNestedManyWithoutTenantInput
    wallets?: WalletUncheckedCreateNestedManyWithoutTenantInput
    employees?: EmployeeUncheckedCreateNestedManyWithoutTenantInput
    payrolls?: PayrollUncheckedCreateNestedManyWithoutTenantInput
    academicScheds?: AcademicScheduleUncheckedCreateNestedManyWithoutTenantInput
    attendances?: AttendanceUncheckedCreateNestedManyWithoutTenantInput
    grades?: GradeUncheckedCreateNestedManyWithoutTenantInput
    ppdbRegistrations?: PpdbRegistrationUncheckedCreateNestedManyWithoutTenantInput
    ppdbDocuments?: PpdbDocumentUncheckedCreateNestedManyWithoutTenantInput
    ppdbExams?: PpdbExamUncheckedCreateNestedManyWithoutTenantInput
    inventoryItems?: ItemUncheckedCreateNestedManyWithoutTenantInput
    inventoryTransactions?: InventoryTransactionUncheckedCreateNestedManyWithoutTenantInput
    suppliers?: SupplierUncheckedCreateNestedManyWithoutTenantInput
    purchaseOrders?: PurchaseOrderUncheckedCreateNestedManyWithoutTenantInput
    buildings?: BuildingUncheckedCreateNestedManyWithoutTenantInput
    rooms?: RoomUncheckedCreateNestedManyWithoutTenantInput
    roomAssignments?: RoomAssignmentUncheckedCreateNestedManyWithoutTenantInput
    maintenanceTickets?: MaintenanceTicketUncheckedCreateNestedManyWithoutTenantInput
  }

  export type TenantCreateOrConnectWithoutTahfidzInput = {
    where: TenantWhereUniqueInput
    create: XOR<TenantCreateWithoutTahfidzInput, TenantUncheckedCreateWithoutTahfidzInput>
  }

  export type SantriCreateWithoutTahfidzInput = {
    id?: string
    nisn?: string | null
    name: string
    gender: string
    dob?: Date | string | null
    kelas?: string | null
    room?: string | null
    contact?: string | null
    address?: string | null
    photo?: string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutSantriInput
    walis?: SantriWaliCreateNestedManyWithoutSantriInput
    izin?: IzinCreateNestedManyWithoutSantriInput
    catatanHarian?: CatatanHarianCreateNestedManyWithoutSantriInput
    invoices?: InvoiceCreateNestedManyWithoutSantriInput
    pelanggaran?: PelanggaranCreateNestedManyWithoutSantriInput
    pembinaan?: PembinaanCreateNestedManyWithoutSantriInput
    kunjungan?: KunjunganCreateNestedManyWithoutSantriInput
    healthRecords?: HealthRecordCreateNestedManyWithoutSantriInput
    medications?: MedicationCreateNestedManyWithoutSantriInput
    mutabaah?: MutabaahCreateNestedManyWithoutSantriInput
    wallet?: WalletCreateNestedOneWithoutSantriInput
    attendances?: AttendanceCreateNestedManyWithoutSantriInput
    grades?: GradeCreateNestedManyWithoutSantriInput
  }

  export type SantriUncheckedCreateWithoutTahfidzInput = {
    id?: string
    tenantId: string
    nisn?: string | null
    name: string
    gender: string
    dob?: Date | string | null
    kelas?: string | null
    room?: string | null
    contact?: string | null
    address?: string | null
    photo?: string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    walis?: SantriWaliUncheckedCreateNestedManyWithoutSantriInput
    izin?: IzinUncheckedCreateNestedManyWithoutSantriInput
    catatanHarian?: CatatanHarianUncheckedCreateNestedManyWithoutSantriInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutSantriInput
    pelanggaran?: PelanggaranUncheckedCreateNestedManyWithoutSantriInput
    pembinaan?: PembinaanUncheckedCreateNestedManyWithoutSantriInput
    kunjungan?: KunjunganUncheckedCreateNestedManyWithoutSantriInput
    healthRecords?: HealthRecordUncheckedCreateNestedManyWithoutSantriInput
    medications?: MedicationUncheckedCreateNestedManyWithoutSantriInput
    mutabaah?: MutabaahUncheckedCreateNestedManyWithoutSantriInput
    wallet?: WalletUncheckedCreateNestedOneWithoutSantriInput
    attendances?: AttendanceUncheckedCreateNestedManyWithoutSantriInput
    grades?: GradeUncheckedCreateNestedManyWithoutSantriInput
  }

  export type SantriCreateOrConnectWithoutTahfidzInput = {
    where: SantriWhereUniqueInput
    create: XOR<SantriCreateWithoutTahfidzInput, SantriUncheckedCreateWithoutTahfidzInput>
  }

  export type TenantUpsertWithoutTahfidzInput = {
    update: XOR<TenantUpdateWithoutTahfidzInput, TenantUncheckedUpdateWithoutTahfidzInput>
    create: XOR<TenantCreateWithoutTahfidzInput, TenantUncheckedCreateWithoutTahfidzInput>
    where?: TenantWhereInput
  }

  export type TenantUpdateToOneWithWhereWithoutTahfidzInput = {
    where?: TenantWhereInput
    data: XOR<TenantUpdateWithoutTahfidzInput, TenantUncheckedUpdateWithoutTahfidzInput>
  }

  export type TenantUpdateWithoutTahfidzInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    adminUserId?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    plan?: StringFieldUpdateOperationsInput | string
    billingContact?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    settings?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutTenantNestedInput
    santri?: SantriUpdateManyWithoutTenantNestedInput
    wali?: WaliUpdateManyWithoutTenantNestedInput
    izin?: IzinUpdateManyWithoutTenantNestedInput
    catatanHarian?: CatatanHarianUpdateManyWithoutTenantNestedInput
    pengumuman?: PengumumanUpdateManyWithoutTenantNestedInput
    invoices?: InvoiceUpdateManyWithoutTenantNestedInput
    pelanggaran?: PelanggaranUpdateManyWithoutTenantNestedInput
    pembinaan?: PembinaanUpdateManyWithoutTenantNestedInput
    kunjungan?: KunjunganUpdateManyWithoutTenantNestedInput
    healthRecords?: HealthRecordUpdateManyWithoutTenantNestedInput
    auditLogs?: AuditLogUpdateManyWithoutTenantNestedInput
    notifications?: NotificationUpdateManyWithoutTenantNestedInput
    webhookEvents?: WebhookEventUpdateManyWithoutTenantNestedInput
    mutabaah?: MutabaahUpdateManyWithoutTenantNestedInput
    wallets?: WalletUpdateManyWithoutTenantNestedInput
    employees?: EmployeeUpdateManyWithoutTenantNestedInput
    payrolls?: PayrollUpdateManyWithoutTenantNestedInput
    academicScheds?: AcademicScheduleUpdateManyWithoutTenantNestedInput
    attendances?: AttendanceUpdateManyWithoutTenantNestedInput
    grades?: GradeUpdateManyWithoutTenantNestedInput
    ppdbRegistrations?: PpdbRegistrationUpdateManyWithoutTenantNestedInput
    ppdbDocuments?: PpdbDocumentUpdateManyWithoutTenantNestedInput
    ppdbExams?: PpdbExamUpdateManyWithoutTenantNestedInput
    inventoryItems?: ItemUpdateManyWithoutTenantNestedInput
    inventoryTransactions?: InventoryTransactionUpdateManyWithoutTenantNestedInput
    suppliers?: SupplierUpdateManyWithoutTenantNestedInput
    purchaseOrders?: PurchaseOrderUpdateManyWithoutTenantNestedInput
    buildings?: BuildingUpdateManyWithoutTenantNestedInput
    rooms?: RoomUpdateManyWithoutTenantNestedInput
    roomAssignments?: RoomAssignmentUpdateManyWithoutTenantNestedInput
    maintenanceTickets?: MaintenanceTicketUpdateManyWithoutTenantNestedInput
  }

  export type TenantUncheckedUpdateWithoutTahfidzInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    adminUserId?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    plan?: StringFieldUpdateOperationsInput | string
    billingContact?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    settings?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutTenantNestedInput
    santri?: SantriUncheckedUpdateManyWithoutTenantNestedInput
    wali?: WaliUncheckedUpdateManyWithoutTenantNestedInput
    izin?: IzinUncheckedUpdateManyWithoutTenantNestedInput
    catatanHarian?: CatatanHarianUncheckedUpdateManyWithoutTenantNestedInput
    pengumuman?: PengumumanUncheckedUpdateManyWithoutTenantNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutTenantNestedInput
    pelanggaran?: PelanggaranUncheckedUpdateManyWithoutTenantNestedInput
    pembinaan?: PembinaanUncheckedUpdateManyWithoutTenantNestedInput
    kunjungan?: KunjunganUncheckedUpdateManyWithoutTenantNestedInput
    healthRecords?: HealthRecordUncheckedUpdateManyWithoutTenantNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutTenantNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutTenantNestedInput
    webhookEvents?: WebhookEventUncheckedUpdateManyWithoutTenantNestedInput
    mutabaah?: MutabaahUncheckedUpdateManyWithoutTenantNestedInput
    wallets?: WalletUncheckedUpdateManyWithoutTenantNestedInput
    employees?: EmployeeUncheckedUpdateManyWithoutTenantNestedInput
    payrolls?: PayrollUncheckedUpdateManyWithoutTenantNestedInput
    academicScheds?: AcademicScheduleUncheckedUpdateManyWithoutTenantNestedInput
    attendances?: AttendanceUncheckedUpdateManyWithoutTenantNestedInput
    grades?: GradeUncheckedUpdateManyWithoutTenantNestedInput
    ppdbRegistrations?: PpdbRegistrationUncheckedUpdateManyWithoutTenantNestedInput
    ppdbDocuments?: PpdbDocumentUncheckedUpdateManyWithoutTenantNestedInput
    ppdbExams?: PpdbExamUncheckedUpdateManyWithoutTenantNestedInput
    inventoryItems?: ItemUncheckedUpdateManyWithoutTenantNestedInput
    inventoryTransactions?: InventoryTransactionUncheckedUpdateManyWithoutTenantNestedInput
    suppliers?: SupplierUncheckedUpdateManyWithoutTenantNestedInput
    purchaseOrders?: PurchaseOrderUncheckedUpdateManyWithoutTenantNestedInput
    buildings?: BuildingUncheckedUpdateManyWithoutTenantNestedInput
    rooms?: RoomUncheckedUpdateManyWithoutTenantNestedInput
    roomAssignments?: RoomAssignmentUncheckedUpdateManyWithoutTenantNestedInput
    maintenanceTickets?: MaintenanceTicketUncheckedUpdateManyWithoutTenantNestedInput
  }

  export type SantriUpsertWithoutTahfidzInput = {
    update: XOR<SantriUpdateWithoutTahfidzInput, SantriUncheckedUpdateWithoutTahfidzInput>
    create: XOR<SantriCreateWithoutTahfidzInput, SantriUncheckedCreateWithoutTahfidzInput>
    where?: SantriWhereInput
  }

  export type SantriUpdateToOneWithWhereWithoutTahfidzInput = {
    where?: SantriWhereInput
    data: XOR<SantriUpdateWithoutTahfidzInput, SantriUncheckedUpdateWithoutTahfidzInput>
  }

  export type SantriUpdateWithoutTahfidzInput = {
    id?: StringFieldUpdateOperationsInput | string
    nisn?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    gender?: StringFieldUpdateOperationsInput | string
    dob?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    kelas?: NullableStringFieldUpdateOperationsInput | string | null
    room?: NullableStringFieldUpdateOperationsInput | string | null
    contact?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutSantriNestedInput
    walis?: SantriWaliUpdateManyWithoutSantriNestedInput
    izin?: IzinUpdateManyWithoutSantriNestedInput
    catatanHarian?: CatatanHarianUpdateManyWithoutSantriNestedInput
    invoices?: InvoiceUpdateManyWithoutSantriNestedInput
    pelanggaran?: PelanggaranUpdateManyWithoutSantriNestedInput
    pembinaan?: PembinaanUpdateManyWithoutSantriNestedInput
    kunjungan?: KunjunganUpdateManyWithoutSantriNestedInput
    healthRecords?: HealthRecordUpdateManyWithoutSantriNestedInput
    medications?: MedicationUpdateManyWithoutSantriNestedInput
    mutabaah?: MutabaahUpdateManyWithoutSantriNestedInput
    wallet?: WalletUpdateOneWithoutSantriNestedInput
    attendances?: AttendanceUpdateManyWithoutSantriNestedInput
    grades?: GradeUpdateManyWithoutSantriNestedInput
  }

  export type SantriUncheckedUpdateWithoutTahfidzInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    nisn?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    gender?: StringFieldUpdateOperationsInput | string
    dob?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    kelas?: NullableStringFieldUpdateOperationsInput | string | null
    room?: NullableStringFieldUpdateOperationsInput | string | null
    contact?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    walis?: SantriWaliUncheckedUpdateManyWithoutSantriNestedInput
    izin?: IzinUncheckedUpdateManyWithoutSantriNestedInput
    catatanHarian?: CatatanHarianUncheckedUpdateManyWithoutSantriNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutSantriNestedInput
    pelanggaran?: PelanggaranUncheckedUpdateManyWithoutSantriNestedInput
    pembinaan?: PembinaanUncheckedUpdateManyWithoutSantriNestedInput
    kunjungan?: KunjunganUncheckedUpdateManyWithoutSantriNestedInput
    healthRecords?: HealthRecordUncheckedUpdateManyWithoutSantriNestedInput
    medications?: MedicationUncheckedUpdateManyWithoutSantriNestedInput
    mutabaah?: MutabaahUncheckedUpdateManyWithoutSantriNestedInput
    wallet?: WalletUncheckedUpdateOneWithoutSantriNestedInput
    attendances?: AttendanceUncheckedUpdateManyWithoutSantriNestedInput
    grades?: GradeUncheckedUpdateManyWithoutSantriNestedInput
  }

  export type TenantCreateWithoutMutabaahInput = {
    id?: string
    name: string
    address?: string | null
    phone?: string | null
    adminUserId?: string | null
    timezone?: string
    plan?: string
    billingContact?: string | null
    status?: string
    settings?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutTenantInput
    santri?: SantriCreateNestedManyWithoutTenantInput
    wali?: WaliCreateNestedManyWithoutTenantInput
    izin?: IzinCreateNestedManyWithoutTenantInput
    catatanHarian?: CatatanHarianCreateNestedManyWithoutTenantInput
    pengumuman?: PengumumanCreateNestedManyWithoutTenantInput
    invoices?: InvoiceCreateNestedManyWithoutTenantInput
    pelanggaran?: PelanggaranCreateNestedManyWithoutTenantInput
    pembinaan?: PembinaanCreateNestedManyWithoutTenantInput
    kunjungan?: KunjunganCreateNestedManyWithoutTenantInput
    healthRecords?: HealthRecordCreateNestedManyWithoutTenantInput
    auditLogs?: AuditLogCreateNestedManyWithoutTenantInput
    notifications?: NotificationCreateNestedManyWithoutTenantInput
    webhookEvents?: WebhookEventCreateNestedManyWithoutTenantInput
    tahfidz?: TahfidzCreateNestedManyWithoutTenantInput
    wallets?: WalletCreateNestedManyWithoutTenantInput
    employees?: EmployeeCreateNestedManyWithoutTenantInput
    payrolls?: PayrollCreateNestedManyWithoutTenantInput
    academicScheds?: AcademicScheduleCreateNestedManyWithoutTenantInput
    attendances?: AttendanceCreateNestedManyWithoutTenantInput
    grades?: GradeCreateNestedManyWithoutTenantInput
    ppdbRegistrations?: PpdbRegistrationCreateNestedManyWithoutTenantInput
    ppdbDocuments?: PpdbDocumentCreateNestedManyWithoutTenantInput
    ppdbExams?: PpdbExamCreateNestedManyWithoutTenantInput
    inventoryItems?: ItemCreateNestedManyWithoutTenantInput
    inventoryTransactions?: InventoryTransactionCreateNestedManyWithoutTenantInput
    suppliers?: SupplierCreateNestedManyWithoutTenantInput
    purchaseOrders?: PurchaseOrderCreateNestedManyWithoutTenantInput
    buildings?: BuildingCreateNestedManyWithoutTenantInput
    rooms?: RoomCreateNestedManyWithoutTenantInput
    roomAssignments?: RoomAssignmentCreateNestedManyWithoutTenantInput
    maintenanceTickets?: MaintenanceTicketCreateNestedManyWithoutTenantInput
  }

  export type TenantUncheckedCreateWithoutMutabaahInput = {
    id?: string
    name: string
    address?: string | null
    phone?: string | null
    adminUserId?: string | null
    timezone?: string
    plan?: string
    billingContact?: string | null
    status?: string
    settings?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutTenantInput
    santri?: SantriUncheckedCreateNestedManyWithoutTenantInput
    wali?: WaliUncheckedCreateNestedManyWithoutTenantInput
    izin?: IzinUncheckedCreateNestedManyWithoutTenantInput
    catatanHarian?: CatatanHarianUncheckedCreateNestedManyWithoutTenantInput
    pengumuman?: PengumumanUncheckedCreateNestedManyWithoutTenantInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutTenantInput
    pelanggaran?: PelanggaranUncheckedCreateNestedManyWithoutTenantInput
    pembinaan?: PembinaanUncheckedCreateNestedManyWithoutTenantInput
    kunjungan?: KunjunganUncheckedCreateNestedManyWithoutTenantInput
    healthRecords?: HealthRecordUncheckedCreateNestedManyWithoutTenantInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutTenantInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutTenantInput
    webhookEvents?: WebhookEventUncheckedCreateNestedManyWithoutTenantInput
    tahfidz?: TahfidzUncheckedCreateNestedManyWithoutTenantInput
    wallets?: WalletUncheckedCreateNestedManyWithoutTenantInput
    employees?: EmployeeUncheckedCreateNestedManyWithoutTenantInput
    payrolls?: PayrollUncheckedCreateNestedManyWithoutTenantInput
    academicScheds?: AcademicScheduleUncheckedCreateNestedManyWithoutTenantInput
    attendances?: AttendanceUncheckedCreateNestedManyWithoutTenantInput
    grades?: GradeUncheckedCreateNestedManyWithoutTenantInput
    ppdbRegistrations?: PpdbRegistrationUncheckedCreateNestedManyWithoutTenantInput
    ppdbDocuments?: PpdbDocumentUncheckedCreateNestedManyWithoutTenantInput
    ppdbExams?: PpdbExamUncheckedCreateNestedManyWithoutTenantInput
    inventoryItems?: ItemUncheckedCreateNestedManyWithoutTenantInput
    inventoryTransactions?: InventoryTransactionUncheckedCreateNestedManyWithoutTenantInput
    suppliers?: SupplierUncheckedCreateNestedManyWithoutTenantInput
    purchaseOrders?: PurchaseOrderUncheckedCreateNestedManyWithoutTenantInput
    buildings?: BuildingUncheckedCreateNestedManyWithoutTenantInput
    rooms?: RoomUncheckedCreateNestedManyWithoutTenantInput
    roomAssignments?: RoomAssignmentUncheckedCreateNestedManyWithoutTenantInput
    maintenanceTickets?: MaintenanceTicketUncheckedCreateNestedManyWithoutTenantInput
  }

  export type TenantCreateOrConnectWithoutMutabaahInput = {
    where: TenantWhereUniqueInput
    create: XOR<TenantCreateWithoutMutabaahInput, TenantUncheckedCreateWithoutMutabaahInput>
  }

  export type SantriCreateWithoutMutabaahInput = {
    id?: string
    nisn?: string | null
    name: string
    gender: string
    dob?: Date | string | null
    kelas?: string | null
    room?: string | null
    contact?: string | null
    address?: string | null
    photo?: string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutSantriInput
    walis?: SantriWaliCreateNestedManyWithoutSantriInput
    izin?: IzinCreateNestedManyWithoutSantriInput
    catatanHarian?: CatatanHarianCreateNestedManyWithoutSantriInput
    invoices?: InvoiceCreateNestedManyWithoutSantriInput
    pelanggaran?: PelanggaranCreateNestedManyWithoutSantriInput
    pembinaan?: PembinaanCreateNestedManyWithoutSantriInput
    kunjungan?: KunjunganCreateNestedManyWithoutSantriInput
    healthRecords?: HealthRecordCreateNestedManyWithoutSantriInput
    medications?: MedicationCreateNestedManyWithoutSantriInput
    tahfidz?: TahfidzCreateNestedManyWithoutSantriInput
    wallet?: WalletCreateNestedOneWithoutSantriInput
    attendances?: AttendanceCreateNestedManyWithoutSantriInput
    grades?: GradeCreateNestedManyWithoutSantriInput
  }

  export type SantriUncheckedCreateWithoutMutabaahInput = {
    id?: string
    tenantId: string
    nisn?: string | null
    name: string
    gender: string
    dob?: Date | string | null
    kelas?: string | null
    room?: string | null
    contact?: string | null
    address?: string | null
    photo?: string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    walis?: SantriWaliUncheckedCreateNestedManyWithoutSantriInput
    izin?: IzinUncheckedCreateNestedManyWithoutSantriInput
    catatanHarian?: CatatanHarianUncheckedCreateNestedManyWithoutSantriInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutSantriInput
    pelanggaran?: PelanggaranUncheckedCreateNestedManyWithoutSantriInput
    pembinaan?: PembinaanUncheckedCreateNestedManyWithoutSantriInput
    kunjungan?: KunjunganUncheckedCreateNestedManyWithoutSantriInput
    healthRecords?: HealthRecordUncheckedCreateNestedManyWithoutSantriInput
    medications?: MedicationUncheckedCreateNestedManyWithoutSantriInput
    tahfidz?: TahfidzUncheckedCreateNestedManyWithoutSantriInput
    wallet?: WalletUncheckedCreateNestedOneWithoutSantriInput
    attendances?: AttendanceUncheckedCreateNestedManyWithoutSantriInput
    grades?: GradeUncheckedCreateNestedManyWithoutSantriInput
  }

  export type SantriCreateOrConnectWithoutMutabaahInput = {
    where: SantriWhereUniqueInput
    create: XOR<SantriCreateWithoutMutabaahInput, SantriUncheckedCreateWithoutMutabaahInput>
  }

  export type TenantUpsertWithoutMutabaahInput = {
    update: XOR<TenantUpdateWithoutMutabaahInput, TenantUncheckedUpdateWithoutMutabaahInput>
    create: XOR<TenantCreateWithoutMutabaahInput, TenantUncheckedCreateWithoutMutabaahInput>
    where?: TenantWhereInput
  }

  export type TenantUpdateToOneWithWhereWithoutMutabaahInput = {
    where?: TenantWhereInput
    data: XOR<TenantUpdateWithoutMutabaahInput, TenantUncheckedUpdateWithoutMutabaahInput>
  }

  export type TenantUpdateWithoutMutabaahInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    adminUserId?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    plan?: StringFieldUpdateOperationsInput | string
    billingContact?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    settings?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutTenantNestedInput
    santri?: SantriUpdateManyWithoutTenantNestedInput
    wali?: WaliUpdateManyWithoutTenantNestedInput
    izin?: IzinUpdateManyWithoutTenantNestedInput
    catatanHarian?: CatatanHarianUpdateManyWithoutTenantNestedInput
    pengumuman?: PengumumanUpdateManyWithoutTenantNestedInput
    invoices?: InvoiceUpdateManyWithoutTenantNestedInput
    pelanggaran?: PelanggaranUpdateManyWithoutTenantNestedInput
    pembinaan?: PembinaanUpdateManyWithoutTenantNestedInput
    kunjungan?: KunjunganUpdateManyWithoutTenantNestedInput
    healthRecords?: HealthRecordUpdateManyWithoutTenantNestedInput
    auditLogs?: AuditLogUpdateManyWithoutTenantNestedInput
    notifications?: NotificationUpdateManyWithoutTenantNestedInput
    webhookEvents?: WebhookEventUpdateManyWithoutTenantNestedInput
    tahfidz?: TahfidzUpdateManyWithoutTenantNestedInput
    wallets?: WalletUpdateManyWithoutTenantNestedInput
    employees?: EmployeeUpdateManyWithoutTenantNestedInput
    payrolls?: PayrollUpdateManyWithoutTenantNestedInput
    academicScheds?: AcademicScheduleUpdateManyWithoutTenantNestedInput
    attendances?: AttendanceUpdateManyWithoutTenantNestedInput
    grades?: GradeUpdateManyWithoutTenantNestedInput
    ppdbRegistrations?: PpdbRegistrationUpdateManyWithoutTenantNestedInput
    ppdbDocuments?: PpdbDocumentUpdateManyWithoutTenantNestedInput
    ppdbExams?: PpdbExamUpdateManyWithoutTenantNestedInput
    inventoryItems?: ItemUpdateManyWithoutTenantNestedInput
    inventoryTransactions?: InventoryTransactionUpdateManyWithoutTenantNestedInput
    suppliers?: SupplierUpdateManyWithoutTenantNestedInput
    purchaseOrders?: PurchaseOrderUpdateManyWithoutTenantNestedInput
    buildings?: BuildingUpdateManyWithoutTenantNestedInput
    rooms?: RoomUpdateManyWithoutTenantNestedInput
    roomAssignments?: RoomAssignmentUpdateManyWithoutTenantNestedInput
    maintenanceTickets?: MaintenanceTicketUpdateManyWithoutTenantNestedInput
  }

  export type TenantUncheckedUpdateWithoutMutabaahInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    adminUserId?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    plan?: StringFieldUpdateOperationsInput | string
    billingContact?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    settings?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutTenantNestedInput
    santri?: SantriUncheckedUpdateManyWithoutTenantNestedInput
    wali?: WaliUncheckedUpdateManyWithoutTenantNestedInput
    izin?: IzinUncheckedUpdateManyWithoutTenantNestedInput
    catatanHarian?: CatatanHarianUncheckedUpdateManyWithoutTenantNestedInput
    pengumuman?: PengumumanUncheckedUpdateManyWithoutTenantNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutTenantNestedInput
    pelanggaran?: PelanggaranUncheckedUpdateManyWithoutTenantNestedInput
    pembinaan?: PembinaanUncheckedUpdateManyWithoutTenantNestedInput
    kunjungan?: KunjunganUncheckedUpdateManyWithoutTenantNestedInput
    healthRecords?: HealthRecordUncheckedUpdateManyWithoutTenantNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutTenantNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutTenantNestedInput
    webhookEvents?: WebhookEventUncheckedUpdateManyWithoutTenantNestedInput
    tahfidz?: TahfidzUncheckedUpdateManyWithoutTenantNestedInput
    wallets?: WalletUncheckedUpdateManyWithoutTenantNestedInput
    employees?: EmployeeUncheckedUpdateManyWithoutTenantNestedInput
    payrolls?: PayrollUncheckedUpdateManyWithoutTenantNestedInput
    academicScheds?: AcademicScheduleUncheckedUpdateManyWithoutTenantNestedInput
    attendances?: AttendanceUncheckedUpdateManyWithoutTenantNestedInput
    grades?: GradeUncheckedUpdateManyWithoutTenantNestedInput
    ppdbRegistrations?: PpdbRegistrationUncheckedUpdateManyWithoutTenantNestedInput
    ppdbDocuments?: PpdbDocumentUncheckedUpdateManyWithoutTenantNestedInput
    ppdbExams?: PpdbExamUncheckedUpdateManyWithoutTenantNestedInput
    inventoryItems?: ItemUncheckedUpdateManyWithoutTenantNestedInput
    inventoryTransactions?: InventoryTransactionUncheckedUpdateManyWithoutTenantNestedInput
    suppliers?: SupplierUncheckedUpdateManyWithoutTenantNestedInput
    purchaseOrders?: PurchaseOrderUncheckedUpdateManyWithoutTenantNestedInput
    buildings?: BuildingUncheckedUpdateManyWithoutTenantNestedInput
    rooms?: RoomUncheckedUpdateManyWithoutTenantNestedInput
    roomAssignments?: RoomAssignmentUncheckedUpdateManyWithoutTenantNestedInput
    maintenanceTickets?: MaintenanceTicketUncheckedUpdateManyWithoutTenantNestedInput
  }

  export type SantriUpsertWithoutMutabaahInput = {
    update: XOR<SantriUpdateWithoutMutabaahInput, SantriUncheckedUpdateWithoutMutabaahInput>
    create: XOR<SantriCreateWithoutMutabaahInput, SantriUncheckedCreateWithoutMutabaahInput>
    where?: SantriWhereInput
  }

  export type SantriUpdateToOneWithWhereWithoutMutabaahInput = {
    where?: SantriWhereInput
    data: XOR<SantriUpdateWithoutMutabaahInput, SantriUncheckedUpdateWithoutMutabaahInput>
  }

  export type SantriUpdateWithoutMutabaahInput = {
    id?: StringFieldUpdateOperationsInput | string
    nisn?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    gender?: StringFieldUpdateOperationsInput | string
    dob?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    kelas?: NullableStringFieldUpdateOperationsInput | string | null
    room?: NullableStringFieldUpdateOperationsInput | string | null
    contact?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutSantriNestedInput
    walis?: SantriWaliUpdateManyWithoutSantriNestedInput
    izin?: IzinUpdateManyWithoutSantriNestedInput
    catatanHarian?: CatatanHarianUpdateManyWithoutSantriNestedInput
    invoices?: InvoiceUpdateManyWithoutSantriNestedInput
    pelanggaran?: PelanggaranUpdateManyWithoutSantriNestedInput
    pembinaan?: PembinaanUpdateManyWithoutSantriNestedInput
    kunjungan?: KunjunganUpdateManyWithoutSantriNestedInput
    healthRecords?: HealthRecordUpdateManyWithoutSantriNestedInput
    medications?: MedicationUpdateManyWithoutSantriNestedInput
    tahfidz?: TahfidzUpdateManyWithoutSantriNestedInput
    wallet?: WalletUpdateOneWithoutSantriNestedInput
    attendances?: AttendanceUpdateManyWithoutSantriNestedInput
    grades?: GradeUpdateManyWithoutSantriNestedInput
  }

  export type SantriUncheckedUpdateWithoutMutabaahInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    nisn?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    gender?: StringFieldUpdateOperationsInput | string
    dob?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    kelas?: NullableStringFieldUpdateOperationsInput | string | null
    room?: NullableStringFieldUpdateOperationsInput | string | null
    contact?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    walis?: SantriWaliUncheckedUpdateManyWithoutSantriNestedInput
    izin?: IzinUncheckedUpdateManyWithoutSantriNestedInput
    catatanHarian?: CatatanHarianUncheckedUpdateManyWithoutSantriNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutSantriNestedInput
    pelanggaran?: PelanggaranUncheckedUpdateManyWithoutSantriNestedInput
    pembinaan?: PembinaanUncheckedUpdateManyWithoutSantriNestedInput
    kunjungan?: KunjunganUncheckedUpdateManyWithoutSantriNestedInput
    healthRecords?: HealthRecordUncheckedUpdateManyWithoutSantriNestedInput
    medications?: MedicationUncheckedUpdateManyWithoutSantriNestedInput
    tahfidz?: TahfidzUncheckedUpdateManyWithoutSantriNestedInput
    wallet?: WalletUncheckedUpdateOneWithoutSantriNestedInput
    attendances?: AttendanceUncheckedUpdateManyWithoutSantriNestedInput
    grades?: GradeUncheckedUpdateManyWithoutSantriNestedInput
  }

  export type TenantCreateWithoutWalletsInput = {
    id?: string
    name: string
    address?: string | null
    phone?: string | null
    adminUserId?: string | null
    timezone?: string
    plan?: string
    billingContact?: string | null
    status?: string
    settings?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutTenantInput
    santri?: SantriCreateNestedManyWithoutTenantInput
    wali?: WaliCreateNestedManyWithoutTenantInput
    izin?: IzinCreateNestedManyWithoutTenantInput
    catatanHarian?: CatatanHarianCreateNestedManyWithoutTenantInput
    pengumuman?: PengumumanCreateNestedManyWithoutTenantInput
    invoices?: InvoiceCreateNestedManyWithoutTenantInput
    pelanggaran?: PelanggaranCreateNestedManyWithoutTenantInput
    pembinaan?: PembinaanCreateNestedManyWithoutTenantInput
    kunjungan?: KunjunganCreateNestedManyWithoutTenantInput
    healthRecords?: HealthRecordCreateNestedManyWithoutTenantInput
    auditLogs?: AuditLogCreateNestedManyWithoutTenantInput
    notifications?: NotificationCreateNestedManyWithoutTenantInput
    webhookEvents?: WebhookEventCreateNestedManyWithoutTenantInput
    tahfidz?: TahfidzCreateNestedManyWithoutTenantInput
    mutabaah?: MutabaahCreateNestedManyWithoutTenantInput
    employees?: EmployeeCreateNestedManyWithoutTenantInput
    payrolls?: PayrollCreateNestedManyWithoutTenantInput
    academicScheds?: AcademicScheduleCreateNestedManyWithoutTenantInput
    attendances?: AttendanceCreateNestedManyWithoutTenantInput
    grades?: GradeCreateNestedManyWithoutTenantInput
    ppdbRegistrations?: PpdbRegistrationCreateNestedManyWithoutTenantInput
    ppdbDocuments?: PpdbDocumentCreateNestedManyWithoutTenantInput
    ppdbExams?: PpdbExamCreateNestedManyWithoutTenantInput
    inventoryItems?: ItemCreateNestedManyWithoutTenantInput
    inventoryTransactions?: InventoryTransactionCreateNestedManyWithoutTenantInput
    suppliers?: SupplierCreateNestedManyWithoutTenantInput
    purchaseOrders?: PurchaseOrderCreateNestedManyWithoutTenantInput
    buildings?: BuildingCreateNestedManyWithoutTenantInput
    rooms?: RoomCreateNestedManyWithoutTenantInput
    roomAssignments?: RoomAssignmentCreateNestedManyWithoutTenantInput
    maintenanceTickets?: MaintenanceTicketCreateNestedManyWithoutTenantInput
  }

  export type TenantUncheckedCreateWithoutWalletsInput = {
    id?: string
    name: string
    address?: string | null
    phone?: string | null
    adminUserId?: string | null
    timezone?: string
    plan?: string
    billingContact?: string | null
    status?: string
    settings?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutTenantInput
    santri?: SantriUncheckedCreateNestedManyWithoutTenantInput
    wali?: WaliUncheckedCreateNestedManyWithoutTenantInput
    izin?: IzinUncheckedCreateNestedManyWithoutTenantInput
    catatanHarian?: CatatanHarianUncheckedCreateNestedManyWithoutTenantInput
    pengumuman?: PengumumanUncheckedCreateNestedManyWithoutTenantInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutTenantInput
    pelanggaran?: PelanggaranUncheckedCreateNestedManyWithoutTenantInput
    pembinaan?: PembinaanUncheckedCreateNestedManyWithoutTenantInput
    kunjungan?: KunjunganUncheckedCreateNestedManyWithoutTenantInput
    healthRecords?: HealthRecordUncheckedCreateNestedManyWithoutTenantInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutTenantInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutTenantInput
    webhookEvents?: WebhookEventUncheckedCreateNestedManyWithoutTenantInput
    tahfidz?: TahfidzUncheckedCreateNestedManyWithoutTenantInput
    mutabaah?: MutabaahUncheckedCreateNestedManyWithoutTenantInput
    employees?: EmployeeUncheckedCreateNestedManyWithoutTenantInput
    payrolls?: PayrollUncheckedCreateNestedManyWithoutTenantInput
    academicScheds?: AcademicScheduleUncheckedCreateNestedManyWithoutTenantInput
    attendances?: AttendanceUncheckedCreateNestedManyWithoutTenantInput
    grades?: GradeUncheckedCreateNestedManyWithoutTenantInput
    ppdbRegistrations?: PpdbRegistrationUncheckedCreateNestedManyWithoutTenantInput
    ppdbDocuments?: PpdbDocumentUncheckedCreateNestedManyWithoutTenantInput
    ppdbExams?: PpdbExamUncheckedCreateNestedManyWithoutTenantInput
    inventoryItems?: ItemUncheckedCreateNestedManyWithoutTenantInput
    inventoryTransactions?: InventoryTransactionUncheckedCreateNestedManyWithoutTenantInput
    suppliers?: SupplierUncheckedCreateNestedManyWithoutTenantInput
    purchaseOrders?: PurchaseOrderUncheckedCreateNestedManyWithoutTenantInput
    buildings?: BuildingUncheckedCreateNestedManyWithoutTenantInput
    rooms?: RoomUncheckedCreateNestedManyWithoutTenantInput
    roomAssignments?: RoomAssignmentUncheckedCreateNestedManyWithoutTenantInput
    maintenanceTickets?: MaintenanceTicketUncheckedCreateNestedManyWithoutTenantInput
  }

  export type TenantCreateOrConnectWithoutWalletsInput = {
    where: TenantWhereUniqueInput
    create: XOR<TenantCreateWithoutWalletsInput, TenantUncheckedCreateWithoutWalletsInput>
  }

  export type SantriCreateWithoutWalletInput = {
    id?: string
    nisn?: string | null
    name: string
    gender: string
    dob?: Date | string | null
    kelas?: string | null
    room?: string | null
    contact?: string | null
    address?: string | null
    photo?: string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutSantriInput
    walis?: SantriWaliCreateNestedManyWithoutSantriInput
    izin?: IzinCreateNestedManyWithoutSantriInput
    catatanHarian?: CatatanHarianCreateNestedManyWithoutSantriInput
    invoices?: InvoiceCreateNestedManyWithoutSantriInput
    pelanggaran?: PelanggaranCreateNestedManyWithoutSantriInput
    pembinaan?: PembinaanCreateNestedManyWithoutSantriInput
    kunjungan?: KunjunganCreateNestedManyWithoutSantriInput
    healthRecords?: HealthRecordCreateNestedManyWithoutSantriInput
    medications?: MedicationCreateNestedManyWithoutSantriInput
    tahfidz?: TahfidzCreateNestedManyWithoutSantriInput
    mutabaah?: MutabaahCreateNestedManyWithoutSantriInput
    attendances?: AttendanceCreateNestedManyWithoutSantriInput
    grades?: GradeCreateNestedManyWithoutSantriInput
  }

  export type SantriUncheckedCreateWithoutWalletInput = {
    id?: string
    tenantId: string
    nisn?: string | null
    name: string
    gender: string
    dob?: Date | string | null
    kelas?: string | null
    room?: string | null
    contact?: string | null
    address?: string | null
    photo?: string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    walis?: SantriWaliUncheckedCreateNestedManyWithoutSantriInput
    izin?: IzinUncheckedCreateNestedManyWithoutSantriInput
    catatanHarian?: CatatanHarianUncheckedCreateNestedManyWithoutSantriInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutSantriInput
    pelanggaran?: PelanggaranUncheckedCreateNestedManyWithoutSantriInput
    pembinaan?: PembinaanUncheckedCreateNestedManyWithoutSantriInput
    kunjungan?: KunjunganUncheckedCreateNestedManyWithoutSantriInput
    healthRecords?: HealthRecordUncheckedCreateNestedManyWithoutSantriInput
    medications?: MedicationUncheckedCreateNestedManyWithoutSantriInput
    tahfidz?: TahfidzUncheckedCreateNestedManyWithoutSantriInput
    mutabaah?: MutabaahUncheckedCreateNestedManyWithoutSantriInput
    attendances?: AttendanceUncheckedCreateNestedManyWithoutSantriInput
    grades?: GradeUncheckedCreateNestedManyWithoutSantriInput
  }

  export type SantriCreateOrConnectWithoutWalletInput = {
    where: SantriWhereUniqueInput
    create: XOR<SantriCreateWithoutWalletInput, SantriUncheckedCreateWithoutWalletInput>
  }

  export type WalletTransactionCreateWithoutWalletInput = {
    id?: string
    amount: number
    type: string
    method: string
    description?: string | null
    reference?: string | null
    status?: string
    handledBy?: string | null
    createdAt?: Date | string
  }

  export type WalletTransactionUncheckedCreateWithoutWalletInput = {
    id?: string
    amount: number
    type: string
    method: string
    description?: string | null
    reference?: string | null
    status?: string
    handledBy?: string | null
    createdAt?: Date | string
  }

  export type WalletTransactionCreateOrConnectWithoutWalletInput = {
    where: WalletTransactionWhereUniqueInput
    create: XOR<WalletTransactionCreateWithoutWalletInput, WalletTransactionUncheckedCreateWithoutWalletInput>
  }

  export type WalletTransactionCreateManyWalletInputEnvelope = {
    data: WalletTransactionCreateManyWalletInput | WalletTransactionCreateManyWalletInput[]
  }

  export type TenantUpsertWithoutWalletsInput = {
    update: XOR<TenantUpdateWithoutWalletsInput, TenantUncheckedUpdateWithoutWalletsInput>
    create: XOR<TenantCreateWithoutWalletsInput, TenantUncheckedCreateWithoutWalletsInput>
    where?: TenantWhereInput
  }

  export type TenantUpdateToOneWithWhereWithoutWalletsInput = {
    where?: TenantWhereInput
    data: XOR<TenantUpdateWithoutWalletsInput, TenantUncheckedUpdateWithoutWalletsInput>
  }

  export type TenantUpdateWithoutWalletsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    adminUserId?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    plan?: StringFieldUpdateOperationsInput | string
    billingContact?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    settings?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutTenantNestedInput
    santri?: SantriUpdateManyWithoutTenantNestedInput
    wali?: WaliUpdateManyWithoutTenantNestedInput
    izin?: IzinUpdateManyWithoutTenantNestedInput
    catatanHarian?: CatatanHarianUpdateManyWithoutTenantNestedInput
    pengumuman?: PengumumanUpdateManyWithoutTenantNestedInput
    invoices?: InvoiceUpdateManyWithoutTenantNestedInput
    pelanggaran?: PelanggaranUpdateManyWithoutTenantNestedInput
    pembinaan?: PembinaanUpdateManyWithoutTenantNestedInput
    kunjungan?: KunjunganUpdateManyWithoutTenantNestedInput
    healthRecords?: HealthRecordUpdateManyWithoutTenantNestedInput
    auditLogs?: AuditLogUpdateManyWithoutTenantNestedInput
    notifications?: NotificationUpdateManyWithoutTenantNestedInput
    webhookEvents?: WebhookEventUpdateManyWithoutTenantNestedInput
    tahfidz?: TahfidzUpdateManyWithoutTenantNestedInput
    mutabaah?: MutabaahUpdateManyWithoutTenantNestedInput
    employees?: EmployeeUpdateManyWithoutTenantNestedInput
    payrolls?: PayrollUpdateManyWithoutTenantNestedInput
    academicScheds?: AcademicScheduleUpdateManyWithoutTenantNestedInput
    attendances?: AttendanceUpdateManyWithoutTenantNestedInput
    grades?: GradeUpdateManyWithoutTenantNestedInput
    ppdbRegistrations?: PpdbRegistrationUpdateManyWithoutTenantNestedInput
    ppdbDocuments?: PpdbDocumentUpdateManyWithoutTenantNestedInput
    ppdbExams?: PpdbExamUpdateManyWithoutTenantNestedInput
    inventoryItems?: ItemUpdateManyWithoutTenantNestedInput
    inventoryTransactions?: InventoryTransactionUpdateManyWithoutTenantNestedInput
    suppliers?: SupplierUpdateManyWithoutTenantNestedInput
    purchaseOrders?: PurchaseOrderUpdateManyWithoutTenantNestedInput
    buildings?: BuildingUpdateManyWithoutTenantNestedInput
    rooms?: RoomUpdateManyWithoutTenantNestedInput
    roomAssignments?: RoomAssignmentUpdateManyWithoutTenantNestedInput
    maintenanceTickets?: MaintenanceTicketUpdateManyWithoutTenantNestedInput
  }

  export type TenantUncheckedUpdateWithoutWalletsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    adminUserId?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    plan?: StringFieldUpdateOperationsInput | string
    billingContact?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    settings?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutTenantNestedInput
    santri?: SantriUncheckedUpdateManyWithoutTenantNestedInput
    wali?: WaliUncheckedUpdateManyWithoutTenantNestedInput
    izin?: IzinUncheckedUpdateManyWithoutTenantNestedInput
    catatanHarian?: CatatanHarianUncheckedUpdateManyWithoutTenantNestedInput
    pengumuman?: PengumumanUncheckedUpdateManyWithoutTenantNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutTenantNestedInput
    pelanggaran?: PelanggaranUncheckedUpdateManyWithoutTenantNestedInput
    pembinaan?: PembinaanUncheckedUpdateManyWithoutTenantNestedInput
    kunjungan?: KunjunganUncheckedUpdateManyWithoutTenantNestedInput
    healthRecords?: HealthRecordUncheckedUpdateManyWithoutTenantNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutTenantNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutTenantNestedInput
    webhookEvents?: WebhookEventUncheckedUpdateManyWithoutTenantNestedInput
    tahfidz?: TahfidzUncheckedUpdateManyWithoutTenantNestedInput
    mutabaah?: MutabaahUncheckedUpdateManyWithoutTenantNestedInput
    employees?: EmployeeUncheckedUpdateManyWithoutTenantNestedInput
    payrolls?: PayrollUncheckedUpdateManyWithoutTenantNestedInput
    academicScheds?: AcademicScheduleUncheckedUpdateManyWithoutTenantNestedInput
    attendances?: AttendanceUncheckedUpdateManyWithoutTenantNestedInput
    grades?: GradeUncheckedUpdateManyWithoutTenantNestedInput
    ppdbRegistrations?: PpdbRegistrationUncheckedUpdateManyWithoutTenantNestedInput
    ppdbDocuments?: PpdbDocumentUncheckedUpdateManyWithoutTenantNestedInput
    ppdbExams?: PpdbExamUncheckedUpdateManyWithoutTenantNestedInput
    inventoryItems?: ItemUncheckedUpdateManyWithoutTenantNestedInput
    inventoryTransactions?: InventoryTransactionUncheckedUpdateManyWithoutTenantNestedInput
    suppliers?: SupplierUncheckedUpdateManyWithoutTenantNestedInput
    purchaseOrders?: PurchaseOrderUncheckedUpdateManyWithoutTenantNestedInput
    buildings?: BuildingUncheckedUpdateManyWithoutTenantNestedInput
    rooms?: RoomUncheckedUpdateManyWithoutTenantNestedInput
    roomAssignments?: RoomAssignmentUncheckedUpdateManyWithoutTenantNestedInput
    maintenanceTickets?: MaintenanceTicketUncheckedUpdateManyWithoutTenantNestedInput
  }

  export type SantriUpsertWithoutWalletInput = {
    update: XOR<SantriUpdateWithoutWalletInput, SantriUncheckedUpdateWithoutWalletInput>
    create: XOR<SantriCreateWithoutWalletInput, SantriUncheckedCreateWithoutWalletInput>
    where?: SantriWhereInput
  }

  export type SantriUpdateToOneWithWhereWithoutWalletInput = {
    where?: SantriWhereInput
    data: XOR<SantriUpdateWithoutWalletInput, SantriUncheckedUpdateWithoutWalletInput>
  }

  export type SantriUpdateWithoutWalletInput = {
    id?: StringFieldUpdateOperationsInput | string
    nisn?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    gender?: StringFieldUpdateOperationsInput | string
    dob?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    kelas?: NullableStringFieldUpdateOperationsInput | string | null
    room?: NullableStringFieldUpdateOperationsInput | string | null
    contact?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutSantriNestedInput
    walis?: SantriWaliUpdateManyWithoutSantriNestedInput
    izin?: IzinUpdateManyWithoutSantriNestedInput
    catatanHarian?: CatatanHarianUpdateManyWithoutSantriNestedInput
    invoices?: InvoiceUpdateManyWithoutSantriNestedInput
    pelanggaran?: PelanggaranUpdateManyWithoutSantriNestedInput
    pembinaan?: PembinaanUpdateManyWithoutSantriNestedInput
    kunjungan?: KunjunganUpdateManyWithoutSantriNestedInput
    healthRecords?: HealthRecordUpdateManyWithoutSantriNestedInput
    medications?: MedicationUpdateManyWithoutSantriNestedInput
    tahfidz?: TahfidzUpdateManyWithoutSantriNestedInput
    mutabaah?: MutabaahUpdateManyWithoutSantriNestedInput
    attendances?: AttendanceUpdateManyWithoutSantriNestedInput
    grades?: GradeUpdateManyWithoutSantriNestedInput
  }

  export type SantriUncheckedUpdateWithoutWalletInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    nisn?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    gender?: StringFieldUpdateOperationsInput | string
    dob?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    kelas?: NullableStringFieldUpdateOperationsInput | string | null
    room?: NullableStringFieldUpdateOperationsInput | string | null
    contact?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    walis?: SantriWaliUncheckedUpdateManyWithoutSantriNestedInput
    izin?: IzinUncheckedUpdateManyWithoutSantriNestedInput
    catatanHarian?: CatatanHarianUncheckedUpdateManyWithoutSantriNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutSantriNestedInput
    pelanggaran?: PelanggaranUncheckedUpdateManyWithoutSantriNestedInput
    pembinaan?: PembinaanUncheckedUpdateManyWithoutSantriNestedInput
    kunjungan?: KunjunganUncheckedUpdateManyWithoutSantriNestedInput
    healthRecords?: HealthRecordUncheckedUpdateManyWithoutSantriNestedInput
    medications?: MedicationUncheckedUpdateManyWithoutSantriNestedInput
    tahfidz?: TahfidzUncheckedUpdateManyWithoutSantriNestedInput
    mutabaah?: MutabaahUncheckedUpdateManyWithoutSantriNestedInput
    attendances?: AttendanceUncheckedUpdateManyWithoutSantriNestedInput
    grades?: GradeUncheckedUpdateManyWithoutSantriNestedInput
  }

  export type WalletTransactionUpsertWithWhereUniqueWithoutWalletInput = {
    where: WalletTransactionWhereUniqueInput
    update: XOR<WalletTransactionUpdateWithoutWalletInput, WalletTransactionUncheckedUpdateWithoutWalletInput>
    create: XOR<WalletTransactionCreateWithoutWalletInput, WalletTransactionUncheckedCreateWithoutWalletInput>
  }

  export type WalletTransactionUpdateWithWhereUniqueWithoutWalletInput = {
    where: WalletTransactionWhereUniqueInput
    data: XOR<WalletTransactionUpdateWithoutWalletInput, WalletTransactionUncheckedUpdateWithoutWalletInput>
  }

  export type WalletTransactionUpdateManyWithWhereWithoutWalletInput = {
    where: WalletTransactionScalarWhereInput
    data: XOR<WalletTransactionUpdateManyMutationInput, WalletTransactionUncheckedUpdateManyWithoutWalletInput>
  }

  export type WalletTransactionScalarWhereInput = {
    AND?: WalletTransactionScalarWhereInput | WalletTransactionScalarWhereInput[]
    OR?: WalletTransactionScalarWhereInput[]
    NOT?: WalletTransactionScalarWhereInput | WalletTransactionScalarWhereInput[]
    id?: StringFilter<"WalletTransaction"> | string
    walletId?: StringFilter<"WalletTransaction"> | string
    amount?: FloatFilter<"WalletTransaction"> | number
    type?: StringFilter<"WalletTransaction"> | string
    method?: StringFilter<"WalletTransaction"> | string
    description?: StringNullableFilter<"WalletTransaction"> | string | null
    reference?: StringNullableFilter<"WalletTransaction"> | string | null
    status?: StringFilter<"WalletTransaction"> | string
    handledBy?: StringNullableFilter<"WalletTransaction"> | string | null
    createdAt?: DateTimeFilter<"WalletTransaction"> | Date | string
  }

  export type WalletCreateWithoutTransactionsInput = {
    id?: string
    balance?: number
    pin?: string | null
    isActive?: boolean
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutWalletsInput
    santri: SantriCreateNestedOneWithoutWalletInput
  }

  export type WalletUncheckedCreateWithoutTransactionsInput = {
    id?: string
    tenantId: string
    santriId: string
    balance?: number
    pin?: string | null
    isActive?: boolean
    updatedAt?: Date | string
  }

  export type WalletCreateOrConnectWithoutTransactionsInput = {
    where: WalletWhereUniqueInput
    create: XOR<WalletCreateWithoutTransactionsInput, WalletUncheckedCreateWithoutTransactionsInput>
  }

  export type WalletUpsertWithoutTransactionsInput = {
    update: XOR<WalletUpdateWithoutTransactionsInput, WalletUncheckedUpdateWithoutTransactionsInput>
    create: XOR<WalletCreateWithoutTransactionsInput, WalletUncheckedCreateWithoutTransactionsInput>
    where?: WalletWhereInput
  }

  export type WalletUpdateToOneWithWhereWithoutTransactionsInput = {
    where?: WalletWhereInput
    data: XOR<WalletUpdateWithoutTransactionsInput, WalletUncheckedUpdateWithoutTransactionsInput>
  }

  export type WalletUpdateWithoutTransactionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    balance?: FloatFieldUpdateOperationsInput | number
    pin?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutWalletsNestedInput
    santri?: SantriUpdateOneRequiredWithoutWalletNestedInput
  }

  export type WalletUncheckedUpdateWithoutTransactionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    santriId?: StringFieldUpdateOperationsInput | string
    balance?: FloatFieldUpdateOperationsInput | number
    pin?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TenantCreateWithoutEmployeesInput = {
    id?: string
    name: string
    address?: string | null
    phone?: string | null
    adminUserId?: string | null
    timezone?: string
    plan?: string
    billingContact?: string | null
    status?: string
    settings?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutTenantInput
    santri?: SantriCreateNestedManyWithoutTenantInput
    wali?: WaliCreateNestedManyWithoutTenantInput
    izin?: IzinCreateNestedManyWithoutTenantInput
    catatanHarian?: CatatanHarianCreateNestedManyWithoutTenantInput
    pengumuman?: PengumumanCreateNestedManyWithoutTenantInput
    invoices?: InvoiceCreateNestedManyWithoutTenantInput
    pelanggaran?: PelanggaranCreateNestedManyWithoutTenantInput
    pembinaan?: PembinaanCreateNestedManyWithoutTenantInput
    kunjungan?: KunjunganCreateNestedManyWithoutTenantInput
    healthRecords?: HealthRecordCreateNestedManyWithoutTenantInput
    auditLogs?: AuditLogCreateNestedManyWithoutTenantInput
    notifications?: NotificationCreateNestedManyWithoutTenantInput
    webhookEvents?: WebhookEventCreateNestedManyWithoutTenantInput
    tahfidz?: TahfidzCreateNestedManyWithoutTenantInput
    mutabaah?: MutabaahCreateNestedManyWithoutTenantInput
    wallets?: WalletCreateNestedManyWithoutTenantInput
    payrolls?: PayrollCreateNestedManyWithoutTenantInput
    academicScheds?: AcademicScheduleCreateNestedManyWithoutTenantInput
    attendances?: AttendanceCreateNestedManyWithoutTenantInput
    grades?: GradeCreateNestedManyWithoutTenantInput
    ppdbRegistrations?: PpdbRegistrationCreateNestedManyWithoutTenantInput
    ppdbDocuments?: PpdbDocumentCreateNestedManyWithoutTenantInput
    ppdbExams?: PpdbExamCreateNestedManyWithoutTenantInput
    inventoryItems?: ItemCreateNestedManyWithoutTenantInput
    inventoryTransactions?: InventoryTransactionCreateNestedManyWithoutTenantInput
    suppliers?: SupplierCreateNestedManyWithoutTenantInput
    purchaseOrders?: PurchaseOrderCreateNestedManyWithoutTenantInput
    buildings?: BuildingCreateNestedManyWithoutTenantInput
    rooms?: RoomCreateNestedManyWithoutTenantInput
    roomAssignments?: RoomAssignmentCreateNestedManyWithoutTenantInput
    maintenanceTickets?: MaintenanceTicketCreateNestedManyWithoutTenantInput
  }

  export type TenantUncheckedCreateWithoutEmployeesInput = {
    id?: string
    name: string
    address?: string | null
    phone?: string | null
    adminUserId?: string | null
    timezone?: string
    plan?: string
    billingContact?: string | null
    status?: string
    settings?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutTenantInput
    santri?: SantriUncheckedCreateNestedManyWithoutTenantInput
    wali?: WaliUncheckedCreateNestedManyWithoutTenantInput
    izin?: IzinUncheckedCreateNestedManyWithoutTenantInput
    catatanHarian?: CatatanHarianUncheckedCreateNestedManyWithoutTenantInput
    pengumuman?: PengumumanUncheckedCreateNestedManyWithoutTenantInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutTenantInput
    pelanggaran?: PelanggaranUncheckedCreateNestedManyWithoutTenantInput
    pembinaan?: PembinaanUncheckedCreateNestedManyWithoutTenantInput
    kunjungan?: KunjunganUncheckedCreateNestedManyWithoutTenantInput
    healthRecords?: HealthRecordUncheckedCreateNestedManyWithoutTenantInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutTenantInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutTenantInput
    webhookEvents?: WebhookEventUncheckedCreateNestedManyWithoutTenantInput
    tahfidz?: TahfidzUncheckedCreateNestedManyWithoutTenantInput
    mutabaah?: MutabaahUncheckedCreateNestedManyWithoutTenantInput
    wallets?: WalletUncheckedCreateNestedManyWithoutTenantInput
    payrolls?: PayrollUncheckedCreateNestedManyWithoutTenantInput
    academicScheds?: AcademicScheduleUncheckedCreateNestedManyWithoutTenantInput
    attendances?: AttendanceUncheckedCreateNestedManyWithoutTenantInput
    grades?: GradeUncheckedCreateNestedManyWithoutTenantInput
    ppdbRegistrations?: PpdbRegistrationUncheckedCreateNestedManyWithoutTenantInput
    ppdbDocuments?: PpdbDocumentUncheckedCreateNestedManyWithoutTenantInput
    ppdbExams?: PpdbExamUncheckedCreateNestedManyWithoutTenantInput
    inventoryItems?: ItemUncheckedCreateNestedManyWithoutTenantInput
    inventoryTransactions?: InventoryTransactionUncheckedCreateNestedManyWithoutTenantInput
    suppliers?: SupplierUncheckedCreateNestedManyWithoutTenantInput
    purchaseOrders?: PurchaseOrderUncheckedCreateNestedManyWithoutTenantInput
    buildings?: BuildingUncheckedCreateNestedManyWithoutTenantInput
    rooms?: RoomUncheckedCreateNestedManyWithoutTenantInput
    roomAssignments?: RoomAssignmentUncheckedCreateNestedManyWithoutTenantInput
    maintenanceTickets?: MaintenanceTicketUncheckedCreateNestedManyWithoutTenantInput
  }

  export type TenantCreateOrConnectWithoutEmployeesInput = {
    where: TenantWhereUniqueInput
    create: XOR<TenantCreateWithoutEmployeesInput, TenantUncheckedCreateWithoutEmployeesInput>
  }

  export type PayrollCreateWithoutEmployeeInput = {
    id?: string
    month: number
    year: number
    baseSalary?: number
    allowances?: number
    deductions?: number
    netAmount: number
    status?: string
    paidAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutPayrollsInput
  }

  export type PayrollUncheckedCreateWithoutEmployeeInput = {
    id?: string
    tenantId: string
    month: number
    year: number
    baseSalary?: number
    allowances?: number
    deductions?: number
    netAmount: number
    status?: string
    paidAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PayrollCreateOrConnectWithoutEmployeeInput = {
    where: PayrollWhereUniqueInput
    create: XOR<PayrollCreateWithoutEmployeeInput, PayrollUncheckedCreateWithoutEmployeeInput>
  }

  export type PayrollCreateManyEmployeeInputEnvelope = {
    data: PayrollCreateManyEmployeeInput | PayrollCreateManyEmployeeInput[]
  }

  export type TenantUpsertWithoutEmployeesInput = {
    update: XOR<TenantUpdateWithoutEmployeesInput, TenantUncheckedUpdateWithoutEmployeesInput>
    create: XOR<TenantCreateWithoutEmployeesInput, TenantUncheckedCreateWithoutEmployeesInput>
    where?: TenantWhereInput
  }

  export type TenantUpdateToOneWithWhereWithoutEmployeesInput = {
    where?: TenantWhereInput
    data: XOR<TenantUpdateWithoutEmployeesInput, TenantUncheckedUpdateWithoutEmployeesInput>
  }

  export type TenantUpdateWithoutEmployeesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    adminUserId?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    plan?: StringFieldUpdateOperationsInput | string
    billingContact?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    settings?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutTenantNestedInput
    santri?: SantriUpdateManyWithoutTenantNestedInput
    wali?: WaliUpdateManyWithoutTenantNestedInput
    izin?: IzinUpdateManyWithoutTenantNestedInput
    catatanHarian?: CatatanHarianUpdateManyWithoutTenantNestedInput
    pengumuman?: PengumumanUpdateManyWithoutTenantNestedInput
    invoices?: InvoiceUpdateManyWithoutTenantNestedInput
    pelanggaran?: PelanggaranUpdateManyWithoutTenantNestedInput
    pembinaan?: PembinaanUpdateManyWithoutTenantNestedInput
    kunjungan?: KunjunganUpdateManyWithoutTenantNestedInput
    healthRecords?: HealthRecordUpdateManyWithoutTenantNestedInput
    auditLogs?: AuditLogUpdateManyWithoutTenantNestedInput
    notifications?: NotificationUpdateManyWithoutTenantNestedInput
    webhookEvents?: WebhookEventUpdateManyWithoutTenantNestedInput
    tahfidz?: TahfidzUpdateManyWithoutTenantNestedInput
    mutabaah?: MutabaahUpdateManyWithoutTenantNestedInput
    wallets?: WalletUpdateManyWithoutTenantNestedInput
    payrolls?: PayrollUpdateManyWithoutTenantNestedInput
    academicScheds?: AcademicScheduleUpdateManyWithoutTenantNestedInput
    attendances?: AttendanceUpdateManyWithoutTenantNestedInput
    grades?: GradeUpdateManyWithoutTenantNestedInput
    ppdbRegistrations?: PpdbRegistrationUpdateManyWithoutTenantNestedInput
    ppdbDocuments?: PpdbDocumentUpdateManyWithoutTenantNestedInput
    ppdbExams?: PpdbExamUpdateManyWithoutTenantNestedInput
    inventoryItems?: ItemUpdateManyWithoutTenantNestedInput
    inventoryTransactions?: InventoryTransactionUpdateManyWithoutTenantNestedInput
    suppliers?: SupplierUpdateManyWithoutTenantNestedInput
    purchaseOrders?: PurchaseOrderUpdateManyWithoutTenantNestedInput
    buildings?: BuildingUpdateManyWithoutTenantNestedInput
    rooms?: RoomUpdateManyWithoutTenantNestedInput
    roomAssignments?: RoomAssignmentUpdateManyWithoutTenantNestedInput
    maintenanceTickets?: MaintenanceTicketUpdateManyWithoutTenantNestedInput
  }

  export type TenantUncheckedUpdateWithoutEmployeesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    adminUserId?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    plan?: StringFieldUpdateOperationsInput | string
    billingContact?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    settings?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutTenantNestedInput
    santri?: SantriUncheckedUpdateManyWithoutTenantNestedInput
    wali?: WaliUncheckedUpdateManyWithoutTenantNestedInput
    izin?: IzinUncheckedUpdateManyWithoutTenantNestedInput
    catatanHarian?: CatatanHarianUncheckedUpdateManyWithoutTenantNestedInput
    pengumuman?: PengumumanUncheckedUpdateManyWithoutTenantNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutTenantNestedInput
    pelanggaran?: PelanggaranUncheckedUpdateManyWithoutTenantNestedInput
    pembinaan?: PembinaanUncheckedUpdateManyWithoutTenantNestedInput
    kunjungan?: KunjunganUncheckedUpdateManyWithoutTenantNestedInput
    healthRecords?: HealthRecordUncheckedUpdateManyWithoutTenantNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutTenantNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutTenantNestedInput
    webhookEvents?: WebhookEventUncheckedUpdateManyWithoutTenantNestedInput
    tahfidz?: TahfidzUncheckedUpdateManyWithoutTenantNestedInput
    mutabaah?: MutabaahUncheckedUpdateManyWithoutTenantNestedInput
    wallets?: WalletUncheckedUpdateManyWithoutTenantNestedInput
    payrolls?: PayrollUncheckedUpdateManyWithoutTenantNestedInput
    academicScheds?: AcademicScheduleUncheckedUpdateManyWithoutTenantNestedInput
    attendances?: AttendanceUncheckedUpdateManyWithoutTenantNestedInput
    grades?: GradeUncheckedUpdateManyWithoutTenantNestedInput
    ppdbRegistrations?: PpdbRegistrationUncheckedUpdateManyWithoutTenantNestedInput
    ppdbDocuments?: PpdbDocumentUncheckedUpdateManyWithoutTenantNestedInput
    ppdbExams?: PpdbExamUncheckedUpdateManyWithoutTenantNestedInput
    inventoryItems?: ItemUncheckedUpdateManyWithoutTenantNestedInput
    inventoryTransactions?: InventoryTransactionUncheckedUpdateManyWithoutTenantNestedInput
    suppliers?: SupplierUncheckedUpdateManyWithoutTenantNestedInput
    purchaseOrders?: PurchaseOrderUncheckedUpdateManyWithoutTenantNestedInput
    buildings?: BuildingUncheckedUpdateManyWithoutTenantNestedInput
    rooms?: RoomUncheckedUpdateManyWithoutTenantNestedInput
    roomAssignments?: RoomAssignmentUncheckedUpdateManyWithoutTenantNestedInput
    maintenanceTickets?: MaintenanceTicketUncheckedUpdateManyWithoutTenantNestedInput
  }

  export type PayrollUpsertWithWhereUniqueWithoutEmployeeInput = {
    where: PayrollWhereUniqueInput
    update: XOR<PayrollUpdateWithoutEmployeeInput, PayrollUncheckedUpdateWithoutEmployeeInput>
    create: XOR<PayrollCreateWithoutEmployeeInput, PayrollUncheckedCreateWithoutEmployeeInput>
  }

  export type PayrollUpdateWithWhereUniqueWithoutEmployeeInput = {
    where: PayrollWhereUniqueInput
    data: XOR<PayrollUpdateWithoutEmployeeInput, PayrollUncheckedUpdateWithoutEmployeeInput>
  }

  export type PayrollUpdateManyWithWhereWithoutEmployeeInput = {
    where: PayrollScalarWhereInput
    data: XOR<PayrollUpdateManyMutationInput, PayrollUncheckedUpdateManyWithoutEmployeeInput>
  }

  export type TenantCreateWithoutPayrollsInput = {
    id?: string
    name: string
    address?: string | null
    phone?: string | null
    adminUserId?: string | null
    timezone?: string
    plan?: string
    billingContact?: string | null
    status?: string
    settings?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutTenantInput
    santri?: SantriCreateNestedManyWithoutTenantInput
    wali?: WaliCreateNestedManyWithoutTenantInput
    izin?: IzinCreateNestedManyWithoutTenantInput
    catatanHarian?: CatatanHarianCreateNestedManyWithoutTenantInput
    pengumuman?: PengumumanCreateNestedManyWithoutTenantInput
    invoices?: InvoiceCreateNestedManyWithoutTenantInput
    pelanggaran?: PelanggaranCreateNestedManyWithoutTenantInput
    pembinaan?: PembinaanCreateNestedManyWithoutTenantInput
    kunjungan?: KunjunganCreateNestedManyWithoutTenantInput
    healthRecords?: HealthRecordCreateNestedManyWithoutTenantInput
    auditLogs?: AuditLogCreateNestedManyWithoutTenantInput
    notifications?: NotificationCreateNestedManyWithoutTenantInput
    webhookEvents?: WebhookEventCreateNestedManyWithoutTenantInput
    tahfidz?: TahfidzCreateNestedManyWithoutTenantInput
    mutabaah?: MutabaahCreateNestedManyWithoutTenantInput
    wallets?: WalletCreateNestedManyWithoutTenantInput
    employees?: EmployeeCreateNestedManyWithoutTenantInput
    academicScheds?: AcademicScheduleCreateNestedManyWithoutTenantInput
    attendances?: AttendanceCreateNestedManyWithoutTenantInput
    grades?: GradeCreateNestedManyWithoutTenantInput
    ppdbRegistrations?: PpdbRegistrationCreateNestedManyWithoutTenantInput
    ppdbDocuments?: PpdbDocumentCreateNestedManyWithoutTenantInput
    ppdbExams?: PpdbExamCreateNestedManyWithoutTenantInput
    inventoryItems?: ItemCreateNestedManyWithoutTenantInput
    inventoryTransactions?: InventoryTransactionCreateNestedManyWithoutTenantInput
    suppliers?: SupplierCreateNestedManyWithoutTenantInput
    purchaseOrders?: PurchaseOrderCreateNestedManyWithoutTenantInput
    buildings?: BuildingCreateNestedManyWithoutTenantInput
    rooms?: RoomCreateNestedManyWithoutTenantInput
    roomAssignments?: RoomAssignmentCreateNestedManyWithoutTenantInput
    maintenanceTickets?: MaintenanceTicketCreateNestedManyWithoutTenantInput
  }

  export type TenantUncheckedCreateWithoutPayrollsInput = {
    id?: string
    name: string
    address?: string | null
    phone?: string | null
    adminUserId?: string | null
    timezone?: string
    plan?: string
    billingContact?: string | null
    status?: string
    settings?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutTenantInput
    santri?: SantriUncheckedCreateNestedManyWithoutTenantInput
    wali?: WaliUncheckedCreateNestedManyWithoutTenantInput
    izin?: IzinUncheckedCreateNestedManyWithoutTenantInput
    catatanHarian?: CatatanHarianUncheckedCreateNestedManyWithoutTenantInput
    pengumuman?: PengumumanUncheckedCreateNestedManyWithoutTenantInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutTenantInput
    pelanggaran?: PelanggaranUncheckedCreateNestedManyWithoutTenantInput
    pembinaan?: PembinaanUncheckedCreateNestedManyWithoutTenantInput
    kunjungan?: KunjunganUncheckedCreateNestedManyWithoutTenantInput
    healthRecords?: HealthRecordUncheckedCreateNestedManyWithoutTenantInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutTenantInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutTenantInput
    webhookEvents?: WebhookEventUncheckedCreateNestedManyWithoutTenantInput
    tahfidz?: TahfidzUncheckedCreateNestedManyWithoutTenantInput
    mutabaah?: MutabaahUncheckedCreateNestedManyWithoutTenantInput
    wallets?: WalletUncheckedCreateNestedManyWithoutTenantInput
    employees?: EmployeeUncheckedCreateNestedManyWithoutTenantInput
    academicScheds?: AcademicScheduleUncheckedCreateNestedManyWithoutTenantInput
    attendances?: AttendanceUncheckedCreateNestedManyWithoutTenantInput
    grades?: GradeUncheckedCreateNestedManyWithoutTenantInput
    ppdbRegistrations?: PpdbRegistrationUncheckedCreateNestedManyWithoutTenantInput
    ppdbDocuments?: PpdbDocumentUncheckedCreateNestedManyWithoutTenantInput
    ppdbExams?: PpdbExamUncheckedCreateNestedManyWithoutTenantInput
    inventoryItems?: ItemUncheckedCreateNestedManyWithoutTenantInput
    inventoryTransactions?: InventoryTransactionUncheckedCreateNestedManyWithoutTenantInput
    suppliers?: SupplierUncheckedCreateNestedManyWithoutTenantInput
    purchaseOrders?: PurchaseOrderUncheckedCreateNestedManyWithoutTenantInput
    buildings?: BuildingUncheckedCreateNestedManyWithoutTenantInput
    rooms?: RoomUncheckedCreateNestedManyWithoutTenantInput
    roomAssignments?: RoomAssignmentUncheckedCreateNestedManyWithoutTenantInput
    maintenanceTickets?: MaintenanceTicketUncheckedCreateNestedManyWithoutTenantInput
  }

  export type TenantCreateOrConnectWithoutPayrollsInput = {
    where: TenantWhereUniqueInput
    create: XOR<TenantCreateWithoutPayrollsInput, TenantUncheckedCreateWithoutPayrollsInput>
  }

  export type EmployeeCreateWithoutPayrollsInput = {
    id?: string
    userId?: string | null
    nip?: string | null
    name: string
    position: string
    phone?: string | null
    address?: string | null
    joinDate?: Date | string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutEmployeesInput
  }

  export type EmployeeUncheckedCreateWithoutPayrollsInput = {
    id?: string
    tenantId: string
    userId?: string | null
    nip?: string | null
    name: string
    position: string
    phone?: string | null
    address?: string | null
    joinDate?: Date | string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EmployeeCreateOrConnectWithoutPayrollsInput = {
    where: EmployeeWhereUniqueInput
    create: XOR<EmployeeCreateWithoutPayrollsInput, EmployeeUncheckedCreateWithoutPayrollsInput>
  }

  export type TenantUpsertWithoutPayrollsInput = {
    update: XOR<TenantUpdateWithoutPayrollsInput, TenantUncheckedUpdateWithoutPayrollsInput>
    create: XOR<TenantCreateWithoutPayrollsInput, TenantUncheckedCreateWithoutPayrollsInput>
    where?: TenantWhereInput
  }

  export type TenantUpdateToOneWithWhereWithoutPayrollsInput = {
    where?: TenantWhereInput
    data: XOR<TenantUpdateWithoutPayrollsInput, TenantUncheckedUpdateWithoutPayrollsInput>
  }

  export type TenantUpdateWithoutPayrollsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    adminUserId?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    plan?: StringFieldUpdateOperationsInput | string
    billingContact?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    settings?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutTenantNestedInput
    santri?: SantriUpdateManyWithoutTenantNestedInput
    wali?: WaliUpdateManyWithoutTenantNestedInput
    izin?: IzinUpdateManyWithoutTenantNestedInput
    catatanHarian?: CatatanHarianUpdateManyWithoutTenantNestedInput
    pengumuman?: PengumumanUpdateManyWithoutTenantNestedInput
    invoices?: InvoiceUpdateManyWithoutTenantNestedInput
    pelanggaran?: PelanggaranUpdateManyWithoutTenantNestedInput
    pembinaan?: PembinaanUpdateManyWithoutTenantNestedInput
    kunjungan?: KunjunganUpdateManyWithoutTenantNestedInput
    healthRecords?: HealthRecordUpdateManyWithoutTenantNestedInput
    auditLogs?: AuditLogUpdateManyWithoutTenantNestedInput
    notifications?: NotificationUpdateManyWithoutTenantNestedInput
    webhookEvents?: WebhookEventUpdateManyWithoutTenantNestedInput
    tahfidz?: TahfidzUpdateManyWithoutTenantNestedInput
    mutabaah?: MutabaahUpdateManyWithoutTenantNestedInput
    wallets?: WalletUpdateManyWithoutTenantNestedInput
    employees?: EmployeeUpdateManyWithoutTenantNestedInput
    academicScheds?: AcademicScheduleUpdateManyWithoutTenantNestedInput
    attendances?: AttendanceUpdateManyWithoutTenantNestedInput
    grades?: GradeUpdateManyWithoutTenantNestedInput
    ppdbRegistrations?: PpdbRegistrationUpdateManyWithoutTenantNestedInput
    ppdbDocuments?: PpdbDocumentUpdateManyWithoutTenantNestedInput
    ppdbExams?: PpdbExamUpdateManyWithoutTenantNestedInput
    inventoryItems?: ItemUpdateManyWithoutTenantNestedInput
    inventoryTransactions?: InventoryTransactionUpdateManyWithoutTenantNestedInput
    suppliers?: SupplierUpdateManyWithoutTenantNestedInput
    purchaseOrders?: PurchaseOrderUpdateManyWithoutTenantNestedInput
    buildings?: BuildingUpdateManyWithoutTenantNestedInput
    rooms?: RoomUpdateManyWithoutTenantNestedInput
    roomAssignments?: RoomAssignmentUpdateManyWithoutTenantNestedInput
    maintenanceTickets?: MaintenanceTicketUpdateManyWithoutTenantNestedInput
  }

  export type TenantUncheckedUpdateWithoutPayrollsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    adminUserId?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    plan?: StringFieldUpdateOperationsInput | string
    billingContact?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    settings?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutTenantNestedInput
    santri?: SantriUncheckedUpdateManyWithoutTenantNestedInput
    wali?: WaliUncheckedUpdateManyWithoutTenantNestedInput
    izin?: IzinUncheckedUpdateManyWithoutTenantNestedInput
    catatanHarian?: CatatanHarianUncheckedUpdateManyWithoutTenantNestedInput
    pengumuman?: PengumumanUncheckedUpdateManyWithoutTenantNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutTenantNestedInput
    pelanggaran?: PelanggaranUncheckedUpdateManyWithoutTenantNestedInput
    pembinaan?: PembinaanUncheckedUpdateManyWithoutTenantNestedInput
    kunjungan?: KunjunganUncheckedUpdateManyWithoutTenantNestedInput
    healthRecords?: HealthRecordUncheckedUpdateManyWithoutTenantNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutTenantNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutTenantNestedInput
    webhookEvents?: WebhookEventUncheckedUpdateManyWithoutTenantNestedInput
    tahfidz?: TahfidzUncheckedUpdateManyWithoutTenantNestedInput
    mutabaah?: MutabaahUncheckedUpdateManyWithoutTenantNestedInput
    wallets?: WalletUncheckedUpdateManyWithoutTenantNestedInput
    employees?: EmployeeUncheckedUpdateManyWithoutTenantNestedInput
    academicScheds?: AcademicScheduleUncheckedUpdateManyWithoutTenantNestedInput
    attendances?: AttendanceUncheckedUpdateManyWithoutTenantNestedInput
    grades?: GradeUncheckedUpdateManyWithoutTenantNestedInput
    ppdbRegistrations?: PpdbRegistrationUncheckedUpdateManyWithoutTenantNestedInput
    ppdbDocuments?: PpdbDocumentUncheckedUpdateManyWithoutTenantNestedInput
    ppdbExams?: PpdbExamUncheckedUpdateManyWithoutTenantNestedInput
    inventoryItems?: ItemUncheckedUpdateManyWithoutTenantNestedInput
    inventoryTransactions?: InventoryTransactionUncheckedUpdateManyWithoutTenantNestedInput
    suppliers?: SupplierUncheckedUpdateManyWithoutTenantNestedInput
    purchaseOrders?: PurchaseOrderUncheckedUpdateManyWithoutTenantNestedInput
    buildings?: BuildingUncheckedUpdateManyWithoutTenantNestedInput
    rooms?: RoomUncheckedUpdateManyWithoutTenantNestedInput
    roomAssignments?: RoomAssignmentUncheckedUpdateManyWithoutTenantNestedInput
    maintenanceTickets?: MaintenanceTicketUncheckedUpdateManyWithoutTenantNestedInput
  }

  export type EmployeeUpsertWithoutPayrollsInput = {
    update: XOR<EmployeeUpdateWithoutPayrollsInput, EmployeeUncheckedUpdateWithoutPayrollsInput>
    create: XOR<EmployeeCreateWithoutPayrollsInput, EmployeeUncheckedCreateWithoutPayrollsInput>
    where?: EmployeeWhereInput
  }

  export type EmployeeUpdateToOneWithWhereWithoutPayrollsInput = {
    where?: EmployeeWhereInput
    data: XOR<EmployeeUpdateWithoutPayrollsInput, EmployeeUncheckedUpdateWithoutPayrollsInput>
  }

  export type EmployeeUpdateWithoutPayrollsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    nip?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    position?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    joinDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutEmployeesNestedInput
  }

  export type EmployeeUncheckedUpdateWithoutPayrollsInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    nip?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    position?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    joinDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TenantCreateWithoutAcademicSchedsInput = {
    id?: string
    name: string
    address?: string | null
    phone?: string | null
    adminUserId?: string | null
    timezone?: string
    plan?: string
    billingContact?: string | null
    status?: string
    settings?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutTenantInput
    santri?: SantriCreateNestedManyWithoutTenantInput
    wali?: WaliCreateNestedManyWithoutTenantInput
    izin?: IzinCreateNestedManyWithoutTenantInput
    catatanHarian?: CatatanHarianCreateNestedManyWithoutTenantInput
    pengumuman?: PengumumanCreateNestedManyWithoutTenantInput
    invoices?: InvoiceCreateNestedManyWithoutTenantInput
    pelanggaran?: PelanggaranCreateNestedManyWithoutTenantInput
    pembinaan?: PembinaanCreateNestedManyWithoutTenantInput
    kunjungan?: KunjunganCreateNestedManyWithoutTenantInput
    healthRecords?: HealthRecordCreateNestedManyWithoutTenantInput
    auditLogs?: AuditLogCreateNestedManyWithoutTenantInput
    notifications?: NotificationCreateNestedManyWithoutTenantInput
    webhookEvents?: WebhookEventCreateNestedManyWithoutTenantInput
    tahfidz?: TahfidzCreateNestedManyWithoutTenantInput
    mutabaah?: MutabaahCreateNestedManyWithoutTenantInput
    wallets?: WalletCreateNestedManyWithoutTenantInput
    employees?: EmployeeCreateNestedManyWithoutTenantInput
    payrolls?: PayrollCreateNestedManyWithoutTenantInput
    attendances?: AttendanceCreateNestedManyWithoutTenantInput
    grades?: GradeCreateNestedManyWithoutTenantInput
    ppdbRegistrations?: PpdbRegistrationCreateNestedManyWithoutTenantInput
    ppdbDocuments?: PpdbDocumentCreateNestedManyWithoutTenantInput
    ppdbExams?: PpdbExamCreateNestedManyWithoutTenantInput
    inventoryItems?: ItemCreateNestedManyWithoutTenantInput
    inventoryTransactions?: InventoryTransactionCreateNestedManyWithoutTenantInput
    suppliers?: SupplierCreateNestedManyWithoutTenantInput
    purchaseOrders?: PurchaseOrderCreateNestedManyWithoutTenantInput
    buildings?: BuildingCreateNestedManyWithoutTenantInput
    rooms?: RoomCreateNestedManyWithoutTenantInput
    roomAssignments?: RoomAssignmentCreateNestedManyWithoutTenantInput
    maintenanceTickets?: MaintenanceTicketCreateNestedManyWithoutTenantInput
  }

  export type TenantUncheckedCreateWithoutAcademicSchedsInput = {
    id?: string
    name: string
    address?: string | null
    phone?: string | null
    adminUserId?: string | null
    timezone?: string
    plan?: string
    billingContact?: string | null
    status?: string
    settings?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutTenantInput
    santri?: SantriUncheckedCreateNestedManyWithoutTenantInput
    wali?: WaliUncheckedCreateNestedManyWithoutTenantInput
    izin?: IzinUncheckedCreateNestedManyWithoutTenantInput
    catatanHarian?: CatatanHarianUncheckedCreateNestedManyWithoutTenantInput
    pengumuman?: PengumumanUncheckedCreateNestedManyWithoutTenantInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutTenantInput
    pelanggaran?: PelanggaranUncheckedCreateNestedManyWithoutTenantInput
    pembinaan?: PembinaanUncheckedCreateNestedManyWithoutTenantInput
    kunjungan?: KunjunganUncheckedCreateNestedManyWithoutTenantInput
    healthRecords?: HealthRecordUncheckedCreateNestedManyWithoutTenantInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutTenantInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutTenantInput
    webhookEvents?: WebhookEventUncheckedCreateNestedManyWithoutTenantInput
    tahfidz?: TahfidzUncheckedCreateNestedManyWithoutTenantInput
    mutabaah?: MutabaahUncheckedCreateNestedManyWithoutTenantInput
    wallets?: WalletUncheckedCreateNestedManyWithoutTenantInput
    employees?: EmployeeUncheckedCreateNestedManyWithoutTenantInput
    payrolls?: PayrollUncheckedCreateNestedManyWithoutTenantInput
    attendances?: AttendanceUncheckedCreateNestedManyWithoutTenantInput
    grades?: GradeUncheckedCreateNestedManyWithoutTenantInput
    ppdbRegistrations?: PpdbRegistrationUncheckedCreateNestedManyWithoutTenantInput
    ppdbDocuments?: PpdbDocumentUncheckedCreateNestedManyWithoutTenantInput
    ppdbExams?: PpdbExamUncheckedCreateNestedManyWithoutTenantInput
    inventoryItems?: ItemUncheckedCreateNestedManyWithoutTenantInput
    inventoryTransactions?: InventoryTransactionUncheckedCreateNestedManyWithoutTenantInput
    suppliers?: SupplierUncheckedCreateNestedManyWithoutTenantInput
    purchaseOrders?: PurchaseOrderUncheckedCreateNestedManyWithoutTenantInput
    buildings?: BuildingUncheckedCreateNestedManyWithoutTenantInput
    rooms?: RoomUncheckedCreateNestedManyWithoutTenantInput
    roomAssignments?: RoomAssignmentUncheckedCreateNestedManyWithoutTenantInput
    maintenanceTickets?: MaintenanceTicketUncheckedCreateNestedManyWithoutTenantInput
  }

  export type TenantCreateOrConnectWithoutAcademicSchedsInput = {
    where: TenantWhereUniqueInput
    create: XOR<TenantCreateWithoutAcademicSchedsInput, TenantUncheckedCreateWithoutAcademicSchedsInput>
  }

  export type TenantUpsertWithoutAcademicSchedsInput = {
    update: XOR<TenantUpdateWithoutAcademicSchedsInput, TenantUncheckedUpdateWithoutAcademicSchedsInput>
    create: XOR<TenantCreateWithoutAcademicSchedsInput, TenantUncheckedCreateWithoutAcademicSchedsInput>
    where?: TenantWhereInput
  }

  export type TenantUpdateToOneWithWhereWithoutAcademicSchedsInput = {
    where?: TenantWhereInput
    data: XOR<TenantUpdateWithoutAcademicSchedsInput, TenantUncheckedUpdateWithoutAcademicSchedsInput>
  }

  export type TenantUpdateWithoutAcademicSchedsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    adminUserId?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    plan?: StringFieldUpdateOperationsInput | string
    billingContact?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    settings?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutTenantNestedInput
    santri?: SantriUpdateManyWithoutTenantNestedInput
    wali?: WaliUpdateManyWithoutTenantNestedInput
    izin?: IzinUpdateManyWithoutTenantNestedInput
    catatanHarian?: CatatanHarianUpdateManyWithoutTenantNestedInput
    pengumuman?: PengumumanUpdateManyWithoutTenantNestedInput
    invoices?: InvoiceUpdateManyWithoutTenantNestedInput
    pelanggaran?: PelanggaranUpdateManyWithoutTenantNestedInput
    pembinaan?: PembinaanUpdateManyWithoutTenantNestedInput
    kunjungan?: KunjunganUpdateManyWithoutTenantNestedInput
    healthRecords?: HealthRecordUpdateManyWithoutTenantNestedInput
    auditLogs?: AuditLogUpdateManyWithoutTenantNestedInput
    notifications?: NotificationUpdateManyWithoutTenantNestedInput
    webhookEvents?: WebhookEventUpdateManyWithoutTenantNestedInput
    tahfidz?: TahfidzUpdateManyWithoutTenantNestedInput
    mutabaah?: MutabaahUpdateManyWithoutTenantNestedInput
    wallets?: WalletUpdateManyWithoutTenantNestedInput
    employees?: EmployeeUpdateManyWithoutTenantNestedInput
    payrolls?: PayrollUpdateManyWithoutTenantNestedInput
    attendances?: AttendanceUpdateManyWithoutTenantNestedInput
    grades?: GradeUpdateManyWithoutTenantNestedInput
    ppdbRegistrations?: PpdbRegistrationUpdateManyWithoutTenantNestedInput
    ppdbDocuments?: PpdbDocumentUpdateManyWithoutTenantNestedInput
    ppdbExams?: PpdbExamUpdateManyWithoutTenantNestedInput
    inventoryItems?: ItemUpdateManyWithoutTenantNestedInput
    inventoryTransactions?: InventoryTransactionUpdateManyWithoutTenantNestedInput
    suppliers?: SupplierUpdateManyWithoutTenantNestedInput
    purchaseOrders?: PurchaseOrderUpdateManyWithoutTenantNestedInput
    buildings?: BuildingUpdateManyWithoutTenantNestedInput
    rooms?: RoomUpdateManyWithoutTenantNestedInput
    roomAssignments?: RoomAssignmentUpdateManyWithoutTenantNestedInput
    maintenanceTickets?: MaintenanceTicketUpdateManyWithoutTenantNestedInput
  }

  export type TenantUncheckedUpdateWithoutAcademicSchedsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    adminUserId?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    plan?: StringFieldUpdateOperationsInput | string
    billingContact?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    settings?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutTenantNestedInput
    santri?: SantriUncheckedUpdateManyWithoutTenantNestedInput
    wali?: WaliUncheckedUpdateManyWithoutTenantNestedInput
    izin?: IzinUncheckedUpdateManyWithoutTenantNestedInput
    catatanHarian?: CatatanHarianUncheckedUpdateManyWithoutTenantNestedInput
    pengumuman?: PengumumanUncheckedUpdateManyWithoutTenantNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutTenantNestedInput
    pelanggaran?: PelanggaranUncheckedUpdateManyWithoutTenantNestedInput
    pembinaan?: PembinaanUncheckedUpdateManyWithoutTenantNestedInput
    kunjungan?: KunjunganUncheckedUpdateManyWithoutTenantNestedInput
    healthRecords?: HealthRecordUncheckedUpdateManyWithoutTenantNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutTenantNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutTenantNestedInput
    webhookEvents?: WebhookEventUncheckedUpdateManyWithoutTenantNestedInput
    tahfidz?: TahfidzUncheckedUpdateManyWithoutTenantNestedInput
    mutabaah?: MutabaahUncheckedUpdateManyWithoutTenantNestedInput
    wallets?: WalletUncheckedUpdateManyWithoutTenantNestedInput
    employees?: EmployeeUncheckedUpdateManyWithoutTenantNestedInput
    payrolls?: PayrollUncheckedUpdateManyWithoutTenantNestedInput
    attendances?: AttendanceUncheckedUpdateManyWithoutTenantNestedInput
    grades?: GradeUncheckedUpdateManyWithoutTenantNestedInput
    ppdbRegistrations?: PpdbRegistrationUncheckedUpdateManyWithoutTenantNestedInput
    ppdbDocuments?: PpdbDocumentUncheckedUpdateManyWithoutTenantNestedInput
    ppdbExams?: PpdbExamUncheckedUpdateManyWithoutTenantNestedInput
    inventoryItems?: ItemUncheckedUpdateManyWithoutTenantNestedInput
    inventoryTransactions?: InventoryTransactionUncheckedUpdateManyWithoutTenantNestedInput
    suppliers?: SupplierUncheckedUpdateManyWithoutTenantNestedInput
    purchaseOrders?: PurchaseOrderUncheckedUpdateManyWithoutTenantNestedInput
    buildings?: BuildingUncheckedUpdateManyWithoutTenantNestedInput
    rooms?: RoomUncheckedUpdateManyWithoutTenantNestedInput
    roomAssignments?: RoomAssignmentUncheckedUpdateManyWithoutTenantNestedInput
    maintenanceTickets?: MaintenanceTicketUncheckedUpdateManyWithoutTenantNestedInput
  }

  export type TenantCreateWithoutAttendancesInput = {
    id?: string
    name: string
    address?: string | null
    phone?: string | null
    adminUserId?: string | null
    timezone?: string
    plan?: string
    billingContact?: string | null
    status?: string
    settings?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutTenantInput
    santri?: SantriCreateNestedManyWithoutTenantInput
    wali?: WaliCreateNestedManyWithoutTenantInput
    izin?: IzinCreateNestedManyWithoutTenantInput
    catatanHarian?: CatatanHarianCreateNestedManyWithoutTenantInput
    pengumuman?: PengumumanCreateNestedManyWithoutTenantInput
    invoices?: InvoiceCreateNestedManyWithoutTenantInput
    pelanggaran?: PelanggaranCreateNestedManyWithoutTenantInput
    pembinaan?: PembinaanCreateNestedManyWithoutTenantInput
    kunjungan?: KunjunganCreateNestedManyWithoutTenantInput
    healthRecords?: HealthRecordCreateNestedManyWithoutTenantInput
    auditLogs?: AuditLogCreateNestedManyWithoutTenantInput
    notifications?: NotificationCreateNestedManyWithoutTenantInput
    webhookEvents?: WebhookEventCreateNestedManyWithoutTenantInput
    tahfidz?: TahfidzCreateNestedManyWithoutTenantInput
    mutabaah?: MutabaahCreateNestedManyWithoutTenantInput
    wallets?: WalletCreateNestedManyWithoutTenantInput
    employees?: EmployeeCreateNestedManyWithoutTenantInput
    payrolls?: PayrollCreateNestedManyWithoutTenantInput
    academicScheds?: AcademicScheduleCreateNestedManyWithoutTenantInput
    grades?: GradeCreateNestedManyWithoutTenantInput
    ppdbRegistrations?: PpdbRegistrationCreateNestedManyWithoutTenantInput
    ppdbDocuments?: PpdbDocumentCreateNestedManyWithoutTenantInput
    ppdbExams?: PpdbExamCreateNestedManyWithoutTenantInput
    inventoryItems?: ItemCreateNestedManyWithoutTenantInput
    inventoryTransactions?: InventoryTransactionCreateNestedManyWithoutTenantInput
    suppliers?: SupplierCreateNestedManyWithoutTenantInput
    purchaseOrders?: PurchaseOrderCreateNestedManyWithoutTenantInput
    buildings?: BuildingCreateNestedManyWithoutTenantInput
    rooms?: RoomCreateNestedManyWithoutTenantInput
    roomAssignments?: RoomAssignmentCreateNestedManyWithoutTenantInput
    maintenanceTickets?: MaintenanceTicketCreateNestedManyWithoutTenantInput
  }

  export type TenantUncheckedCreateWithoutAttendancesInput = {
    id?: string
    name: string
    address?: string | null
    phone?: string | null
    adminUserId?: string | null
    timezone?: string
    plan?: string
    billingContact?: string | null
    status?: string
    settings?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutTenantInput
    santri?: SantriUncheckedCreateNestedManyWithoutTenantInput
    wali?: WaliUncheckedCreateNestedManyWithoutTenantInput
    izin?: IzinUncheckedCreateNestedManyWithoutTenantInput
    catatanHarian?: CatatanHarianUncheckedCreateNestedManyWithoutTenantInput
    pengumuman?: PengumumanUncheckedCreateNestedManyWithoutTenantInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutTenantInput
    pelanggaran?: PelanggaranUncheckedCreateNestedManyWithoutTenantInput
    pembinaan?: PembinaanUncheckedCreateNestedManyWithoutTenantInput
    kunjungan?: KunjunganUncheckedCreateNestedManyWithoutTenantInput
    healthRecords?: HealthRecordUncheckedCreateNestedManyWithoutTenantInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutTenantInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutTenantInput
    webhookEvents?: WebhookEventUncheckedCreateNestedManyWithoutTenantInput
    tahfidz?: TahfidzUncheckedCreateNestedManyWithoutTenantInput
    mutabaah?: MutabaahUncheckedCreateNestedManyWithoutTenantInput
    wallets?: WalletUncheckedCreateNestedManyWithoutTenantInput
    employees?: EmployeeUncheckedCreateNestedManyWithoutTenantInput
    payrolls?: PayrollUncheckedCreateNestedManyWithoutTenantInput
    academicScheds?: AcademicScheduleUncheckedCreateNestedManyWithoutTenantInput
    grades?: GradeUncheckedCreateNestedManyWithoutTenantInput
    ppdbRegistrations?: PpdbRegistrationUncheckedCreateNestedManyWithoutTenantInput
    ppdbDocuments?: PpdbDocumentUncheckedCreateNestedManyWithoutTenantInput
    ppdbExams?: PpdbExamUncheckedCreateNestedManyWithoutTenantInput
    inventoryItems?: ItemUncheckedCreateNestedManyWithoutTenantInput
    inventoryTransactions?: InventoryTransactionUncheckedCreateNestedManyWithoutTenantInput
    suppliers?: SupplierUncheckedCreateNestedManyWithoutTenantInput
    purchaseOrders?: PurchaseOrderUncheckedCreateNestedManyWithoutTenantInput
    buildings?: BuildingUncheckedCreateNestedManyWithoutTenantInput
    rooms?: RoomUncheckedCreateNestedManyWithoutTenantInput
    roomAssignments?: RoomAssignmentUncheckedCreateNestedManyWithoutTenantInput
    maintenanceTickets?: MaintenanceTicketUncheckedCreateNestedManyWithoutTenantInput
  }

  export type TenantCreateOrConnectWithoutAttendancesInput = {
    where: TenantWhereUniqueInput
    create: XOR<TenantCreateWithoutAttendancesInput, TenantUncheckedCreateWithoutAttendancesInput>
  }

  export type SantriCreateWithoutAttendancesInput = {
    id?: string
    nisn?: string | null
    name: string
    gender: string
    dob?: Date | string | null
    kelas?: string | null
    room?: string | null
    contact?: string | null
    address?: string | null
    photo?: string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutSantriInput
    walis?: SantriWaliCreateNestedManyWithoutSantriInput
    izin?: IzinCreateNestedManyWithoutSantriInput
    catatanHarian?: CatatanHarianCreateNestedManyWithoutSantriInput
    invoices?: InvoiceCreateNestedManyWithoutSantriInput
    pelanggaran?: PelanggaranCreateNestedManyWithoutSantriInput
    pembinaan?: PembinaanCreateNestedManyWithoutSantriInput
    kunjungan?: KunjunganCreateNestedManyWithoutSantriInput
    healthRecords?: HealthRecordCreateNestedManyWithoutSantriInput
    medications?: MedicationCreateNestedManyWithoutSantriInput
    tahfidz?: TahfidzCreateNestedManyWithoutSantriInput
    mutabaah?: MutabaahCreateNestedManyWithoutSantriInput
    wallet?: WalletCreateNestedOneWithoutSantriInput
    grades?: GradeCreateNestedManyWithoutSantriInput
  }

  export type SantriUncheckedCreateWithoutAttendancesInput = {
    id?: string
    tenantId: string
    nisn?: string | null
    name: string
    gender: string
    dob?: Date | string | null
    kelas?: string | null
    room?: string | null
    contact?: string | null
    address?: string | null
    photo?: string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    walis?: SantriWaliUncheckedCreateNestedManyWithoutSantriInput
    izin?: IzinUncheckedCreateNestedManyWithoutSantriInput
    catatanHarian?: CatatanHarianUncheckedCreateNestedManyWithoutSantriInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutSantriInput
    pelanggaran?: PelanggaranUncheckedCreateNestedManyWithoutSantriInput
    pembinaan?: PembinaanUncheckedCreateNestedManyWithoutSantriInput
    kunjungan?: KunjunganUncheckedCreateNestedManyWithoutSantriInput
    healthRecords?: HealthRecordUncheckedCreateNestedManyWithoutSantriInput
    medications?: MedicationUncheckedCreateNestedManyWithoutSantriInput
    tahfidz?: TahfidzUncheckedCreateNestedManyWithoutSantriInput
    mutabaah?: MutabaahUncheckedCreateNestedManyWithoutSantriInput
    wallet?: WalletUncheckedCreateNestedOneWithoutSantriInput
    grades?: GradeUncheckedCreateNestedManyWithoutSantriInput
  }

  export type SantriCreateOrConnectWithoutAttendancesInput = {
    where: SantriWhereUniqueInput
    create: XOR<SantriCreateWithoutAttendancesInput, SantriUncheckedCreateWithoutAttendancesInput>
  }

  export type TenantUpsertWithoutAttendancesInput = {
    update: XOR<TenantUpdateWithoutAttendancesInput, TenantUncheckedUpdateWithoutAttendancesInput>
    create: XOR<TenantCreateWithoutAttendancesInput, TenantUncheckedCreateWithoutAttendancesInput>
    where?: TenantWhereInput
  }

  export type TenantUpdateToOneWithWhereWithoutAttendancesInput = {
    where?: TenantWhereInput
    data: XOR<TenantUpdateWithoutAttendancesInput, TenantUncheckedUpdateWithoutAttendancesInput>
  }

  export type TenantUpdateWithoutAttendancesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    adminUserId?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    plan?: StringFieldUpdateOperationsInput | string
    billingContact?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    settings?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutTenantNestedInput
    santri?: SantriUpdateManyWithoutTenantNestedInput
    wali?: WaliUpdateManyWithoutTenantNestedInput
    izin?: IzinUpdateManyWithoutTenantNestedInput
    catatanHarian?: CatatanHarianUpdateManyWithoutTenantNestedInput
    pengumuman?: PengumumanUpdateManyWithoutTenantNestedInput
    invoices?: InvoiceUpdateManyWithoutTenantNestedInput
    pelanggaran?: PelanggaranUpdateManyWithoutTenantNestedInput
    pembinaan?: PembinaanUpdateManyWithoutTenantNestedInput
    kunjungan?: KunjunganUpdateManyWithoutTenantNestedInput
    healthRecords?: HealthRecordUpdateManyWithoutTenantNestedInput
    auditLogs?: AuditLogUpdateManyWithoutTenantNestedInput
    notifications?: NotificationUpdateManyWithoutTenantNestedInput
    webhookEvents?: WebhookEventUpdateManyWithoutTenantNestedInput
    tahfidz?: TahfidzUpdateManyWithoutTenantNestedInput
    mutabaah?: MutabaahUpdateManyWithoutTenantNestedInput
    wallets?: WalletUpdateManyWithoutTenantNestedInput
    employees?: EmployeeUpdateManyWithoutTenantNestedInput
    payrolls?: PayrollUpdateManyWithoutTenantNestedInput
    academicScheds?: AcademicScheduleUpdateManyWithoutTenantNestedInput
    grades?: GradeUpdateManyWithoutTenantNestedInput
    ppdbRegistrations?: PpdbRegistrationUpdateManyWithoutTenantNestedInput
    ppdbDocuments?: PpdbDocumentUpdateManyWithoutTenantNestedInput
    ppdbExams?: PpdbExamUpdateManyWithoutTenantNestedInput
    inventoryItems?: ItemUpdateManyWithoutTenantNestedInput
    inventoryTransactions?: InventoryTransactionUpdateManyWithoutTenantNestedInput
    suppliers?: SupplierUpdateManyWithoutTenantNestedInput
    purchaseOrders?: PurchaseOrderUpdateManyWithoutTenantNestedInput
    buildings?: BuildingUpdateManyWithoutTenantNestedInput
    rooms?: RoomUpdateManyWithoutTenantNestedInput
    roomAssignments?: RoomAssignmentUpdateManyWithoutTenantNestedInput
    maintenanceTickets?: MaintenanceTicketUpdateManyWithoutTenantNestedInput
  }

  export type TenantUncheckedUpdateWithoutAttendancesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    adminUserId?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    plan?: StringFieldUpdateOperationsInput | string
    billingContact?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    settings?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutTenantNestedInput
    santri?: SantriUncheckedUpdateManyWithoutTenantNestedInput
    wali?: WaliUncheckedUpdateManyWithoutTenantNestedInput
    izin?: IzinUncheckedUpdateManyWithoutTenantNestedInput
    catatanHarian?: CatatanHarianUncheckedUpdateManyWithoutTenantNestedInput
    pengumuman?: PengumumanUncheckedUpdateManyWithoutTenantNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutTenantNestedInput
    pelanggaran?: PelanggaranUncheckedUpdateManyWithoutTenantNestedInput
    pembinaan?: PembinaanUncheckedUpdateManyWithoutTenantNestedInput
    kunjungan?: KunjunganUncheckedUpdateManyWithoutTenantNestedInput
    healthRecords?: HealthRecordUncheckedUpdateManyWithoutTenantNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutTenantNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutTenantNestedInput
    webhookEvents?: WebhookEventUncheckedUpdateManyWithoutTenantNestedInput
    tahfidz?: TahfidzUncheckedUpdateManyWithoutTenantNestedInput
    mutabaah?: MutabaahUncheckedUpdateManyWithoutTenantNestedInput
    wallets?: WalletUncheckedUpdateManyWithoutTenantNestedInput
    employees?: EmployeeUncheckedUpdateManyWithoutTenantNestedInput
    payrolls?: PayrollUncheckedUpdateManyWithoutTenantNestedInput
    academicScheds?: AcademicScheduleUncheckedUpdateManyWithoutTenantNestedInput
    grades?: GradeUncheckedUpdateManyWithoutTenantNestedInput
    ppdbRegistrations?: PpdbRegistrationUncheckedUpdateManyWithoutTenantNestedInput
    ppdbDocuments?: PpdbDocumentUncheckedUpdateManyWithoutTenantNestedInput
    ppdbExams?: PpdbExamUncheckedUpdateManyWithoutTenantNestedInput
    inventoryItems?: ItemUncheckedUpdateManyWithoutTenantNestedInput
    inventoryTransactions?: InventoryTransactionUncheckedUpdateManyWithoutTenantNestedInput
    suppliers?: SupplierUncheckedUpdateManyWithoutTenantNestedInput
    purchaseOrders?: PurchaseOrderUncheckedUpdateManyWithoutTenantNestedInput
    buildings?: BuildingUncheckedUpdateManyWithoutTenantNestedInput
    rooms?: RoomUncheckedUpdateManyWithoutTenantNestedInput
    roomAssignments?: RoomAssignmentUncheckedUpdateManyWithoutTenantNestedInput
    maintenanceTickets?: MaintenanceTicketUncheckedUpdateManyWithoutTenantNestedInput
  }

  export type SantriUpsertWithoutAttendancesInput = {
    update: XOR<SantriUpdateWithoutAttendancesInput, SantriUncheckedUpdateWithoutAttendancesInput>
    create: XOR<SantriCreateWithoutAttendancesInput, SantriUncheckedCreateWithoutAttendancesInput>
    where?: SantriWhereInput
  }

  export type SantriUpdateToOneWithWhereWithoutAttendancesInput = {
    where?: SantriWhereInput
    data: XOR<SantriUpdateWithoutAttendancesInput, SantriUncheckedUpdateWithoutAttendancesInput>
  }

  export type SantriUpdateWithoutAttendancesInput = {
    id?: StringFieldUpdateOperationsInput | string
    nisn?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    gender?: StringFieldUpdateOperationsInput | string
    dob?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    kelas?: NullableStringFieldUpdateOperationsInput | string | null
    room?: NullableStringFieldUpdateOperationsInput | string | null
    contact?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutSantriNestedInput
    walis?: SantriWaliUpdateManyWithoutSantriNestedInput
    izin?: IzinUpdateManyWithoutSantriNestedInput
    catatanHarian?: CatatanHarianUpdateManyWithoutSantriNestedInput
    invoices?: InvoiceUpdateManyWithoutSantriNestedInput
    pelanggaran?: PelanggaranUpdateManyWithoutSantriNestedInput
    pembinaan?: PembinaanUpdateManyWithoutSantriNestedInput
    kunjungan?: KunjunganUpdateManyWithoutSantriNestedInput
    healthRecords?: HealthRecordUpdateManyWithoutSantriNestedInput
    medications?: MedicationUpdateManyWithoutSantriNestedInput
    tahfidz?: TahfidzUpdateManyWithoutSantriNestedInput
    mutabaah?: MutabaahUpdateManyWithoutSantriNestedInput
    wallet?: WalletUpdateOneWithoutSantriNestedInput
    grades?: GradeUpdateManyWithoutSantriNestedInput
  }

  export type SantriUncheckedUpdateWithoutAttendancesInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    nisn?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    gender?: StringFieldUpdateOperationsInput | string
    dob?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    kelas?: NullableStringFieldUpdateOperationsInput | string | null
    room?: NullableStringFieldUpdateOperationsInput | string | null
    contact?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    walis?: SantriWaliUncheckedUpdateManyWithoutSantriNestedInput
    izin?: IzinUncheckedUpdateManyWithoutSantriNestedInput
    catatanHarian?: CatatanHarianUncheckedUpdateManyWithoutSantriNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutSantriNestedInput
    pelanggaran?: PelanggaranUncheckedUpdateManyWithoutSantriNestedInput
    pembinaan?: PembinaanUncheckedUpdateManyWithoutSantriNestedInput
    kunjungan?: KunjunganUncheckedUpdateManyWithoutSantriNestedInput
    healthRecords?: HealthRecordUncheckedUpdateManyWithoutSantriNestedInput
    medications?: MedicationUncheckedUpdateManyWithoutSantriNestedInput
    tahfidz?: TahfidzUncheckedUpdateManyWithoutSantriNestedInput
    mutabaah?: MutabaahUncheckedUpdateManyWithoutSantriNestedInput
    wallet?: WalletUncheckedUpdateOneWithoutSantriNestedInput
    grades?: GradeUncheckedUpdateManyWithoutSantriNestedInput
  }

  export type TenantCreateWithoutGradesInput = {
    id?: string
    name: string
    address?: string | null
    phone?: string | null
    adminUserId?: string | null
    timezone?: string
    plan?: string
    billingContact?: string | null
    status?: string
    settings?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutTenantInput
    santri?: SantriCreateNestedManyWithoutTenantInput
    wali?: WaliCreateNestedManyWithoutTenantInput
    izin?: IzinCreateNestedManyWithoutTenantInput
    catatanHarian?: CatatanHarianCreateNestedManyWithoutTenantInput
    pengumuman?: PengumumanCreateNestedManyWithoutTenantInput
    invoices?: InvoiceCreateNestedManyWithoutTenantInput
    pelanggaran?: PelanggaranCreateNestedManyWithoutTenantInput
    pembinaan?: PembinaanCreateNestedManyWithoutTenantInput
    kunjungan?: KunjunganCreateNestedManyWithoutTenantInput
    healthRecords?: HealthRecordCreateNestedManyWithoutTenantInput
    auditLogs?: AuditLogCreateNestedManyWithoutTenantInput
    notifications?: NotificationCreateNestedManyWithoutTenantInput
    webhookEvents?: WebhookEventCreateNestedManyWithoutTenantInput
    tahfidz?: TahfidzCreateNestedManyWithoutTenantInput
    mutabaah?: MutabaahCreateNestedManyWithoutTenantInput
    wallets?: WalletCreateNestedManyWithoutTenantInput
    employees?: EmployeeCreateNestedManyWithoutTenantInput
    payrolls?: PayrollCreateNestedManyWithoutTenantInput
    academicScheds?: AcademicScheduleCreateNestedManyWithoutTenantInput
    attendances?: AttendanceCreateNestedManyWithoutTenantInput
    ppdbRegistrations?: PpdbRegistrationCreateNestedManyWithoutTenantInput
    ppdbDocuments?: PpdbDocumentCreateNestedManyWithoutTenantInput
    ppdbExams?: PpdbExamCreateNestedManyWithoutTenantInput
    inventoryItems?: ItemCreateNestedManyWithoutTenantInput
    inventoryTransactions?: InventoryTransactionCreateNestedManyWithoutTenantInput
    suppliers?: SupplierCreateNestedManyWithoutTenantInput
    purchaseOrders?: PurchaseOrderCreateNestedManyWithoutTenantInput
    buildings?: BuildingCreateNestedManyWithoutTenantInput
    rooms?: RoomCreateNestedManyWithoutTenantInput
    roomAssignments?: RoomAssignmentCreateNestedManyWithoutTenantInput
    maintenanceTickets?: MaintenanceTicketCreateNestedManyWithoutTenantInput
  }

  export type TenantUncheckedCreateWithoutGradesInput = {
    id?: string
    name: string
    address?: string | null
    phone?: string | null
    adminUserId?: string | null
    timezone?: string
    plan?: string
    billingContact?: string | null
    status?: string
    settings?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutTenantInput
    santri?: SantriUncheckedCreateNestedManyWithoutTenantInput
    wali?: WaliUncheckedCreateNestedManyWithoutTenantInput
    izin?: IzinUncheckedCreateNestedManyWithoutTenantInput
    catatanHarian?: CatatanHarianUncheckedCreateNestedManyWithoutTenantInput
    pengumuman?: PengumumanUncheckedCreateNestedManyWithoutTenantInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutTenantInput
    pelanggaran?: PelanggaranUncheckedCreateNestedManyWithoutTenantInput
    pembinaan?: PembinaanUncheckedCreateNestedManyWithoutTenantInput
    kunjungan?: KunjunganUncheckedCreateNestedManyWithoutTenantInput
    healthRecords?: HealthRecordUncheckedCreateNestedManyWithoutTenantInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutTenantInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutTenantInput
    webhookEvents?: WebhookEventUncheckedCreateNestedManyWithoutTenantInput
    tahfidz?: TahfidzUncheckedCreateNestedManyWithoutTenantInput
    mutabaah?: MutabaahUncheckedCreateNestedManyWithoutTenantInput
    wallets?: WalletUncheckedCreateNestedManyWithoutTenantInput
    employees?: EmployeeUncheckedCreateNestedManyWithoutTenantInput
    payrolls?: PayrollUncheckedCreateNestedManyWithoutTenantInput
    academicScheds?: AcademicScheduleUncheckedCreateNestedManyWithoutTenantInput
    attendances?: AttendanceUncheckedCreateNestedManyWithoutTenantInput
    ppdbRegistrations?: PpdbRegistrationUncheckedCreateNestedManyWithoutTenantInput
    ppdbDocuments?: PpdbDocumentUncheckedCreateNestedManyWithoutTenantInput
    ppdbExams?: PpdbExamUncheckedCreateNestedManyWithoutTenantInput
    inventoryItems?: ItemUncheckedCreateNestedManyWithoutTenantInput
    inventoryTransactions?: InventoryTransactionUncheckedCreateNestedManyWithoutTenantInput
    suppliers?: SupplierUncheckedCreateNestedManyWithoutTenantInput
    purchaseOrders?: PurchaseOrderUncheckedCreateNestedManyWithoutTenantInput
    buildings?: BuildingUncheckedCreateNestedManyWithoutTenantInput
    rooms?: RoomUncheckedCreateNestedManyWithoutTenantInput
    roomAssignments?: RoomAssignmentUncheckedCreateNestedManyWithoutTenantInput
    maintenanceTickets?: MaintenanceTicketUncheckedCreateNestedManyWithoutTenantInput
  }

  export type TenantCreateOrConnectWithoutGradesInput = {
    where: TenantWhereUniqueInput
    create: XOR<TenantCreateWithoutGradesInput, TenantUncheckedCreateWithoutGradesInput>
  }

  export type SantriCreateWithoutGradesInput = {
    id?: string
    nisn?: string | null
    name: string
    gender: string
    dob?: Date | string | null
    kelas?: string | null
    room?: string | null
    contact?: string | null
    address?: string | null
    photo?: string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutSantriInput
    walis?: SantriWaliCreateNestedManyWithoutSantriInput
    izin?: IzinCreateNestedManyWithoutSantriInput
    catatanHarian?: CatatanHarianCreateNestedManyWithoutSantriInput
    invoices?: InvoiceCreateNestedManyWithoutSantriInput
    pelanggaran?: PelanggaranCreateNestedManyWithoutSantriInput
    pembinaan?: PembinaanCreateNestedManyWithoutSantriInput
    kunjungan?: KunjunganCreateNestedManyWithoutSantriInput
    healthRecords?: HealthRecordCreateNestedManyWithoutSantriInput
    medications?: MedicationCreateNestedManyWithoutSantriInput
    tahfidz?: TahfidzCreateNestedManyWithoutSantriInput
    mutabaah?: MutabaahCreateNestedManyWithoutSantriInput
    wallet?: WalletCreateNestedOneWithoutSantriInput
    attendances?: AttendanceCreateNestedManyWithoutSantriInput
  }

  export type SantriUncheckedCreateWithoutGradesInput = {
    id?: string
    tenantId: string
    nisn?: string | null
    name: string
    gender: string
    dob?: Date | string | null
    kelas?: string | null
    room?: string | null
    contact?: string | null
    address?: string | null
    photo?: string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    walis?: SantriWaliUncheckedCreateNestedManyWithoutSantriInput
    izin?: IzinUncheckedCreateNestedManyWithoutSantriInput
    catatanHarian?: CatatanHarianUncheckedCreateNestedManyWithoutSantriInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutSantriInput
    pelanggaran?: PelanggaranUncheckedCreateNestedManyWithoutSantriInput
    pembinaan?: PembinaanUncheckedCreateNestedManyWithoutSantriInput
    kunjungan?: KunjunganUncheckedCreateNestedManyWithoutSantriInput
    healthRecords?: HealthRecordUncheckedCreateNestedManyWithoutSantriInput
    medications?: MedicationUncheckedCreateNestedManyWithoutSantriInput
    tahfidz?: TahfidzUncheckedCreateNestedManyWithoutSantriInput
    mutabaah?: MutabaahUncheckedCreateNestedManyWithoutSantriInput
    wallet?: WalletUncheckedCreateNestedOneWithoutSantriInput
    attendances?: AttendanceUncheckedCreateNestedManyWithoutSantriInput
  }

  export type SantriCreateOrConnectWithoutGradesInput = {
    where: SantriWhereUniqueInput
    create: XOR<SantriCreateWithoutGradesInput, SantriUncheckedCreateWithoutGradesInput>
  }

  export type TenantUpsertWithoutGradesInput = {
    update: XOR<TenantUpdateWithoutGradesInput, TenantUncheckedUpdateWithoutGradesInput>
    create: XOR<TenantCreateWithoutGradesInput, TenantUncheckedCreateWithoutGradesInput>
    where?: TenantWhereInput
  }

  export type TenantUpdateToOneWithWhereWithoutGradesInput = {
    where?: TenantWhereInput
    data: XOR<TenantUpdateWithoutGradesInput, TenantUncheckedUpdateWithoutGradesInput>
  }

  export type TenantUpdateWithoutGradesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    adminUserId?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    plan?: StringFieldUpdateOperationsInput | string
    billingContact?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    settings?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutTenantNestedInput
    santri?: SantriUpdateManyWithoutTenantNestedInput
    wali?: WaliUpdateManyWithoutTenantNestedInput
    izin?: IzinUpdateManyWithoutTenantNestedInput
    catatanHarian?: CatatanHarianUpdateManyWithoutTenantNestedInput
    pengumuman?: PengumumanUpdateManyWithoutTenantNestedInput
    invoices?: InvoiceUpdateManyWithoutTenantNestedInput
    pelanggaran?: PelanggaranUpdateManyWithoutTenantNestedInput
    pembinaan?: PembinaanUpdateManyWithoutTenantNestedInput
    kunjungan?: KunjunganUpdateManyWithoutTenantNestedInput
    healthRecords?: HealthRecordUpdateManyWithoutTenantNestedInput
    auditLogs?: AuditLogUpdateManyWithoutTenantNestedInput
    notifications?: NotificationUpdateManyWithoutTenantNestedInput
    webhookEvents?: WebhookEventUpdateManyWithoutTenantNestedInput
    tahfidz?: TahfidzUpdateManyWithoutTenantNestedInput
    mutabaah?: MutabaahUpdateManyWithoutTenantNestedInput
    wallets?: WalletUpdateManyWithoutTenantNestedInput
    employees?: EmployeeUpdateManyWithoutTenantNestedInput
    payrolls?: PayrollUpdateManyWithoutTenantNestedInput
    academicScheds?: AcademicScheduleUpdateManyWithoutTenantNestedInput
    attendances?: AttendanceUpdateManyWithoutTenantNestedInput
    ppdbRegistrations?: PpdbRegistrationUpdateManyWithoutTenantNestedInput
    ppdbDocuments?: PpdbDocumentUpdateManyWithoutTenantNestedInput
    ppdbExams?: PpdbExamUpdateManyWithoutTenantNestedInput
    inventoryItems?: ItemUpdateManyWithoutTenantNestedInput
    inventoryTransactions?: InventoryTransactionUpdateManyWithoutTenantNestedInput
    suppliers?: SupplierUpdateManyWithoutTenantNestedInput
    purchaseOrders?: PurchaseOrderUpdateManyWithoutTenantNestedInput
    buildings?: BuildingUpdateManyWithoutTenantNestedInput
    rooms?: RoomUpdateManyWithoutTenantNestedInput
    roomAssignments?: RoomAssignmentUpdateManyWithoutTenantNestedInput
    maintenanceTickets?: MaintenanceTicketUpdateManyWithoutTenantNestedInput
  }

  export type TenantUncheckedUpdateWithoutGradesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    adminUserId?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    plan?: StringFieldUpdateOperationsInput | string
    billingContact?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    settings?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutTenantNestedInput
    santri?: SantriUncheckedUpdateManyWithoutTenantNestedInput
    wali?: WaliUncheckedUpdateManyWithoutTenantNestedInput
    izin?: IzinUncheckedUpdateManyWithoutTenantNestedInput
    catatanHarian?: CatatanHarianUncheckedUpdateManyWithoutTenantNestedInput
    pengumuman?: PengumumanUncheckedUpdateManyWithoutTenantNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutTenantNestedInput
    pelanggaran?: PelanggaranUncheckedUpdateManyWithoutTenantNestedInput
    pembinaan?: PembinaanUncheckedUpdateManyWithoutTenantNestedInput
    kunjungan?: KunjunganUncheckedUpdateManyWithoutTenantNestedInput
    healthRecords?: HealthRecordUncheckedUpdateManyWithoutTenantNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutTenantNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutTenantNestedInput
    webhookEvents?: WebhookEventUncheckedUpdateManyWithoutTenantNestedInput
    tahfidz?: TahfidzUncheckedUpdateManyWithoutTenantNestedInput
    mutabaah?: MutabaahUncheckedUpdateManyWithoutTenantNestedInput
    wallets?: WalletUncheckedUpdateManyWithoutTenantNestedInput
    employees?: EmployeeUncheckedUpdateManyWithoutTenantNestedInput
    payrolls?: PayrollUncheckedUpdateManyWithoutTenantNestedInput
    academicScheds?: AcademicScheduleUncheckedUpdateManyWithoutTenantNestedInput
    attendances?: AttendanceUncheckedUpdateManyWithoutTenantNestedInput
    ppdbRegistrations?: PpdbRegistrationUncheckedUpdateManyWithoutTenantNestedInput
    ppdbDocuments?: PpdbDocumentUncheckedUpdateManyWithoutTenantNestedInput
    ppdbExams?: PpdbExamUncheckedUpdateManyWithoutTenantNestedInput
    inventoryItems?: ItemUncheckedUpdateManyWithoutTenantNestedInput
    inventoryTransactions?: InventoryTransactionUncheckedUpdateManyWithoutTenantNestedInput
    suppliers?: SupplierUncheckedUpdateManyWithoutTenantNestedInput
    purchaseOrders?: PurchaseOrderUncheckedUpdateManyWithoutTenantNestedInput
    buildings?: BuildingUncheckedUpdateManyWithoutTenantNestedInput
    rooms?: RoomUncheckedUpdateManyWithoutTenantNestedInput
    roomAssignments?: RoomAssignmentUncheckedUpdateManyWithoutTenantNestedInput
    maintenanceTickets?: MaintenanceTicketUncheckedUpdateManyWithoutTenantNestedInput
  }

  export type SantriUpsertWithoutGradesInput = {
    update: XOR<SantriUpdateWithoutGradesInput, SantriUncheckedUpdateWithoutGradesInput>
    create: XOR<SantriCreateWithoutGradesInput, SantriUncheckedCreateWithoutGradesInput>
    where?: SantriWhereInput
  }

  export type SantriUpdateToOneWithWhereWithoutGradesInput = {
    where?: SantriWhereInput
    data: XOR<SantriUpdateWithoutGradesInput, SantriUncheckedUpdateWithoutGradesInput>
  }

  export type SantriUpdateWithoutGradesInput = {
    id?: StringFieldUpdateOperationsInput | string
    nisn?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    gender?: StringFieldUpdateOperationsInput | string
    dob?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    kelas?: NullableStringFieldUpdateOperationsInput | string | null
    room?: NullableStringFieldUpdateOperationsInput | string | null
    contact?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutSantriNestedInput
    walis?: SantriWaliUpdateManyWithoutSantriNestedInput
    izin?: IzinUpdateManyWithoutSantriNestedInput
    catatanHarian?: CatatanHarianUpdateManyWithoutSantriNestedInput
    invoices?: InvoiceUpdateManyWithoutSantriNestedInput
    pelanggaran?: PelanggaranUpdateManyWithoutSantriNestedInput
    pembinaan?: PembinaanUpdateManyWithoutSantriNestedInput
    kunjungan?: KunjunganUpdateManyWithoutSantriNestedInput
    healthRecords?: HealthRecordUpdateManyWithoutSantriNestedInput
    medications?: MedicationUpdateManyWithoutSantriNestedInput
    tahfidz?: TahfidzUpdateManyWithoutSantriNestedInput
    mutabaah?: MutabaahUpdateManyWithoutSantriNestedInput
    wallet?: WalletUpdateOneWithoutSantriNestedInput
    attendances?: AttendanceUpdateManyWithoutSantriNestedInput
  }

  export type SantriUncheckedUpdateWithoutGradesInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    nisn?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    gender?: StringFieldUpdateOperationsInput | string
    dob?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    kelas?: NullableStringFieldUpdateOperationsInput | string | null
    room?: NullableStringFieldUpdateOperationsInput | string | null
    contact?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    walis?: SantriWaliUncheckedUpdateManyWithoutSantriNestedInput
    izin?: IzinUncheckedUpdateManyWithoutSantriNestedInput
    catatanHarian?: CatatanHarianUncheckedUpdateManyWithoutSantriNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutSantriNestedInput
    pelanggaran?: PelanggaranUncheckedUpdateManyWithoutSantriNestedInput
    pembinaan?: PembinaanUncheckedUpdateManyWithoutSantriNestedInput
    kunjungan?: KunjunganUncheckedUpdateManyWithoutSantriNestedInput
    healthRecords?: HealthRecordUncheckedUpdateManyWithoutSantriNestedInput
    medications?: MedicationUncheckedUpdateManyWithoutSantriNestedInput
    tahfidz?: TahfidzUncheckedUpdateManyWithoutSantriNestedInput
    mutabaah?: MutabaahUncheckedUpdateManyWithoutSantriNestedInput
    wallet?: WalletUncheckedUpdateOneWithoutSantriNestedInput
    attendances?: AttendanceUncheckedUpdateManyWithoutSantriNestedInput
  }

  export type TenantCreateWithoutPpdbRegistrationsInput = {
    id?: string
    name: string
    address?: string | null
    phone?: string | null
    adminUserId?: string | null
    timezone?: string
    plan?: string
    billingContact?: string | null
    status?: string
    settings?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutTenantInput
    santri?: SantriCreateNestedManyWithoutTenantInput
    wali?: WaliCreateNestedManyWithoutTenantInput
    izin?: IzinCreateNestedManyWithoutTenantInput
    catatanHarian?: CatatanHarianCreateNestedManyWithoutTenantInput
    pengumuman?: PengumumanCreateNestedManyWithoutTenantInput
    invoices?: InvoiceCreateNestedManyWithoutTenantInput
    pelanggaran?: PelanggaranCreateNestedManyWithoutTenantInput
    pembinaan?: PembinaanCreateNestedManyWithoutTenantInput
    kunjungan?: KunjunganCreateNestedManyWithoutTenantInput
    healthRecords?: HealthRecordCreateNestedManyWithoutTenantInput
    auditLogs?: AuditLogCreateNestedManyWithoutTenantInput
    notifications?: NotificationCreateNestedManyWithoutTenantInput
    webhookEvents?: WebhookEventCreateNestedManyWithoutTenantInput
    tahfidz?: TahfidzCreateNestedManyWithoutTenantInput
    mutabaah?: MutabaahCreateNestedManyWithoutTenantInput
    wallets?: WalletCreateNestedManyWithoutTenantInput
    employees?: EmployeeCreateNestedManyWithoutTenantInput
    payrolls?: PayrollCreateNestedManyWithoutTenantInput
    academicScheds?: AcademicScheduleCreateNestedManyWithoutTenantInput
    attendances?: AttendanceCreateNestedManyWithoutTenantInput
    grades?: GradeCreateNestedManyWithoutTenantInput
    ppdbDocuments?: PpdbDocumentCreateNestedManyWithoutTenantInput
    ppdbExams?: PpdbExamCreateNestedManyWithoutTenantInput
    inventoryItems?: ItemCreateNestedManyWithoutTenantInput
    inventoryTransactions?: InventoryTransactionCreateNestedManyWithoutTenantInput
    suppliers?: SupplierCreateNestedManyWithoutTenantInput
    purchaseOrders?: PurchaseOrderCreateNestedManyWithoutTenantInput
    buildings?: BuildingCreateNestedManyWithoutTenantInput
    rooms?: RoomCreateNestedManyWithoutTenantInput
    roomAssignments?: RoomAssignmentCreateNestedManyWithoutTenantInput
    maintenanceTickets?: MaintenanceTicketCreateNestedManyWithoutTenantInput
  }

  export type TenantUncheckedCreateWithoutPpdbRegistrationsInput = {
    id?: string
    name: string
    address?: string | null
    phone?: string | null
    adminUserId?: string | null
    timezone?: string
    plan?: string
    billingContact?: string | null
    status?: string
    settings?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutTenantInput
    santri?: SantriUncheckedCreateNestedManyWithoutTenantInput
    wali?: WaliUncheckedCreateNestedManyWithoutTenantInput
    izin?: IzinUncheckedCreateNestedManyWithoutTenantInput
    catatanHarian?: CatatanHarianUncheckedCreateNestedManyWithoutTenantInput
    pengumuman?: PengumumanUncheckedCreateNestedManyWithoutTenantInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutTenantInput
    pelanggaran?: PelanggaranUncheckedCreateNestedManyWithoutTenantInput
    pembinaan?: PembinaanUncheckedCreateNestedManyWithoutTenantInput
    kunjungan?: KunjunganUncheckedCreateNestedManyWithoutTenantInput
    healthRecords?: HealthRecordUncheckedCreateNestedManyWithoutTenantInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutTenantInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutTenantInput
    webhookEvents?: WebhookEventUncheckedCreateNestedManyWithoutTenantInput
    tahfidz?: TahfidzUncheckedCreateNestedManyWithoutTenantInput
    mutabaah?: MutabaahUncheckedCreateNestedManyWithoutTenantInput
    wallets?: WalletUncheckedCreateNestedManyWithoutTenantInput
    employees?: EmployeeUncheckedCreateNestedManyWithoutTenantInput
    payrolls?: PayrollUncheckedCreateNestedManyWithoutTenantInput
    academicScheds?: AcademicScheduleUncheckedCreateNestedManyWithoutTenantInput
    attendances?: AttendanceUncheckedCreateNestedManyWithoutTenantInput
    grades?: GradeUncheckedCreateNestedManyWithoutTenantInput
    ppdbDocuments?: PpdbDocumentUncheckedCreateNestedManyWithoutTenantInput
    ppdbExams?: PpdbExamUncheckedCreateNestedManyWithoutTenantInput
    inventoryItems?: ItemUncheckedCreateNestedManyWithoutTenantInput
    inventoryTransactions?: InventoryTransactionUncheckedCreateNestedManyWithoutTenantInput
    suppliers?: SupplierUncheckedCreateNestedManyWithoutTenantInput
    purchaseOrders?: PurchaseOrderUncheckedCreateNestedManyWithoutTenantInput
    buildings?: BuildingUncheckedCreateNestedManyWithoutTenantInput
    rooms?: RoomUncheckedCreateNestedManyWithoutTenantInput
    roomAssignments?: RoomAssignmentUncheckedCreateNestedManyWithoutTenantInput
    maintenanceTickets?: MaintenanceTicketUncheckedCreateNestedManyWithoutTenantInput
  }

  export type TenantCreateOrConnectWithoutPpdbRegistrationsInput = {
    where: TenantWhereUniqueInput
    create: XOR<TenantCreateWithoutPpdbRegistrationsInput, TenantUncheckedCreateWithoutPpdbRegistrationsInput>
  }

  export type PpdbDocumentCreateWithoutRegistrationInput = {
    id?: string
    documentType: string
    fileUrl: string
    isVerified?: boolean
    createdAt?: Date | string
    tenant: TenantCreateNestedOneWithoutPpdbDocumentsInput
  }

  export type PpdbDocumentUncheckedCreateWithoutRegistrationInput = {
    id?: string
    tenantId: string
    documentType: string
    fileUrl: string
    isVerified?: boolean
    createdAt?: Date | string
  }

  export type PpdbDocumentCreateOrConnectWithoutRegistrationInput = {
    where: PpdbDocumentWhereUniqueInput
    create: XOR<PpdbDocumentCreateWithoutRegistrationInput, PpdbDocumentUncheckedCreateWithoutRegistrationInput>
  }

  export type PpdbDocumentCreateManyRegistrationInputEnvelope = {
    data: PpdbDocumentCreateManyRegistrationInput | PpdbDocumentCreateManyRegistrationInput[]
  }

  export type PpdbExamCreateWithoutRegistrationInput = {
    id?: string
    examType: string
    examDate: Date | string
    score?: number | null
    result?: string | null
    interviewer?: string | null
    createdAt?: Date | string
    tenant: TenantCreateNestedOneWithoutPpdbExamsInput
  }

  export type PpdbExamUncheckedCreateWithoutRegistrationInput = {
    id?: string
    tenantId: string
    examType: string
    examDate: Date | string
    score?: number | null
    result?: string | null
    interviewer?: string | null
    createdAt?: Date | string
  }

  export type PpdbExamCreateOrConnectWithoutRegistrationInput = {
    where: PpdbExamWhereUniqueInput
    create: XOR<PpdbExamCreateWithoutRegistrationInput, PpdbExamUncheckedCreateWithoutRegistrationInput>
  }

  export type PpdbExamCreateManyRegistrationInputEnvelope = {
    data: PpdbExamCreateManyRegistrationInput | PpdbExamCreateManyRegistrationInput[]
  }

  export type TenantUpsertWithoutPpdbRegistrationsInput = {
    update: XOR<TenantUpdateWithoutPpdbRegistrationsInput, TenantUncheckedUpdateWithoutPpdbRegistrationsInput>
    create: XOR<TenantCreateWithoutPpdbRegistrationsInput, TenantUncheckedCreateWithoutPpdbRegistrationsInput>
    where?: TenantWhereInput
  }

  export type TenantUpdateToOneWithWhereWithoutPpdbRegistrationsInput = {
    where?: TenantWhereInput
    data: XOR<TenantUpdateWithoutPpdbRegistrationsInput, TenantUncheckedUpdateWithoutPpdbRegistrationsInput>
  }

  export type TenantUpdateWithoutPpdbRegistrationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    adminUserId?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    plan?: StringFieldUpdateOperationsInput | string
    billingContact?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    settings?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutTenantNestedInput
    santri?: SantriUpdateManyWithoutTenantNestedInput
    wali?: WaliUpdateManyWithoutTenantNestedInput
    izin?: IzinUpdateManyWithoutTenantNestedInput
    catatanHarian?: CatatanHarianUpdateManyWithoutTenantNestedInput
    pengumuman?: PengumumanUpdateManyWithoutTenantNestedInput
    invoices?: InvoiceUpdateManyWithoutTenantNestedInput
    pelanggaran?: PelanggaranUpdateManyWithoutTenantNestedInput
    pembinaan?: PembinaanUpdateManyWithoutTenantNestedInput
    kunjungan?: KunjunganUpdateManyWithoutTenantNestedInput
    healthRecords?: HealthRecordUpdateManyWithoutTenantNestedInput
    auditLogs?: AuditLogUpdateManyWithoutTenantNestedInput
    notifications?: NotificationUpdateManyWithoutTenantNestedInput
    webhookEvents?: WebhookEventUpdateManyWithoutTenantNestedInput
    tahfidz?: TahfidzUpdateManyWithoutTenantNestedInput
    mutabaah?: MutabaahUpdateManyWithoutTenantNestedInput
    wallets?: WalletUpdateManyWithoutTenantNestedInput
    employees?: EmployeeUpdateManyWithoutTenantNestedInput
    payrolls?: PayrollUpdateManyWithoutTenantNestedInput
    academicScheds?: AcademicScheduleUpdateManyWithoutTenantNestedInput
    attendances?: AttendanceUpdateManyWithoutTenantNestedInput
    grades?: GradeUpdateManyWithoutTenantNestedInput
    ppdbDocuments?: PpdbDocumentUpdateManyWithoutTenantNestedInput
    ppdbExams?: PpdbExamUpdateManyWithoutTenantNestedInput
    inventoryItems?: ItemUpdateManyWithoutTenantNestedInput
    inventoryTransactions?: InventoryTransactionUpdateManyWithoutTenantNestedInput
    suppliers?: SupplierUpdateManyWithoutTenantNestedInput
    purchaseOrders?: PurchaseOrderUpdateManyWithoutTenantNestedInput
    buildings?: BuildingUpdateManyWithoutTenantNestedInput
    rooms?: RoomUpdateManyWithoutTenantNestedInput
    roomAssignments?: RoomAssignmentUpdateManyWithoutTenantNestedInput
    maintenanceTickets?: MaintenanceTicketUpdateManyWithoutTenantNestedInput
  }

  export type TenantUncheckedUpdateWithoutPpdbRegistrationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    adminUserId?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    plan?: StringFieldUpdateOperationsInput | string
    billingContact?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    settings?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutTenantNestedInput
    santri?: SantriUncheckedUpdateManyWithoutTenantNestedInput
    wali?: WaliUncheckedUpdateManyWithoutTenantNestedInput
    izin?: IzinUncheckedUpdateManyWithoutTenantNestedInput
    catatanHarian?: CatatanHarianUncheckedUpdateManyWithoutTenantNestedInput
    pengumuman?: PengumumanUncheckedUpdateManyWithoutTenantNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutTenantNestedInput
    pelanggaran?: PelanggaranUncheckedUpdateManyWithoutTenantNestedInput
    pembinaan?: PembinaanUncheckedUpdateManyWithoutTenantNestedInput
    kunjungan?: KunjunganUncheckedUpdateManyWithoutTenantNestedInput
    healthRecords?: HealthRecordUncheckedUpdateManyWithoutTenantNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutTenantNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutTenantNestedInput
    webhookEvents?: WebhookEventUncheckedUpdateManyWithoutTenantNestedInput
    tahfidz?: TahfidzUncheckedUpdateManyWithoutTenantNestedInput
    mutabaah?: MutabaahUncheckedUpdateManyWithoutTenantNestedInput
    wallets?: WalletUncheckedUpdateManyWithoutTenantNestedInput
    employees?: EmployeeUncheckedUpdateManyWithoutTenantNestedInput
    payrolls?: PayrollUncheckedUpdateManyWithoutTenantNestedInput
    academicScheds?: AcademicScheduleUncheckedUpdateManyWithoutTenantNestedInput
    attendances?: AttendanceUncheckedUpdateManyWithoutTenantNestedInput
    grades?: GradeUncheckedUpdateManyWithoutTenantNestedInput
    ppdbDocuments?: PpdbDocumentUncheckedUpdateManyWithoutTenantNestedInput
    ppdbExams?: PpdbExamUncheckedUpdateManyWithoutTenantNestedInput
    inventoryItems?: ItemUncheckedUpdateManyWithoutTenantNestedInput
    inventoryTransactions?: InventoryTransactionUncheckedUpdateManyWithoutTenantNestedInput
    suppliers?: SupplierUncheckedUpdateManyWithoutTenantNestedInput
    purchaseOrders?: PurchaseOrderUncheckedUpdateManyWithoutTenantNestedInput
    buildings?: BuildingUncheckedUpdateManyWithoutTenantNestedInput
    rooms?: RoomUncheckedUpdateManyWithoutTenantNestedInput
    roomAssignments?: RoomAssignmentUncheckedUpdateManyWithoutTenantNestedInput
    maintenanceTickets?: MaintenanceTicketUncheckedUpdateManyWithoutTenantNestedInput
  }

  export type PpdbDocumentUpsertWithWhereUniqueWithoutRegistrationInput = {
    where: PpdbDocumentWhereUniqueInput
    update: XOR<PpdbDocumentUpdateWithoutRegistrationInput, PpdbDocumentUncheckedUpdateWithoutRegistrationInput>
    create: XOR<PpdbDocumentCreateWithoutRegistrationInput, PpdbDocumentUncheckedCreateWithoutRegistrationInput>
  }

  export type PpdbDocumentUpdateWithWhereUniqueWithoutRegistrationInput = {
    where: PpdbDocumentWhereUniqueInput
    data: XOR<PpdbDocumentUpdateWithoutRegistrationInput, PpdbDocumentUncheckedUpdateWithoutRegistrationInput>
  }

  export type PpdbDocumentUpdateManyWithWhereWithoutRegistrationInput = {
    where: PpdbDocumentScalarWhereInput
    data: XOR<PpdbDocumentUpdateManyMutationInput, PpdbDocumentUncheckedUpdateManyWithoutRegistrationInput>
  }

  export type PpdbExamUpsertWithWhereUniqueWithoutRegistrationInput = {
    where: PpdbExamWhereUniqueInput
    update: XOR<PpdbExamUpdateWithoutRegistrationInput, PpdbExamUncheckedUpdateWithoutRegistrationInput>
    create: XOR<PpdbExamCreateWithoutRegistrationInput, PpdbExamUncheckedCreateWithoutRegistrationInput>
  }

  export type PpdbExamUpdateWithWhereUniqueWithoutRegistrationInput = {
    where: PpdbExamWhereUniqueInput
    data: XOR<PpdbExamUpdateWithoutRegistrationInput, PpdbExamUncheckedUpdateWithoutRegistrationInput>
  }

  export type PpdbExamUpdateManyWithWhereWithoutRegistrationInput = {
    where: PpdbExamScalarWhereInput
    data: XOR<PpdbExamUpdateManyMutationInput, PpdbExamUncheckedUpdateManyWithoutRegistrationInput>
  }

  export type TenantCreateWithoutPpdbDocumentsInput = {
    id?: string
    name: string
    address?: string | null
    phone?: string | null
    adminUserId?: string | null
    timezone?: string
    plan?: string
    billingContact?: string | null
    status?: string
    settings?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutTenantInput
    santri?: SantriCreateNestedManyWithoutTenantInput
    wali?: WaliCreateNestedManyWithoutTenantInput
    izin?: IzinCreateNestedManyWithoutTenantInput
    catatanHarian?: CatatanHarianCreateNestedManyWithoutTenantInput
    pengumuman?: PengumumanCreateNestedManyWithoutTenantInput
    invoices?: InvoiceCreateNestedManyWithoutTenantInput
    pelanggaran?: PelanggaranCreateNestedManyWithoutTenantInput
    pembinaan?: PembinaanCreateNestedManyWithoutTenantInput
    kunjungan?: KunjunganCreateNestedManyWithoutTenantInput
    healthRecords?: HealthRecordCreateNestedManyWithoutTenantInput
    auditLogs?: AuditLogCreateNestedManyWithoutTenantInput
    notifications?: NotificationCreateNestedManyWithoutTenantInput
    webhookEvents?: WebhookEventCreateNestedManyWithoutTenantInput
    tahfidz?: TahfidzCreateNestedManyWithoutTenantInput
    mutabaah?: MutabaahCreateNestedManyWithoutTenantInput
    wallets?: WalletCreateNestedManyWithoutTenantInput
    employees?: EmployeeCreateNestedManyWithoutTenantInput
    payrolls?: PayrollCreateNestedManyWithoutTenantInput
    academicScheds?: AcademicScheduleCreateNestedManyWithoutTenantInput
    attendances?: AttendanceCreateNestedManyWithoutTenantInput
    grades?: GradeCreateNestedManyWithoutTenantInput
    ppdbRegistrations?: PpdbRegistrationCreateNestedManyWithoutTenantInput
    ppdbExams?: PpdbExamCreateNestedManyWithoutTenantInput
    inventoryItems?: ItemCreateNestedManyWithoutTenantInput
    inventoryTransactions?: InventoryTransactionCreateNestedManyWithoutTenantInput
    suppliers?: SupplierCreateNestedManyWithoutTenantInput
    purchaseOrders?: PurchaseOrderCreateNestedManyWithoutTenantInput
    buildings?: BuildingCreateNestedManyWithoutTenantInput
    rooms?: RoomCreateNestedManyWithoutTenantInput
    roomAssignments?: RoomAssignmentCreateNestedManyWithoutTenantInput
    maintenanceTickets?: MaintenanceTicketCreateNestedManyWithoutTenantInput
  }

  export type TenantUncheckedCreateWithoutPpdbDocumentsInput = {
    id?: string
    name: string
    address?: string | null
    phone?: string | null
    adminUserId?: string | null
    timezone?: string
    plan?: string
    billingContact?: string | null
    status?: string
    settings?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutTenantInput
    santri?: SantriUncheckedCreateNestedManyWithoutTenantInput
    wali?: WaliUncheckedCreateNestedManyWithoutTenantInput
    izin?: IzinUncheckedCreateNestedManyWithoutTenantInput
    catatanHarian?: CatatanHarianUncheckedCreateNestedManyWithoutTenantInput
    pengumuman?: PengumumanUncheckedCreateNestedManyWithoutTenantInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutTenantInput
    pelanggaran?: PelanggaranUncheckedCreateNestedManyWithoutTenantInput
    pembinaan?: PembinaanUncheckedCreateNestedManyWithoutTenantInput
    kunjungan?: KunjunganUncheckedCreateNestedManyWithoutTenantInput
    healthRecords?: HealthRecordUncheckedCreateNestedManyWithoutTenantInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutTenantInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutTenantInput
    webhookEvents?: WebhookEventUncheckedCreateNestedManyWithoutTenantInput
    tahfidz?: TahfidzUncheckedCreateNestedManyWithoutTenantInput
    mutabaah?: MutabaahUncheckedCreateNestedManyWithoutTenantInput
    wallets?: WalletUncheckedCreateNestedManyWithoutTenantInput
    employees?: EmployeeUncheckedCreateNestedManyWithoutTenantInput
    payrolls?: PayrollUncheckedCreateNestedManyWithoutTenantInput
    academicScheds?: AcademicScheduleUncheckedCreateNestedManyWithoutTenantInput
    attendances?: AttendanceUncheckedCreateNestedManyWithoutTenantInput
    grades?: GradeUncheckedCreateNestedManyWithoutTenantInput
    ppdbRegistrations?: PpdbRegistrationUncheckedCreateNestedManyWithoutTenantInput
    ppdbExams?: PpdbExamUncheckedCreateNestedManyWithoutTenantInput
    inventoryItems?: ItemUncheckedCreateNestedManyWithoutTenantInput
    inventoryTransactions?: InventoryTransactionUncheckedCreateNestedManyWithoutTenantInput
    suppliers?: SupplierUncheckedCreateNestedManyWithoutTenantInput
    purchaseOrders?: PurchaseOrderUncheckedCreateNestedManyWithoutTenantInput
    buildings?: BuildingUncheckedCreateNestedManyWithoutTenantInput
    rooms?: RoomUncheckedCreateNestedManyWithoutTenantInput
    roomAssignments?: RoomAssignmentUncheckedCreateNestedManyWithoutTenantInput
    maintenanceTickets?: MaintenanceTicketUncheckedCreateNestedManyWithoutTenantInput
  }

  export type TenantCreateOrConnectWithoutPpdbDocumentsInput = {
    where: TenantWhereUniqueInput
    create: XOR<TenantCreateWithoutPpdbDocumentsInput, TenantUncheckedCreateWithoutPpdbDocumentsInput>
  }

  export type PpdbRegistrationCreateWithoutDocumentsInput = {
    id?: string
    registrationNumber: string
    fullName: string
    gender: string
    dob?: Date | string | null
    previousSchool?: string | null
    pathway?: string
    status?: string
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutPpdbRegistrationsInput
    exams?: PpdbExamCreateNestedManyWithoutRegistrationInput
  }

  export type PpdbRegistrationUncheckedCreateWithoutDocumentsInput = {
    id?: string
    tenantId: string
    registrationNumber: string
    fullName: string
    gender: string
    dob?: Date | string | null
    previousSchool?: string | null
    pathway?: string
    status?: string
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    exams?: PpdbExamUncheckedCreateNestedManyWithoutRegistrationInput
  }

  export type PpdbRegistrationCreateOrConnectWithoutDocumentsInput = {
    where: PpdbRegistrationWhereUniqueInput
    create: XOR<PpdbRegistrationCreateWithoutDocumentsInput, PpdbRegistrationUncheckedCreateWithoutDocumentsInput>
  }

  export type TenantUpsertWithoutPpdbDocumentsInput = {
    update: XOR<TenantUpdateWithoutPpdbDocumentsInput, TenantUncheckedUpdateWithoutPpdbDocumentsInput>
    create: XOR<TenantCreateWithoutPpdbDocumentsInput, TenantUncheckedCreateWithoutPpdbDocumentsInput>
    where?: TenantWhereInput
  }

  export type TenantUpdateToOneWithWhereWithoutPpdbDocumentsInput = {
    where?: TenantWhereInput
    data: XOR<TenantUpdateWithoutPpdbDocumentsInput, TenantUncheckedUpdateWithoutPpdbDocumentsInput>
  }

  export type TenantUpdateWithoutPpdbDocumentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    adminUserId?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    plan?: StringFieldUpdateOperationsInput | string
    billingContact?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    settings?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutTenantNestedInput
    santri?: SantriUpdateManyWithoutTenantNestedInput
    wali?: WaliUpdateManyWithoutTenantNestedInput
    izin?: IzinUpdateManyWithoutTenantNestedInput
    catatanHarian?: CatatanHarianUpdateManyWithoutTenantNestedInput
    pengumuman?: PengumumanUpdateManyWithoutTenantNestedInput
    invoices?: InvoiceUpdateManyWithoutTenantNestedInput
    pelanggaran?: PelanggaranUpdateManyWithoutTenantNestedInput
    pembinaan?: PembinaanUpdateManyWithoutTenantNestedInput
    kunjungan?: KunjunganUpdateManyWithoutTenantNestedInput
    healthRecords?: HealthRecordUpdateManyWithoutTenantNestedInput
    auditLogs?: AuditLogUpdateManyWithoutTenantNestedInput
    notifications?: NotificationUpdateManyWithoutTenantNestedInput
    webhookEvents?: WebhookEventUpdateManyWithoutTenantNestedInput
    tahfidz?: TahfidzUpdateManyWithoutTenantNestedInput
    mutabaah?: MutabaahUpdateManyWithoutTenantNestedInput
    wallets?: WalletUpdateManyWithoutTenantNestedInput
    employees?: EmployeeUpdateManyWithoutTenantNestedInput
    payrolls?: PayrollUpdateManyWithoutTenantNestedInput
    academicScheds?: AcademicScheduleUpdateManyWithoutTenantNestedInput
    attendances?: AttendanceUpdateManyWithoutTenantNestedInput
    grades?: GradeUpdateManyWithoutTenantNestedInput
    ppdbRegistrations?: PpdbRegistrationUpdateManyWithoutTenantNestedInput
    ppdbExams?: PpdbExamUpdateManyWithoutTenantNestedInput
    inventoryItems?: ItemUpdateManyWithoutTenantNestedInput
    inventoryTransactions?: InventoryTransactionUpdateManyWithoutTenantNestedInput
    suppliers?: SupplierUpdateManyWithoutTenantNestedInput
    purchaseOrders?: PurchaseOrderUpdateManyWithoutTenantNestedInput
    buildings?: BuildingUpdateManyWithoutTenantNestedInput
    rooms?: RoomUpdateManyWithoutTenantNestedInput
    roomAssignments?: RoomAssignmentUpdateManyWithoutTenantNestedInput
    maintenanceTickets?: MaintenanceTicketUpdateManyWithoutTenantNestedInput
  }

  export type TenantUncheckedUpdateWithoutPpdbDocumentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    adminUserId?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    plan?: StringFieldUpdateOperationsInput | string
    billingContact?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    settings?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutTenantNestedInput
    santri?: SantriUncheckedUpdateManyWithoutTenantNestedInput
    wali?: WaliUncheckedUpdateManyWithoutTenantNestedInput
    izin?: IzinUncheckedUpdateManyWithoutTenantNestedInput
    catatanHarian?: CatatanHarianUncheckedUpdateManyWithoutTenantNestedInput
    pengumuman?: PengumumanUncheckedUpdateManyWithoutTenantNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutTenantNestedInput
    pelanggaran?: PelanggaranUncheckedUpdateManyWithoutTenantNestedInput
    pembinaan?: PembinaanUncheckedUpdateManyWithoutTenantNestedInput
    kunjungan?: KunjunganUncheckedUpdateManyWithoutTenantNestedInput
    healthRecords?: HealthRecordUncheckedUpdateManyWithoutTenantNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutTenantNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutTenantNestedInput
    webhookEvents?: WebhookEventUncheckedUpdateManyWithoutTenantNestedInput
    tahfidz?: TahfidzUncheckedUpdateManyWithoutTenantNestedInput
    mutabaah?: MutabaahUncheckedUpdateManyWithoutTenantNestedInput
    wallets?: WalletUncheckedUpdateManyWithoutTenantNestedInput
    employees?: EmployeeUncheckedUpdateManyWithoutTenantNestedInput
    payrolls?: PayrollUncheckedUpdateManyWithoutTenantNestedInput
    academicScheds?: AcademicScheduleUncheckedUpdateManyWithoutTenantNestedInput
    attendances?: AttendanceUncheckedUpdateManyWithoutTenantNestedInput
    grades?: GradeUncheckedUpdateManyWithoutTenantNestedInput
    ppdbRegistrations?: PpdbRegistrationUncheckedUpdateManyWithoutTenantNestedInput
    ppdbExams?: PpdbExamUncheckedUpdateManyWithoutTenantNestedInput
    inventoryItems?: ItemUncheckedUpdateManyWithoutTenantNestedInput
    inventoryTransactions?: InventoryTransactionUncheckedUpdateManyWithoutTenantNestedInput
    suppliers?: SupplierUncheckedUpdateManyWithoutTenantNestedInput
    purchaseOrders?: PurchaseOrderUncheckedUpdateManyWithoutTenantNestedInput
    buildings?: BuildingUncheckedUpdateManyWithoutTenantNestedInput
    rooms?: RoomUncheckedUpdateManyWithoutTenantNestedInput
    roomAssignments?: RoomAssignmentUncheckedUpdateManyWithoutTenantNestedInput
    maintenanceTickets?: MaintenanceTicketUncheckedUpdateManyWithoutTenantNestedInput
  }

  export type PpdbRegistrationUpsertWithoutDocumentsInput = {
    update: XOR<PpdbRegistrationUpdateWithoutDocumentsInput, PpdbRegistrationUncheckedUpdateWithoutDocumentsInput>
    create: XOR<PpdbRegistrationCreateWithoutDocumentsInput, PpdbRegistrationUncheckedCreateWithoutDocumentsInput>
    where?: PpdbRegistrationWhereInput
  }

  export type PpdbRegistrationUpdateToOneWithWhereWithoutDocumentsInput = {
    where?: PpdbRegistrationWhereInput
    data: XOR<PpdbRegistrationUpdateWithoutDocumentsInput, PpdbRegistrationUncheckedUpdateWithoutDocumentsInput>
  }

  export type PpdbRegistrationUpdateWithoutDocumentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    registrationNumber?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    gender?: StringFieldUpdateOperationsInput | string
    dob?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    previousSchool?: NullableStringFieldUpdateOperationsInput | string | null
    pathway?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutPpdbRegistrationsNestedInput
    exams?: PpdbExamUpdateManyWithoutRegistrationNestedInput
  }

  export type PpdbRegistrationUncheckedUpdateWithoutDocumentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    registrationNumber?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    gender?: StringFieldUpdateOperationsInput | string
    dob?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    previousSchool?: NullableStringFieldUpdateOperationsInput | string | null
    pathway?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    exams?: PpdbExamUncheckedUpdateManyWithoutRegistrationNestedInput
  }

  export type TenantCreateWithoutPpdbExamsInput = {
    id?: string
    name: string
    address?: string | null
    phone?: string | null
    adminUserId?: string | null
    timezone?: string
    plan?: string
    billingContact?: string | null
    status?: string
    settings?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutTenantInput
    santri?: SantriCreateNestedManyWithoutTenantInput
    wali?: WaliCreateNestedManyWithoutTenantInput
    izin?: IzinCreateNestedManyWithoutTenantInput
    catatanHarian?: CatatanHarianCreateNestedManyWithoutTenantInput
    pengumuman?: PengumumanCreateNestedManyWithoutTenantInput
    invoices?: InvoiceCreateNestedManyWithoutTenantInput
    pelanggaran?: PelanggaranCreateNestedManyWithoutTenantInput
    pembinaan?: PembinaanCreateNestedManyWithoutTenantInput
    kunjungan?: KunjunganCreateNestedManyWithoutTenantInput
    healthRecords?: HealthRecordCreateNestedManyWithoutTenantInput
    auditLogs?: AuditLogCreateNestedManyWithoutTenantInput
    notifications?: NotificationCreateNestedManyWithoutTenantInput
    webhookEvents?: WebhookEventCreateNestedManyWithoutTenantInput
    tahfidz?: TahfidzCreateNestedManyWithoutTenantInput
    mutabaah?: MutabaahCreateNestedManyWithoutTenantInput
    wallets?: WalletCreateNestedManyWithoutTenantInput
    employees?: EmployeeCreateNestedManyWithoutTenantInput
    payrolls?: PayrollCreateNestedManyWithoutTenantInput
    academicScheds?: AcademicScheduleCreateNestedManyWithoutTenantInput
    attendances?: AttendanceCreateNestedManyWithoutTenantInput
    grades?: GradeCreateNestedManyWithoutTenantInput
    ppdbRegistrations?: PpdbRegistrationCreateNestedManyWithoutTenantInput
    ppdbDocuments?: PpdbDocumentCreateNestedManyWithoutTenantInput
    inventoryItems?: ItemCreateNestedManyWithoutTenantInput
    inventoryTransactions?: InventoryTransactionCreateNestedManyWithoutTenantInput
    suppliers?: SupplierCreateNestedManyWithoutTenantInput
    purchaseOrders?: PurchaseOrderCreateNestedManyWithoutTenantInput
    buildings?: BuildingCreateNestedManyWithoutTenantInput
    rooms?: RoomCreateNestedManyWithoutTenantInput
    roomAssignments?: RoomAssignmentCreateNestedManyWithoutTenantInput
    maintenanceTickets?: MaintenanceTicketCreateNestedManyWithoutTenantInput
  }

  export type TenantUncheckedCreateWithoutPpdbExamsInput = {
    id?: string
    name: string
    address?: string | null
    phone?: string | null
    adminUserId?: string | null
    timezone?: string
    plan?: string
    billingContact?: string | null
    status?: string
    settings?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutTenantInput
    santri?: SantriUncheckedCreateNestedManyWithoutTenantInput
    wali?: WaliUncheckedCreateNestedManyWithoutTenantInput
    izin?: IzinUncheckedCreateNestedManyWithoutTenantInput
    catatanHarian?: CatatanHarianUncheckedCreateNestedManyWithoutTenantInput
    pengumuman?: PengumumanUncheckedCreateNestedManyWithoutTenantInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutTenantInput
    pelanggaran?: PelanggaranUncheckedCreateNestedManyWithoutTenantInput
    pembinaan?: PembinaanUncheckedCreateNestedManyWithoutTenantInput
    kunjungan?: KunjunganUncheckedCreateNestedManyWithoutTenantInput
    healthRecords?: HealthRecordUncheckedCreateNestedManyWithoutTenantInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutTenantInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutTenantInput
    webhookEvents?: WebhookEventUncheckedCreateNestedManyWithoutTenantInput
    tahfidz?: TahfidzUncheckedCreateNestedManyWithoutTenantInput
    mutabaah?: MutabaahUncheckedCreateNestedManyWithoutTenantInput
    wallets?: WalletUncheckedCreateNestedManyWithoutTenantInput
    employees?: EmployeeUncheckedCreateNestedManyWithoutTenantInput
    payrolls?: PayrollUncheckedCreateNestedManyWithoutTenantInput
    academicScheds?: AcademicScheduleUncheckedCreateNestedManyWithoutTenantInput
    attendances?: AttendanceUncheckedCreateNestedManyWithoutTenantInput
    grades?: GradeUncheckedCreateNestedManyWithoutTenantInput
    ppdbRegistrations?: PpdbRegistrationUncheckedCreateNestedManyWithoutTenantInput
    ppdbDocuments?: PpdbDocumentUncheckedCreateNestedManyWithoutTenantInput
    inventoryItems?: ItemUncheckedCreateNestedManyWithoutTenantInput
    inventoryTransactions?: InventoryTransactionUncheckedCreateNestedManyWithoutTenantInput
    suppliers?: SupplierUncheckedCreateNestedManyWithoutTenantInput
    purchaseOrders?: PurchaseOrderUncheckedCreateNestedManyWithoutTenantInput
    buildings?: BuildingUncheckedCreateNestedManyWithoutTenantInput
    rooms?: RoomUncheckedCreateNestedManyWithoutTenantInput
    roomAssignments?: RoomAssignmentUncheckedCreateNestedManyWithoutTenantInput
    maintenanceTickets?: MaintenanceTicketUncheckedCreateNestedManyWithoutTenantInput
  }

  export type TenantCreateOrConnectWithoutPpdbExamsInput = {
    where: TenantWhereUniqueInput
    create: XOR<TenantCreateWithoutPpdbExamsInput, TenantUncheckedCreateWithoutPpdbExamsInput>
  }

  export type PpdbRegistrationCreateWithoutExamsInput = {
    id?: string
    registrationNumber: string
    fullName: string
    gender: string
    dob?: Date | string | null
    previousSchool?: string | null
    pathway?: string
    status?: string
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutPpdbRegistrationsInput
    documents?: PpdbDocumentCreateNestedManyWithoutRegistrationInput
  }

  export type PpdbRegistrationUncheckedCreateWithoutExamsInput = {
    id?: string
    tenantId: string
    registrationNumber: string
    fullName: string
    gender: string
    dob?: Date | string | null
    previousSchool?: string | null
    pathway?: string
    status?: string
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    documents?: PpdbDocumentUncheckedCreateNestedManyWithoutRegistrationInput
  }

  export type PpdbRegistrationCreateOrConnectWithoutExamsInput = {
    where: PpdbRegistrationWhereUniqueInput
    create: XOR<PpdbRegistrationCreateWithoutExamsInput, PpdbRegistrationUncheckedCreateWithoutExamsInput>
  }

  export type TenantUpsertWithoutPpdbExamsInput = {
    update: XOR<TenantUpdateWithoutPpdbExamsInput, TenantUncheckedUpdateWithoutPpdbExamsInput>
    create: XOR<TenantCreateWithoutPpdbExamsInput, TenantUncheckedCreateWithoutPpdbExamsInput>
    where?: TenantWhereInput
  }

  export type TenantUpdateToOneWithWhereWithoutPpdbExamsInput = {
    where?: TenantWhereInput
    data: XOR<TenantUpdateWithoutPpdbExamsInput, TenantUncheckedUpdateWithoutPpdbExamsInput>
  }

  export type TenantUpdateWithoutPpdbExamsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    adminUserId?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    plan?: StringFieldUpdateOperationsInput | string
    billingContact?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    settings?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutTenantNestedInput
    santri?: SantriUpdateManyWithoutTenantNestedInput
    wali?: WaliUpdateManyWithoutTenantNestedInput
    izin?: IzinUpdateManyWithoutTenantNestedInput
    catatanHarian?: CatatanHarianUpdateManyWithoutTenantNestedInput
    pengumuman?: PengumumanUpdateManyWithoutTenantNestedInput
    invoices?: InvoiceUpdateManyWithoutTenantNestedInput
    pelanggaran?: PelanggaranUpdateManyWithoutTenantNestedInput
    pembinaan?: PembinaanUpdateManyWithoutTenantNestedInput
    kunjungan?: KunjunganUpdateManyWithoutTenantNestedInput
    healthRecords?: HealthRecordUpdateManyWithoutTenantNestedInput
    auditLogs?: AuditLogUpdateManyWithoutTenantNestedInput
    notifications?: NotificationUpdateManyWithoutTenantNestedInput
    webhookEvents?: WebhookEventUpdateManyWithoutTenantNestedInput
    tahfidz?: TahfidzUpdateManyWithoutTenantNestedInput
    mutabaah?: MutabaahUpdateManyWithoutTenantNestedInput
    wallets?: WalletUpdateManyWithoutTenantNestedInput
    employees?: EmployeeUpdateManyWithoutTenantNestedInput
    payrolls?: PayrollUpdateManyWithoutTenantNestedInput
    academicScheds?: AcademicScheduleUpdateManyWithoutTenantNestedInput
    attendances?: AttendanceUpdateManyWithoutTenantNestedInput
    grades?: GradeUpdateManyWithoutTenantNestedInput
    ppdbRegistrations?: PpdbRegistrationUpdateManyWithoutTenantNestedInput
    ppdbDocuments?: PpdbDocumentUpdateManyWithoutTenantNestedInput
    inventoryItems?: ItemUpdateManyWithoutTenantNestedInput
    inventoryTransactions?: InventoryTransactionUpdateManyWithoutTenantNestedInput
    suppliers?: SupplierUpdateManyWithoutTenantNestedInput
    purchaseOrders?: PurchaseOrderUpdateManyWithoutTenantNestedInput
    buildings?: BuildingUpdateManyWithoutTenantNestedInput
    rooms?: RoomUpdateManyWithoutTenantNestedInput
    roomAssignments?: RoomAssignmentUpdateManyWithoutTenantNestedInput
    maintenanceTickets?: MaintenanceTicketUpdateManyWithoutTenantNestedInput
  }

  export type TenantUncheckedUpdateWithoutPpdbExamsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    adminUserId?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    plan?: StringFieldUpdateOperationsInput | string
    billingContact?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    settings?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutTenantNestedInput
    santri?: SantriUncheckedUpdateManyWithoutTenantNestedInput
    wali?: WaliUncheckedUpdateManyWithoutTenantNestedInput
    izin?: IzinUncheckedUpdateManyWithoutTenantNestedInput
    catatanHarian?: CatatanHarianUncheckedUpdateManyWithoutTenantNestedInput
    pengumuman?: PengumumanUncheckedUpdateManyWithoutTenantNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutTenantNestedInput
    pelanggaran?: PelanggaranUncheckedUpdateManyWithoutTenantNestedInput
    pembinaan?: PembinaanUncheckedUpdateManyWithoutTenantNestedInput
    kunjungan?: KunjunganUncheckedUpdateManyWithoutTenantNestedInput
    healthRecords?: HealthRecordUncheckedUpdateManyWithoutTenantNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutTenantNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutTenantNestedInput
    webhookEvents?: WebhookEventUncheckedUpdateManyWithoutTenantNestedInput
    tahfidz?: TahfidzUncheckedUpdateManyWithoutTenantNestedInput
    mutabaah?: MutabaahUncheckedUpdateManyWithoutTenantNestedInput
    wallets?: WalletUncheckedUpdateManyWithoutTenantNestedInput
    employees?: EmployeeUncheckedUpdateManyWithoutTenantNestedInput
    payrolls?: PayrollUncheckedUpdateManyWithoutTenantNestedInput
    academicScheds?: AcademicScheduleUncheckedUpdateManyWithoutTenantNestedInput
    attendances?: AttendanceUncheckedUpdateManyWithoutTenantNestedInput
    grades?: GradeUncheckedUpdateManyWithoutTenantNestedInput
    ppdbRegistrations?: PpdbRegistrationUncheckedUpdateManyWithoutTenantNestedInput
    ppdbDocuments?: PpdbDocumentUncheckedUpdateManyWithoutTenantNestedInput
    inventoryItems?: ItemUncheckedUpdateManyWithoutTenantNestedInput
    inventoryTransactions?: InventoryTransactionUncheckedUpdateManyWithoutTenantNestedInput
    suppliers?: SupplierUncheckedUpdateManyWithoutTenantNestedInput
    purchaseOrders?: PurchaseOrderUncheckedUpdateManyWithoutTenantNestedInput
    buildings?: BuildingUncheckedUpdateManyWithoutTenantNestedInput
    rooms?: RoomUncheckedUpdateManyWithoutTenantNestedInput
    roomAssignments?: RoomAssignmentUncheckedUpdateManyWithoutTenantNestedInput
    maintenanceTickets?: MaintenanceTicketUncheckedUpdateManyWithoutTenantNestedInput
  }

  export type PpdbRegistrationUpsertWithoutExamsInput = {
    update: XOR<PpdbRegistrationUpdateWithoutExamsInput, PpdbRegistrationUncheckedUpdateWithoutExamsInput>
    create: XOR<PpdbRegistrationCreateWithoutExamsInput, PpdbRegistrationUncheckedCreateWithoutExamsInput>
    where?: PpdbRegistrationWhereInput
  }

  export type PpdbRegistrationUpdateToOneWithWhereWithoutExamsInput = {
    where?: PpdbRegistrationWhereInput
    data: XOR<PpdbRegistrationUpdateWithoutExamsInput, PpdbRegistrationUncheckedUpdateWithoutExamsInput>
  }

  export type PpdbRegistrationUpdateWithoutExamsInput = {
    id?: StringFieldUpdateOperationsInput | string
    registrationNumber?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    gender?: StringFieldUpdateOperationsInput | string
    dob?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    previousSchool?: NullableStringFieldUpdateOperationsInput | string | null
    pathway?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutPpdbRegistrationsNestedInput
    documents?: PpdbDocumentUpdateManyWithoutRegistrationNestedInput
  }

  export type PpdbRegistrationUncheckedUpdateWithoutExamsInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    registrationNumber?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    gender?: StringFieldUpdateOperationsInput | string
    dob?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    previousSchool?: NullableStringFieldUpdateOperationsInput | string | null
    pathway?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    documents?: PpdbDocumentUncheckedUpdateManyWithoutRegistrationNestedInput
  }

  export type TenantCreateWithoutInventoryItemsInput = {
    id?: string
    name: string
    address?: string | null
    phone?: string | null
    adminUserId?: string | null
    timezone?: string
    plan?: string
    billingContact?: string | null
    status?: string
    settings?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutTenantInput
    santri?: SantriCreateNestedManyWithoutTenantInput
    wali?: WaliCreateNestedManyWithoutTenantInput
    izin?: IzinCreateNestedManyWithoutTenantInput
    catatanHarian?: CatatanHarianCreateNestedManyWithoutTenantInput
    pengumuman?: PengumumanCreateNestedManyWithoutTenantInput
    invoices?: InvoiceCreateNestedManyWithoutTenantInput
    pelanggaran?: PelanggaranCreateNestedManyWithoutTenantInput
    pembinaan?: PembinaanCreateNestedManyWithoutTenantInput
    kunjungan?: KunjunganCreateNestedManyWithoutTenantInput
    healthRecords?: HealthRecordCreateNestedManyWithoutTenantInput
    auditLogs?: AuditLogCreateNestedManyWithoutTenantInput
    notifications?: NotificationCreateNestedManyWithoutTenantInput
    webhookEvents?: WebhookEventCreateNestedManyWithoutTenantInput
    tahfidz?: TahfidzCreateNestedManyWithoutTenantInput
    mutabaah?: MutabaahCreateNestedManyWithoutTenantInput
    wallets?: WalletCreateNestedManyWithoutTenantInput
    employees?: EmployeeCreateNestedManyWithoutTenantInput
    payrolls?: PayrollCreateNestedManyWithoutTenantInput
    academicScheds?: AcademicScheduleCreateNestedManyWithoutTenantInput
    attendances?: AttendanceCreateNestedManyWithoutTenantInput
    grades?: GradeCreateNestedManyWithoutTenantInput
    ppdbRegistrations?: PpdbRegistrationCreateNestedManyWithoutTenantInput
    ppdbDocuments?: PpdbDocumentCreateNestedManyWithoutTenantInput
    ppdbExams?: PpdbExamCreateNestedManyWithoutTenantInput
    inventoryTransactions?: InventoryTransactionCreateNestedManyWithoutTenantInput
    suppliers?: SupplierCreateNestedManyWithoutTenantInput
    purchaseOrders?: PurchaseOrderCreateNestedManyWithoutTenantInput
    buildings?: BuildingCreateNestedManyWithoutTenantInput
    rooms?: RoomCreateNestedManyWithoutTenantInput
    roomAssignments?: RoomAssignmentCreateNestedManyWithoutTenantInput
    maintenanceTickets?: MaintenanceTicketCreateNestedManyWithoutTenantInput
  }

  export type TenantUncheckedCreateWithoutInventoryItemsInput = {
    id?: string
    name: string
    address?: string | null
    phone?: string | null
    adminUserId?: string | null
    timezone?: string
    plan?: string
    billingContact?: string | null
    status?: string
    settings?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutTenantInput
    santri?: SantriUncheckedCreateNestedManyWithoutTenantInput
    wali?: WaliUncheckedCreateNestedManyWithoutTenantInput
    izin?: IzinUncheckedCreateNestedManyWithoutTenantInput
    catatanHarian?: CatatanHarianUncheckedCreateNestedManyWithoutTenantInput
    pengumuman?: PengumumanUncheckedCreateNestedManyWithoutTenantInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutTenantInput
    pelanggaran?: PelanggaranUncheckedCreateNestedManyWithoutTenantInput
    pembinaan?: PembinaanUncheckedCreateNestedManyWithoutTenantInput
    kunjungan?: KunjunganUncheckedCreateNestedManyWithoutTenantInput
    healthRecords?: HealthRecordUncheckedCreateNestedManyWithoutTenantInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutTenantInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutTenantInput
    webhookEvents?: WebhookEventUncheckedCreateNestedManyWithoutTenantInput
    tahfidz?: TahfidzUncheckedCreateNestedManyWithoutTenantInput
    mutabaah?: MutabaahUncheckedCreateNestedManyWithoutTenantInput
    wallets?: WalletUncheckedCreateNestedManyWithoutTenantInput
    employees?: EmployeeUncheckedCreateNestedManyWithoutTenantInput
    payrolls?: PayrollUncheckedCreateNestedManyWithoutTenantInput
    academicScheds?: AcademicScheduleUncheckedCreateNestedManyWithoutTenantInput
    attendances?: AttendanceUncheckedCreateNestedManyWithoutTenantInput
    grades?: GradeUncheckedCreateNestedManyWithoutTenantInput
    ppdbRegistrations?: PpdbRegistrationUncheckedCreateNestedManyWithoutTenantInput
    ppdbDocuments?: PpdbDocumentUncheckedCreateNestedManyWithoutTenantInput
    ppdbExams?: PpdbExamUncheckedCreateNestedManyWithoutTenantInput
    inventoryTransactions?: InventoryTransactionUncheckedCreateNestedManyWithoutTenantInput
    suppliers?: SupplierUncheckedCreateNestedManyWithoutTenantInput
    purchaseOrders?: PurchaseOrderUncheckedCreateNestedManyWithoutTenantInput
    buildings?: BuildingUncheckedCreateNestedManyWithoutTenantInput
    rooms?: RoomUncheckedCreateNestedManyWithoutTenantInput
    roomAssignments?: RoomAssignmentUncheckedCreateNestedManyWithoutTenantInput
    maintenanceTickets?: MaintenanceTicketUncheckedCreateNestedManyWithoutTenantInput
  }

  export type TenantCreateOrConnectWithoutInventoryItemsInput = {
    where: TenantWhereUniqueInput
    create: XOR<TenantCreateWithoutInventoryItemsInput, TenantUncheckedCreateWithoutInventoryItemsInput>
  }

  export type InventoryTransactionCreateWithoutItemInput = {
    id?: string
    type: string
    quantity: number
    reference?: string | null
    notes?: string | null
    handledBy?: string | null
    date?: Date | string
    tenant: TenantCreateNestedOneWithoutInventoryTransactionsInput
  }

  export type InventoryTransactionUncheckedCreateWithoutItemInput = {
    id?: string
    tenantId: string
    type: string
    quantity: number
    reference?: string | null
    notes?: string | null
    handledBy?: string | null
    date?: Date | string
  }

  export type InventoryTransactionCreateOrConnectWithoutItemInput = {
    where: InventoryTransactionWhereUniqueInput
    create: XOR<InventoryTransactionCreateWithoutItemInput, InventoryTransactionUncheckedCreateWithoutItemInput>
  }

  export type InventoryTransactionCreateManyItemInputEnvelope = {
    data: InventoryTransactionCreateManyItemInput | InventoryTransactionCreateManyItemInput[]
  }

  export type TenantUpsertWithoutInventoryItemsInput = {
    update: XOR<TenantUpdateWithoutInventoryItemsInput, TenantUncheckedUpdateWithoutInventoryItemsInput>
    create: XOR<TenantCreateWithoutInventoryItemsInput, TenantUncheckedCreateWithoutInventoryItemsInput>
    where?: TenantWhereInput
  }

  export type TenantUpdateToOneWithWhereWithoutInventoryItemsInput = {
    where?: TenantWhereInput
    data: XOR<TenantUpdateWithoutInventoryItemsInput, TenantUncheckedUpdateWithoutInventoryItemsInput>
  }

  export type TenantUpdateWithoutInventoryItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    adminUserId?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    plan?: StringFieldUpdateOperationsInput | string
    billingContact?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    settings?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutTenantNestedInput
    santri?: SantriUpdateManyWithoutTenantNestedInput
    wali?: WaliUpdateManyWithoutTenantNestedInput
    izin?: IzinUpdateManyWithoutTenantNestedInput
    catatanHarian?: CatatanHarianUpdateManyWithoutTenantNestedInput
    pengumuman?: PengumumanUpdateManyWithoutTenantNestedInput
    invoices?: InvoiceUpdateManyWithoutTenantNestedInput
    pelanggaran?: PelanggaranUpdateManyWithoutTenantNestedInput
    pembinaan?: PembinaanUpdateManyWithoutTenantNestedInput
    kunjungan?: KunjunganUpdateManyWithoutTenantNestedInput
    healthRecords?: HealthRecordUpdateManyWithoutTenantNestedInput
    auditLogs?: AuditLogUpdateManyWithoutTenantNestedInput
    notifications?: NotificationUpdateManyWithoutTenantNestedInput
    webhookEvents?: WebhookEventUpdateManyWithoutTenantNestedInput
    tahfidz?: TahfidzUpdateManyWithoutTenantNestedInput
    mutabaah?: MutabaahUpdateManyWithoutTenantNestedInput
    wallets?: WalletUpdateManyWithoutTenantNestedInput
    employees?: EmployeeUpdateManyWithoutTenantNestedInput
    payrolls?: PayrollUpdateManyWithoutTenantNestedInput
    academicScheds?: AcademicScheduleUpdateManyWithoutTenantNestedInput
    attendances?: AttendanceUpdateManyWithoutTenantNestedInput
    grades?: GradeUpdateManyWithoutTenantNestedInput
    ppdbRegistrations?: PpdbRegistrationUpdateManyWithoutTenantNestedInput
    ppdbDocuments?: PpdbDocumentUpdateManyWithoutTenantNestedInput
    ppdbExams?: PpdbExamUpdateManyWithoutTenantNestedInput
    inventoryTransactions?: InventoryTransactionUpdateManyWithoutTenantNestedInput
    suppliers?: SupplierUpdateManyWithoutTenantNestedInput
    purchaseOrders?: PurchaseOrderUpdateManyWithoutTenantNestedInput
    buildings?: BuildingUpdateManyWithoutTenantNestedInput
    rooms?: RoomUpdateManyWithoutTenantNestedInput
    roomAssignments?: RoomAssignmentUpdateManyWithoutTenantNestedInput
    maintenanceTickets?: MaintenanceTicketUpdateManyWithoutTenantNestedInput
  }

  export type TenantUncheckedUpdateWithoutInventoryItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    adminUserId?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    plan?: StringFieldUpdateOperationsInput | string
    billingContact?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    settings?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutTenantNestedInput
    santri?: SantriUncheckedUpdateManyWithoutTenantNestedInput
    wali?: WaliUncheckedUpdateManyWithoutTenantNestedInput
    izin?: IzinUncheckedUpdateManyWithoutTenantNestedInput
    catatanHarian?: CatatanHarianUncheckedUpdateManyWithoutTenantNestedInput
    pengumuman?: PengumumanUncheckedUpdateManyWithoutTenantNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutTenantNestedInput
    pelanggaran?: PelanggaranUncheckedUpdateManyWithoutTenantNestedInput
    pembinaan?: PembinaanUncheckedUpdateManyWithoutTenantNestedInput
    kunjungan?: KunjunganUncheckedUpdateManyWithoutTenantNestedInput
    healthRecords?: HealthRecordUncheckedUpdateManyWithoutTenantNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutTenantNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutTenantNestedInput
    webhookEvents?: WebhookEventUncheckedUpdateManyWithoutTenantNestedInput
    tahfidz?: TahfidzUncheckedUpdateManyWithoutTenantNestedInput
    mutabaah?: MutabaahUncheckedUpdateManyWithoutTenantNestedInput
    wallets?: WalletUncheckedUpdateManyWithoutTenantNestedInput
    employees?: EmployeeUncheckedUpdateManyWithoutTenantNestedInput
    payrolls?: PayrollUncheckedUpdateManyWithoutTenantNestedInput
    academicScheds?: AcademicScheduleUncheckedUpdateManyWithoutTenantNestedInput
    attendances?: AttendanceUncheckedUpdateManyWithoutTenantNestedInput
    grades?: GradeUncheckedUpdateManyWithoutTenantNestedInput
    ppdbRegistrations?: PpdbRegistrationUncheckedUpdateManyWithoutTenantNestedInput
    ppdbDocuments?: PpdbDocumentUncheckedUpdateManyWithoutTenantNestedInput
    ppdbExams?: PpdbExamUncheckedUpdateManyWithoutTenantNestedInput
    inventoryTransactions?: InventoryTransactionUncheckedUpdateManyWithoutTenantNestedInput
    suppliers?: SupplierUncheckedUpdateManyWithoutTenantNestedInput
    purchaseOrders?: PurchaseOrderUncheckedUpdateManyWithoutTenantNestedInput
    buildings?: BuildingUncheckedUpdateManyWithoutTenantNestedInput
    rooms?: RoomUncheckedUpdateManyWithoutTenantNestedInput
    roomAssignments?: RoomAssignmentUncheckedUpdateManyWithoutTenantNestedInput
    maintenanceTickets?: MaintenanceTicketUncheckedUpdateManyWithoutTenantNestedInput
  }

  export type InventoryTransactionUpsertWithWhereUniqueWithoutItemInput = {
    where: InventoryTransactionWhereUniqueInput
    update: XOR<InventoryTransactionUpdateWithoutItemInput, InventoryTransactionUncheckedUpdateWithoutItemInput>
    create: XOR<InventoryTransactionCreateWithoutItemInput, InventoryTransactionUncheckedCreateWithoutItemInput>
  }

  export type InventoryTransactionUpdateWithWhereUniqueWithoutItemInput = {
    where: InventoryTransactionWhereUniqueInput
    data: XOR<InventoryTransactionUpdateWithoutItemInput, InventoryTransactionUncheckedUpdateWithoutItemInput>
  }

  export type InventoryTransactionUpdateManyWithWhereWithoutItemInput = {
    where: InventoryTransactionScalarWhereInput
    data: XOR<InventoryTransactionUpdateManyMutationInput, InventoryTransactionUncheckedUpdateManyWithoutItemInput>
  }

  export type TenantCreateWithoutInventoryTransactionsInput = {
    id?: string
    name: string
    address?: string | null
    phone?: string | null
    adminUserId?: string | null
    timezone?: string
    plan?: string
    billingContact?: string | null
    status?: string
    settings?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutTenantInput
    santri?: SantriCreateNestedManyWithoutTenantInput
    wali?: WaliCreateNestedManyWithoutTenantInput
    izin?: IzinCreateNestedManyWithoutTenantInput
    catatanHarian?: CatatanHarianCreateNestedManyWithoutTenantInput
    pengumuman?: PengumumanCreateNestedManyWithoutTenantInput
    invoices?: InvoiceCreateNestedManyWithoutTenantInput
    pelanggaran?: PelanggaranCreateNestedManyWithoutTenantInput
    pembinaan?: PembinaanCreateNestedManyWithoutTenantInput
    kunjungan?: KunjunganCreateNestedManyWithoutTenantInput
    healthRecords?: HealthRecordCreateNestedManyWithoutTenantInput
    auditLogs?: AuditLogCreateNestedManyWithoutTenantInput
    notifications?: NotificationCreateNestedManyWithoutTenantInput
    webhookEvents?: WebhookEventCreateNestedManyWithoutTenantInput
    tahfidz?: TahfidzCreateNestedManyWithoutTenantInput
    mutabaah?: MutabaahCreateNestedManyWithoutTenantInput
    wallets?: WalletCreateNestedManyWithoutTenantInput
    employees?: EmployeeCreateNestedManyWithoutTenantInput
    payrolls?: PayrollCreateNestedManyWithoutTenantInput
    academicScheds?: AcademicScheduleCreateNestedManyWithoutTenantInput
    attendances?: AttendanceCreateNestedManyWithoutTenantInput
    grades?: GradeCreateNestedManyWithoutTenantInput
    ppdbRegistrations?: PpdbRegistrationCreateNestedManyWithoutTenantInput
    ppdbDocuments?: PpdbDocumentCreateNestedManyWithoutTenantInput
    ppdbExams?: PpdbExamCreateNestedManyWithoutTenantInput
    inventoryItems?: ItemCreateNestedManyWithoutTenantInput
    suppliers?: SupplierCreateNestedManyWithoutTenantInput
    purchaseOrders?: PurchaseOrderCreateNestedManyWithoutTenantInput
    buildings?: BuildingCreateNestedManyWithoutTenantInput
    rooms?: RoomCreateNestedManyWithoutTenantInput
    roomAssignments?: RoomAssignmentCreateNestedManyWithoutTenantInput
    maintenanceTickets?: MaintenanceTicketCreateNestedManyWithoutTenantInput
  }

  export type TenantUncheckedCreateWithoutInventoryTransactionsInput = {
    id?: string
    name: string
    address?: string | null
    phone?: string | null
    adminUserId?: string | null
    timezone?: string
    plan?: string
    billingContact?: string | null
    status?: string
    settings?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutTenantInput
    santri?: SantriUncheckedCreateNestedManyWithoutTenantInput
    wali?: WaliUncheckedCreateNestedManyWithoutTenantInput
    izin?: IzinUncheckedCreateNestedManyWithoutTenantInput
    catatanHarian?: CatatanHarianUncheckedCreateNestedManyWithoutTenantInput
    pengumuman?: PengumumanUncheckedCreateNestedManyWithoutTenantInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutTenantInput
    pelanggaran?: PelanggaranUncheckedCreateNestedManyWithoutTenantInput
    pembinaan?: PembinaanUncheckedCreateNestedManyWithoutTenantInput
    kunjungan?: KunjunganUncheckedCreateNestedManyWithoutTenantInput
    healthRecords?: HealthRecordUncheckedCreateNestedManyWithoutTenantInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutTenantInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutTenantInput
    webhookEvents?: WebhookEventUncheckedCreateNestedManyWithoutTenantInput
    tahfidz?: TahfidzUncheckedCreateNestedManyWithoutTenantInput
    mutabaah?: MutabaahUncheckedCreateNestedManyWithoutTenantInput
    wallets?: WalletUncheckedCreateNestedManyWithoutTenantInput
    employees?: EmployeeUncheckedCreateNestedManyWithoutTenantInput
    payrolls?: PayrollUncheckedCreateNestedManyWithoutTenantInput
    academicScheds?: AcademicScheduleUncheckedCreateNestedManyWithoutTenantInput
    attendances?: AttendanceUncheckedCreateNestedManyWithoutTenantInput
    grades?: GradeUncheckedCreateNestedManyWithoutTenantInput
    ppdbRegistrations?: PpdbRegistrationUncheckedCreateNestedManyWithoutTenantInput
    ppdbDocuments?: PpdbDocumentUncheckedCreateNestedManyWithoutTenantInput
    ppdbExams?: PpdbExamUncheckedCreateNestedManyWithoutTenantInput
    inventoryItems?: ItemUncheckedCreateNestedManyWithoutTenantInput
    suppliers?: SupplierUncheckedCreateNestedManyWithoutTenantInput
    purchaseOrders?: PurchaseOrderUncheckedCreateNestedManyWithoutTenantInput
    buildings?: BuildingUncheckedCreateNestedManyWithoutTenantInput
    rooms?: RoomUncheckedCreateNestedManyWithoutTenantInput
    roomAssignments?: RoomAssignmentUncheckedCreateNestedManyWithoutTenantInput
    maintenanceTickets?: MaintenanceTicketUncheckedCreateNestedManyWithoutTenantInput
  }

  export type TenantCreateOrConnectWithoutInventoryTransactionsInput = {
    where: TenantWhereUniqueInput
    create: XOR<TenantCreateWithoutInventoryTransactionsInput, TenantUncheckedCreateWithoutInventoryTransactionsInput>
  }

  export type ItemCreateWithoutTransactionsInput = {
    id?: string
    sku: string
    name: string
    description?: string | null
    category: string
    price: number
    costPrice?: number | null
    stock?: number
    minStock?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutInventoryItemsInput
  }

  export type ItemUncheckedCreateWithoutTransactionsInput = {
    id?: string
    tenantId: string
    sku: string
    name: string
    description?: string | null
    category: string
    price: number
    costPrice?: number | null
    stock?: number
    minStock?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ItemCreateOrConnectWithoutTransactionsInput = {
    where: ItemWhereUniqueInput
    create: XOR<ItemCreateWithoutTransactionsInput, ItemUncheckedCreateWithoutTransactionsInput>
  }

  export type TenantUpsertWithoutInventoryTransactionsInput = {
    update: XOR<TenantUpdateWithoutInventoryTransactionsInput, TenantUncheckedUpdateWithoutInventoryTransactionsInput>
    create: XOR<TenantCreateWithoutInventoryTransactionsInput, TenantUncheckedCreateWithoutInventoryTransactionsInput>
    where?: TenantWhereInput
  }

  export type TenantUpdateToOneWithWhereWithoutInventoryTransactionsInput = {
    where?: TenantWhereInput
    data: XOR<TenantUpdateWithoutInventoryTransactionsInput, TenantUncheckedUpdateWithoutInventoryTransactionsInput>
  }

  export type TenantUpdateWithoutInventoryTransactionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    adminUserId?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    plan?: StringFieldUpdateOperationsInput | string
    billingContact?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    settings?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutTenantNestedInput
    santri?: SantriUpdateManyWithoutTenantNestedInput
    wali?: WaliUpdateManyWithoutTenantNestedInput
    izin?: IzinUpdateManyWithoutTenantNestedInput
    catatanHarian?: CatatanHarianUpdateManyWithoutTenantNestedInput
    pengumuman?: PengumumanUpdateManyWithoutTenantNestedInput
    invoices?: InvoiceUpdateManyWithoutTenantNestedInput
    pelanggaran?: PelanggaranUpdateManyWithoutTenantNestedInput
    pembinaan?: PembinaanUpdateManyWithoutTenantNestedInput
    kunjungan?: KunjunganUpdateManyWithoutTenantNestedInput
    healthRecords?: HealthRecordUpdateManyWithoutTenantNestedInput
    auditLogs?: AuditLogUpdateManyWithoutTenantNestedInput
    notifications?: NotificationUpdateManyWithoutTenantNestedInput
    webhookEvents?: WebhookEventUpdateManyWithoutTenantNestedInput
    tahfidz?: TahfidzUpdateManyWithoutTenantNestedInput
    mutabaah?: MutabaahUpdateManyWithoutTenantNestedInput
    wallets?: WalletUpdateManyWithoutTenantNestedInput
    employees?: EmployeeUpdateManyWithoutTenantNestedInput
    payrolls?: PayrollUpdateManyWithoutTenantNestedInput
    academicScheds?: AcademicScheduleUpdateManyWithoutTenantNestedInput
    attendances?: AttendanceUpdateManyWithoutTenantNestedInput
    grades?: GradeUpdateManyWithoutTenantNestedInput
    ppdbRegistrations?: PpdbRegistrationUpdateManyWithoutTenantNestedInput
    ppdbDocuments?: PpdbDocumentUpdateManyWithoutTenantNestedInput
    ppdbExams?: PpdbExamUpdateManyWithoutTenantNestedInput
    inventoryItems?: ItemUpdateManyWithoutTenantNestedInput
    suppliers?: SupplierUpdateManyWithoutTenantNestedInput
    purchaseOrders?: PurchaseOrderUpdateManyWithoutTenantNestedInput
    buildings?: BuildingUpdateManyWithoutTenantNestedInput
    rooms?: RoomUpdateManyWithoutTenantNestedInput
    roomAssignments?: RoomAssignmentUpdateManyWithoutTenantNestedInput
    maintenanceTickets?: MaintenanceTicketUpdateManyWithoutTenantNestedInput
  }

  export type TenantUncheckedUpdateWithoutInventoryTransactionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    adminUserId?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    plan?: StringFieldUpdateOperationsInput | string
    billingContact?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    settings?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutTenantNestedInput
    santri?: SantriUncheckedUpdateManyWithoutTenantNestedInput
    wali?: WaliUncheckedUpdateManyWithoutTenantNestedInput
    izin?: IzinUncheckedUpdateManyWithoutTenantNestedInput
    catatanHarian?: CatatanHarianUncheckedUpdateManyWithoutTenantNestedInput
    pengumuman?: PengumumanUncheckedUpdateManyWithoutTenantNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutTenantNestedInput
    pelanggaran?: PelanggaranUncheckedUpdateManyWithoutTenantNestedInput
    pembinaan?: PembinaanUncheckedUpdateManyWithoutTenantNestedInput
    kunjungan?: KunjunganUncheckedUpdateManyWithoutTenantNestedInput
    healthRecords?: HealthRecordUncheckedUpdateManyWithoutTenantNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutTenantNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutTenantNestedInput
    webhookEvents?: WebhookEventUncheckedUpdateManyWithoutTenantNestedInput
    tahfidz?: TahfidzUncheckedUpdateManyWithoutTenantNestedInput
    mutabaah?: MutabaahUncheckedUpdateManyWithoutTenantNestedInput
    wallets?: WalletUncheckedUpdateManyWithoutTenantNestedInput
    employees?: EmployeeUncheckedUpdateManyWithoutTenantNestedInput
    payrolls?: PayrollUncheckedUpdateManyWithoutTenantNestedInput
    academicScheds?: AcademicScheduleUncheckedUpdateManyWithoutTenantNestedInput
    attendances?: AttendanceUncheckedUpdateManyWithoutTenantNestedInput
    grades?: GradeUncheckedUpdateManyWithoutTenantNestedInput
    ppdbRegistrations?: PpdbRegistrationUncheckedUpdateManyWithoutTenantNestedInput
    ppdbDocuments?: PpdbDocumentUncheckedUpdateManyWithoutTenantNestedInput
    ppdbExams?: PpdbExamUncheckedUpdateManyWithoutTenantNestedInput
    inventoryItems?: ItemUncheckedUpdateManyWithoutTenantNestedInput
    suppliers?: SupplierUncheckedUpdateManyWithoutTenantNestedInput
    purchaseOrders?: PurchaseOrderUncheckedUpdateManyWithoutTenantNestedInput
    buildings?: BuildingUncheckedUpdateManyWithoutTenantNestedInput
    rooms?: RoomUncheckedUpdateManyWithoutTenantNestedInput
    roomAssignments?: RoomAssignmentUncheckedUpdateManyWithoutTenantNestedInput
    maintenanceTickets?: MaintenanceTicketUncheckedUpdateManyWithoutTenantNestedInput
  }

  export type ItemUpsertWithoutTransactionsInput = {
    update: XOR<ItemUpdateWithoutTransactionsInput, ItemUncheckedUpdateWithoutTransactionsInput>
    create: XOR<ItemCreateWithoutTransactionsInput, ItemUncheckedCreateWithoutTransactionsInput>
    where?: ItemWhereInput
  }

  export type ItemUpdateToOneWithWhereWithoutTransactionsInput = {
    where?: ItemWhereInput
    data: XOR<ItemUpdateWithoutTransactionsInput, ItemUncheckedUpdateWithoutTransactionsInput>
  }

  export type ItemUpdateWithoutTransactionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    costPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    stock?: IntFieldUpdateOperationsInput | number
    minStock?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutInventoryItemsNestedInput
  }

  export type ItemUncheckedUpdateWithoutTransactionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    costPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    stock?: IntFieldUpdateOperationsInput | number
    minStock?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TenantCreateWithoutSuppliersInput = {
    id?: string
    name: string
    address?: string | null
    phone?: string | null
    adminUserId?: string | null
    timezone?: string
    plan?: string
    billingContact?: string | null
    status?: string
    settings?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutTenantInput
    santri?: SantriCreateNestedManyWithoutTenantInput
    wali?: WaliCreateNestedManyWithoutTenantInput
    izin?: IzinCreateNestedManyWithoutTenantInput
    catatanHarian?: CatatanHarianCreateNestedManyWithoutTenantInput
    pengumuman?: PengumumanCreateNestedManyWithoutTenantInput
    invoices?: InvoiceCreateNestedManyWithoutTenantInput
    pelanggaran?: PelanggaranCreateNestedManyWithoutTenantInput
    pembinaan?: PembinaanCreateNestedManyWithoutTenantInput
    kunjungan?: KunjunganCreateNestedManyWithoutTenantInput
    healthRecords?: HealthRecordCreateNestedManyWithoutTenantInput
    auditLogs?: AuditLogCreateNestedManyWithoutTenantInput
    notifications?: NotificationCreateNestedManyWithoutTenantInput
    webhookEvents?: WebhookEventCreateNestedManyWithoutTenantInput
    tahfidz?: TahfidzCreateNestedManyWithoutTenantInput
    mutabaah?: MutabaahCreateNestedManyWithoutTenantInput
    wallets?: WalletCreateNestedManyWithoutTenantInput
    employees?: EmployeeCreateNestedManyWithoutTenantInput
    payrolls?: PayrollCreateNestedManyWithoutTenantInput
    academicScheds?: AcademicScheduleCreateNestedManyWithoutTenantInput
    attendances?: AttendanceCreateNestedManyWithoutTenantInput
    grades?: GradeCreateNestedManyWithoutTenantInput
    ppdbRegistrations?: PpdbRegistrationCreateNestedManyWithoutTenantInput
    ppdbDocuments?: PpdbDocumentCreateNestedManyWithoutTenantInput
    ppdbExams?: PpdbExamCreateNestedManyWithoutTenantInput
    inventoryItems?: ItemCreateNestedManyWithoutTenantInput
    inventoryTransactions?: InventoryTransactionCreateNestedManyWithoutTenantInput
    purchaseOrders?: PurchaseOrderCreateNestedManyWithoutTenantInput
    buildings?: BuildingCreateNestedManyWithoutTenantInput
    rooms?: RoomCreateNestedManyWithoutTenantInput
    roomAssignments?: RoomAssignmentCreateNestedManyWithoutTenantInput
    maintenanceTickets?: MaintenanceTicketCreateNestedManyWithoutTenantInput
  }

  export type TenantUncheckedCreateWithoutSuppliersInput = {
    id?: string
    name: string
    address?: string | null
    phone?: string | null
    adminUserId?: string | null
    timezone?: string
    plan?: string
    billingContact?: string | null
    status?: string
    settings?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutTenantInput
    santri?: SantriUncheckedCreateNestedManyWithoutTenantInput
    wali?: WaliUncheckedCreateNestedManyWithoutTenantInput
    izin?: IzinUncheckedCreateNestedManyWithoutTenantInput
    catatanHarian?: CatatanHarianUncheckedCreateNestedManyWithoutTenantInput
    pengumuman?: PengumumanUncheckedCreateNestedManyWithoutTenantInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutTenantInput
    pelanggaran?: PelanggaranUncheckedCreateNestedManyWithoutTenantInput
    pembinaan?: PembinaanUncheckedCreateNestedManyWithoutTenantInput
    kunjungan?: KunjunganUncheckedCreateNestedManyWithoutTenantInput
    healthRecords?: HealthRecordUncheckedCreateNestedManyWithoutTenantInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutTenantInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutTenantInput
    webhookEvents?: WebhookEventUncheckedCreateNestedManyWithoutTenantInput
    tahfidz?: TahfidzUncheckedCreateNestedManyWithoutTenantInput
    mutabaah?: MutabaahUncheckedCreateNestedManyWithoutTenantInput
    wallets?: WalletUncheckedCreateNestedManyWithoutTenantInput
    employees?: EmployeeUncheckedCreateNestedManyWithoutTenantInput
    payrolls?: PayrollUncheckedCreateNestedManyWithoutTenantInput
    academicScheds?: AcademicScheduleUncheckedCreateNestedManyWithoutTenantInput
    attendances?: AttendanceUncheckedCreateNestedManyWithoutTenantInput
    grades?: GradeUncheckedCreateNestedManyWithoutTenantInput
    ppdbRegistrations?: PpdbRegistrationUncheckedCreateNestedManyWithoutTenantInput
    ppdbDocuments?: PpdbDocumentUncheckedCreateNestedManyWithoutTenantInput
    ppdbExams?: PpdbExamUncheckedCreateNestedManyWithoutTenantInput
    inventoryItems?: ItemUncheckedCreateNestedManyWithoutTenantInput
    inventoryTransactions?: InventoryTransactionUncheckedCreateNestedManyWithoutTenantInput
    purchaseOrders?: PurchaseOrderUncheckedCreateNestedManyWithoutTenantInput
    buildings?: BuildingUncheckedCreateNestedManyWithoutTenantInput
    rooms?: RoomUncheckedCreateNestedManyWithoutTenantInput
    roomAssignments?: RoomAssignmentUncheckedCreateNestedManyWithoutTenantInput
    maintenanceTickets?: MaintenanceTicketUncheckedCreateNestedManyWithoutTenantInput
  }

  export type TenantCreateOrConnectWithoutSuppliersInput = {
    where: TenantWhereUniqueInput
    create: XOR<TenantCreateWithoutSuppliersInput, TenantUncheckedCreateWithoutSuppliersInput>
  }

  export type PurchaseOrderCreateWithoutSupplierInput = {
    id?: string
    poNumber: string
    totalCost: number
    status?: string
    orderDate?: Date | string
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutPurchaseOrdersInput
  }

  export type PurchaseOrderUncheckedCreateWithoutSupplierInput = {
    id?: string
    tenantId: string
    poNumber: string
    totalCost: number
    status?: string
    orderDate?: Date | string
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PurchaseOrderCreateOrConnectWithoutSupplierInput = {
    where: PurchaseOrderWhereUniqueInput
    create: XOR<PurchaseOrderCreateWithoutSupplierInput, PurchaseOrderUncheckedCreateWithoutSupplierInput>
  }

  export type PurchaseOrderCreateManySupplierInputEnvelope = {
    data: PurchaseOrderCreateManySupplierInput | PurchaseOrderCreateManySupplierInput[]
  }

  export type TenantUpsertWithoutSuppliersInput = {
    update: XOR<TenantUpdateWithoutSuppliersInput, TenantUncheckedUpdateWithoutSuppliersInput>
    create: XOR<TenantCreateWithoutSuppliersInput, TenantUncheckedCreateWithoutSuppliersInput>
    where?: TenantWhereInput
  }

  export type TenantUpdateToOneWithWhereWithoutSuppliersInput = {
    where?: TenantWhereInput
    data: XOR<TenantUpdateWithoutSuppliersInput, TenantUncheckedUpdateWithoutSuppliersInput>
  }

  export type TenantUpdateWithoutSuppliersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    adminUserId?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    plan?: StringFieldUpdateOperationsInput | string
    billingContact?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    settings?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutTenantNestedInput
    santri?: SantriUpdateManyWithoutTenantNestedInput
    wali?: WaliUpdateManyWithoutTenantNestedInput
    izin?: IzinUpdateManyWithoutTenantNestedInput
    catatanHarian?: CatatanHarianUpdateManyWithoutTenantNestedInput
    pengumuman?: PengumumanUpdateManyWithoutTenantNestedInput
    invoices?: InvoiceUpdateManyWithoutTenantNestedInput
    pelanggaran?: PelanggaranUpdateManyWithoutTenantNestedInput
    pembinaan?: PembinaanUpdateManyWithoutTenantNestedInput
    kunjungan?: KunjunganUpdateManyWithoutTenantNestedInput
    healthRecords?: HealthRecordUpdateManyWithoutTenantNestedInput
    auditLogs?: AuditLogUpdateManyWithoutTenantNestedInput
    notifications?: NotificationUpdateManyWithoutTenantNestedInput
    webhookEvents?: WebhookEventUpdateManyWithoutTenantNestedInput
    tahfidz?: TahfidzUpdateManyWithoutTenantNestedInput
    mutabaah?: MutabaahUpdateManyWithoutTenantNestedInput
    wallets?: WalletUpdateManyWithoutTenantNestedInput
    employees?: EmployeeUpdateManyWithoutTenantNestedInput
    payrolls?: PayrollUpdateManyWithoutTenantNestedInput
    academicScheds?: AcademicScheduleUpdateManyWithoutTenantNestedInput
    attendances?: AttendanceUpdateManyWithoutTenantNestedInput
    grades?: GradeUpdateManyWithoutTenantNestedInput
    ppdbRegistrations?: PpdbRegistrationUpdateManyWithoutTenantNestedInput
    ppdbDocuments?: PpdbDocumentUpdateManyWithoutTenantNestedInput
    ppdbExams?: PpdbExamUpdateManyWithoutTenantNestedInput
    inventoryItems?: ItemUpdateManyWithoutTenantNestedInput
    inventoryTransactions?: InventoryTransactionUpdateManyWithoutTenantNestedInput
    purchaseOrders?: PurchaseOrderUpdateManyWithoutTenantNestedInput
    buildings?: BuildingUpdateManyWithoutTenantNestedInput
    rooms?: RoomUpdateManyWithoutTenantNestedInput
    roomAssignments?: RoomAssignmentUpdateManyWithoutTenantNestedInput
    maintenanceTickets?: MaintenanceTicketUpdateManyWithoutTenantNestedInput
  }

  export type TenantUncheckedUpdateWithoutSuppliersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    adminUserId?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    plan?: StringFieldUpdateOperationsInput | string
    billingContact?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    settings?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutTenantNestedInput
    santri?: SantriUncheckedUpdateManyWithoutTenantNestedInput
    wali?: WaliUncheckedUpdateManyWithoutTenantNestedInput
    izin?: IzinUncheckedUpdateManyWithoutTenantNestedInput
    catatanHarian?: CatatanHarianUncheckedUpdateManyWithoutTenantNestedInput
    pengumuman?: PengumumanUncheckedUpdateManyWithoutTenantNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutTenantNestedInput
    pelanggaran?: PelanggaranUncheckedUpdateManyWithoutTenantNestedInput
    pembinaan?: PembinaanUncheckedUpdateManyWithoutTenantNestedInput
    kunjungan?: KunjunganUncheckedUpdateManyWithoutTenantNestedInput
    healthRecords?: HealthRecordUncheckedUpdateManyWithoutTenantNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutTenantNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutTenantNestedInput
    webhookEvents?: WebhookEventUncheckedUpdateManyWithoutTenantNestedInput
    tahfidz?: TahfidzUncheckedUpdateManyWithoutTenantNestedInput
    mutabaah?: MutabaahUncheckedUpdateManyWithoutTenantNestedInput
    wallets?: WalletUncheckedUpdateManyWithoutTenantNestedInput
    employees?: EmployeeUncheckedUpdateManyWithoutTenantNestedInput
    payrolls?: PayrollUncheckedUpdateManyWithoutTenantNestedInput
    academicScheds?: AcademicScheduleUncheckedUpdateManyWithoutTenantNestedInput
    attendances?: AttendanceUncheckedUpdateManyWithoutTenantNestedInput
    grades?: GradeUncheckedUpdateManyWithoutTenantNestedInput
    ppdbRegistrations?: PpdbRegistrationUncheckedUpdateManyWithoutTenantNestedInput
    ppdbDocuments?: PpdbDocumentUncheckedUpdateManyWithoutTenantNestedInput
    ppdbExams?: PpdbExamUncheckedUpdateManyWithoutTenantNestedInput
    inventoryItems?: ItemUncheckedUpdateManyWithoutTenantNestedInput
    inventoryTransactions?: InventoryTransactionUncheckedUpdateManyWithoutTenantNestedInput
    purchaseOrders?: PurchaseOrderUncheckedUpdateManyWithoutTenantNestedInput
    buildings?: BuildingUncheckedUpdateManyWithoutTenantNestedInput
    rooms?: RoomUncheckedUpdateManyWithoutTenantNestedInput
    roomAssignments?: RoomAssignmentUncheckedUpdateManyWithoutTenantNestedInput
    maintenanceTickets?: MaintenanceTicketUncheckedUpdateManyWithoutTenantNestedInput
  }

  export type PurchaseOrderUpsertWithWhereUniqueWithoutSupplierInput = {
    where: PurchaseOrderWhereUniqueInput
    update: XOR<PurchaseOrderUpdateWithoutSupplierInput, PurchaseOrderUncheckedUpdateWithoutSupplierInput>
    create: XOR<PurchaseOrderCreateWithoutSupplierInput, PurchaseOrderUncheckedCreateWithoutSupplierInput>
  }

  export type PurchaseOrderUpdateWithWhereUniqueWithoutSupplierInput = {
    where: PurchaseOrderWhereUniqueInput
    data: XOR<PurchaseOrderUpdateWithoutSupplierInput, PurchaseOrderUncheckedUpdateWithoutSupplierInput>
  }

  export type PurchaseOrderUpdateManyWithWhereWithoutSupplierInput = {
    where: PurchaseOrderScalarWhereInput
    data: XOR<PurchaseOrderUpdateManyMutationInput, PurchaseOrderUncheckedUpdateManyWithoutSupplierInput>
  }

  export type TenantCreateWithoutPurchaseOrdersInput = {
    id?: string
    name: string
    address?: string | null
    phone?: string | null
    adminUserId?: string | null
    timezone?: string
    plan?: string
    billingContact?: string | null
    status?: string
    settings?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutTenantInput
    santri?: SantriCreateNestedManyWithoutTenantInput
    wali?: WaliCreateNestedManyWithoutTenantInput
    izin?: IzinCreateNestedManyWithoutTenantInput
    catatanHarian?: CatatanHarianCreateNestedManyWithoutTenantInput
    pengumuman?: PengumumanCreateNestedManyWithoutTenantInput
    invoices?: InvoiceCreateNestedManyWithoutTenantInput
    pelanggaran?: PelanggaranCreateNestedManyWithoutTenantInput
    pembinaan?: PembinaanCreateNestedManyWithoutTenantInput
    kunjungan?: KunjunganCreateNestedManyWithoutTenantInput
    healthRecords?: HealthRecordCreateNestedManyWithoutTenantInput
    auditLogs?: AuditLogCreateNestedManyWithoutTenantInput
    notifications?: NotificationCreateNestedManyWithoutTenantInput
    webhookEvents?: WebhookEventCreateNestedManyWithoutTenantInput
    tahfidz?: TahfidzCreateNestedManyWithoutTenantInput
    mutabaah?: MutabaahCreateNestedManyWithoutTenantInput
    wallets?: WalletCreateNestedManyWithoutTenantInput
    employees?: EmployeeCreateNestedManyWithoutTenantInput
    payrolls?: PayrollCreateNestedManyWithoutTenantInput
    academicScheds?: AcademicScheduleCreateNestedManyWithoutTenantInput
    attendances?: AttendanceCreateNestedManyWithoutTenantInput
    grades?: GradeCreateNestedManyWithoutTenantInput
    ppdbRegistrations?: PpdbRegistrationCreateNestedManyWithoutTenantInput
    ppdbDocuments?: PpdbDocumentCreateNestedManyWithoutTenantInput
    ppdbExams?: PpdbExamCreateNestedManyWithoutTenantInput
    inventoryItems?: ItemCreateNestedManyWithoutTenantInput
    inventoryTransactions?: InventoryTransactionCreateNestedManyWithoutTenantInput
    suppliers?: SupplierCreateNestedManyWithoutTenantInput
    buildings?: BuildingCreateNestedManyWithoutTenantInput
    rooms?: RoomCreateNestedManyWithoutTenantInput
    roomAssignments?: RoomAssignmentCreateNestedManyWithoutTenantInput
    maintenanceTickets?: MaintenanceTicketCreateNestedManyWithoutTenantInput
  }

  export type TenantUncheckedCreateWithoutPurchaseOrdersInput = {
    id?: string
    name: string
    address?: string | null
    phone?: string | null
    adminUserId?: string | null
    timezone?: string
    plan?: string
    billingContact?: string | null
    status?: string
    settings?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutTenantInput
    santri?: SantriUncheckedCreateNestedManyWithoutTenantInput
    wali?: WaliUncheckedCreateNestedManyWithoutTenantInput
    izin?: IzinUncheckedCreateNestedManyWithoutTenantInput
    catatanHarian?: CatatanHarianUncheckedCreateNestedManyWithoutTenantInput
    pengumuman?: PengumumanUncheckedCreateNestedManyWithoutTenantInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutTenantInput
    pelanggaran?: PelanggaranUncheckedCreateNestedManyWithoutTenantInput
    pembinaan?: PembinaanUncheckedCreateNestedManyWithoutTenantInput
    kunjungan?: KunjunganUncheckedCreateNestedManyWithoutTenantInput
    healthRecords?: HealthRecordUncheckedCreateNestedManyWithoutTenantInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutTenantInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutTenantInput
    webhookEvents?: WebhookEventUncheckedCreateNestedManyWithoutTenantInput
    tahfidz?: TahfidzUncheckedCreateNestedManyWithoutTenantInput
    mutabaah?: MutabaahUncheckedCreateNestedManyWithoutTenantInput
    wallets?: WalletUncheckedCreateNestedManyWithoutTenantInput
    employees?: EmployeeUncheckedCreateNestedManyWithoutTenantInput
    payrolls?: PayrollUncheckedCreateNestedManyWithoutTenantInput
    academicScheds?: AcademicScheduleUncheckedCreateNestedManyWithoutTenantInput
    attendances?: AttendanceUncheckedCreateNestedManyWithoutTenantInput
    grades?: GradeUncheckedCreateNestedManyWithoutTenantInput
    ppdbRegistrations?: PpdbRegistrationUncheckedCreateNestedManyWithoutTenantInput
    ppdbDocuments?: PpdbDocumentUncheckedCreateNestedManyWithoutTenantInput
    ppdbExams?: PpdbExamUncheckedCreateNestedManyWithoutTenantInput
    inventoryItems?: ItemUncheckedCreateNestedManyWithoutTenantInput
    inventoryTransactions?: InventoryTransactionUncheckedCreateNestedManyWithoutTenantInput
    suppliers?: SupplierUncheckedCreateNestedManyWithoutTenantInput
    buildings?: BuildingUncheckedCreateNestedManyWithoutTenantInput
    rooms?: RoomUncheckedCreateNestedManyWithoutTenantInput
    roomAssignments?: RoomAssignmentUncheckedCreateNestedManyWithoutTenantInput
    maintenanceTickets?: MaintenanceTicketUncheckedCreateNestedManyWithoutTenantInput
  }

  export type TenantCreateOrConnectWithoutPurchaseOrdersInput = {
    where: TenantWhereUniqueInput
    create: XOR<TenantCreateWithoutPurchaseOrdersInput, TenantUncheckedCreateWithoutPurchaseOrdersInput>
  }

  export type SupplierCreateWithoutPurchaseOrdersInput = {
    id?: string
    name: string
    contact?: string | null
    address?: string | null
    email?: string | null
    createdAt?: Date | string
    tenant: TenantCreateNestedOneWithoutSuppliersInput
  }

  export type SupplierUncheckedCreateWithoutPurchaseOrdersInput = {
    id?: string
    tenantId: string
    name: string
    contact?: string | null
    address?: string | null
    email?: string | null
    createdAt?: Date | string
  }

  export type SupplierCreateOrConnectWithoutPurchaseOrdersInput = {
    where: SupplierWhereUniqueInput
    create: XOR<SupplierCreateWithoutPurchaseOrdersInput, SupplierUncheckedCreateWithoutPurchaseOrdersInput>
  }

  export type TenantUpsertWithoutPurchaseOrdersInput = {
    update: XOR<TenantUpdateWithoutPurchaseOrdersInput, TenantUncheckedUpdateWithoutPurchaseOrdersInput>
    create: XOR<TenantCreateWithoutPurchaseOrdersInput, TenantUncheckedCreateWithoutPurchaseOrdersInput>
    where?: TenantWhereInput
  }

  export type TenantUpdateToOneWithWhereWithoutPurchaseOrdersInput = {
    where?: TenantWhereInput
    data: XOR<TenantUpdateWithoutPurchaseOrdersInput, TenantUncheckedUpdateWithoutPurchaseOrdersInput>
  }

  export type TenantUpdateWithoutPurchaseOrdersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    adminUserId?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    plan?: StringFieldUpdateOperationsInput | string
    billingContact?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    settings?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutTenantNestedInput
    santri?: SantriUpdateManyWithoutTenantNestedInput
    wali?: WaliUpdateManyWithoutTenantNestedInput
    izin?: IzinUpdateManyWithoutTenantNestedInput
    catatanHarian?: CatatanHarianUpdateManyWithoutTenantNestedInput
    pengumuman?: PengumumanUpdateManyWithoutTenantNestedInput
    invoices?: InvoiceUpdateManyWithoutTenantNestedInput
    pelanggaran?: PelanggaranUpdateManyWithoutTenantNestedInput
    pembinaan?: PembinaanUpdateManyWithoutTenantNestedInput
    kunjungan?: KunjunganUpdateManyWithoutTenantNestedInput
    healthRecords?: HealthRecordUpdateManyWithoutTenantNestedInput
    auditLogs?: AuditLogUpdateManyWithoutTenantNestedInput
    notifications?: NotificationUpdateManyWithoutTenantNestedInput
    webhookEvents?: WebhookEventUpdateManyWithoutTenantNestedInput
    tahfidz?: TahfidzUpdateManyWithoutTenantNestedInput
    mutabaah?: MutabaahUpdateManyWithoutTenantNestedInput
    wallets?: WalletUpdateManyWithoutTenantNestedInput
    employees?: EmployeeUpdateManyWithoutTenantNestedInput
    payrolls?: PayrollUpdateManyWithoutTenantNestedInput
    academicScheds?: AcademicScheduleUpdateManyWithoutTenantNestedInput
    attendances?: AttendanceUpdateManyWithoutTenantNestedInput
    grades?: GradeUpdateManyWithoutTenantNestedInput
    ppdbRegistrations?: PpdbRegistrationUpdateManyWithoutTenantNestedInput
    ppdbDocuments?: PpdbDocumentUpdateManyWithoutTenantNestedInput
    ppdbExams?: PpdbExamUpdateManyWithoutTenantNestedInput
    inventoryItems?: ItemUpdateManyWithoutTenantNestedInput
    inventoryTransactions?: InventoryTransactionUpdateManyWithoutTenantNestedInput
    suppliers?: SupplierUpdateManyWithoutTenantNestedInput
    buildings?: BuildingUpdateManyWithoutTenantNestedInput
    rooms?: RoomUpdateManyWithoutTenantNestedInput
    roomAssignments?: RoomAssignmentUpdateManyWithoutTenantNestedInput
    maintenanceTickets?: MaintenanceTicketUpdateManyWithoutTenantNestedInput
  }

  export type TenantUncheckedUpdateWithoutPurchaseOrdersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    adminUserId?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    plan?: StringFieldUpdateOperationsInput | string
    billingContact?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    settings?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutTenantNestedInput
    santri?: SantriUncheckedUpdateManyWithoutTenantNestedInput
    wali?: WaliUncheckedUpdateManyWithoutTenantNestedInput
    izin?: IzinUncheckedUpdateManyWithoutTenantNestedInput
    catatanHarian?: CatatanHarianUncheckedUpdateManyWithoutTenantNestedInput
    pengumuman?: PengumumanUncheckedUpdateManyWithoutTenantNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutTenantNestedInput
    pelanggaran?: PelanggaranUncheckedUpdateManyWithoutTenantNestedInput
    pembinaan?: PembinaanUncheckedUpdateManyWithoutTenantNestedInput
    kunjungan?: KunjunganUncheckedUpdateManyWithoutTenantNestedInput
    healthRecords?: HealthRecordUncheckedUpdateManyWithoutTenantNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutTenantNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutTenantNestedInput
    webhookEvents?: WebhookEventUncheckedUpdateManyWithoutTenantNestedInput
    tahfidz?: TahfidzUncheckedUpdateManyWithoutTenantNestedInput
    mutabaah?: MutabaahUncheckedUpdateManyWithoutTenantNestedInput
    wallets?: WalletUncheckedUpdateManyWithoutTenantNestedInput
    employees?: EmployeeUncheckedUpdateManyWithoutTenantNestedInput
    payrolls?: PayrollUncheckedUpdateManyWithoutTenantNestedInput
    academicScheds?: AcademicScheduleUncheckedUpdateManyWithoutTenantNestedInput
    attendances?: AttendanceUncheckedUpdateManyWithoutTenantNestedInput
    grades?: GradeUncheckedUpdateManyWithoutTenantNestedInput
    ppdbRegistrations?: PpdbRegistrationUncheckedUpdateManyWithoutTenantNestedInput
    ppdbDocuments?: PpdbDocumentUncheckedUpdateManyWithoutTenantNestedInput
    ppdbExams?: PpdbExamUncheckedUpdateManyWithoutTenantNestedInput
    inventoryItems?: ItemUncheckedUpdateManyWithoutTenantNestedInput
    inventoryTransactions?: InventoryTransactionUncheckedUpdateManyWithoutTenantNestedInput
    suppliers?: SupplierUncheckedUpdateManyWithoutTenantNestedInput
    buildings?: BuildingUncheckedUpdateManyWithoutTenantNestedInput
    rooms?: RoomUncheckedUpdateManyWithoutTenantNestedInput
    roomAssignments?: RoomAssignmentUncheckedUpdateManyWithoutTenantNestedInput
    maintenanceTickets?: MaintenanceTicketUncheckedUpdateManyWithoutTenantNestedInput
  }

  export type SupplierUpsertWithoutPurchaseOrdersInput = {
    update: XOR<SupplierUpdateWithoutPurchaseOrdersInput, SupplierUncheckedUpdateWithoutPurchaseOrdersInput>
    create: XOR<SupplierCreateWithoutPurchaseOrdersInput, SupplierUncheckedCreateWithoutPurchaseOrdersInput>
    where?: SupplierWhereInput
  }

  export type SupplierUpdateToOneWithWhereWithoutPurchaseOrdersInput = {
    where?: SupplierWhereInput
    data: XOR<SupplierUpdateWithoutPurchaseOrdersInput, SupplierUncheckedUpdateWithoutPurchaseOrdersInput>
  }

  export type SupplierUpdateWithoutPurchaseOrdersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    contact?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutSuppliersNestedInput
  }

  export type SupplierUncheckedUpdateWithoutPurchaseOrdersInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    contact?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TenantCreateWithoutBuildingsInput = {
    id?: string
    name: string
    address?: string | null
    phone?: string | null
    adminUserId?: string | null
    timezone?: string
    plan?: string
    billingContact?: string | null
    status?: string
    settings?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutTenantInput
    santri?: SantriCreateNestedManyWithoutTenantInput
    wali?: WaliCreateNestedManyWithoutTenantInput
    izin?: IzinCreateNestedManyWithoutTenantInput
    catatanHarian?: CatatanHarianCreateNestedManyWithoutTenantInput
    pengumuman?: PengumumanCreateNestedManyWithoutTenantInput
    invoices?: InvoiceCreateNestedManyWithoutTenantInput
    pelanggaran?: PelanggaranCreateNestedManyWithoutTenantInput
    pembinaan?: PembinaanCreateNestedManyWithoutTenantInput
    kunjungan?: KunjunganCreateNestedManyWithoutTenantInput
    healthRecords?: HealthRecordCreateNestedManyWithoutTenantInput
    auditLogs?: AuditLogCreateNestedManyWithoutTenantInput
    notifications?: NotificationCreateNestedManyWithoutTenantInput
    webhookEvents?: WebhookEventCreateNestedManyWithoutTenantInput
    tahfidz?: TahfidzCreateNestedManyWithoutTenantInput
    mutabaah?: MutabaahCreateNestedManyWithoutTenantInput
    wallets?: WalletCreateNestedManyWithoutTenantInput
    employees?: EmployeeCreateNestedManyWithoutTenantInput
    payrolls?: PayrollCreateNestedManyWithoutTenantInput
    academicScheds?: AcademicScheduleCreateNestedManyWithoutTenantInput
    attendances?: AttendanceCreateNestedManyWithoutTenantInput
    grades?: GradeCreateNestedManyWithoutTenantInput
    ppdbRegistrations?: PpdbRegistrationCreateNestedManyWithoutTenantInput
    ppdbDocuments?: PpdbDocumentCreateNestedManyWithoutTenantInput
    ppdbExams?: PpdbExamCreateNestedManyWithoutTenantInput
    inventoryItems?: ItemCreateNestedManyWithoutTenantInput
    inventoryTransactions?: InventoryTransactionCreateNestedManyWithoutTenantInput
    suppliers?: SupplierCreateNestedManyWithoutTenantInput
    purchaseOrders?: PurchaseOrderCreateNestedManyWithoutTenantInput
    rooms?: RoomCreateNestedManyWithoutTenantInput
    roomAssignments?: RoomAssignmentCreateNestedManyWithoutTenantInput
    maintenanceTickets?: MaintenanceTicketCreateNestedManyWithoutTenantInput
  }

  export type TenantUncheckedCreateWithoutBuildingsInput = {
    id?: string
    name: string
    address?: string | null
    phone?: string | null
    adminUserId?: string | null
    timezone?: string
    plan?: string
    billingContact?: string | null
    status?: string
    settings?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutTenantInput
    santri?: SantriUncheckedCreateNestedManyWithoutTenantInput
    wali?: WaliUncheckedCreateNestedManyWithoutTenantInput
    izin?: IzinUncheckedCreateNestedManyWithoutTenantInput
    catatanHarian?: CatatanHarianUncheckedCreateNestedManyWithoutTenantInput
    pengumuman?: PengumumanUncheckedCreateNestedManyWithoutTenantInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutTenantInput
    pelanggaran?: PelanggaranUncheckedCreateNestedManyWithoutTenantInput
    pembinaan?: PembinaanUncheckedCreateNestedManyWithoutTenantInput
    kunjungan?: KunjunganUncheckedCreateNestedManyWithoutTenantInput
    healthRecords?: HealthRecordUncheckedCreateNestedManyWithoutTenantInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutTenantInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutTenantInput
    webhookEvents?: WebhookEventUncheckedCreateNestedManyWithoutTenantInput
    tahfidz?: TahfidzUncheckedCreateNestedManyWithoutTenantInput
    mutabaah?: MutabaahUncheckedCreateNestedManyWithoutTenantInput
    wallets?: WalletUncheckedCreateNestedManyWithoutTenantInput
    employees?: EmployeeUncheckedCreateNestedManyWithoutTenantInput
    payrolls?: PayrollUncheckedCreateNestedManyWithoutTenantInput
    academicScheds?: AcademicScheduleUncheckedCreateNestedManyWithoutTenantInput
    attendances?: AttendanceUncheckedCreateNestedManyWithoutTenantInput
    grades?: GradeUncheckedCreateNestedManyWithoutTenantInput
    ppdbRegistrations?: PpdbRegistrationUncheckedCreateNestedManyWithoutTenantInput
    ppdbDocuments?: PpdbDocumentUncheckedCreateNestedManyWithoutTenantInput
    ppdbExams?: PpdbExamUncheckedCreateNestedManyWithoutTenantInput
    inventoryItems?: ItemUncheckedCreateNestedManyWithoutTenantInput
    inventoryTransactions?: InventoryTransactionUncheckedCreateNestedManyWithoutTenantInput
    suppliers?: SupplierUncheckedCreateNestedManyWithoutTenantInput
    purchaseOrders?: PurchaseOrderUncheckedCreateNestedManyWithoutTenantInput
    rooms?: RoomUncheckedCreateNestedManyWithoutTenantInput
    roomAssignments?: RoomAssignmentUncheckedCreateNestedManyWithoutTenantInput
    maintenanceTickets?: MaintenanceTicketUncheckedCreateNestedManyWithoutTenantInput
  }

  export type TenantCreateOrConnectWithoutBuildingsInput = {
    where: TenantWhereUniqueInput
    create: XOR<TenantCreateWithoutBuildingsInput, TenantUncheckedCreateWithoutBuildingsInput>
  }

  export type RoomCreateWithoutBuildingInput = {
    id?: string
    name: string
    capacity: number
    picName?: string | null
    createdAt?: Date | string
    tenant: TenantCreateNestedOneWithoutRoomsInput
    assignments?: RoomAssignmentCreateNestedManyWithoutRoomInput
    tickets?: MaintenanceTicketCreateNestedManyWithoutRoomInput
  }

  export type RoomUncheckedCreateWithoutBuildingInput = {
    id?: string
    tenantId: string
    name: string
    capacity: number
    picName?: string | null
    createdAt?: Date | string
    assignments?: RoomAssignmentUncheckedCreateNestedManyWithoutRoomInput
    tickets?: MaintenanceTicketUncheckedCreateNestedManyWithoutRoomInput
  }

  export type RoomCreateOrConnectWithoutBuildingInput = {
    where: RoomWhereUniqueInput
    create: XOR<RoomCreateWithoutBuildingInput, RoomUncheckedCreateWithoutBuildingInput>
  }

  export type RoomCreateManyBuildingInputEnvelope = {
    data: RoomCreateManyBuildingInput | RoomCreateManyBuildingInput[]
  }

  export type TenantUpsertWithoutBuildingsInput = {
    update: XOR<TenantUpdateWithoutBuildingsInput, TenantUncheckedUpdateWithoutBuildingsInput>
    create: XOR<TenantCreateWithoutBuildingsInput, TenantUncheckedCreateWithoutBuildingsInput>
    where?: TenantWhereInput
  }

  export type TenantUpdateToOneWithWhereWithoutBuildingsInput = {
    where?: TenantWhereInput
    data: XOR<TenantUpdateWithoutBuildingsInput, TenantUncheckedUpdateWithoutBuildingsInput>
  }

  export type TenantUpdateWithoutBuildingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    adminUserId?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    plan?: StringFieldUpdateOperationsInput | string
    billingContact?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    settings?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutTenantNestedInput
    santri?: SantriUpdateManyWithoutTenantNestedInput
    wali?: WaliUpdateManyWithoutTenantNestedInput
    izin?: IzinUpdateManyWithoutTenantNestedInput
    catatanHarian?: CatatanHarianUpdateManyWithoutTenantNestedInput
    pengumuman?: PengumumanUpdateManyWithoutTenantNestedInput
    invoices?: InvoiceUpdateManyWithoutTenantNestedInput
    pelanggaran?: PelanggaranUpdateManyWithoutTenantNestedInput
    pembinaan?: PembinaanUpdateManyWithoutTenantNestedInput
    kunjungan?: KunjunganUpdateManyWithoutTenantNestedInput
    healthRecords?: HealthRecordUpdateManyWithoutTenantNestedInput
    auditLogs?: AuditLogUpdateManyWithoutTenantNestedInput
    notifications?: NotificationUpdateManyWithoutTenantNestedInput
    webhookEvents?: WebhookEventUpdateManyWithoutTenantNestedInput
    tahfidz?: TahfidzUpdateManyWithoutTenantNestedInput
    mutabaah?: MutabaahUpdateManyWithoutTenantNestedInput
    wallets?: WalletUpdateManyWithoutTenantNestedInput
    employees?: EmployeeUpdateManyWithoutTenantNestedInput
    payrolls?: PayrollUpdateManyWithoutTenantNestedInput
    academicScheds?: AcademicScheduleUpdateManyWithoutTenantNestedInput
    attendances?: AttendanceUpdateManyWithoutTenantNestedInput
    grades?: GradeUpdateManyWithoutTenantNestedInput
    ppdbRegistrations?: PpdbRegistrationUpdateManyWithoutTenantNestedInput
    ppdbDocuments?: PpdbDocumentUpdateManyWithoutTenantNestedInput
    ppdbExams?: PpdbExamUpdateManyWithoutTenantNestedInput
    inventoryItems?: ItemUpdateManyWithoutTenantNestedInput
    inventoryTransactions?: InventoryTransactionUpdateManyWithoutTenantNestedInput
    suppliers?: SupplierUpdateManyWithoutTenantNestedInput
    purchaseOrders?: PurchaseOrderUpdateManyWithoutTenantNestedInput
    rooms?: RoomUpdateManyWithoutTenantNestedInput
    roomAssignments?: RoomAssignmentUpdateManyWithoutTenantNestedInput
    maintenanceTickets?: MaintenanceTicketUpdateManyWithoutTenantNestedInput
  }

  export type TenantUncheckedUpdateWithoutBuildingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    adminUserId?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    plan?: StringFieldUpdateOperationsInput | string
    billingContact?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    settings?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutTenantNestedInput
    santri?: SantriUncheckedUpdateManyWithoutTenantNestedInput
    wali?: WaliUncheckedUpdateManyWithoutTenantNestedInput
    izin?: IzinUncheckedUpdateManyWithoutTenantNestedInput
    catatanHarian?: CatatanHarianUncheckedUpdateManyWithoutTenantNestedInput
    pengumuman?: PengumumanUncheckedUpdateManyWithoutTenantNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutTenantNestedInput
    pelanggaran?: PelanggaranUncheckedUpdateManyWithoutTenantNestedInput
    pembinaan?: PembinaanUncheckedUpdateManyWithoutTenantNestedInput
    kunjungan?: KunjunganUncheckedUpdateManyWithoutTenantNestedInput
    healthRecords?: HealthRecordUncheckedUpdateManyWithoutTenantNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutTenantNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutTenantNestedInput
    webhookEvents?: WebhookEventUncheckedUpdateManyWithoutTenantNestedInput
    tahfidz?: TahfidzUncheckedUpdateManyWithoutTenantNestedInput
    mutabaah?: MutabaahUncheckedUpdateManyWithoutTenantNestedInput
    wallets?: WalletUncheckedUpdateManyWithoutTenantNestedInput
    employees?: EmployeeUncheckedUpdateManyWithoutTenantNestedInput
    payrolls?: PayrollUncheckedUpdateManyWithoutTenantNestedInput
    academicScheds?: AcademicScheduleUncheckedUpdateManyWithoutTenantNestedInput
    attendances?: AttendanceUncheckedUpdateManyWithoutTenantNestedInput
    grades?: GradeUncheckedUpdateManyWithoutTenantNestedInput
    ppdbRegistrations?: PpdbRegistrationUncheckedUpdateManyWithoutTenantNestedInput
    ppdbDocuments?: PpdbDocumentUncheckedUpdateManyWithoutTenantNestedInput
    ppdbExams?: PpdbExamUncheckedUpdateManyWithoutTenantNestedInput
    inventoryItems?: ItemUncheckedUpdateManyWithoutTenantNestedInput
    inventoryTransactions?: InventoryTransactionUncheckedUpdateManyWithoutTenantNestedInput
    suppliers?: SupplierUncheckedUpdateManyWithoutTenantNestedInput
    purchaseOrders?: PurchaseOrderUncheckedUpdateManyWithoutTenantNestedInput
    rooms?: RoomUncheckedUpdateManyWithoutTenantNestedInput
    roomAssignments?: RoomAssignmentUncheckedUpdateManyWithoutTenantNestedInput
    maintenanceTickets?: MaintenanceTicketUncheckedUpdateManyWithoutTenantNestedInput
  }

  export type RoomUpsertWithWhereUniqueWithoutBuildingInput = {
    where: RoomWhereUniqueInput
    update: XOR<RoomUpdateWithoutBuildingInput, RoomUncheckedUpdateWithoutBuildingInput>
    create: XOR<RoomCreateWithoutBuildingInput, RoomUncheckedCreateWithoutBuildingInput>
  }

  export type RoomUpdateWithWhereUniqueWithoutBuildingInput = {
    where: RoomWhereUniqueInput
    data: XOR<RoomUpdateWithoutBuildingInput, RoomUncheckedUpdateWithoutBuildingInput>
  }

  export type RoomUpdateManyWithWhereWithoutBuildingInput = {
    where: RoomScalarWhereInput
    data: XOR<RoomUpdateManyMutationInput, RoomUncheckedUpdateManyWithoutBuildingInput>
  }

  export type TenantCreateWithoutRoomsInput = {
    id?: string
    name: string
    address?: string | null
    phone?: string | null
    adminUserId?: string | null
    timezone?: string
    plan?: string
    billingContact?: string | null
    status?: string
    settings?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutTenantInput
    santri?: SantriCreateNestedManyWithoutTenantInput
    wali?: WaliCreateNestedManyWithoutTenantInput
    izin?: IzinCreateNestedManyWithoutTenantInput
    catatanHarian?: CatatanHarianCreateNestedManyWithoutTenantInput
    pengumuman?: PengumumanCreateNestedManyWithoutTenantInput
    invoices?: InvoiceCreateNestedManyWithoutTenantInput
    pelanggaran?: PelanggaranCreateNestedManyWithoutTenantInput
    pembinaan?: PembinaanCreateNestedManyWithoutTenantInput
    kunjungan?: KunjunganCreateNestedManyWithoutTenantInput
    healthRecords?: HealthRecordCreateNestedManyWithoutTenantInput
    auditLogs?: AuditLogCreateNestedManyWithoutTenantInput
    notifications?: NotificationCreateNestedManyWithoutTenantInput
    webhookEvents?: WebhookEventCreateNestedManyWithoutTenantInput
    tahfidz?: TahfidzCreateNestedManyWithoutTenantInput
    mutabaah?: MutabaahCreateNestedManyWithoutTenantInput
    wallets?: WalletCreateNestedManyWithoutTenantInput
    employees?: EmployeeCreateNestedManyWithoutTenantInput
    payrolls?: PayrollCreateNestedManyWithoutTenantInput
    academicScheds?: AcademicScheduleCreateNestedManyWithoutTenantInput
    attendances?: AttendanceCreateNestedManyWithoutTenantInput
    grades?: GradeCreateNestedManyWithoutTenantInput
    ppdbRegistrations?: PpdbRegistrationCreateNestedManyWithoutTenantInput
    ppdbDocuments?: PpdbDocumentCreateNestedManyWithoutTenantInput
    ppdbExams?: PpdbExamCreateNestedManyWithoutTenantInput
    inventoryItems?: ItemCreateNestedManyWithoutTenantInput
    inventoryTransactions?: InventoryTransactionCreateNestedManyWithoutTenantInput
    suppliers?: SupplierCreateNestedManyWithoutTenantInput
    purchaseOrders?: PurchaseOrderCreateNestedManyWithoutTenantInput
    buildings?: BuildingCreateNestedManyWithoutTenantInput
    roomAssignments?: RoomAssignmentCreateNestedManyWithoutTenantInput
    maintenanceTickets?: MaintenanceTicketCreateNestedManyWithoutTenantInput
  }

  export type TenantUncheckedCreateWithoutRoomsInput = {
    id?: string
    name: string
    address?: string | null
    phone?: string | null
    adminUserId?: string | null
    timezone?: string
    plan?: string
    billingContact?: string | null
    status?: string
    settings?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutTenantInput
    santri?: SantriUncheckedCreateNestedManyWithoutTenantInput
    wali?: WaliUncheckedCreateNestedManyWithoutTenantInput
    izin?: IzinUncheckedCreateNestedManyWithoutTenantInput
    catatanHarian?: CatatanHarianUncheckedCreateNestedManyWithoutTenantInput
    pengumuman?: PengumumanUncheckedCreateNestedManyWithoutTenantInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutTenantInput
    pelanggaran?: PelanggaranUncheckedCreateNestedManyWithoutTenantInput
    pembinaan?: PembinaanUncheckedCreateNestedManyWithoutTenantInput
    kunjungan?: KunjunganUncheckedCreateNestedManyWithoutTenantInput
    healthRecords?: HealthRecordUncheckedCreateNestedManyWithoutTenantInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutTenantInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutTenantInput
    webhookEvents?: WebhookEventUncheckedCreateNestedManyWithoutTenantInput
    tahfidz?: TahfidzUncheckedCreateNestedManyWithoutTenantInput
    mutabaah?: MutabaahUncheckedCreateNestedManyWithoutTenantInput
    wallets?: WalletUncheckedCreateNestedManyWithoutTenantInput
    employees?: EmployeeUncheckedCreateNestedManyWithoutTenantInput
    payrolls?: PayrollUncheckedCreateNestedManyWithoutTenantInput
    academicScheds?: AcademicScheduleUncheckedCreateNestedManyWithoutTenantInput
    attendances?: AttendanceUncheckedCreateNestedManyWithoutTenantInput
    grades?: GradeUncheckedCreateNestedManyWithoutTenantInput
    ppdbRegistrations?: PpdbRegistrationUncheckedCreateNestedManyWithoutTenantInput
    ppdbDocuments?: PpdbDocumentUncheckedCreateNestedManyWithoutTenantInput
    ppdbExams?: PpdbExamUncheckedCreateNestedManyWithoutTenantInput
    inventoryItems?: ItemUncheckedCreateNestedManyWithoutTenantInput
    inventoryTransactions?: InventoryTransactionUncheckedCreateNestedManyWithoutTenantInput
    suppliers?: SupplierUncheckedCreateNestedManyWithoutTenantInput
    purchaseOrders?: PurchaseOrderUncheckedCreateNestedManyWithoutTenantInput
    buildings?: BuildingUncheckedCreateNestedManyWithoutTenantInput
    roomAssignments?: RoomAssignmentUncheckedCreateNestedManyWithoutTenantInput
    maintenanceTickets?: MaintenanceTicketUncheckedCreateNestedManyWithoutTenantInput
  }

  export type TenantCreateOrConnectWithoutRoomsInput = {
    where: TenantWhereUniqueInput
    create: XOR<TenantCreateWithoutRoomsInput, TenantUncheckedCreateWithoutRoomsInput>
  }

  export type BuildingCreateWithoutRoomsInput = {
    id?: string
    name: string
    description?: string | null
    gender: string
    capacity?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutBuildingsInput
  }

  export type BuildingUncheckedCreateWithoutRoomsInput = {
    id?: string
    tenantId: string
    name: string
    description?: string | null
    gender: string
    capacity?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BuildingCreateOrConnectWithoutRoomsInput = {
    where: BuildingWhereUniqueInput
    create: XOR<BuildingCreateWithoutRoomsInput, BuildingUncheckedCreateWithoutRoomsInput>
  }

  export type RoomAssignmentCreateWithoutRoomInput = {
    id?: string
    santriId: string
    startDate?: Date | string
    endDate?: Date | string | null
    status?: string
    tenant: TenantCreateNestedOneWithoutRoomAssignmentsInput
  }

  export type RoomAssignmentUncheckedCreateWithoutRoomInput = {
    id?: string
    tenantId: string
    santriId: string
    startDate?: Date | string
    endDate?: Date | string | null
    status?: string
  }

  export type RoomAssignmentCreateOrConnectWithoutRoomInput = {
    where: RoomAssignmentWhereUniqueInput
    create: XOR<RoomAssignmentCreateWithoutRoomInput, RoomAssignmentUncheckedCreateWithoutRoomInput>
  }

  export type RoomAssignmentCreateManyRoomInputEnvelope = {
    data: RoomAssignmentCreateManyRoomInput | RoomAssignmentCreateManyRoomInput[]
  }

  export type MaintenanceTicketCreateWithoutRoomInput = {
    id?: string
    title: string
    description: string
    priority?: string
    status?: string
    reportedBy: string
    resolvedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutMaintenanceTicketsInput
  }

  export type MaintenanceTicketUncheckedCreateWithoutRoomInput = {
    id?: string
    tenantId: string
    title: string
    description: string
    priority?: string
    status?: string
    reportedBy: string
    resolvedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MaintenanceTicketCreateOrConnectWithoutRoomInput = {
    where: MaintenanceTicketWhereUniqueInput
    create: XOR<MaintenanceTicketCreateWithoutRoomInput, MaintenanceTicketUncheckedCreateWithoutRoomInput>
  }

  export type MaintenanceTicketCreateManyRoomInputEnvelope = {
    data: MaintenanceTicketCreateManyRoomInput | MaintenanceTicketCreateManyRoomInput[]
  }

  export type TenantUpsertWithoutRoomsInput = {
    update: XOR<TenantUpdateWithoutRoomsInput, TenantUncheckedUpdateWithoutRoomsInput>
    create: XOR<TenantCreateWithoutRoomsInput, TenantUncheckedCreateWithoutRoomsInput>
    where?: TenantWhereInput
  }

  export type TenantUpdateToOneWithWhereWithoutRoomsInput = {
    where?: TenantWhereInput
    data: XOR<TenantUpdateWithoutRoomsInput, TenantUncheckedUpdateWithoutRoomsInput>
  }

  export type TenantUpdateWithoutRoomsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    adminUserId?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    plan?: StringFieldUpdateOperationsInput | string
    billingContact?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    settings?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutTenantNestedInput
    santri?: SantriUpdateManyWithoutTenantNestedInput
    wali?: WaliUpdateManyWithoutTenantNestedInput
    izin?: IzinUpdateManyWithoutTenantNestedInput
    catatanHarian?: CatatanHarianUpdateManyWithoutTenantNestedInput
    pengumuman?: PengumumanUpdateManyWithoutTenantNestedInput
    invoices?: InvoiceUpdateManyWithoutTenantNestedInput
    pelanggaran?: PelanggaranUpdateManyWithoutTenantNestedInput
    pembinaan?: PembinaanUpdateManyWithoutTenantNestedInput
    kunjungan?: KunjunganUpdateManyWithoutTenantNestedInput
    healthRecords?: HealthRecordUpdateManyWithoutTenantNestedInput
    auditLogs?: AuditLogUpdateManyWithoutTenantNestedInput
    notifications?: NotificationUpdateManyWithoutTenantNestedInput
    webhookEvents?: WebhookEventUpdateManyWithoutTenantNestedInput
    tahfidz?: TahfidzUpdateManyWithoutTenantNestedInput
    mutabaah?: MutabaahUpdateManyWithoutTenantNestedInput
    wallets?: WalletUpdateManyWithoutTenantNestedInput
    employees?: EmployeeUpdateManyWithoutTenantNestedInput
    payrolls?: PayrollUpdateManyWithoutTenantNestedInput
    academicScheds?: AcademicScheduleUpdateManyWithoutTenantNestedInput
    attendances?: AttendanceUpdateManyWithoutTenantNestedInput
    grades?: GradeUpdateManyWithoutTenantNestedInput
    ppdbRegistrations?: PpdbRegistrationUpdateManyWithoutTenantNestedInput
    ppdbDocuments?: PpdbDocumentUpdateManyWithoutTenantNestedInput
    ppdbExams?: PpdbExamUpdateManyWithoutTenantNestedInput
    inventoryItems?: ItemUpdateManyWithoutTenantNestedInput
    inventoryTransactions?: InventoryTransactionUpdateManyWithoutTenantNestedInput
    suppliers?: SupplierUpdateManyWithoutTenantNestedInput
    purchaseOrders?: PurchaseOrderUpdateManyWithoutTenantNestedInput
    buildings?: BuildingUpdateManyWithoutTenantNestedInput
    roomAssignments?: RoomAssignmentUpdateManyWithoutTenantNestedInput
    maintenanceTickets?: MaintenanceTicketUpdateManyWithoutTenantNestedInput
  }

  export type TenantUncheckedUpdateWithoutRoomsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    adminUserId?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    plan?: StringFieldUpdateOperationsInput | string
    billingContact?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    settings?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutTenantNestedInput
    santri?: SantriUncheckedUpdateManyWithoutTenantNestedInput
    wali?: WaliUncheckedUpdateManyWithoutTenantNestedInput
    izin?: IzinUncheckedUpdateManyWithoutTenantNestedInput
    catatanHarian?: CatatanHarianUncheckedUpdateManyWithoutTenantNestedInput
    pengumuman?: PengumumanUncheckedUpdateManyWithoutTenantNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutTenantNestedInput
    pelanggaran?: PelanggaranUncheckedUpdateManyWithoutTenantNestedInput
    pembinaan?: PembinaanUncheckedUpdateManyWithoutTenantNestedInput
    kunjungan?: KunjunganUncheckedUpdateManyWithoutTenantNestedInput
    healthRecords?: HealthRecordUncheckedUpdateManyWithoutTenantNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutTenantNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutTenantNestedInput
    webhookEvents?: WebhookEventUncheckedUpdateManyWithoutTenantNestedInput
    tahfidz?: TahfidzUncheckedUpdateManyWithoutTenantNestedInput
    mutabaah?: MutabaahUncheckedUpdateManyWithoutTenantNestedInput
    wallets?: WalletUncheckedUpdateManyWithoutTenantNestedInput
    employees?: EmployeeUncheckedUpdateManyWithoutTenantNestedInput
    payrolls?: PayrollUncheckedUpdateManyWithoutTenantNestedInput
    academicScheds?: AcademicScheduleUncheckedUpdateManyWithoutTenantNestedInput
    attendances?: AttendanceUncheckedUpdateManyWithoutTenantNestedInput
    grades?: GradeUncheckedUpdateManyWithoutTenantNestedInput
    ppdbRegistrations?: PpdbRegistrationUncheckedUpdateManyWithoutTenantNestedInput
    ppdbDocuments?: PpdbDocumentUncheckedUpdateManyWithoutTenantNestedInput
    ppdbExams?: PpdbExamUncheckedUpdateManyWithoutTenantNestedInput
    inventoryItems?: ItemUncheckedUpdateManyWithoutTenantNestedInput
    inventoryTransactions?: InventoryTransactionUncheckedUpdateManyWithoutTenantNestedInput
    suppliers?: SupplierUncheckedUpdateManyWithoutTenantNestedInput
    purchaseOrders?: PurchaseOrderUncheckedUpdateManyWithoutTenantNestedInput
    buildings?: BuildingUncheckedUpdateManyWithoutTenantNestedInput
    roomAssignments?: RoomAssignmentUncheckedUpdateManyWithoutTenantNestedInput
    maintenanceTickets?: MaintenanceTicketUncheckedUpdateManyWithoutTenantNestedInput
  }

  export type BuildingUpsertWithoutRoomsInput = {
    update: XOR<BuildingUpdateWithoutRoomsInput, BuildingUncheckedUpdateWithoutRoomsInput>
    create: XOR<BuildingCreateWithoutRoomsInput, BuildingUncheckedCreateWithoutRoomsInput>
    where?: BuildingWhereInput
  }

  export type BuildingUpdateToOneWithWhereWithoutRoomsInput = {
    where?: BuildingWhereInput
    data: XOR<BuildingUpdateWithoutRoomsInput, BuildingUncheckedUpdateWithoutRoomsInput>
  }

  export type BuildingUpdateWithoutRoomsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: StringFieldUpdateOperationsInput | string
    capacity?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutBuildingsNestedInput
  }

  export type BuildingUncheckedUpdateWithoutRoomsInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: StringFieldUpdateOperationsInput | string
    capacity?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RoomAssignmentUpsertWithWhereUniqueWithoutRoomInput = {
    where: RoomAssignmentWhereUniqueInput
    update: XOR<RoomAssignmentUpdateWithoutRoomInput, RoomAssignmentUncheckedUpdateWithoutRoomInput>
    create: XOR<RoomAssignmentCreateWithoutRoomInput, RoomAssignmentUncheckedCreateWithoutRoomInput>
  }

  export type RoomAssignmentUpdateWithWhereUniqueWithoutRoomInput = {
    where: RoomAssignmentWhereUniqueInput
    data: XOR<RoomAssignmentUpdateWithoutRoomInput, RoomAssignmentUncheckedUpdateWithoutRoomInput>
  }

  export type RoomAssignmentUpdateManyWithWhereWithoutRoomInput = {
    where: RoomAssignmentScalarWhereInput
    data: XOR<RoomAssignmentUpdateManyMutationInput, RoomAssignmentUncheckedUpdateManyWithoutRoomInput>
  }

  export type MaintenanceTicketUpsertWithWhereUniqueWithoutRoomInput = {
    where: MaintenanceTicketWhereUniqueInput
    update: XOR<MaintenanceTicketUpdateWithoutRoomInput, MaintenanceTicketUncheckedUpdateWithoutRoomInput>
    create: XOR<MaintenanceTicketCreateWithoutRoomInput, MaintenanceTicketUncheckedCreateWithoutRoomInput>
  }

  export type MaintenanceTicketUpdateWithWhereUniqueWithoutRoomInput = {
    where: MaintenanceTicketWhereUniqueInput
    data: XOR<MaintenanceTicketUpdateWithoutRoomInput, MaintenanceTicketUncheckedUpdateWithoutRoomInput>
  }

  export type MaintenanceTicketUpdateManyWithWhereWithoutRoomInput = {
    where: MaintenanceTicketScalarWhereInput
    data: XOR<MaintenanceTicketUpdateManyMutationInput, MaintenanceTicketUncheckedUpdateManyWithoutRoomInput>
  }

  export type TenantCreateWithoutRoomAssignmentsInput = {
    id?: string
    name: string
    address?: string | null
    phone?: string | null
    adminUserId?: string | null
    timezone?: string
    plan?: string
    billingContact?: string | null
    status?: string
    settings?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutTenantInput
    santri?: SantriCreateNestedManyWithoutTenantInput
    wali?: WaliCreateNestedManyWithoutTenantInput
    izin?: IzinCreateNestedManyWithoutTenantInput
    catatanHarian?: CatatanHarianCreateNestedManyWithoutTenantInput
    pengumuman?: PengumumanCreateNestedManyWithoutTenantInput
    invoices?: InvoiceCreateNestedManyWithoutTenantInput
    pelanggaran?: PelanggaranCreateNestedManyWithoutTenantInput
    pembinaan?: PembinaanCreateNestedManyWithoutTenantInput
    kunjungan?: KunjunganCreateNestedManyWithoutTenantInput
    healthRecords?: HealthRecordCreateNestedManyWithoutTenantInput
    auditLogs?: AuditLogCreateNestedManyWithoutTenantInput
    notifications?: NotificationCreateNestedManyWithoutTenantInput
    webhookEvents?: WebhookEventCreateNestedManyWithoutTenantInput
    tahfidz?: TahfidzCreateNestedManyWithoutTenantInput
    mutabaah?: MutabaahCreateNestedManyWithoutTenantInput
    wallets?: WalletCreateNestedManyWithoutTenantInput
    employees?: EmployeeCreateNestedManyWithoutTenantInput
    payrolls?: PayrollCreateNestedManyWithoutTenantInput
    academicScheds?: AcademicScheduleCreateNestedManyWithoutTenantInput
    attendances?: AttendanceCreateNestedManyWithoutTenantInput
    grades?: GradeCreateNestedManyWithoutTenantInput
    ppdbRegistrations?: PpdbRegistrationCreateNestedManyWithoutTenantInput
    ppdbDocuments?: PpdbDocumentCreateNestedManyWithoutTenantInput
    ppdbExams?: PpdbExamCreateNestedManyWithoutTenantInput
    inventoryItems?: ItemCreateNestedManyWithoutTenantInput
    inventoryTransactions?: InventoryTransactionCreateNestedManyWithoutTenantInput
    suppliers?: SupplierCreateNestedManyWithoutTenantInput
    purchaseOrders?: PurchaseOrderCreateNestedManyWithoutTenantInput
    buildings?: BuildingCreateNestedManyWithoutTenantInput
    rooms?: RoomCreateNestedManyWithoutTenantInput
    maintenanceTickets?: MaintenanceTicketCreateNestedManyWithoutTenantInput
  }

  export type TenantUncheckedCreateWithoutRoomAssignmentsInput = {
    id?: string
    name: string
    address?: string | null
    phone?: string | null
    adminUserId?: string | null
    timezone?: string
    plan?: string
    billingContact?: string | null
    status?: string
    settings?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutTenantInput
    santri?: SantriUncheckedCreateNestedManyWithoutTenantInput
    wali?: WaliUncheckedCreateNestedManyWithoutTenantInput
    izin?: IzinUncheckedCreateNestedManyWithoutTenantInput
    catatanHarian?: CatatanHarianUncheckedCreateNestedManyWithoutTenantInput
    pengumuman?: PengumumanUncheckedCreateNestedManyWithoutTenantInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutTenantInput
    pelanggaran?: PelanggaranUncheckedCreateNestedManyWithoutTenantInput
    pembinaan?: PembinaanUncheckedCreateNestedManyWithoutTenantInput
    kunjungan?: KunjunganUncheckedCreateNestedManyWithoutTenantInput
    healthRecords?: HealthRecordUncheckedCreateNestedManyWithoutTenantInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutTenantInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutTenantInput
    webhookEvents?: WebhookEventUncheckedCreateNestedManyWithoutTenantInput
    tahfidz?: TahfidzUncheckedCreateNestedManyWithoutTenantInput
    mutabaah?: MutabaahUncheckedCreateNestedManyWithoutTenantInput
    wallets?: WalletUncheckedCreateNestedManyWithoutTenantInput
    employees?: EmployeeUncheckedCreateNestedManyWithoutTenantInput
    payrolls?: PayrollUncheckedCreateNestedManyWithoutTenantInput
    academicScheds?: AcademicScheduleUncheckedCreateNestedManyWithoutTenantInput
    attendances?: AttendanceUncheckedCreateNestedManyWithoutTenantInput
    grades?: GradeUncheckedCreateNestedManyWithoutTenantInput
    ppdbRegistrations?: PpdbRegistrationUncheckedCreateNestedManyWithoutTenantInput
    ppdbDocuments?: PpdbDocumentUncheckedCreateNestedManyWithoutTenantInput
    ppdbExams?: PpdbExamUncheckedCreateNestedManyWithoutTenantInput
    inventoryItems?: ItemUncheckedCreateNestedManyWithoutTenantInput
    inventoryTransactions?: InventoryTransactionUncheckedCreateNestedManyWithoutTenantInput
    suppliers?: SupplierUncheckedCreateNestedManyWithoutTenantInput
    purchaseOrders?: PurchaseOrderUncheckedCreateNestedManyWithoutTenantInput
    buildings?: BuildingUncheckedCreateNestedManyWithoutTenantInput
    rooms?: RoomUncheckedCreateNestedManyWithoutTenantInput
    maintenanceTickets?: MaintenanceTicketUncheckedCreateNestedManyWithoutTenantInput
  }

  export type TenantCreateOrConnectWithoutRoomAssignmentsInput = {
    where: TenantWhereUniqueInput
    create: XOR<TenantCreateWithoutRoomAssignmentsInput, TenantUncheckedCreateWithoutRoomAssignmentsInput>
  }

  export type RoomCreateWithoutAssignmentsInput = {
    id?: string
    name: string
    capacity: number
    picName?: string | null
    createdAt?: Date | string
    tenant: TenantCreateNestedOneWithoutRoomsInput
    building: BuildingCreateNestedOneWithoutRoomsInput
    tickets?: MaintenanceTicketCreateNestedManyWithoutRoomInput
  }

  export type RoomUncheckedCreateWithoutAssignmentsInput = {
    id?: string
    tenantId: string
    buildingId: string
    name: string
    capacity: number
    picName?: string | null
    createdAt?: Date | string
    tickets?: MaintenanceTicketUncheckedCreateNestedManyWithoutRoomInput
  }

  export type RoomCreateOrConnectWithoutAssignmentsInput = {
    where: RoomWhereUniqueInput
    create: XOR<RoomCreateWithoutAssignmentsInput, RoomUncheckedCreateWithoutAssignmentsInput>
  }

  export type TenantUpsertWithoutRoomAssignmentsInput = {
    update: XOR<TenantUpdateWithoutRoomAssignmentsInput, TenantUncheckedUpdateWithoutRoomAssignmentsInput>
    create: XOR<TenantCreateWithoutRoomAssignmentsInput, TenantUncheckedCreateWithoutRoomAssignmentsInput>
    where?: TenantWhereInput
  }

  export type TenantUpdateToOneWithWhereWithoutRoomAssignmentsInput = {
    where?: TenantWhereInput
    data: XOR<TenantUpdateWithoutRoomAssignmentsInput, TenantUncheckedUpdateWithoutRoomAssignmentsInput>
  }

  export type TenantUpdateWithoutRoomAssignmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    adminUserId?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    plan?: StringFieldUpdateOperationsInput | string
    billingContact?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    settings?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutTenantNestedInput
    santri?: SantriUpdateManyWithoutTenantNestedInput
    wali?: WaliUpdateManyWithoutTenantNestedInput
    izin?: IzinUpdateManyWithoutTenantNestedInput
    catatanHarian?: CatatanHarianUpdateManyWithoutTenantNestedInput
    pengumuman?: PengumumanUpdateManyWithoutTenantNestedInput
    invoices?: InvoiceUpdateManyWithoutTenantNestedInput
    pelanggaran?: PelanggaranUpdateManyWithoutTenantNestedInput
    pembinaan?: PembinaanUpdateManyWithoutTenantNestedInput
    kunjungan?: KunjunganUpdateManyWithoutTenantNestedInput
    healthRecords?: HealthRecordUpdateManyWithoutTenantNestedInput
    auditLogs?: AuditLogUpdateManyWithoutTenantNestedInput
    notifications?: NotificationUpdateManyWithoutTenantNestedInput
    webhookEvents?: WebhookEventUpdateManyWithoutTenantNestedInput
    tahfidz?: TahfidzUpdateManyWithoutTenantNestedInput
    mutabaah?: MutabaahUpdateManyWithoutTenantNestedInput
    wallets?: WalletUpdateManyWithoutTenantNestedInput
    employees?: EmployeeUpdateManyWithoutTenantNestedInput
    payrolls?: PayrollUpdateManyWithoutTenantNestedInput
    academicScheds?: AcademicScheduleUpdateManyWithoutTenantNestedInput
    attendances?: AttendanceUpdateManyWithoutTenantNestedInput
    grades?: GradeUpdateManyWithoutTenantNestedInput
    ppdbRegistrations?: PpdbRegistrationUpdateManyWithoutTenantNestedInput
    ppdbDocuments?: PpdbDocumentUpdateManyWithoutTenantNestedInput
    ppdbExams?: PpdbExamUpdateManyWithoutTenantNestedInput
    inventoryItems?: ItemUpdateManyWithoutTenantNestedInput
    inventoryTransactions?: InventoryTransactionUpdateManyWithoutTenantNestedInput
    suppliers?: SupplierUpdateManyWithoutTenantNestedInput
    purchaseOrders?: PurchaseOrderUpdateManyWithoutTenantNestedInput
    buildings?: BuildingUpdateManyWithoutTenantNestedInput
    rooms?: RoomUpdateManyWithoutTenantNestedInput
    maintenanceTickets?: MaintenanceTicketUpdateManyWithoutTenantNestedInput
  }

  export type TenantUncheckedUpdateWithoutRoomAssignmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    adminUserId?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    plan?: StringFieldUpdateOperationsInput | string
    billingContact?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    settings?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutTenantNestedInput
    santri?: SantriUncheckedUpdateManyWithoutTenantNestedInput
    wali?: WaliUncheckedUpdateManyWithoutTenantNestedInput
    izin?: IzinUncheckedUpdateManyWithoutTenantNestedInput
    catatanHarian?: CatatanHarianUncheckedUpdateManyWithoutTenantNestedInput
    pengumuman?: PengumumanUncheckedUpdateManyWithoutTenantNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutTenantNestedInput
    pelanggaran?: PelanggaranUncheckedUpdateManyWithoutTenantNestedInput
    pembinaan?: PembinaanUncheckedUpdateManyWithoutTenantNestedInput
    kunjungan?: KunjunganUncheckedUpdateManyWithoutTenantNestedInput
    healthRecords?: HealthRecordUncheckedUpdateManyWithoutTenantNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutTenantNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutTenantNestedInput
    webhookEvents?: WebhookEventUncheckedUpdateManyWithoutTenantNestedInput
    tahfidz?: TahfidzUncheckedUpdateManyWithoutTenantNestedInput
    mutabaah?: MutabaahUncheckedUpdateManyWithoutTenantNestedInput
    wallets?: WalletUncheckedUpdateManyWithoutTenantNestedInput
    employees?: EmployeeUncheckedUpdateManyWithoutTenantNestedInput
    payrolls?: PayrollUncheckedUpdateManyWithoutTenantNestedInput
    academicScheds?: AcademicScheduleUncheckedUpdateManyWithoutTenantNestedInput
    attendances?: AttendanceUncheckedUpdateManyWithoutTenantNestedInput
    grades?: GradeUncheckedUpdateManyWithoutTenantNestedInput
    ppdbRegistrations?: PpdbRegistrationUncheckedUpdateManyWithoutTenantNestedInput
    ppdbDocuments?: PpdbDocumentUncheckedUpdateManyWithoutTenantNestedInput
    ppdbExams?: PpdbExamUncheckedUpdateManyWithoutTenantNestedInput
    inventoryItems?: ItemUncheckedUpdateManyWithoutTenantNestedInput
    inventoryTransactions?: InventoryTransactionUncheckedUpdateManyWithoutTenantNestedInput
    suppliers?: SupplierUncheckedUpdateManyWithoutTenantNestedInput
    purchaseOrders?: PurchaseOrderUncheckedUpdateManyWithoutTenantNestedInput
    buildings?: BuildingUncheckedUpdateManyWithoutTenantNestedInput
    rooms?: RoomUncheckedUpdateManyWithoutTenantNestedInput
    maintenanceTickets?: MaintenanceTicketUncheckedUpdateManyWithoutTenantNestedInput
  }

  export type RoomUpsertWithoutAssignmentsInput = {
    update: XOR<RoomUpdateWithoutAssignmentsInput, RoomUncheckedUpdateWithoutAssignmentsInput>
    create: XOR<RoomCreateWithoutAssignmentsInput, RoomUncheckedCreateWithoutAssignmentsInput>
    where?: RoomWhereInput
  }

  export type RoomUpdateToOneWithWhereWithoutAssignmentsInput = {
    where?: RoomWhereInput
    data: XOR<RoomUpdateWithoutAssignmentsInput, RoomUncheckedUpdateWithoutAssignmentsInput>
  }

  export type RoomUpdateWithoutAssignmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    capacity?: IntFieldUpdateOperationsInput | number
    picName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutRoomsNestedInput
    building?: BuildingUpdateOneRequiredWithoutRoomsNestedInput
    tickets?: MaintenanceTicketUpdateManyWithoutRoomNestedInput
  }

  export type RoomUncheckedUpdateWithoutAssignmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    buildingId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    capacity?: IntFieldUpdateOperationsInput | number
    picName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tickets?: MaintenanceTicketUncheckedUpdateManyWithoutRoomNestedInput
  }

  export type TenantCreateWithoutMaintenanceTicketsInput = {
    id?: string
    name: string
    address?: string | null
    phone?: string | null
    adminUserId?: string | null
    timezone?: string
    plan?: string
    billingContact?: string | null
    status?: string
    settings?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutTenantInput
    santri?: SantriCreateNestedManyWithoutTenantInput
    wali?: WaliCreateNestedManyWithoutTenantInput
    izin?: IzinCreateNestedManyWithoutTenantInput
    catatanHarian?: CatatanHarianCreateNestedManyWithoutTenantInput
    pengumuman?: PengumumanCreateNestedManyWithoutTenantInput
    invoices?: InvoiceCreateNestedManyWithoutTenantInput
    pelanggaran?: PelanggaranCreateNestedManyWithoutTenantInput
    pembinaan?: PembinaanCreateNestedManyWithoutTenantInput
    kunjungan?: KunjunganCreateNestedManyWithoutTenantInput
    healthRecords?: HealthRecordCreateNestedManyWithoutTenantInput
    auditLogs?: AuditLogCreateNestedManyWithoutTenantInput
    notifications?: NotificationCreateNestedManyWithoutTenantInput
    webhookEvents?: WebhookEventCreateNestedManyWithoutTenantInput
    tahfidz?: TahfidzCreateNestedManyWithoutTenantInput
    mutabaah?: MutabaahCreateNestedManyWithoutTenantInput
    wallets?: WalletCreateNestedManyWithoutTenantInput
    employees?: EmployeeCreateNestedManyWithoutTenantInput
    payrolls?: PayrollCreateNestedManyWithoutTenantInput
    academicScheds?: AcademicScheduleCreateNestedManyWithoutTenantInput
    attendances?: AttendanceCreateNestedManyWithoutTenantInput
    grades?: GradeCreateNestedManyWithoutTenantInput
    ppdbRegistrations?: PpdbRegistrationCreateNestedManyWithoutTenantInput
    ppdbDocuments?: PpdbDocumentCreateNestedManyWithoutTenantInput
    ppdbExams?: PpdbExamCreateNestedManyWithoutTenantInput
    inventoryItems?: ItemCreateNestedManyWithoutTenantInput
    inventoryTransactions?: InventoryTransactionCreateNestedManyWithoutTenantInput
    suppliers?: SupplierCreateNestedManyWithoutTenantInput
    purchaseOrders?: PurchaseOrderCreateNestedManyWithoutTenantInput
    buildings?: BuildingCreateNestedManyWithoutTenantInput
    rooms?: RoomCreateNestedManyWithoutTenantInput
    roomAssignments?: RoomAssignmentCreateNestedManyWithoutTenantInput
  }

  export type TenantUncheckedCreateWithoutMaintenanceTicketsInput = {
    id?: string
    name: string
    address?: string | null
    phone?: string | null
    adminUserId?: string | null
    timezone?: string
    plan?: string
    billingContact?: string | null
    status?: string
    settings?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutTenantInput
    santri?: SantriUncheckedCreateNestedManyWithoutTenantInput
    wali?: WaliUncheckedCreateNestedManyWithoutTenantInput
    izin?: IzinUncheckedCreateNestedManyWithoutTenantInput
    catatanHarian?: CatatanHarianUncheckedCreateNestedManyWithoutTenantInput
    pengumuman?: PengumumanUncheckedCreateNestedManyWithoutTenantInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutTenantInput
    pelanggaran?: PelanggaranUncheckedCreateNestedManyWithoutTenantInput
    pembinaan?: PembinaanUncheckedCreateNestedManyWithoutTenantInput
    kunjungan?: KunjunganUncheckedCreateNestedManyWithoutTenantInput
    healthRecords?: HealthRecordUncheckedCreateNestedManyWithoutTenantInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutTenantInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutTenantInput
    webhookEvents?: WebhookEventUncheckedCreateNestedManyWithoutTenantInput
    tahfidz?: TahfidzUncheckedCreateNestedManyWithoutTenantInput
    mutabaah?: MutabaahUncheckedCreateNestedManyWithoutTenantInput
    wallets?: WalletUncheckedCreateNestedManyWithoutTenantInput
    employees?: EmployeeUncheckedCreateNestedManyWithoutTenantInput
    payrolls?: PayrollUncheckedCreateNestedManyWithoutTenantInput
    academicScheds?: AcademicScheduleUncheckedCreateNestedManyWithoutTenantInput
    attendances?: AttendanceUncheckedCreateNestedManyWithoutTenantInput
    grades?: GradeUncheckedCreateNestedManyWithoutTenantInput
    ppdbRegistrations?: PpdbRegistrationUncheckedCreateNestedManyWithoutTenantInput
    ppdbDocuments?: PpdbDocumentUncheckedCreateNestedManyWithoutTenantInput
    ppdbExams?: PpdbExamUncheckedCreateNestedManyWithoutTenantInput
    inventoryItems?: ItemUncheckedCreateNestedManyWithoutTenantInput
    inventoryTransactions?: InventoryTransactionUncheckedCreateNestedManyWithoutTenantInput
    suppliers?: SupplierUncheckedCreateNestedManyWithoutTenantInput
    purchaseOrders?: PurchaseOrderUncheckedCreateNestedManyWithoutTenantInput
    buildings?: BuildingUncheckedCreateNestedManyWithoutTenantInput
    rooms?: RoomUncheckedCreateNestedManyWithoutTenantInput
    roomAssignments?: RoomAssignmentUncheckedCreateNestedManyWithoutTenantInput
  }

  export type TenantCreateOrConnectWithoutMaintenanceTicketsInput = {
    where: TenantWhereUniqueInput
    create: XOR<TenantCreateWithoutMaintenanceTicketsInput, TenantUncheckedCreateWithoutMaintenanceTicketsInput>
  }

  export type RoomCreateWithoutTicketsInput = {
    id?: string
    name: string
    capacity: number
    picName?: string | null
    createdAt?: Date | string
    tenant: TenantCreateNestedOneWithoutRoomsInput
    building: BuildingCreateNestedOneWithoutRoomsInput
    assignments?: RoomAssignmentCreateNestedManyWithoutRoomInput
  }

  export type RoomUncheckedCreateWithoutTicketsInput = {
    id?: string
    tenantId: string
    buildingId: string
    name: string
    capacity: number
    picName?: string | null
    createdAt?: Date | string
    assignments?: RoomAssignmentUncheckedCreateNestedManyWithoutRoomInput
  }

  export type RoomCreateOrConnectWithoutTicketsInput = {
    where: RoomWhereUniqueInput
    create: XOR<RoomCreateWithoutTicketsInput, RoomUncheckedCreateWithoutTicketsInput>
  }

  export type TenantUpsertWithoutMaintenanceTicketsInput = {
    update: XOR<TenantUpdateWithoutMaintenanceTicketsInput, TenantUncheckedUpdateWithoutMaintenanceTicketsInput>
    create: XOR<TenantCreateWithoutMaintenanceTicketsInput, TenantUncheckedCreateWithoutMaintenanceTicketsInput>
    where?: TenantWhereInput
  }

  export type TenantUpdateToOneWithWhereWithoutMaintenanceTicketsInput = {
    where?: TenantWhereInput
    data: XOR<TenantUpdateWithoutMaintenanceTicketsInput, TenantUncheckedUpdateWithoutMaintenanceTicketsInput>
  }

  export type TenantUpdateWithoutMaintenanceTicketsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    adminUserId?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    plan?: StringFieldUpdateOperationsInput | string
    billingContact?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    settings?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutTenantNestedInput
    santri?: SantriUpdateManyWithoutTenantNestedInput
    wali?: WaliUpdateManyWithoutTenantNestedInput
    izin?: IzinUpdateManyWithoutTenantNestedInput
    catatanHarian?: CatatanHarianUpdateManyWithoutTenantNestedInput
    pengumuman?: PengumumanUpdateManyWithoutTenantNestedInput
    invoices?: InvoiceUpdateManyWithoutTenantNestedInput
    pelanggaran?: PelanggaranUpdateManyWithoutTenantNestedInput
    pembinaan?: PembinaanUpdateManyWithoutTenantNestedInput
    kunjungan?: KunjunganUpdateManyWithoutTenantNestedInput
    healthRecords?: HealthRecordUpdateManyWithoutTenantNestedInput
    auditLogs?: AuditLogUpdateManyWithoutTenantNestedInput
    notifications?: NotificationUpdateManyWithoutTenantNestedInput
    webhookEvents?: WebhookEventUpdateManyWithoutTenantNestedInput
    tahfidz?: TahfidzUpdateManyWithoutTenantNestedInput
    mutabaah?: MutabaahUpdateManyWithoutTenantNestedInput
    wallets?: WalletUpdateManyWithoutTenantNestedInput
    employees?: EmployeeUpdateManyWithoutTenantNestedInput
    payrolls?: PayrollUpdateManyWithoutTenantNestedInput
    academicScheds?: AcademicScheduleUpdateManyWithoutTenantNestedInput
    attendances?: AttendanceUpdateManyWithoutTenantNestedInput
    grades?: GradeUpdateManyWithoutTenantNestedInput
    ppdbRegistrations?: PpdbRegistrationUpdateManyWithoutTenantNestedInput
    ppdbDocuments?: PpdbDocumentUpdateManyWithoutTenantNestedInput
    ppdbExams?: PpdbExamUpdateManyWithoutTenantNestedInput
    inventoryItems?: ItemUpdateManyWithoutTenantNestedInput
    inventoryTransactions?: InventoryTransactionUpdateManyWithoutTenantNestedInput
    suppliers?: SupplierUpdateManyWithoutTenantNestedInput
    purchaseOrders?: PurchaseOrderUpdateManyWithoutTenantNestedInput
    buildings?: BuildingUpdateManyWithoutTenantNestedInput
    rooms?: RoomUpdateManyWithoutTenantNestedInput
    roomAssignments?: RoomAssignmentUpdateManyWithoutTenantNestedInput
  }

  export type TenantUncheckedUpdateWithoutMaintenanceTicketsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    adminUserId?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    plan?: StringFieldUpdateOperationsInput | string
    billingContact?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    settings?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutTenantNestedInput
    santri?: SantriUncheckedUpdateManyWithoutTenantNestedInput
    wali?: WaliUncheckedUpdateManyWithoutTenantNestedInput
    izin?: IzinUncheckedUpdateManyWithoutTenantNestedInput
    catatanHarian?: CatatanHarianUncheckedUpdateManyWithoutTenantNestedInput
    pengumuman?: PengumumanUncheckedUpdateManyWithoutTenantNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutTenantNestedInput
    pelanggaran?: PelanggaranUncheckedUpdateManyWithoutTenantNestedInput
    pembinaan?: PembinaanUncheckedUpdateManyWithoutTenantNestedInput
    kunjungan?: KunjunganUncheckedUpdateManyWithoutTenantNestedInput
    healthRecords?: HealthRecordUncheckedUpdateManyWithoutTenantNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutTenantNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutTenantNestedInput
    webhookEvents?: WebhookEventUncheckedUpdateManyWithoutTenantNestedInput
    tahfidz?: TahfidzUncheckedUpdateManyWithoutTenantNestedInput
    mutabaah?: MutabaahUncheckedUpdateManyWithoutTenantNestedInput
    wallets?: WalletUncheckedUpdateManyWithoutTenantNestedInput
    employees?: EmployeeUncheckedUpdateManyWithoutTenantNestedInput
    payrolls?: PayrollUncheckedUpdateManyWithoutTenantNestedInput
    academicScheds?: AcademicScheduleUncheckedUpdateManyWithoutTenantNestedInput
    attendances?: AttendanceUncheckedUpdateManyWithoutTenantNestedInput
    grades?: GradeUncheckedUpdateManyWithoutTenantNestedInput
    ppdbRegistrations?: PpdbRegistrationUncheckedUpdateManyWithoutTenantNestedInput
    ppdbDocuments?: PpdbDocumentUncheckedUpdateManyWithoutTenantNestedInput
    ppdbExams?: PpdbExamUncheckedUpdateManyWithoutTenantNestedInput
    inventoryItems?: ItemUncheckedUpdateManyWithoutTenantNestedInput
    inventoryTransactions?: InventoryTransactionUncheckedUpdateManyWithoutTenantNestedInput
    suppliers?: SupplierUncheckedUpdateManyWithoutTenantNestedInput
    purchaseOrders?: PurchaseOrderUncheckedUpdateManyWithoutTenantNestedInput
    buildings?: BuildingUncheckedUpdateManyWithoutTenantNestedInput
    rooms?: RoomUncheckedUpdateManyWithoutTenantNestedInput
    roomAssignments?: RoomAssignmentUncheckedUpdateManyWithoutTenantNestedInput
  }

  export type RoomUpsertWithoutTicketsInput = {
    update: XOR<RoomUpdateWithoutTicketsInput, RoomUncheckedUpdateWithoutTicketsInput>
    create: XOR<RoomCreateWithoutTicketsInput, RoomUncheckedCreateWithoutTicketsInput>
    where?: RoomWhereInput
  }

  export type RoomUpdateToOneWithWhereWithoutTicketsInput = {
    where?: RoomWhereInput
    data: XOR<RoomUpdateWithoutTicketsInput, RoomUncheckedUpdateWithoutTicketsInput>
  }

  export type RoomUpdateWithoutTicketsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    capacity?: IntFieldUpdateOperationsInput | number
    picName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutRoomsNestedInput
    building?: BuildingUpdateOneRequiredWithoutRoomsNestedInput
    assignments?: RoomAssignmentUpdateManyWithoutRoomNestedInput
  }

  export type RoomUncheckedUpdateWithoutTicketsInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    buildingId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    capacity?: IntFieldUpdateOperationsInput | number
    picName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignments?: RoomAssignmentUncheckedUpdateManyWithoutRoomNestedInput
  }

  export type UserCreateManyTenantInput = {
    id?: string
    email: string
    passwordHash: string
    role?: string
    name: string
    phone?: string | null
    isActive?: boolean
    lastLogin?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SantriCreateManyTenantInput = {
    id?: string
    nisn?: string | null
    name: string
    gender: string
    dob?: Date | string | null
    kelas?: string | null
    room?: string | null
    contact?: string | null
    address?: string | null
    photo?: string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WaliCreateManyTenantInput = {
    id?: string
    name: string
    relation: string
    phone: string
    email?: string | null
    address?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type IzinCreateManyTenantInput = {
    id?: string
    santriId: string
    type: string
    reason: string
    startAt: Date | string
    endAt: Date | string
    status?: string
    requestedBy: string
    approvedBy?: string | null
    approvedAt?: Date | string | null
    qrCodeData?: string | null
    checkoutAt?: Date | string | null
    checkoutBy?: string | null
    checkinAt?: Date | string | null
    checkinBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CatatanHarianCreateManyTenantInput = {
    id?: string
    santriId: string
    authorId: string
    date?: Date | string
    content: string
    category: string
    attachments?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PengumumanCreateManyTenantInput = {
    id?: string
    title: string
    content: string
    audience: string
    pinnedUntil?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InvoiceCreateManyTenantInput = {
    id?: string
    santriId: string
    amountDue: number
    dueDate: Date | string
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PelanggaranCreateManyTenantInput = {
    id?: string
    santriId: string
    recordedBy: string
    category: string
    severity: number
    points?: number
    description: string
    date?: Date | string
    resolved?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PembinaanCreateManyTenantInput = {
    id?: string
    santriId: string
    plan: string
    targetDate: Date | string
    status?: string
    assignedTo: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type KunjunganCreateManyTenantInput = {
    id?: string
    santriId: string
    scheduledAt: Date | string
    slot: string
    visitorLimit?: number
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type HealthRecordCreateManyTenantInput = {
    id?: string
    santriId: string
    recordedBy: string
    symptoms: string
    diagnosis?: string | null
    actionTaken?: string | null
    referred?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AuditLogCreateManyTenantInput = {
    id?: string
    userId?: string | null
    action: string
    entity: string
    entityId: string
    oldValue?: string | null
    newValue?: string | null
    ip?: string | null
    createdAt?: Date | string
  }

  export type NotificationCreateManyTenantInput = {
    id?: string
    userId: string
    type: string
    title: string
    body: string
    read?: boolean
    createdAt?: Date | string
  }

  export type WebhookEventCreateManyTenantInput = {
    id?: string
    eventType: string
    payload: string
    status?: string
    error?: string | null
    createdAt?: Date | string
    processedAt?: Date | string | null
  }

  export type TahfidzCreateManyTenantInput = {
    id?: string
    santriId: string
    surah: string
    ayat?: string | null
    type?: string
    grade?: string | null
    notes?: string | null
    recordedBy: string
    date?: Date | string
    createdAt?: Date | string
  }

  export type MutabaahCreateManyTenantInput = {
    id?: string
    santriId: string
    date?: Date | string
    sholatWajib?: boolean
    tahajud?: boolean
    dhuha?: boolean
    puasaSunnah?: boolean
    bacaQuran?: boolean
    notes?: string | null
    recordedBy?: string | null
    createdAt?: Date | string
  }

  export type WalletCreateManyTenantInput = {
    id?: string
    santriId: string
    balance?: number
    pin?: string | null
    isActive?: boolean
    updatedAt?: Date | string
  }

  export type EmployeeCreateManyTenantInput = {
    id?: string
    userId?: string | null
    nip?: string | null
    name: string
    position: string
    phone?: string | null
    address?: string | null
    joinDate?: Date | string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PayrollCreateManyTenantInput = {
    id?: string
    employeeId: string
    month: number
    year: number
    baseSalary?: number
    allowances?: number
    deductions?: number
    netAmount: number
    status?: string
    paidAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AcademicScheduleCreateManyTenantInput = {
    id?: string
    subject: string
    teacherId: string
    kelas: string
    dayOfWeek: number
    startTime: string
    endTime: string
    room?: string | null
    createdAt?: Date | string
  }

  export type AttendanceCreateManyTenantInput = {
    id?: string
    santriId: string
    scheduleId?: string | null
    date?: Date | string
    status: string
    notes?: string | null
    recordedBy?: string | null
    createdAt?: Date | string
  }

  export type GradeCreateManyTenantInput = {
    id?: string
    santriId: string
    subject: string
    semester: string
    academicYear: string
    type: string
    score: number
    notes?: string | null
    createdAt?: Date | string
  }

  export type PpdbRegistrationCreateManyTenantInput = {
    id?: string
    registrationNumber: string
    fullName: string
    gender: string
    dob?: Date | string | null
    previousSchool?: string | null
    pathway?: string
    status?: string
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PpdbDocumentCreateManyTenantInput = {
    id?: string
    registrationId: string
    documentType: string
    fileUrl: string
    isVerified?: boolean
    createdAt?: Date | string
  }

  export type PpdbExamCreateManyTenantInput = {
    id?: string
    registrationId: string
    examType: string
    examDate: Date | string
    score?: number | null
    result?: string | null
    interviewer?: string | null
    createdAt?: Date | string
  }

  export type ItemCreateManyTenantInput = {
    id?: string
    sku: string
    name: string
    description?: string | null
    category: string
    price: number
    costPrice?: number | null
    stock?: number
    minStock?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InventoryTransactionCreateManyTenantInput = {
    id?: string
    itemId: string
    type: string
    quantity: number
    reference?: string | null
    notes?: string | null
    handledBy?: string | null
    date?: Date | string
  }

  export type SupplierCreateManyTenantInput = {
    id?: string
    name: string
    contact?: string | null
    address?: string | null
    email?: string | null
    createdAt?: Date | string
  }

  export type PurchaseOrderCreateManyTenantInput = {
    id?: string
    supplierId: string
    poNumber: string
    totalCost: number
    status?: string
    orderDate?: Date | string
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BuildingCreateManyTenantInput = {
    id?: string
    name: string
    description?: string | null
    gender: string
    capacity?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RoomCreateManyTenantInput = {
    id?: string
    buildingId: string
    name: string
    capacity: number
    picName?: string | null
    createdAt?: Date | string
  }

  export type RoomAssignmentCreateManyTenantInput = {
    id?: string
    roomId: string
    santriId: string
    startDate?: Date | string
    endDate?: Date | string | null
    status?: string
  }

  export type MaintenanceTicketCreateManyTenantInput = {
    id?: string
    roomId: string
    title: string
    description: string
    priority?: string
    status?: string
    reportedBy: string
    resolvedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    refreshTokens?: RefreshTokenUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    refreshTokens?: RefreshTokenUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateManyWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SantriUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    nisn?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    gender?: StringFieldUpdateOperationsInput | string
    dob?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    kelas?: NullableStringFieldUpdateOperationsInput | string | null
    room?: NullableStringFieldUpdateOperationsInput | string | null
    contact?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    walis?: SantriWaliUpdateManyWithoutSantriNestedInput
    izin?: IzinUpdateManyWithoutSantriNestedInput
    catatanHarian?: CatatanHarianUpdateManyWithoutSantriNestedInput
    invoices?: InvoiceUpdateManyWithoutSantriNestedInput
    pelanggaran?: PelanggaranUpdateManyWithoutSantriNestedInput
    pembinaan?: PembinaanUpdateManyWithoutSantriNestedInput
    kunjungan?: KunjunganUpdateManyWithoutSantriNestedInput
    healthRecords?: HealthRecordUpdateManyWithoutSantriNestedInput
    medications?: MedicationUpdateManyWithoutSantriNestedInput
    tahfidz?: TahfidzUpdateManyWithoutSantriNestedInput
    mutabaah?: MutabaahUpdateManyWithoutSantriNestedInput
    wallet?: WalletUpdateOneWithoutSantriNestedInput
    attendances?: AttendanceUpdateManyWithoutSantriNestedInput
    grades?: GradeUpdateManyWithoutSantriNestedInput
  }

  export type SantriUncheckedUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    nisn?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    gender?: StringFieldUpdateOperationsInput | string
    dob?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    kelas?: NullableStringFieldUpdateOperationsInput | string | null
    room?: NullableStringFieldUpdateOperationsInput | string | null
    contact?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    walis?: SantriWaliUncheckedUpdateManyWithoutSantriNestedInput
    izin?: IzinUncheckedUpdateManyWithoutSantriNestedInput
    catatanHarian?: CatatanHarianUncheckedUpdateManyWithoutSantriNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutSantriNestedInput
    pelanggaran?: PelanggaranUncheckedUpdateManyWithoutSantriNestedInput
    pembinaan?: PembinaanUncheckedUpdateManyWithoutSantriNestedInput
    kunjungan?: KunjunganUncheckedUpdateManyWithoutSantriNestedInput
    healthRecords?: HealthRecordUncheckedUpdateManyWithoutSantriNestedInput
    medications?: MedicationUncheckedUpdateManyWithoutSantriNestedInput
    tahfidz?: TahfidzUncheckedUpdateManyWithoutSantriNestedInput
    mutabaah?: MutabaahUncheckedUpdateManyWithoutSantriNestedInput
    wallet?: WalletUncheckedUpdateOneWithoutSantriNestedInput
    attendances?: AttendanceUncheckedUpdateManyWithoutSantriNestedInput
    grades?: GradeUncheckedUpdateManyWithoutSantriNestedInput
  }

  export type SantriUncheckedUpdateManyWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    nisn?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    gender?: StringFieldUpdateOperationsInput | string
    dob?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    kelas?: NullableStringFieldUpdateOperationsInput | string | null
    room?: NullableStringFieldUpdateOperationsInput | string | null
    contact?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WaliUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    relation?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    santris?: SantriWaliUpdateManyWithoutWaliNestedInput
  }

  export type WaliUncheckedUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    relation?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    santris?: SantriWaliUncheckedUpdateManyWithoutWaliNestedInput
  }

  export type WaliUncheckedUpdateManyWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    relation?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IzinUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    reason?: StringFieldUpdateOperationsInput | string
    startAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    requestedBy?: StringFieldUpdateOperationsInput | string
    approvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    qrCodeData?: NullableStringFieldUpdateOperationsInput | string | null
    checkoutAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    checkoutBy?: NullableStringFieldUpdateOperationsInput | string | null
    checkinAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    checkinBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    santri?: SantriUpdateOneRequiredWithoutIzinNestedInput
  }

  export type IzinUncheckedUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    santriId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    reason?: StringFieldUpdateOperationsInput | string
    startAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    requestedBy?: StringFieldUpdateOperationsInput | string
    approvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    qrCodeData?: NullableStringFieldUpdateOperationsInput | string | null
    checkoutAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    checkoutBy?: NullableStringFieldUpdateOperationsInput | string | null
    checkinAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    checkinBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IzinUncheckedUpdateManyWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    santriId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    reason?: StringFieldUpdateOperationsInput | string
    startAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    requestedBy?: StringFieldUpdateOperationsInput | string
    approvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    qrCodeData?: NullableStringFieldUpdateOperationsInput | string | null
    checkoutAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    checkoutBy?: NullableStringFieldUpdateOperationsInput | string | null
    checkinAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    checkinBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CatatanHarianUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    content?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    attachments?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    santri?: SantriUpdateOneRequiredWithoutCatatanHarianNestedInput
  }

  export type CatatanHarianUncheckedUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    santriId?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    content?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    attachments?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CatatanHarianUncheckedUpdateManyWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    santriId?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    content?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    attachments?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PengumumanUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    audience?: StringFieldUpdateOperationsInput | string
    pinnedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PengumumanUncheckedUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    audience?: StringFieldUpdateOperationsInput | string
    pinnedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PengumumanUncheckedUpdateManyWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    audience?: StringFieldUpdateOperationsInput | string
    pinnedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvoiceUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    amountDue?: FloatFieldUpdateOperationsInput | number
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    santri?: SantriUpdateOneRequiredWithoutInvoicesNestedInput
    lines?: InvoiceLineUpdateManyWithoutInvoiceNestedInput
    payments?: PaymentUpdateManyWithoutInvoiceNestedInput
  }

  export type InvoiceUncheckedUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    santriId?: StringFieldUpdateOperationsInput | string
    amountDue?: FloatFieldUpdateOperationsInput | number
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lines?: InvoiceLineUncheckedUpdateManyWithoutInvoiceNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutInvoiceNestedInput
  }

  export type InvoiceUncheckedUpdateManyWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    santriId?: StringFieldUpdateOperationsInput | string
    amountDue?: FloatFieldUpdateOperationsInput | number
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PelanggaranUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    recordedBy?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    severity?: IntFieldUpdateOperationsInput | number
    points?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    resolved?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    santri?: SantriUpdateOneRequiredWithoutPelanggaranNestedInput
  }

  export type PelanggaranUncheckedUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    santriId?: StringFieldUpdateOperationsInput | string
    recordedBy?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    severity?: IntFieldUpdateOperationsInput | number
    points?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    resolved?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PelanggaranUncheckedUpdateManyWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    santriId?: StringFieldUpdateOperationsInput | string
    recordedBy?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    severity?: IntFieldUpdateOperationsInput | number
    points?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    resolved?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PembinaanUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    plan?: StringFieldUpdateOperationsInput | string
    targetDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    assignedTo?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    santri?: SantriUpdateOneRequiredWithoutPembinaanNestedInput
  }

  export type PembinaanUncheckedUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    santriId?: StringFieldUpdateOperationsInput | string
    plan?: StringFieldUpdateOperationsInput | string
    targetDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    assignedTo?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PembinaanUncheckedUpdateManyWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    santriId?: StringFieldUpdateOperationsInput | string
    plan?: StringFieldUpdateOperationsInput | string
    targetDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    assignedTo?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type KunjunganUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    scheduledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    slot?: StringFieldUpdateOperationsInput | string
    visitorLimit?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    santri?: SantriUpdateOneRequiredWithoutKunjunganNestedInput
    tamu?: TamuUpdateManyWithoutKunjunganNestedInput
  }

  export type KunjunganUncheckedUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    santriId?: StringFieldUpdateOperationsInput | string
    scheduledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    slot?: StringFieldUpdateOperationsInput | string
    visitorLimit?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tamu?: TamuUncheckedUpdateManyWithoutKunjunganNestedInput
  }

  export type KunjunganUncheckedUpdateManyWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    santriId?: StringFieldUpdateOperationsInput | string
    scheduledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    slot?: StringFieldUpdateOperationsInput | string
    visitorLimit?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HealthRecordUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    recordedBy?: StringFieldUpdateOperationsInput | string
    symptoms?: StringFieldUpdateOperationsInput | string
    diagnosis?: NullableStringFieldUpdateOperationsInput | string | null
    actionTaken?: NullableStringFieldUpdateOperationsInput | string | null
    referred?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    santri?: SantriUpdateOneRequiredWithoutHealthRecordsNestedInput
  }

  export type HealthRecordUncheckedUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    santriId?: StringFieldUpdateOperationsInput | string
    recordedBy?: StringFieldUpdateOperationsInput | string
    symptoms?: StringFieldUpdateOperationsInput | string
    diagnosis?: NullableStringFieldUpdateOperationsInput | string | null
    actionTaken?: NullableStringFieldUpdateOperationsInput | string | null
    referred?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HealthRecordUncheckedUpdateManyWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    santriId?: StringFieldUpdateOperationsInput | string
    recordedBy?: StringFieldUpdateOperationsInput | string
    symptoms?: StringFieldUpdateOperationsInput | string
    diagnosis?: NullableStringFieldUpdateOperationsInput | string | null
    actionTaken?: NullableStringFieldUpdateOperationsInput | string | null
    referred?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    entity?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    oldValue?: NullableStringFieldUpdateOperationsInput | string | null
    newValue?: NullableStringFieldUpdateOperationsInput | string | null
    ip?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutAuditLogsNestedInput
  }

  export type AuditLogUncheckedUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    action?: StringFieldUpdateOperationsInput | string
    entity?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    oldValue?: NullableStringFieldUpdateOperationsInput | string | null
    newValue?: NullableStringFieldUpdateOperationsInput | string | null
    ip?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogUncheckedUpdateManyWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    action?: StringFieldUpdateOperationsInput | string
    entity?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    oldValue?: NullableStringFieldUpdateOperationsInput | string | null
    newValue?: NullableStringFieldUpdateOperationsInput | string | null
    ip?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    read?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutNotificationsNestedInput
  }

  export type NotificationUncheckedUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    read?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUncheckedUpdateManyWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    read?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WebhookEventUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    eventType?: StringFieldUpdateOperationsInput | string
    payload?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    error?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type WebhookEventUncheckedUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    eventType?: StringFieldUpdateOperationsInput | string
    payload?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    error?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type WebhookEventUncheckedUpdateManyWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    eventType?: StringFieldUpdateOperationsInput | string
    payload?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    error?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type TahfidzUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    surah?: StringFieldUpdateOperationsInput | string
    ayat?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    grade?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    recordedBy?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    santri?: SantriUpdateOneRequiredWithoutTahfidzNestedInput
  }

  export type TahfidzUncheckedUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    santriId?: StringFieldUpdateOperationsInput | string
    surah?: StringFieldUpdateOperationsInput | string
    ayat?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    grade?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    recordedBy?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TahfidzUncheckedUpdateManyWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    santriId?: StringFieldUpdateOperationsInput | string
    surah?: StringFieldUpdateOperationsInput | string
    ayat?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    grade?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    recordedBy?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MutabaahUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    sholatWajib?: BoolFieldUpdateOperationsInput | boolean
    tahajud?: BoolFieldUpdateOperationsInput | boolean
    dhuha?: BoolFieldUpdateOperationsInput | boolean
    puasaSunnah?: BoolFieldUpdateOperationsInput | boolean
    bacaQuran?: BoolFieldUpdateOperationsInput | boolean
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    recordedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    santri?: SantriUpdateOneRequiredWithoutMutabaahNestedInput
  }

  export type MutabaahUncheckedUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    santriId?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    sholatWajib?: BoolFieldUpdateOperationsInput | boolean
    tahajud?: BoolFieldUpdateOperationsInput | boolean
    dhuha?: BoolFieldUpdateOperationsInput | boolean
    puasaSunnah?: BoolFieldUpdateOperationsInput | boolean
    bacaQuran?: BoolFieldUpdateOperationsInput | boolean
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    recordedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MutabaahUncheckedUpdateManyWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    santriId?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    sholatWajib?: BoolFieldUpdateOperationsInput | boolean
    tahajud?: BoolFieldUpdateOperationsInput | boolean
    dhuha?: BoolFieldUpdateOperationsInput | boolean
    puasaSunnah?: BoolFieldUpdateOperationsInput | boolean
    bacaQuran?: BoolFieldUpdateOperationsInput | boolean
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    recordedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WalletUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    balance?: FloatFieldUpdateOperationsInput | number
    pin?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    santri?: SantriUpdateOneRequiredWithoutWalletNestedInput
    transactions?: WalletTransactionUpdateManyWithoutWalletNestedInput
  }

  export type WalletUncheckedUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    santriId?: StringFieldUpdateOperationsInput | string
    balance?: FloatFieldUpdateOperationsInput | number
    pin?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transactions?: WalletTransactionUncheckedUpdateManyWithoutWalletNestedInput
  }

  export type WalletUncheckedUpdateManyWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    santriId?: StringFieldUpdateOperationsInput | string
    balance?: FloatFieldUpdateOperationsInput | number
    pin?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmployeeUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    nip?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    position?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    joinDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    payrolls?: PayrollUpdateManyWithoutEmployeeNestedInput
  }

  export type EmployeeUncheckedUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    nip?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    position?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    joinDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    payrolls?: PayrollUncheckedUpdateManyWithoutEmployeeNestedInput
  }

  export type EmployeeUncheckedUpdateManyWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    nip?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    position?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    joinDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PayrollUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    month?: IntFieldUpdateOperationsInput | number
    year?: IntFieldUpdateOperationsInput | number
    baseSalary?: FloatFieldUpdateOperationsInput | number
    allowances?: FloatFieldUpdateOperationsInput | number
    deductions?: FloatFieldUpdateOperationsInput | number
    netAmount?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    employee?: EmployeeUpdateOneRequiredWithoutPayrollsNestedInput
  }

  export type PayrollUncheckedUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    employeeId?: StringFieldUpdateOperationsInput | string
    month?: IntFieldUpdateOperationsInput | number
    year?: IntFieldUpdateOperationsInput | number
    baseSalary?: FloatFieldUpdateOperationsInput | number
    allowances?: FloatFieldUpdateOperationsInput | number
    deductions?: FloatFieldUpdateOperationsInput | number
    netAmount?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PayrollUncheckedUpdateManyWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    employeeId?: StringFieldUpdateOperationsInput | string
    month?: IntFieldUpdateOperationsInput | number
    year?: IntFieldUpdateOperationsInput | number
    baseSalary?: FloatFieldUpdateOperationsInput | number
    allowances?: FloatFieldUpdateOperationsInput | number
    deductions?: FloatFieldUpdateOperationsInput | number
    netAmount?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AcademicScheduleUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    teacherId?: StringFieldUpdateOperationsInput | string
    kelas?: StringFieldUpdateOperationsInput | string
    dayOfWeek?: IntFieldUpdateOperationsInput | number
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    room?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AcademicScheduleUncheckedUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    teacherId?: StringFieldUpdateOperationsInput | string
    kelas?: StringFieldUpdateOperationsInput | string
    dayOfWeek?: IntFieldUpdateOperationsInput | number
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    room?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AcademicScheduleUncheckedUpdateManyWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    teacherId?: StringFieldUpdateOperationsInput | string
    kelas?: StringFieldUpdateOperationsInput | string
    dayOfWeek?: IntFieldUpdateOperationsInput | number
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    room?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AttendanceUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    scheduleId?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    recordedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    santri?: SantriUpdateOneRequiredWithoutAttendancesNestedInput
  }

  export type AttendanceUncheckedUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    santriId?: StringFieldUpdateOperationsInput | string
    scheduleId?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    recordedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AttendanceUncheckedUpdateManyWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    santriId?: StringFieldUpdateOperationsInput | string
    scheduleId?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    recordedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GradeUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    semester?: StringFieldUpdateOperationsInput | string
    academicYear?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    score?: FloatFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    santri?: SantriUpdateOneRequiredWithoutGradesNestedInput
  }

  export type GradeUncheckedUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    santriId?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    semester?: StringFieldUpdateOperationsInput | string
    academicYear?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    score?: FloatFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GradeUncheckedUpdateManyWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    santriId?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    semester?: StringFieldUpdateOperationsInput | string
    academicYear?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    score?: FloatFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PpdbRegistrationUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    registrationNumber?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    gender?: StringFieldUpdateOperationsInput | string
    dob?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    previousSchool?: NullableStringFieldUpdateOperationsInput | string | null
    pathway?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    documents?: PpdbDocumentUpdateManyWithoutRegistrationNestedInput
    exams?: PpdbExamUpdateManyWithoutRegistrationNestedInput
  }

  export type PpdbRegistrationUncheckedUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    registrationNumber?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    gender?: StringFieldUpdateOperationsInput | string
    dob?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    previousSchool?: NullableStringFieldUpdateOperationsInput | string | null
    pathway?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    documents?: PpdbDocumentUncheckedUpdateManyWithoutRegistrationNestedInput
    exams?: PpdbExamUncheckedUpdateManyWithoutRegistrationNestedInput
  }

  export type PpdbRegistrationUncheckedUpdateManyWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    registrationNumber?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    gender?: StringFieldUpdateOperationsInput | string
    dob?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    previousSchool?: NullableStringFieldUpdateOperationsInput | string | null
    pathway?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PpdbDocumentUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    documentType?: StringFieldUpdateOperationsInput | string
    fileUrl?: StringFieldUpdateOperationsInput | string
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    registration?: PpdbRegistrationUpdateOneRequiredWithoutDocumentsNestedInput
  }

  export type PpdbDocumentUncheckedUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    registrationId?: StringFieldUpdateOperationsInput | string
    documentType?: StringFieldUpdateOperationsInput | string
    fileUrl?: StringFieldUpdateOperationsInput | string
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PpdbDocumentUncheckedUpdateManyWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    registrationId?: StringFieldUpdateOperationsInput | string
    documentType?: StringFieldUpdateOperationsInput | string
    fileUrl?: StringFieldUpdateOperationsInput | string
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PpdbExamUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    examType?: StringFieldUpdateOperationsInput | string
    examDate?: DateTimeFieldUpdateOperationsInput | Date | string
    score?: NullableFloatFieldUpdateOperationsInput | number | null
    result?: NullableStringFieldUpdateOperationsInput | string | null
    interviewer?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    registration?: PpdbRegistrationUpdateOneRequiredWithoutExamsNestedInput
  }

  export type PpdbExamUncheckedUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    registrationId?: StringFieldUpdateOperationsInput | string
    examType?: StringFieldUpdateOperationsInput | string
    examDate?: DateTimeFieldUpdateOperationsInput | Date | string
    score?: NullableFloatFieldUpdateOperationsInput | number | null
    result?: NullableStringFieldUpdateOperationsInput | string | null
    interviewer?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PpdbExamUncheckedUpdateManyWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    registrationId?: StringFieldUpdateOperationsInput | string
    examType?: StringFieldUpdateOperationsInput | string
    examDate?: DateTimeFieldUpdateOperationsInput | Date | string
    score?: NullableFloatFieldUpdateOperationsInput | number | null
    result?: NullableStringFieldUpdateOperationsInput | string | null
    interviewer?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ItemUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    costPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    stock?: IntFieldUpdateOperationsInput | number
    minStock?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transactions?: InventoryTransactionUpdateManyWithoutItemNestedInput
  }

  export type ItemUncheckedUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    costPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    stock?: IntFieldUpdateOperationsInput | number
    minStock?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transactions?: InventoryTransactionUncheckedUpdateManyWithoutItemNestedInput
  }

  export type ItemUncheckedUpdateManyWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    costPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    stock?: IntFieldUpdateOperationsInput | number
    minStock?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InventoryTransactionUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    handledBy?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    item?: ItemUpdateOneRequiredWithoutTransactionsNestedInput
  }

  export type InventoryTransactionUncheckedUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    itemId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    handledBy?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InventoryTransactionUncheckedUpdateManyWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    itemId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    handledBy?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SupplierUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    contact?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    purchaseOrders?: PurchaseOrderUpdateManyWithoutSupplierNestedInput
  }

  export type SupplierUncheckedUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    contact?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    purchaseOrders?: PurchaseOrderUncheckedUpdateManyWithoutSupplierNestedInput
  }

  export type SupplierUncheckedUpdateManyWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    contact?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PurchaseOrderUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    poNumber?: StringFieldUpdateOperationsInput | string
    totalCost?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    orderDate?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    supplier?: SupplierUpdateOneRequiredWithoutPurchaseOrdersNestedInput
  }

  export type PurchaseOrderUncheckedUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    supplierId?: StringFieldUpdateOperationsInput | string
    poNumber?: StringFieldUpdateOperationsInput | string
    totalCost?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    orderDate?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PurchaseOrderUncheckedUpdateManyWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    supplierId?: StringFieldUpdateOperationsInput | string
    poNumber?: StringFieldUpdateOperationsInput | string
    totalCost?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    orderDate?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BuildingUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: StringFieldUpdateOperationsInput | string
    capacity?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rooms?: RoomUpdateManyWithoutBuildingNestedInput
  }

  export type BuildingUncheckedUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: StringFieldUpdateOperationsInput | string
    capacity?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rooms?: RoomUncheckedUpdateManyWithoutBuildingNestedInput
  }

  export type BuildingUncheckedUpdateManyWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: StringFieldUpdateOperationsInput | string
    capacity?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RoomUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    capacity?: IntFieldUpdateOperationsInput | number
    picName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    building?: BuildingUpdateOneRequiredWithoutRoomsNestedInput
    assignments?: RoomAssignmentUpdateManyWithoutRoomNestedInput
    tickets?: MaintenanceTicketUpdateManyWithoutRoomNestedInput
  }

  export type RoomUncheckedUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    buildingId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    capacity?: IntFieldUpdateOperationsInput | number
    picName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignments?: RoomAssignmentUncheckedUpdateManyWithoutRoomNestedInput
    tickets?: MaintenanceTicketUncheckedUpdateManyWithoutRoomNestedInput
  }

  export type RoomUncheckedUpdateManyWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    buildingId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    capacity?: IntFieldUpdateOperationsInput | number
    picName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RoomAssignmentUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    santriId?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    room?: RoomUpdateOneRequiredWithoutAssignmentsNestedInput
  }

  export type RoomAssignmentUncheckedUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    roomId?: StringFieldUpdateOperationsInput | string
    santriId?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
  }

  export type RoomAssignmentUncheckedUpdateManyWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    roomId?: StringFieldUpdateOperationsInput | string
    santriId?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
  }

  export type MaintenanceTicketUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    reportedBy?: StringFieldUpdateOperationsInput | string
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    room?: RoomUpdateOneRequiredWithoutTicketsNestedInput
  }

  export type MaintenanceTicketUncheckedUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    roomId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    reportedBy?: StringFieldUpdateOperationsInput | string
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MaintenanceTicketUncheckedUpdateManyWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    roomId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    reportedBy?: StringFieldUpdateOperationsInput | string
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RefreshTokenCreateManyUserInput = {
    id?: string
    token: string
    expiresAt: Date | string
    revoked?: boolean
    createdAt?: Date | string
  }

  export type AuditLogCreateManyUserInput = {
    id?: string
    tenantId?: string | null
    action: string
    entity: string
    entityId: string
    oldValue?: string | null
    newValue?: string | null
    ip?: string | null
    createdAt?: Date | string
  }

  export type NotificationCreateManyUserInput = {
    id?: string
    tenantId: string
    type: string
    title: string
    body: string
    read?: boolean
    createdAt?: Date | string
  }

  export type RefreshTokenUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    revoked?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RefreshTokenUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    revoked?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RefreshTokenUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    revoked?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    entity?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    oldValue?: NullableStringFieldUpdateOperationsInput | string | null
    newValue?: NullableStringFieldUpdateOperationsInput | string | null
    ip?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneWithoutAuditLogsNestedInput
  }

  export type AuditLogUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: NullableStringFieldUpdateOperationsInput | string | null
    action?: StringFieldUpdateOperationsInput | string
    entity?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    oldValue?: NullableStringFieldUpdateOperationsInput | string | null
    newValue?: NullableStringFieldUpdateOperationsInput | string | null
    ip?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: NullableStringFieldUpdateOperationsInput | string | null
    action?: StringFieldUpdateOperationsInput | string
    entity?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    oldValue?: NullableStringFieldUpdateOperationsInput | string | null
    newValue?: NullableStringFieldUpdateOperationsInput | string | null
    ip?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    read?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutNotificationsNestedInput
  }

  export type NotificationUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    read?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    read?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SantriWaliCreateManySantriInput = {
    waliId: string
    isPrimary?: boolean
  }

  export type IzinCreateManySantriInput = {
    id?: string
    tenantId: string
    type: string
    reason: string
    startAt: Date | string
    endAt: Date | string
    status?: string
    requestedBy: string
    approvedBy?: string | null
    approvedAt?: Date | string | null
    qrCodeData?: string | null
    checkoutAt?: Date | string | null
    checkoutBy?: string | null
    checkinAt?: Date | string | null
    checkinBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CatatanHarianCreateManySantriInput = {
    id?: string
    tenantId: string
    authorId: string
    date?: Date | string
    content: string
    category: string
    attachments?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InvoiceCreateManySantriInput = {
    id?: string
    tenantId: string
    amountDue: number
    dueDate: Date | string
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PelanggaranCreateManySantriInput = {
    id?: string
    tenantId: string
    recordedBy: string
    category: string
    severity: number
    points?: number
    description: string
    date?: Date | string
    resolved?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PembinaanCreateManySantriInput = {
    id?: string
    tenantId: string
    plan: string
    targetDate: Date | string
    status?: string
    assignedTo: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type KunjunganCreateManySantriInput = {
    id?: string
    tenantId: string
    scheduledAt: Date | string
    slot: string
    visitorLimit?: number
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type HealthRecordCreateManySantriInput = {
    id?: string
    tenantId: string
    recordedBy: string
    symptoms: string
    diagnosis?: string | null
    actionTaken?: string | null
    referred?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MedicationCreateManySantriInput = {
    id?: string
    medicineName: string
    dose: string
    schedule: string
    givenBy?: string | null
    givenAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TahfidzCreateManySantriInput = {
    id?: string
    tenantId: string
    surah: string
    ayat?: string | null
    type?: string
    grade?: string | null
    notes?: string | null
    recordedBy: string
    date?: Date | string
    createdAt?: Date | string
  }

  export type MutabaahCreateManySantriInput = {
    id?: string
    tenantId: string
    date?: Date | string
    sholatWajib?: boolean
    tahajud?: boolean
    dhuha?: boolean
    puasaSunnah?: boolean
    bacaQuran?: boolean
    notes?: string | null
    recordedBy?: string | null
    createdAt?: Date | string
  }

  export type AttendanceCreateManySantriInput = {
    id?: string
    tenantId: string
    scheduleId?: string | null
    date?: Date | string
    status: string
    notes?: string | null
    recordedBy?: string | null
    createdAt?: Date | string
  }

  export type GradeCreateManySantriInput = {
    id?: string
    tenantId: string
    subject: string
    semester: string
    academicYear: string
    type: string
    score: number
    notes?: string | null
    createdAt?: Date | string
  }

  export type SantriWaliUpdateWithoutSantriInput = {
    isPrimary?: BoolFieldUpdateOperationsInput | boolean
    wali?: WaliUpdateOneRequiredWithoutSantrisNestedInput
  }

  export type SantriWaliUncheckedUpdateWithoutSantriInput = {
    waliId?: StringFieldUpdateOperationsInput | string
    isPrimary?: BoolFieldUpdateOperationsInput | boolean
  }

  export type SantriWaliUncheckedUpdateManyWithoutSantriInput = {
    waliId?: StringFieldUpdateOperationsInput | string
    isPrimary?: BoolFieldUpdateOperationsInput | boolean
  }

  export type IzinUpdateWithoutSantriInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    reason?: StringFieldUpdateOperationsInput | string
    startAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    requestedBy?: StringFieldUpdateOperationsInput | string
    approvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    qrCodeData?: NullableStringFieldUpdateOperationsInput | string | null
    checkoutAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    checkoutBy?: NullableStringFieldUpdateOperationsInput | string | null
    checkinAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    checkinBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutIzinNestedInput
  }

  export type IzinUncheckedUpdateWithoutSantriInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    reason?: StringFieldUpdateOperationsInput | string
    startAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    requestedBy?: StringFieldUpdateOperationsInput | string
    approvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    qrCodeData?: NullableStringFieldUpdateOperationsInput | string | null
    checkoutAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    checkoutBy?: NullableStringFieldUpdateOperationsInput | string | null
    checkinAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    checkinBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IzinUncheckedUpdateManyWithoutSantriInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    reason?: StringFieldUpdateOperationsInput | string
    startAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    requestedBy?: StringFieldUpdateOperationsInput | string
    approvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    qrCodeData?: NullableStringFieldUpdateOperationsInput | string | null
    checkoutAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    checkoutBy?: NullableStringFieldUpdateOperationsInput | string | null
    checkinAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    checkinBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CatatanHarianUpdateWithoutSantriInput = {
    id?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    content?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    attachments?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutCatatanHarianNestedInput
  }

  export type CatatanHarianUncheckedUpdateWithoutSantriInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    content?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    attachments?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CatatanHarianUncheckedUpdateManyWithoutSantriInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    content?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    attachments?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvoiceUpdateWithoutSantriInput = {
    id?: StringFieldUpdateOperationsInput | string
    amountDue?: FloatFieldUpdateOperationsInput | number
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutInvoicesNestedInput
    lines?: InvoiceLineUpdateManyWithoutInvoiceNestedInput
    payments?: PaymentUpdateManyWithoutInvoiceNestedInput
  }

  export type InvoiceUncheckedUpdateWithoutSantriInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    amountDue?: FloatFieldUpdateOperationsInput | number
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lines?: InvoiceLineUncheckedUpdateManyWithoutInvoiceNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutInvoiceNestedInput
  }

  export type InvoiceUncheckedUpdateManyWithoutSantriInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    amountDue?: FloatFieldUpdateOperationsInput | number
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PelanggaranUpdateWithoutSantriInput = {
    id?: StringFieldUpdateOperationsInput | string
    recordedBy?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    severity?: IntFieldUpdateOperationsInput | number
    points?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    resolved?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutPelanggaranNestedInput
  }

  export type PelanggaranUncheckedUpdateWithoutSantriInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    recordedBy?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    severity?: IntFieldUpdateOperationsInput | number
    points?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    resolved?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PelanggaranUncheckedUpdateManyWithoutSantriInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    recordedBy?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    severity?: IntFieldUpdateOperationsInput | number
    points?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    resolved?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PembinaanUpdateWithoutSantriInput = {
    id?: StringFieldUpdateOperationsInput | string
    plan?: StringFieldUpdateOperationsInput | string
    targetDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    assignedTo?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutPembinaanNestedInput
  }

  export type PembinaanUncheckedUpdateWithoutSantriInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    plan?: StringFieldUpdateOperationsInput | string
    targetDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    assignedTo?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PembinaanUncheckedUpdateManyWithoutSantriInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    plan?: StringFieldUpdateOperationsInput | string
    targetDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    assignedTo?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type KunjunganUpdateWithoutSantriInput = {
    id?: StringFieldUpdateOperationsInput | string
    scheduledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    slot?: StringFieldUpdateOperationsInput | string
    visitorLimit?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutKunjunganNestedInput
    tamu?: TamuUpdateManyWithoutKunjunganNestedInput
  }

  export type KunjunganUncheckedUpdateWithoutSantriInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    scheduledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    slot?: StringFieldUpdateOperationsInput | string
    visitorLimit?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tamu?: TamuUncheckedUpdateManyWithoutKunjunganNestedInput
  }

  export type KunjunganUncheckedUpdateManyWithoutSantriInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    scheduledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    slot?: StringFieldUpdateOperationsInput | string
    visitorLimit?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HealthRecordUpdateWithoutSantriInput = {
    id?: StringFieldUpdateOperationsInput | string
    recordedBy?: StringFieldUpdateOperationsInput | string
    symptoms?: StringFieldUpdateOperationsInput | string
    diagnosis?: NullableStringFieldUpdateOperationsInput | string | null
    actionTaken?: NullableStringFieldUpdateOperationsInput | string | null
    referred?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutHealthRecordsNestedInput
  }

  export type HealthRecordUncheckedUpdateWithoutSantriInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    recordedBy?: StringFieldUpdateOperationsInput | string
    symptoms?: StringFieldUpdateOperationsInput | string
    diagnosis?: NullableStringFieldUpdateOperationsInput | string | null
    actionTaken?: NullableStringFieldUpdateOperationsInput | string | null
    referred?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HealthRecordUncheckedUpdateManyWithoutSantriInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    recordedBy?: StringFieldUpdateOperationsInput | string
    symptoms?: StringFieldUpdateOperationsInput | string
    diagnosis?: NullableStringFieldUpdateOperationsInput | string | null
    actionTaken?: NullableStringFieldUpdateOperationsInput | string | null
    referred?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MedicationUpdateWithoutSantriInput = {
    id?: StringFieldUpdateOperationsInput | string
    medicineName?: StringFieldUpdateOperationsInput | string
    dose?: StringFieldUpdateOperationsInput | string
    schedule?: StringFieldUpdateOperationsInput | string
    givenBy?: NullableStringFieldUpdateOperationsInput | string | null
    givenAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MedicationUncheckedUpdateWithoutSantriInput = {
    id?: StringFieldUpdateOperationsInput | string
    medicineName?: StringFieldUpdateOperationsInput | string
    dose?: StringFieldUpdateOperationsInput | string
    schedule?: StringFieldUpdateOperationsInput | string
    givenBy?: NullableStringFieldUpdateOperationsInput | string | null
    givenAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MedicationUncheckedUpdateManyWithoutSantriInput = {
    id?: StringFieldUpdateOperationsInput | string
    medicineName?: StringFieldUpdateOperationsInput | string
    dose?: StringFieldUpdateOperationsInput | string
    schedule?: StringFieldUpdateOperationsInput | string
    givenBy?: NullableStringFieldUpdateOperationsInput | string | null
    givenAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TahfidzUpdateWithoutSantriInput = {
    id?: StringFieldUpdateOperationsInput | string
    surah?: StringFieldUpdateOperationsInput | string
    ayat?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    grade?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    recordedBy?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutTahfidzNestedInput
  }

  export type TahfidzUncheckedUpdateWithoutSantriInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    surah?: StringFieldUpdateOperationsInput | string
    ayat?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    grade?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    recordedBy?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TahfidzUncheckedUpdateManyWithoutSantriInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    surah?: StringFieldUpdateOperationsInput | string
    ayat?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    grade?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    recordedBy?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MutabaahUpdateWithoutSantriInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    sholatWajib?: BoolFieldUpdateOperationsInput | boolean
    tahajud?: BoolFieldUpdateOperationsInput | boolean
    dhuha?: BoolFieldUpdateOperationsInput | boolean
    puasaSunnah?: BoolFieldUpdateOperationsInput | boolean
    bacaQuran?: BoolFieldUpdateOperationsInput | boolean
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    recordedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutMutabaahNestedInput
  }

  export type MutabaahUncheckedUpdateWithoutSantriInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    sholatWajib?: BoolFieldUpdateOperationsInput | boolean
    tahajud?: BoolFieldUpdateOperationsInput | boolean
    dhuha?: BoolFieldUpdateOperationsInput | boolean
    puasaSunnah?: BoolFieldUpdateOperationsInput | boolean
    bacaQuran?: BoolFieldUpdateOperationsInput | boolean
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    recordedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MutabaahUncheckedUpdateManyWithoutSantriInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    sholatWajib?: BoolFieldUpdateOperationsInput | boolean
    tahajud?: BoolFieldUpdateOperationsInput | boolean
    dhuha?: BoolFieldUpdateOperationsInput | boolean
    puasaSunnah?: BoolFieldUpdateOperationsInput | boolean
    bacaQuran?: BoolFieldUpdateOperationsInput | boolean
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    recordedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AttendanceUpdateWithoutSantriInput = {
    id?: StringFieldUpdateOperationsInput | string
    scheduleId?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    recordedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutAttendancesNestedInput
  }

  export type AttendanceUncheckedUpdateWithoutSantriInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    scheduleId?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    recordedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AttendanceUncheckedUpdateManyWithoutSantriInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    scheduleId?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    recordedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GradeUpdateWithoutSantriInput = {
    id?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    semester?: StringFieldUpdateOperationsInput | string
    academicYear?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    score?: FloatFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutGradesNestedInput
  }

  export type GradeUncheckedUpdateWithoutSantriInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    semester?: StringFieldUpdateOperationsInput | string
    academicYear?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    score?: FloatFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GradeUncheckedUpdateManyWithoutSantriInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    semester?: StringFieldUpdateOperationsInput | string
    academicYear?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    score?: FloatFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SantriWaliCreateManyWaliInput = {
    santriId: string
    isPrimary?: boolean
  }

  export type SantriWaliUpdateWithoutWaliInput = {
    isPrimary?: BoolFieldUpdateOperationsInput | boolean
    santri?: SantriUpdateOneRequiredWithoutWalisNestedInput
  }

  export type SantriWaliUncheckedUpdateWithoutWaliInput = {
    santriId?: StringFieldUpdateOperationsInput | string
    isPrimary?: BoolFieldUpdateOperationsInput | boolean
  }

  export type SantriWaliUncheckedUpdateManyWithoutWaliInput = {
    santriId?: StringFieldUpdateOperationsInput | string
    isPrimary?: BoolFieldUpdateOperationsInput | boolean
  }

  export type InvoiceLineCreateManyInvoiceInput = {
    id?: string
    description: string
    amount: number
    type: string
  }

  export type PaymentCreateManyInvoiceInput = {
    id?: string
    method: string
    amount: number
    status?: string
    transactionRef?: string | null
    paidAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InvoiceLineUpdateWithoutInvoiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
  }

  export type InvoiceLineUncheckedUpdateWithoutInvoiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
  }

  export type InvoiceLineUncheckedUpdateManyWithoutInvoiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
  }

  export type PaymentUpdateWithoutInvoiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    method?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    transactionRef?: NullableStringFieldUpdateOperationsInput | string | null
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentUncheckedUpdateWithoutInvoiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    method?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    transactionRef?: NullableStringFieldUpdateOperationsInput | string | null
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentUncheckedUpdateManyWithoutInvoiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    method?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    transactionRef?: NullableStringFieldUpdateOperationsInput | string | null
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TamuCreateManyKunjunganInput = {
    id?: string
    name: string
    phone?: string | null
    idNumber?: string | null
    checkinAt?: Date | string | null
    createdAt?: Date | string
  }

  export type TamuUpdateWithoutKunjunganInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    idNumber?: NullableStringFieldUpdateOperationsInput | string | null
    checkinAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TamuUncheckedUpdateWithoutKunjunganInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    idNumber?: NullableStringFieldUpdateOperationsInput | string | null
    checkinAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TamuUncheckedUpdateManyWithoutKunjunganInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    idNumber?: NullableStringFieldUpdateOperationsInput | string | null
    checkinAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WalletTransactionCreateManyWalletInput = {
    id?: string
    amount: number
    type: string
    method: string
    description?: string | null
    reference?: string | null
    status?: string
    handledBy?: string | null
    createdAt?: Date | string
  }

  export type WalletTransactionUpdateWithoutWalletInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    method?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    handledBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WalletTransactionUncheckedUpdateWithoutWalletInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    method?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    handledBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WalletTransactionUncheckedUpdateManyWithoutWalletInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    method?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    handledBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PayrollCreateManyEmployeeInput = {
    id?: string
    tenantId: string
    month: number
    year: number
    baseSalary?: number
    allowances?: number
    deductions?: number
    netAmount: number
    status?: string
    paidAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PayrollUpdateWithoutEmployeeInput = {
    id?: StringFieldUpdateOperationsInput | string
    month?: IntFieldUpdateOperationsInput | number
    year?: IntFieldUpdateOperationsInput | number
    baseSalary?: FloatFieldUpdateOperationsInput | number
    allowances?: FloatFieldUpdateOperationsInput | number
    deductions?: FloatFieldUpdateOperationsInput | number
    netAmount?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutPayrollsNestedInput
  }

  export type PayrollUncheckedUpdateWithoutEmployeeInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    month?: IntFieldUpdateOperationsInput | number
    year?: IntFieldUpdateOperationsInput | number
    baseSalary?: FloatFieldUpdateOperationsInput | number
    allowances?: FloatFieldUpdateOperationsInput | number
    deductions?: FloatFieldUpdateOperationsInput | number
    netAmount?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PayrollUncheckedUpdateManyWithoutEmployeeInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    month?: IntFieldUpdateOperationsInput | number
    year?: IntFieldUpdateOperationsInput | number
    baseSalary?: FloatFieldUpdateOperationsInput | number
    allowances?: FloatFieldUpdateOperationsInput | number
    deductions?: FloatFieldUpdateOperationsInput | number
    netAmount?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PpdbDocumentCreateManyRegistrationInput = {
    id?: string
    tenantId: string
    documentType: string
    fileUrl: string
    isVerified?: boolean
    createdAt?: Date | string
  }

  export type PpdbExamCreateManyRegistrationInput = {
    id?: string
    tenantId: string
    examType: string
    examDate: Date | string
    score?: number | null
    result?: string | null
    interviewer?: string | null
    createdAt?: Date | string
  }

  export type PpdbDocumentUpdateWithoutRegistrationInput = {
    id?: StringFieldUpdateOperationsInput | string
    documentType?: StringFieldUpdateOperationsInput | string
    fileUrl?: StringFieldUpdateOperationsInput | string
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutPpdbDocumentsNestedInput
  }

  export type PpdbDocumentUncheckedUpdateWithoutRegistrationInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    documentType?: StringFieldUpdateOperationsInput | string
    fileUrl?: StringFieldUpdateOperationsInput | string
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PpdbDocumentUncheckedUpdateManyWithoutRegistrationInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    documentType?: StringFieldUpdateOperationsInput | string
    fileUrl?: StringFieldUpdateOperationsInput | string
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PpdbExamUpdateWithoutRegistrationInput = {
    id?: StringFieldUpdateOperationsInput | string
    examType?: StringFieldUpdateOperationsInput | string
    examDate?: DateTimeFieldUpdateOperationsInput | Date | string
    score?: NullableFloatFieldUpdateOperationsInput | number | null
    result?: NullableStringFieldUpdateOperationsInput | string | null
    interviewer?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutPpdbExamsNestedInput
  }

  export type PpdbExamUncheckedUpdateWithoutRegistrationInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    examType?: StringFieldUpdateOperationsInput | string
    examDate?: DateTimeFieldUpdateOperationsInput | Date | string
    score?: NullableFloatFieldUpdateOperationsInput | number | null
    result?: NullableStringFieldUpdateOperationsInput | string | null
    interviewer?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PpdbExamUncheckedUpdateManyWithoutRegistrationInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    examType?: StringFieldUpdateOperationsInput | string
    examDate?: DateTimeFieldUpdateOperationsInput | Date | string
    score?: NullableFloatFieldUpdateOperationsInput | number | null
    result?: NullableStringFieldUpdateOperationsInput | string | null
    interviewer?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InventoryTransactionCreateManyItemInput = {
    id?: string
    tenantId: string
    type: string
    quantity: number
    reference?: string | null
    notes?: string | null
    handledBy?: string | null
    date?: Date | string
  }

  export type InventoryTransactionUpdateWithoutItemInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    handledBy?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutInventoryTransactionsNestedInput
  }

  export type InventoryTransactionUncheckedUpdateWithoutItemInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    handledBy?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InventoryTransactionUncheckedUpdateManyWithoutItemInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    handledBy?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PurchaseOrderCreateManySupplierInput = {
    id?: string
    tenantId: string
    poNumber: string
    totalCost: number
    status?: string
    orderDate?: Date | string
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PurchaseOrderUpdateWithoutSupplierInput = {
    id?: StringFieldUpdateOperationsInput | string
    poNumber?: StringFieldUpdateOperationsInput | string
    totalCost?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    orderDate?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutPurchaseOrdersNestedInput
  }

  export type PurchaseOrderUncheckedUpdateWithoutSupplierInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    poNumber?: StringFieldUpdateOperationsInput | string
    totalCost?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    orderDate?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PurchaseOrderUncheckedUpdateManyWithoutSupplierInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    poNumber?: StringFieldUpdateOperationsInput | string
    totalCost?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    orderDate?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RoomCreateManyBuildingInput = {
    id?: string
    tenantId: string
    name: string
    capacity: number
    picName?: string | null
    createdAt?: Date | string
  }

  export type RoomUpdateWithoutBuildingInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    capacity?: IntFieldUpdateOperationsInput | number
    picName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutRoomsNestedInput
    assignments?: RoomAssignmentUpdateManyWithoutRoomNestedInput
    tickets?: MaintenanceTicketUpdateManyWithoutRoomNestedInput
  }

  export type RoomUncheckedUpdateWithoutBuildingInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    capacity?: IntFieldUpdateOperationsInput | number
    picName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignments?: RoomAssignmentUncheckedUpdateManyWithoutRoomNestedInput
    tickets?: MaintenanceTicketUncheckedUpdateManyWithoutRoomNestedInput
  }

  export type RoomUncheckedUpdateManyWithoutBuildingInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    capacity?: IntFieldUpdateOperationsInput | number
    picName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RoomAssignmentCreateManyRoomInput = {
    id?: string
    tenantId: string
    santriId: string
    startDate?: Date | string
    endDate?: Date | string | null
    status?: string
  }

  export type MaintenanceTicketCreateManyRoomInput = {
    id?: string
    tenantId: string
    title: string
    description: string
    priority?: string
    status?: string
    reportedBy: string
    resolvedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RoomAssignmentUpdateWithoutRoomInput = {
    id?: StringFieldUpdateOperationsInput | string
    santriId?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    tenant?: TenantUpdateOneRequiredWithoutRoomAssignmentsNestedInput
  }

  export type RoomAssignmentUncheckedUpdateWithoutRoomInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    santriId?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
  }

  export type RoomAssignmentUncheckedUpdateManyWithoutRoomInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    santriId?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
  }

  export type MaintenanceTicketUpdateWithoutRoomInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    reportedBy?: StringFieldUpdateOperationsInput | string
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutMaintenanceTicketsNestedInput
  }

  export type MaintenanceTicketUncheckedUpdateWithoutRoomInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    reportedBy?: StringFieldUpdateOperationsInput | string
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MaintenanceTicketUncheckedUpdateManyWithoutRoomInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    priority?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    reportedBy?: StringFieldUpdateOperationsInput | string
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Aliases for legacy arg types
   */
    /**
     * @deprecated Use TenantCountOutputTypeDefaultArgs instead
     */
    export type TenantCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TenantCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UserCountOutputTypeDefaultArgs instead
     */
    export type UserCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SantriCountOutputTypeDefaultArgs instead
     */
    export type SantriCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SantriCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use WaliCountOutputTypeDefaultArgs instead
     */
    export type WaliCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = WaliCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use InvoiceCountOutputTypeDefaultArgs instead
     */
    export type InvoiceCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = InvoiceCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use KunjunganCountOutputTypeDefaultArgs instead
     */
    export type KunjunganCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = KunjunganCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use WalletCountOutputTypeDefaultArgs instead
     */
    export type WalletCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = WalletCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use EmployeeCountOutputTypeDefaultArgs instead
     */
    export type EmployeeCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = EmployeeCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PpdbRegistrationCountOutputTypeDefaultArgs instead
     */
    export type PpdbRegistrationCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PpdbRegistrationCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ItemCountOutputTypeDefaultArgs instead
     */
    export type ItemCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ItemCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SupplierCountOutputTypeDefaultArgs instead
     */
    export type SupplierCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SupplierCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use BuildingCountOutputTypeDefaultArgs instead
     */
    export type BuildingCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = BuildingCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use RoomCountOutputTypeDefaultArgs instead
     */
    export type RoomCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = RoomCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TenantDefaultArgs instead
     */
    export type TenantArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TenantDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UserDefaultArgs instead
     */
    export type UserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserDefaultArgs<ExtArgs>
    /**
     * @deprecated Use RefreshTokenDefaultArgs instead
     */
    export type RefreshTokenArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = RefreshTokenDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SantriDefaultArgs instead
     */
    export type SantriArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SantriDefaultArgs<ExtArgs>
    /**
     * @deprecated Use WaliDefaultArgs instead
     */
    export type WaliArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = WaliDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SantriWaliDefaultArgs instead
     */
    export type SantriWaliArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SantriWaliDefaultArgs<ExtArgs>
    /**
     * @deprecated Use IzinDefaultArgs instead
     */
    export type IzinArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = IzinDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CatatanHarianDefaultArgs instead
     */
    export type CatatanHarianArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CatatanHarianDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PengumumanDefaultArgs instead
     */
    export type PengumumanArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PengumumanDefaultArgs<ExtArgs>
    /**
     * @deprecated Use InvoiceDefaultArgs instead
     */
    export type InvoiceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = InvoiceDefaultArgs<ExtArgs>
    /**
     * @deprecated Use InvoiceLineDefaultArgs instead
     */
    export type InvoiceLineArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = InvoiceLineDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PaymentDefaultArgs instead
     */
    export type PaymentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PaymentDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PelanggaranDefaultArgs instead
     */
    export type PelanggaranArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PelanggaranDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PembinaanDefaultArgs instead
     */
    export type PembinaanArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PembinaanDefaultArgs<ExtArgs>
    /**
     * @deprecated Use KunjunganDefaultArgs instead
     */
    export type KunjunganArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = KunjunganDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TamuDefaultArgs instead
     */
    export type TamuArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TamuDefaultArgs<ExtArgs>
    /**
     * @deprecated Use HealthRecordDefaultArgs instead
     */
    export type HealthRecordArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = HealthRecordDefaultArgs<ExtArgs>
    /**
     * @deprecated Use MedicationDefaultArgs instead
     */
    export type MedicationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = MedicationDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AuditLogDefaultArgs instead
     */
    export type AuditLogArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AuditLogDefaultArgs<ExtArgs>
    /**
     * @deprecated Use NotificationDefaultArgs instead
     */
    export type NotificationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = NotificationDefaultArgs<ExtArgs>
    /**
     * @deprecated Use WebhookEventDefaultArgs instead
     */
    export type WebhookEventArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = WebhookEventDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TahfidzDefaultArgs instead
     */
    export type TahfidzArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TahfidzDefaultArgs<ExtArgs>
    /**
     * @deprecated Use MutabaahDefaultArgs instead
     */
    export type MutabaahArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = MutabaahDefaultArgs<ExtArgs>
    /**
     * @deprecated Use WalletDefaultArgs instead
     */
    export type WalletArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = WalletDefaultArgs<ExtArgs>
    /**
     * @deprecated Use WalletTransactionDefaultArgs instead
     */
    export type WalletTransactionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = WalletTransactionDefaultArgs<ExtArgs>
    /**
     * @deprecated Use EmployeeDefaultArgs instead
     */
    export type EmployeeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = EmployeeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PayrollDefaultArgs instead
     */
    export type PayrollArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PayrollDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AcademicScheduleDefaultArgs instead
     */
    export type AcademicScheduleArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AcademicScheduleDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AttendanceDefaultArgs instead
     */
    export type AttendanceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AttendanceDefaultArgs<ExtArgs>
    /**
     * @deprecated Use GradeDefaultArgs instead
     */
    export type GradeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = GradeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PpdbRegistrationDefaultArgs instead
     */
    export type PpdbRegistrationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PpdbRegistrationDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PpdbDocumentDefaultArgs instead
     */
    export type PpdbDocumentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PpdbDocumentDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PpdbExamDefaultArgs instead
     */
    export type PpdbExamArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PpdbExamDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ItemDefaultArgs instead
     */
    export type ItemArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ItemDefaultArgs<ExtArgs>
    /**
     * @deprecated Use InventoryTransactionDefaultArgs instead
     */
    export type InventoryTransactionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = InventoryTransactionDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SupplierDefaultArgs instead
     */
    export type SupplierArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SupplierDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PurchaseOrderDefaultArgs instead
     */
    export type PurchaseOrderArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PurchaseOrderDefaultArgs<ExtArgs>
    /**
     * @deprecated Use BuildingDefaultArgs instead
     */
    export type BuildingArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = BuildingDefaultArgs<ExtArgs>
    /**
     * @deprecated Use RoomDefaultArgs instead
     */
    export type RoomArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = RoomDefaultArgs<ExtArgs>
    /**
     * @deprecated Use RoomAssignmentDefaultArgs instead
     */
    export type RoomAssignmentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = RoomAssignmentDefaultArgs<ExtArgs>
    /**
     * @deprecated Use MaintenanceTicketDefaultArgs instead
     */
    export type MaintenanceTicketArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = MaintenanceTicketDefaultArgs<ExtArgs>

  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}