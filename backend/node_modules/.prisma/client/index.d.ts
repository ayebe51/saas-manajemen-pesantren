
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model Tenant
 * 
 */
export type Tenant = $Result.DefaultSelection<Prisma.$TenantPayload>
/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model RefreshToken
 * 
 */
export type RefreshToken = $Result.DefaultSelection<Prisma.$RefreshTokenPayload>
/**
 * Model Santri
 * 
 */
export type Santri = $Result.DefaultSelection<Prisma.$SantriPayload>
/**
 * Model Wali
 * 
 */
export type Wali = $Result.DefaultSelection<Prisma.$WaliPayload>
/**
 * Model SantriWali
 * 
 */
export type SantriWali = $Result.DefaultSelection<Prisma.$SantriWaliPayload>
/**
 * Model Izin
 * 
 */
export type Izin = $Result.DefaultSelection<Prisma.$IzinPayload>
/**
 * Model CatatanHarian
 * 
 */
export type CatatanHarian = $Result.DefaultSelection<Prisma.$CatatanHarianPayload>
/**
 * Model Pengumuman
 * 
 */
export type Pengumuman = $Result.DefaultSelection<Prisma.$PengumumanPayload>
/**
 * Model Invoice
 * 
 */
export type Invoice = $Result.DefaultSelection<Prisma.$InvoicePayload>
/**
 * Model InvoiceLine
 * 
 */
export type InvoiceLine = $Result.DefaultSelection<Prisma.$InvoiceLinePayload>
/**
 * Model Payment
 * 
 */
export type Payment = $Result.DefaultSelection<Prisma.$PaymentPayload>
/**
 * Model Pelanggaran
 * 
 */
export type Pelanggaran = $Result.DefaultSelection<Prisma.$PelanggaranPayload>
/**
 * Model Pembinaan
 * 
 */
export type Pembinaan = $Result.DefaultSelection<Prisma.$PembinaanPayload>
/**
 * Model Kunjungan
 * 
 */
export type Kunjungan = $Result.DefaultSelection<Prisma.$KunjunganPayload>
/**
 * Model Tamu
 * 
 */
export type Tamu = $Result.DefaultSelection<Prisma.$TamuPayload>
/**
 * Model HealthRecord
 * 
 */
export type HealthRecord = $Result.DefaultSelection<Prisma.$HealthRecordPayload>
/**
 * Model Medication
 * 
 */
export type Medication = $Result.DefaultSelection<Prisma.$MedicationPayload>
/**
 * Model AuditLog
 * 
 */
export type AuditLog = $Result.DefaultSelection<Prisma.$AuditLogPayload>
/**
 * Model Notification
 * 
 */
export type Notification = $Result.DefaultSelection<Prisma.$NotificationPayload>
/**
 * Model WebhookEvent
 * 
 */
export type WebhookEvent = $Result.DefaultSelection<Prisma.$WebhookEventPayload>

/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Tenants
 * const tenants = await prisma.tenant.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Tenants
   * const tenants = await prisma.tenant.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb, ExtArgs>

      /**
   * `prisma.tenant`: Exposes CRUD operations for the **Tenant** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Tenants
    * const tenants = await prisma.tenant.findMany()
    * ```
    */
  get tenant(): Prisma.TenantDelegate<ExtArgs>;

  /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs>;

  /**
   * `prisma.refreshToken`: Exposes CRUD operations for the **RefreshToken** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RefreshTokens
    * const refreshTokens = await prisma.refreshToken.findMany()
    * ```
    */
  get refreshToken(): Prisma.RefreshTokenDelegate<ExtArgs>;

  /**
   * `prisma.santri`: Exposes CRUD operations for the **Santri** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Santris
    * const santris = await prisma.santri.findMany()
    * ```
    */
  get santri(): Prisma.SantriDelegate<ExtArgs>;

  /**
   * `prisma.wali`: Exposes CRUD operations for the **Wali** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Walis
    * const walis = await prisma.wali.findMany()
    * ```
    */
  get wali(): Prisma.WaliDelegate<ExtArgs>;

  /**
   * `prisma.santriWali`: Exposes CRUD operations for the **SantriWali** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SantriWalis
    * const santriWalis = await prisma.santriWali.findMany()
    * ```
    */
  get santriWali(): Prisma.SantriWaliDelegate<ExtArgs>;

  /**
   * `prisma.izin`: Exposes CRUD operations for the **Izin** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Izins
    * const izins = await prisma.izin.findMany()
    * ```
    */
  get izin(): Prisma.IzinDelegate<ExtArgs>;

  /**
   * `prisma.catatanHarian`: Exposes CRUD operations for the **CatatanHarian** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CatatanHarians
    * const catatanHarians = await prisma.catatanHarian.findMany()
    * ```
    */
  get catatanHarian(): Prisma.CatatanHarianDelegate<ExtArgs>;

  /**
   * `prisma.pengumuman`: Exposes CRUD operations for the **Pengumuman** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Pengumumen
    * const pengumumen = await prisma.pengumuman.findMany()
    * ```
    */
  get pengumuman(): Prisma.PengumumanDelegate<ExtArgs>;

  /**
   * `prisma.invoice`: Exposes CRUD operations for the **Invoice** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Invoices
    * const invoices = await prisma.invoice.findMany()
    * ```
    */
  get invoice(): Prisma.InvoiceDelegate<ExtArgs>;

  /**
   * `prisma.invoiceLine`: Exposes CRUD operations for the **InvoiceLine** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more InvoiceLines
    * const invoiceLines = await prisma.invoiceLine.findMany()
    * ```
    */
  get invoiceLine(): Prisma.InvoiceLineDelegate<ExtArgs>;

  /**
   * `prisma.payment`: Exposes CRUD operations for the **Payment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Payments
    * const payments = await prisma.payment.findMany()
    * ```
    */
  get payment(): Prisma.PaymentDelegate<ExtArgs>;

  /**
   * `prisma.pelanggaran`: Exposes CRUD operations for the **Pelanggaran** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Pelanggarans
    * const pelanggarans = await prisma.pelanggaran.findMany()
    * ```
    */
  get pelanggaran(): Prisma.PelanggaranDelegate<ExtArgs>;

  /**
   * `prisma.pembinaan`: Exposes CRUD operations for the **Pembinaan** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Pembinaans
    * const pembinaans = await prisma.pembinaan.findMany()
    * ```
    */
  get pembinaan(): Prisma.PembinaanDelegate<ExtArgs>;

  /**
   * `prisma.kunjungan`: Exposes CRUD operations for the **Kunjungan** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Kunjungans
    * const kunjungans = await prisma.kunjungan.findMany()
    * ```
    */
  get kunjungan(): Prisma.KunjunganDelegate<ExtArgs>;

  /**
   * `prisma.tamu`: Exposes CRUD operations for the **Tamu** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Tamus
    * const tamus = await prisma.tamu.findMany()
    * ```
    */
  get tamu(): Prisma.TamuDelegate<ExtArgs>;

  /**
   * `prisma.healthRecord`: Exposes CRUD operations for the **HealthRecord** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more HealthRecords
    * const healthRecords = await prisma.healthRecord.findMany()
    * ```
    */
  get healthRecord(): Prisma.HealthRecordDelegate<ExtArgs>;

  /**
   * `prisma.medication`: Exposes CRUD operations for the **Medication** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Medications
    * const medications = await prisma.medication.findMany()
    * ```
    */
  get medication(): Prisma.MedicationDelegate<ExtArgs>;

  /**
   * `prisma.auditLog`: Exposes CRUD operations for the **AuditLog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AuditLogs
    * const auditLogs = await prisma.auditLog.findMany()
    * ```
    */
  get auditLog(): Prisma.AuditLogDelegate<ExtArgs>;

  /**
   * `prisma.notification`: Exposes CRUD operations for the **Notification** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Notifications
    * const notifications = await prisma.notification.findMany()
    * ```
    */
  get notification(): Prisma.NotificationDelegate<ExtArgs>;

  /**
   * `prisma.webhookEvent`: Exposes CRUD operations for the **WebhookEvent** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more WebhookEvents
    * const webhookEvents = await prisma.webhookEvent.findMany()
    * ```
    */
  get webhookEvent(): Prisma.WebhookEventDelegate<ExtArgs>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 5.22.0
   * Query Engine version: 605197351a3c8bdd595af2d2a9bc3025bca48ea2
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    Tenant: 'Tenant',
    User: 'User',
    RefreshToken: 'RefreshToken',
    Santri: 'Santri',
    Wali: 'Wali',
    SantriWali: 'SantriWali',
    Izin: 'Izin',
    CatatanHarian: 'CatatanHarian',
    Pengumuman: 'Pengumuman',
    Invoice: 'Invoice',
    InvoiceLine: 'InvoiceLine',
    Payment: 'Payment',
    Pelanggaran: 'Pelanggaran',
    Pembinaan: 'Pembinaan',
    Kunjungan: 'Kunjungan',
    Tamu: 'Tamu',
    HealthRecord: 'HealthRecord',
    Medication: 'Medication',
    AuditLog: 'AuditLog',
    Notification: 'Notification',
    WebhookEvent: 'WebhookEvent'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb extends $Utils.Fn<{extArgs: $Extensions.InternalArgs, clientOptions: PrismaClientOptions }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], this['params']['clientOptions']>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> = {
    meta: {
      modelProps: "tenant" | "user" | "refreshToken" | "santri" | "wali" | "santriWali" | "izin" | "catatanHarian" | "pengumuman" | "invoice" | "invoiceLine" | "payment" | "pelanggaran" | "pembinaan" | "kunjungan" | "tamu" | "healthRecord" | "medication" | "auditLog" | "notification" | "webhookEvent"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      Tenant: {
        payload: Prisma.$TenantPayload<ExtArgs>
        fields: Prisma.TenantFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TenantFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TenantFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantPayload>
          }
          findFirst: {
            args: Prisma.TenantFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TenantFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantPayload>
          }
          findMany: {
            args: Prisma.TenantFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantPayload>[]
          }
          create: {
            args: Prisma.TenantCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantPayload>
          }
          createMany: {
            args: Prisma.TenantCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TenantCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantPayload>[]
          }
          delete: {
            args: Prisma.TenantDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantPayload>
          }
          update: {
            args: Prisma.TenantUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantPayload>
          }
          deleteMany: {
            args: Prisma.TenantDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TenantUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.TenantUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantPayload>
          }
          aggregate: {
            args: Prisma.TenantAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTenant>
          }
          groupBy: {
            args: Prisma.TenantGroupByArgs<ExtArgs>
            result: $Utils.Optional<TenantGroupByOutputType>[]
          }
          count: {
            args: Prisma.TenantCountArgs<ExtArgs>
            result: $Utils.Optional<TenantCountAggregateOutputType> | number
          }
        }
      }
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      RefreshToken: {
        payload: Prisma.$RefreshTokenPayload<ExtArgs>
        fields: Prisma.RefreshTokenFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RefreshTokenFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefreshTokenPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RefreshTokenFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefreshTokenPayload>
          }
          findFirst: {
            args: Prisma.RefreshTokenFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefreshTokenPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RefreshTokenFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefreshTokenPayload>
          }
          findMany: {
            args: Prisma.RefreshTokenFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefreshTokenPayload>[]
          }
          create: {
            args: Prisma.RefreshTokenCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefreshTokenPayload>
          }
          createMany: {
            args: Prisma.RefreshTokenCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RefreshTokenCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefreshTokenPayload>[]
          }
          delete: {
            args: Prisma.RefreshTokenDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefreshTokenPayload>
          }
          update: {
            args: Prisma.RefreshTokenUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefreshTokenPayload>
          }
          deleteMany: {
            args: Prisma.RefreshTokenDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RefreshTokenUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.RefreshTokenUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefreshTokenPayload>
          }
          aggregate: {
            args: Prisma.RefreshTokenAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRefreshToken>
          }
          groupBy: {
            args: Prisma.RefreshTokenGroupByArgs<ExtArgs>
            result: $Utils.Optional<RefreshTokenGroupByOutputType>[]
          }
          count: {
            args: Prisma.RefreshTokenCountArgs<ExtArgs>
            result: $Utils.Optional<RefreshTokenCountAggregateOutputType> | number
          }
        }
      }
      Santri: {
        payload: Prisma.$SantriPayload<ExtArgs>
        fields: Prisma.SantriFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SantriFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SantriPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SantriFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SantriPayload>
          }
          findFirst: {
            args: Prisma.SantriFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SantriPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SantriFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SantriPayload>
          }
          findMany: {
            args: Prisma.SantriFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SantriPayload>[]
          }
          create: {
            args: Prisma.SantriCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SantriPayload>
          }
          createMany: {
            args: Prisma.SantriCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SantriCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SantriPayload>[]
          }
          delete: {
            args: Prisma.SantriDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SantriPayload>
          }
          update: {
            args: Prisma.SantriUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SantriPayload>
          }
          deleteMany: {
            args: Prisma.SantriDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SantriUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SantriUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SantriPayload>
          }
          aggregate: {
            args: Prisma.SantriAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSantri>
          }
          groupBy: {
            args: Prisma.SantriGroupByArgs<ExtArgs>
            result: $Utils.Optional<SantriGroupByOutputType>[]
          }
          count: {
            args: Prisma.SantriCountArgs<ExtArgs>
            result: $Utils.Optional<SantriCountAggregateOutputType> | number
          }
        }
      }
      Wali: {
        payload: Prisma.$WaliPayload<ExtArgs>
        fields: Prisma.WaliFieldRefs
        operations: {
          findUnique: {
            args: Prisma.WaliFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WaliPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.WaliFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WaliPayload>
          }
          findFirst: {
            args: Prisma.WaliFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WaliPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.WaliFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WaliPayload>
          }
          findMany: {
            args: Prisma.WaliFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WaliPayload>[]
          }
          create: {
            args: Prisma.WaliCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WaliPayload>
          }
          createMany: {
            args: Prisma.WaliCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.WaliCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WaliPayload>[]
          }
          delete: {
            args: Prisma.WaliDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WaliPayload>
          }
          update: {
            args: Prisma.WaliUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WaliPayload>
          }
          deleteMany: {
            args: Prisma.WaliDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.WaliUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.WaliUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WaliPayload>
          }
          aggregate: {
            args: Prisma.WaliAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateWali>
          }
          groupBy: {
            args: Prisma.WaliGroupByArgs<ExtArgs>
            result: $Utils.Optional<WaliGroupByOutputType>[]
          }
          count: {
            args: Prisma.WaliCountArgs<ExtArgs>
            result: $Utils.Optional<WaliCountAggregateOutputType> | number
          }
        }
      }
      SantriWali: {
        payload: Prisma.$SantriWaliPayload<ExtArgs>
        fields: Prisma.SantriWaliFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SantriWaliFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SantriWaliPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SantriWaliFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SantriWaliPayload>
          }
          findFirst: {
            args: Prisma.SantriWaliFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SantriWaliPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SantriWaliFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SantriWaliPayload>
          }
          findMany: {
            args: Prisma.SantriWaliFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SantriWaliPayload>[]
          }
          create: {
            args: Prisma.SantriWaliCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SantriWaliPayload>
          }
          createMany: {
            args: Prisma.SantriWaliCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SantriWaliCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SantriWaliPayload>[]
          }
          delete: {
            args: Prisma.SantriWaliDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SantriWaliPayload>
          }
          update: {
            args: Prisma.SantriWaliUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SantriWaliPayload>
          }
          deleteMany: {
            args: Prisma.SantriWaliDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SantriWaliUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SantriWaliUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SantriWaliPayload>
          }
          aggregate: {
            args: Prisma.SantriWaliAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSantriWali>
          }
          groupBy: {
            args: Prisma.SantriWaliGroupByArgs<ExtArgs>
            result: $Utils.Optional<SantriWaliGroupByOutputType>[]
          }
          count: {
            args: Prisma.SantriWaliCountArgs<ExtArgs>
            result: $Utils.Optional<SantriWaliCountAggregateOutputType> | number
          }
        }
      }
      Izin: {
        payload: Prisma.$IzinPayload<ExtArgs>
        fields: Prisma.IzinFieldRefs
        operations: {
          findUnique: {
            args: Prisma.IzinFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IzinPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.IzinFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IzinPayload>
          }
          findFirst: {
            args: Prisma.IzinFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IzinPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.IzinFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IzinPayload>
          }
          findMany: {
            args: Prisma.IzinFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IzinPayload>[]
          }
          create: {
            args: Prisma.IzinCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IzinPayload>
          }
          createMany: {
            args: Prisma.IzinCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.IzinCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IzinPayload>[]
          }
          delete: {
            args: Prisma.IzinDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IzinPayload>
          }
          update: {
            args: Prisma.IzinUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IzinPayload>
          }
          deleteMany: {
            args: Prisma.IzinDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.IzinUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.IzinUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IzinPayload>
          }
          aggregate: {
            args: Prisma.IzinAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateIzin>
          }
          groupBy: {
            args: Prisma.IzinGroupByArgs<ExtArgs>
            result: $Utils.Optional<IzinGroupByOutputType>[]
          }
          count: {
            args: Prisma.IzinCountArgs<ExtArgs>
            result: $Utils.Optional<IzinCountAggregateOutputType> | number
          }
        }
      }
      CatatanHarian: {
        payload: Prisma.$CatatanHarianPayload<ExtArgs>
        fields: Prisma.CatatanHarianFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CatatanHarianFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CatatanHarianPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CatatanHarianFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CatatanHarianPayload>
          }
          findFirst: {
            args: Prisma.CatatanHarianFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CatatanHarianPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CatatanHarianFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CatatanHarianPayload>
          }
          findMany: {
            args: Prisma.CatatanHarianFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CatatanHarianPayload>[]
          }
          create: {
            args: Prisma.CatatanHarianCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CatatanHarianPayload>
          }
          createMany: {
            args: Prisma.CatatanHarianCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CatatanHarianCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CatatanHarianPayload>[]
          }
          delete: {
            args: Prisma.CatatanHarianDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CatatanHarianPayload>
          }
          update: {
            args: Prisma.CatatanHarianUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CatatanHarianPayload>
          }
          deleteMany: {
            args: Prisma.CatatanHarianDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CatatanHarianUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CatatanHarianUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CatatanHarianPayload>
          }
          aggregate: {
            args: Prisma.CatatanHarianAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCatatanHarian>
          }
          groupBy: {
            args: Prisma.CatatanHarianGroupByArgs<ExtArgs>
            result: $Utils.Optional<CatatanHarianGroupByOutputType>[]
          }
          count: {
            args: Prisma.CatatanHarianCountArgs<ExtArgs>
            result: $Utils.Optional<CatatanHarianCountAggregateOutputType> | number
          }
        }
      }
      Pengumuman: {
        payload: Prisma.$PengumumanPayload<ExtArgs>
        fields: Prisma.PengumumanFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PengumumanFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PengumumanPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PengumumanFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PengumumanPayload>
          }
          findFirst: {
            args: Prisma.PengumumanFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PengumumanPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PengumumanFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PengumumanPayload>
          }
          findMany: {
            args: Prisma.PengumumanFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PengumumanPayload>[]
          }
          create: {
            args: Prisma.PengumumanCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PengumumanPayload>
          }
          createMany: {
            args: Prisma.PengumumanCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PengumumanCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PengumumanPayload>[]
          }
          delete: {
            args: Prisma.PengumumanDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PengumumanPayload>
          }
          update: {
            args: Prisma.PengumumanUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PengumumanPayload>
          }
          deleteMany: {
            args: Prisma.PengumumanDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PengumumanUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PengumumanUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PengumumanPayload>
          }
          aggregate: {
            args: Prisma.PengumumanAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePengumuman>
          }
          groupBy: {
            args: Prisma.PengumumanGroupByArgs<ExtArgs>
            result: $Utils.Optional<PengumumanGroupByOutputType>[]
          }
          count: {
            args: Prisma.PengumumanCountArgs<ExtArgs>
            result: $Utils.Optional<PengumumanCountAggregateOutputType> | number
          }
        }
      }
      Invoice: {
        payload: Prisma.$InvoicePayload<ExtArgs>
        fields: Prisma.InvoiceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.InvoiceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.InvoiceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>
          }
          findFirst: {
            args: Prisma.InvoiceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.InvoiceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>
          }
          findMany: {
            args: Prisma.InvoiceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>[]
          }
          create: {
            args: Prisma.InvoiceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>
          }
          createMany: {
            args: Prisma.InvoiceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.InvoiceCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>[]
          }
          delete: {
            args: Prisma.InvoiceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>
          }
          update: {
            args: Prisma.InvoiceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>
          }
          deleteMany: {
            args: Prisma.InvoiceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.InvoiceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.InvoiceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>
          }
          aggregate: {
            args: Prisma.InvoiceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateInvoice>
          }
          groupBy: {
            args: Prisma.InvoiceGroupByArgs<ExtArgs>
            result: $Utils.Optional<InvoiceGroupByOutputType>[]
          }
          count: {
            args: Prisma.InvoiceCountArgs<ExtArgs>
            result: $Utils.Optional<InvoiceCountAggregateOutputType> | number
          }
        }
      }
      InvoiceLine: {
        payload: Prisma.$InvoiceLinePayload<ExtArgs>
        fields: Prisma.InvoiceLineFieldRefs
        operations: {
          findUnique: {
            args: Prisma.InvoiceLineFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoiceLinePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.InvoiceLineFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoiceLinePayload>
          }
          findFirst: {
            args: Prisma.InvoiceLineFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoiceLinePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.InvoiceLineFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoiceLinePayload>
          }
          findMany: {
            args: Prisma.InvoiceLineFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoiceLinePayload>[]
          }
          create: {
            args: Prisma.InvoiceLineCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoiceLinePayload>
          }
          createMany: {
            args: Prisma.InvoiceLineCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.InvoiceLineCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoiceLinePayload>[]
          }
          delete: {
            args: Prisma.InvoiceLineDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoiceLinePayload>
          }
          update: {
            args: Prisma.InvoiceLineUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoiceLinePayload>
          }
          deleteMany: {
            args: Prisma.InvoiceLineDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.InvoiceLineUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.InvoiceLineUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoiceLinePayload>
          }
          aggregate: {
            args: Prisma.InvoiceLineAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateInvoiceLine>
          }
          groupBy: {
            args: Prisma.InvoiceLineGroupByArgs<ExtArgs>
            result: $Utils.Optional<InvoiceLineGroupByOutputType>[]
          }
          count: {
            args: Prisma.InvoiceLineCountArgs<ExtArgs>
            result: $Utils.Optional<InvoiceLineCountAggregateOutputType> | number
          }
        }
      }
      Payment: {
        payload: Prisma.$PaymentPayload<ExtArgs>
        fields: Prisma.PaymentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PaymentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PaymentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          findFirst: {
            args: Prisma.PaymentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PaymentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          findMany: {
            args: Prisma.PaymentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>[]
          }
          create: {
            args: Prisma.PaymentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          createMany: {
            args: Prisma.PaymentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PaymentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>[]
          }
          delete: {
            args: Prisma.PaymentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          update: {
            args: Prisma.PaymentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          deleteMany: {
            args: Prisma.PaymentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PaymentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PaymentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          aggregate: {
            args: Prisma.PaymentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePayment>
          }
          groupBy: {
            args: Prisma.PaymentGroupByArgs<ExtArgs>
            result: $Utils.Optional<PaymentGroupByOutputType>[]
          }
          count: {
            args: Prisma.PaymentCountArgs<ExtArgs>
            result: $Utils.Optional<PaymentCountAggregateOutputType> | number
          }
        }
      }
      Pelanggaran: {
        payload: Prisma.$PelanggaranPayload<ExtArgs>
        fields: Prisma.PelanggaranFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PelanggaranFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PelanggaranPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PelanggaranFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PelanggaranPayload>
          }
          findFirst: {
            args: Prisma.PelanggaranFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PelanggaranPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PelanggaranFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PelanggaranPayload>
          }
          findMany: {
            args: Prisma.PelanggaranFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PelanggaranPayload>[]
          }
          create: {
            args: Prisma.PelanggaranCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PelanggaranPayload>
          }
          createMany: {
            args: Prisma.PelanggaranCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PelanggaranCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PelanggaranPayload>[]
          }
          delete: {
            args: Prisma.PelanggaranDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PelanggaranPayload>
          }
          update: {
            args: Prisma.PelanggaranUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PelanggaranPayload>
          }
          deleteMany: {
            args: Prisma.PelanggaranDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PelanggaranUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PelanggaranUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PelanggaranPayload>
          }
          aggregate: {
            args: Prisma.PelanggaranAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePelanggaran>
          }
          groupBy: {
            args: Prisma.PelanggaranGroupByArgs<ExtArgs>
            result: $Utils.Optional<PelanggaranGroupByOutputType>[]
          }
          count: {
            args: Prisma.PelanggaranCountArgs<ExtArgs>
            result: $Utils.Optional<PelanggaranCountAggregateOutputType> | number
          }
        }
      }
      Pembinaan: {
        payload: Prisma.$PembinaanPayload<ExtArgs>
        fields: Prisma.PembinaanFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PembinaanFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PembinaanPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PembinaanFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PembinaanPayload>
          }
          findFirst: {
            args: Prisma.PembinaanFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PembinaanPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PembinaanFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PembinaanPayload>
          }
          findMany: {
            args: Prisma.PembinaanFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PembinaanPayload>[]
          }
          create: {
            args: Prisma.PembinaanCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PembinaanPayload>
          }
          createMany: {
            args: Prisma.PembinaanCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PembinaanCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PembinaanPayload>[]
          }
          delete: {
            args: Prisma.PembinaanDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PembinaanPayload>
          }
          update: {
            args: Prisma.PembinaanUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PembinaanPayload>
          }
          deleteMany: {
            args: Prisma.PembinaanDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PembinaanUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PembinaanUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PembinaanPayload>
          }
          aggregate: {
            args: Prisma.PembinaanAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePembinaan>
          }
          groupBy: {
            args: Prisma.PembinaanGroupByArgs<ExtArgs>
            result: $Utils.Optional<PembinaanGroupByOutputType>[]
          }
          count: {
            args: Prisma.PembinaanCountArgs<ExtArgs>
            result: $Utils.Optional<PembinaanCountAggregateOutputType> | number
          }
        }
      }
      Kunjungan: {
        payload: Prisma.$KunjunganPayload<ExtArgs>
        fields: Prisma.KunjunganFieldRefs
        operations: {
          findUnique: {
            args: Prisma.KunjunganFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KunjunganPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.KunjunganFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KunjunganPayload>
          }
          findFirst: {
            args: Prisma.KunjunganFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KunjunganPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.KunjunganFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KunjunganPayload>
          }
          findMany: {
            args: Prisma.KunjunganFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KunjunganPayload>[]
          }
          create: {
            args: Prisma.KunjunganCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KunjunganPayload>
          }
          createMany: {
            args: Prisma.KunjunganCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.KunjunganCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KunjunganPayload>[]
          }
          delete: {
            args: Prisma.KunjunganDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KunjunganPayload>
          }
          update: {
            args: Prisma.KunjunganUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KunjunganPayload>
          }
          deleteMany: {
            args: Prisma.KunjunganDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.KunjunganUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.KunjunganUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KunjunganPayload>
          }
          aggregate: {
            args: Prisma.KunjunganAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateKunjungan>
          }
          groupBy: {
            args: Prisma.KunjunganGroupByArgs<ExtArgs>
            result: $Utils.Optional<KunjunganGroupByOutputType>[]
          }
          count: {
            args: Prisma.KunjunganCountArgs<ExtArgs>
            result: $Utils.Optional<KunjunganCountAggregateOutputType> | number
          }
        }
      }
      Tamu: {
        payload: Prisma.$TamuPayload<ExtArgs>
        fields: Prisma.TamuFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TamuFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TamuPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TamuFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TamuPayload>
          }
          findFirst: {
            args: Prisma.TamuFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TamuPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TamuFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TamuPayload>
          }
          findMany: {
            args: Prisma.TamuFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TamuPayload>[]
          }
          create: {
            args: Prisma.TamuCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TamuPayload>
          }
          createMany: {
            args: Prisma.TamuCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TamuCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TamuPayload>[]
          }
          delete: {
            args: Prisma.TamuDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TamuPayload>
          }
          update: {
            args: Prisma.TamuUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TamuPayload>
          }
          deleteMany: {
            args: Prisma.TamuDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TamuUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.TamuUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TamuPayload>
          }
          aggregate: {
            args: Prisma.TamuAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTamu>
          }
          groupBy: {
            args: Prisma.TamuGroupByArgs<ExtArgs>
            result: $Utils.Optional<TamuGroupByOutputType>[]
          }
          count: {
            args: Prisma.TamuCountArgs<ExtArgs>
            result: $Utils.Optional<TamuCountAggregateOutputType> | number
          }
        }
      }
      HealthRecord: {
        payload: Prisma.$HealthRecordPayload<ExtArgs>
        fields: Prisma.HealthRecordFieldRefs
        operations: {
          findUnique: {
            args: Prisma.HealthRecordFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HealthRecordPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.HealthRecordFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HealthRecordPayload>
          }
          findFirst: {
            args: Prisma.HealthRecordFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HealthRecordPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.HealthRecordFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HealthRecordPayload>
          }
          findMany: {
            args: Prisma.HealthRecordFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HealthRecordPayload>[]
          }
          create: {
            args: Prisma.HealthRecordCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HealthRecordPayload>
          }
          createMany: {
            args: Prisma.HealthRecordCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.HealthRecordCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HealthRecordPayload>[]
          }
          delete: {
            args: Prisma.HealthRecordDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HealthRecordPayload>
          }
          update: {
            args: Prisma.HealthRecordUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HealthRecordPayload>
          }
          deleteMany: {
            args: Prisma.HealthRecordDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.HealthRecordUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.HealthRecordUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HealthRecordPayload>
          }
          aggregate: {
            args: Prisma.HealthRecordAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateHealthRecord>
          }
          groupBy: {
            args: Prisma.HealthRecordGroupByArgs<ExtArgs>
            result: $Utils.Optional<HealthRecordGroupByOutputType>[]
          }
          count: {
            args: Prisma.HealthRecordCountArgs<ExtArgs>
            result: $Utils.Optional<HealthRecordCountAggregateOutputType> | number
          }
        }
      }
      Medication: {
        payload: Prisma.$MedicationPayload<ExtArgs>
        fields: Prisma.MedicationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MedicationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MedicationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicationPayload>
          }
          findFirst: {
            args: Prisma.MedicationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MedicationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicationPayload>
          }
          findMany: {
            args: Prisma.MedicationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicationPayload>[]
          }
          create: {
            args: Prisma.MedicationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicationPayload>
          }
          createMany: {
            args: Prisma.MedicationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MedicationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicationPayload>[]
          }
          delete: {
            args: Prisma.MedicationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicationPayload>
          }
          update: {
            args: Prisma.MedicationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicationPayload>
          }
          deleteMany: {
            args: Prisma.MedicationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MedicationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.MedicationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicationPayload>
          }
          aggregate: {
            args: Prisma.MedicationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMedication>
          }
          groupBy: {
            args: Prisma.MedicationGroupByArgs<ExtArgs>
            result: $Utils.Optional<MedicationGroupByOutputType>[]
          }
          count: {
            args: Prisma.MedicationCountArgs<ExtArgs>
            result: $Utils.Optional<MedicationCountAggregateOutputType> | number
          }
        }
      }
      AuditLog: {
        payload: Prisma.$AuditLogPayload<ExtArgs>
        fields: Prisma.AuditLogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AuditLogFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AuditLogFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          findFirst: {
            args: Prisma.AuditLogFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AuditLogFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          findMany: {
            args: Prisma.AuditLogFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>[]
          }
          create: {
            args: Prisma.AuditLogCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          createMany: {
            args: Prisma.AuditLogCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AuditLogCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>[]
          }
          delete: {
            args: Prisma.AuditLogDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          update: {
            args: Prisma.AuditLogUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          deleteMany: {
            args: Prisma.AuditLogDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AuditLogUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AuditLogUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          aggregate: {
            args: Prisma.AuditLogAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAuditLog>
          }
          groupBy: {
            args: Prisma.AuditLogGroupByArgs<ExtArgs>
            result: $Utils.Optional<AuditLogGroupByOutputType>[]
          }
          count: {
            args: Prisma.AuditLogCountArgs<ExtArgs>
            result: $Utils.Optional<AuditLogCountAggregateOutputType> | number
          }
        }
      }
      Notification: {
        payload: Prisma.$NotificationPayload<ExtArgs>
        fields: Prisma.NotificationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.NotificationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.NotificationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          findFirst: {
            args: Prisma.NotificationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.NotificationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          findMany: {
            args: Prisma.NotificationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>[]
          }
          create: {
            args: Prisma.NotificationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          createMany: {
            args: Prisma.NotificationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.NotificationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>[]
          }
          delete: {
            args: Prisma.NotificationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          update: {
            args: Prisma.NotificationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          deleteMany: {
            args: Prisma.NotificationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.NotificationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.NotificationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          aggregate: {
            args: Prisma.NotificationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNotification>
          }
          groupBy: {
            args: Prisma.NotificationGroupByArgs<ExtArgs>
            result: $Utils.Optional<NotificationGroupByOutputType>[]
          }
          count: {
            args: Prisma.NotificationCountArgs<ExtArgs>
            result: $Utils.Optional<NotificationCountAggregateOutputType> | number
          }
        }
      }
      WebhookEvent: {
        payload: Prisma.$WebhookEventPayload<ExtArgs>
        fields: Prisma.WebhookEventFieldRefs
        operations: {
          findUnique: {
            args: Prisma.WebhookEventFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebhookEventPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.WebhookEventFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebhookEventPayload>
          }
          findFirst: {
            args: Prisma.WebhookEventFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebhookEventPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.WebhookEventFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebhookEventPayload>
          }
          findMany: {
            args: Prisma.WebhookEventFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebhookEventPayload>[]
          }
          create: {
            args: Prisma.WebhookEventCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebhookEventPayload>
          }
          createMany: {
            args: Prisma.WebhookEventCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.WebhookEventCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebhookEventPayload>[]
          }
          delete: {
            args: Prisma.WebhookEventDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebhookEventPayload>
          }
          update: {
            args: Prisma.WebhookEventUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebhookEventPayload>
          }
          deleteMany: {
            args: Prisma.WebhookEventDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.WebhookEventUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.WebhookEventUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WebhookEventPayload>
          }
          aggregate: {
            args: Prisma.WebhookEventAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateWebhookEvent>
          }
          groupBy: {
            args: Prisma.WebhookEventGroupByArgs<ExtArgs>
            result: $Utils.Optional<WebhookEventGroupByOutputType>[]
          }
          count: {
            args: Prisma.WebhookEventCountArgs<ExtArgs>
            result: $Utils.Optional<WebhookEventCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
  }


  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type TenantCountOutputType
   */

  export type TenantCountOutputType = {
    users: number
    santri: number
    wali: number
    izin: number
    catatanHarian: number
    pengumuman: number
    invoices: number
    pelanggaran: number
    pembinaan: number
    kunjungan: number
    healthRecords: number
    auditLogs: number
    notifications: number
    webhookEvents: number
  }

  export type TenantCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | TenantCountOutputTypeCountUsersArgs
    santri?: boolean | TenantCountOutputTypeCountSantriArgs
    wali?: boolean | TenantCountOutputTypeCountWaliArgs
    izin?: boolean | TenantCountOutputTypeCountIzinArgs
    catatanHarian?: boolean | TenantCountOutputTypeCountCatatanHarianArgs
    pengumuman?: boolean | TenantCountOutputTypeCountPengumumanArgs
    invoices?: boolean | TenantCountOutputTypeCountInvoicesArgs
    pelanggaran?: boolean | TenantCountOutputTypeCountPelanggaranArgs
    pembinaan?: boolean | TenantCountOutputTypeCountPembinaanArgs
    kunjungan?: boolean | TenantCountOutputTypeCountKunjunganArgs
    healthRecords?: boolean | TenantCountOutputTypeCountHealthRecordsArgs
    auditLogs?: boolean | TenantCountOutputTypeCountAuditLogsArgs
    notifications?: boolean | TenantCountOutputTypeCountNotificationsArgs
    webhookEvents?: boolean | TenantCountOutputTypeCountWebhookEventsArgs
  }

  // Custom InputTypes
  /**
   * TenantCountOutputType without action
   */
  export type TenantCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TenantCountOutputType
     */
    select?: TenantCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TenantCountOutputType without action
   */
  export type TenantCountOutputTypeCountUsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
  }

  /**
   * TenantCountOutputType without action
   */
  export type TenantCountOutputTypeCountSantriArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SantriWhereInput
  }

  /**
   * TenantCountOutputType without action
   */
  export type TenantCountOutputTypeCountWaliArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WaliWhereInput
  }

  /**
   * TenantCountOutputType without action
   */
  export type TenantCountOutputTypeCountIzinArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: IzinWhereInput
  }

  /**
   * TenantCountOutputType without action
   */
  export type TenantCountOutputTypeCountCatatanHarianArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CatatanHarianWhereInput
  }

  /**
   * TenantCountOutputType without action
   */
  export type TenantCountOutputTypeCountPengumumanArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PengumumanWhereInput
  }

  /**
   * TenantCountOutputType without action
   */
  export type TenantCountOutputTypeCountInvoicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InvoiceWhereInput
  }

  /**
   * TenantCountOutputType without action
   */
  export type TenantCountOutputTypeCountPelanggaranArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PelanggaranWhereInput
  }

  /**
   * TenantCountOutputType without action
   */
  export type TenantCountOutputTypeCountPembinaanArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PembinaanWhereInput
  }

  /**
   * TenantCountOutputType without action
   */
  export type TenantCountOutputTypeCountKunjunganArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: KunjunganWhereInput
  }

  /**
   * TenantCountOutputType without action
   */
  export type TenantCountOutputTypeCountHealthRecordsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: HealthRecordWhereInput
  }

  /**
   * TenantCountOutputType without action
   */
  export type TenantCountOutputTypeCountAuditLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AuditLogWhereInput
  }

  /**
   * TenantCountOutputType without action
   */
  export type TenantCountOutputTypeCountNotificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationWhereInput
  }

  /**
   * TenantCountOutputType without action
   */
  export type TenantCountOutputTypeCountWebhookEventsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WebhookEventWhereInput
  }


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    refreshTokens: number
    auditLogs: number
    notifications: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    refreshTokens?: boolean | UserCountOutputTypeCountRefreshTokensArgs
    auditLogs?: boolean | UserCountOutputTypeCountAuditLogsArgs
    notifications?: boolean | UserCountOutputTypeCountNotificationsArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountRefreshTokensArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RefreshTokenWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAuditLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AuditLogWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountNotificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationWhereInput
  }


  /**
   * Count Type SantriCountOutputType
   */

  export type SantriCountOutputType = {
    walis: number
    izin: number
    catatanHarian: number
    invoices: number
    pelanggaran: number
    pembinaan: number
    kunjungan: number
    healthRecords: number
    medications: number
  }

  export type SantriCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    walis?: boolean | SantriCountOutputTypeCountWalisArgs
    izin?: boolean | SantriCountOutputTypeCountIzinArgs
    catatanHarian?: boolean | SantriCountOutputTypeCountCatatanHarianArgs
    invoices?: boolean | SantriCountOutputTypeCountInvoicesArgs
    pelanggaran?: boolean | SantriCountOutputTypeCountPelanggaranArgs
    pembinaan?: boolean | SantriCountOutputTypeCountPembinaanArgs
    kunjungan?: boolean | SantriCountOutputTypeCountKunjunganArgs
    healthRecords?: boolean | SantriCountOutputTypeCountHealthRecordsArgs
    medications?: boolean | SantriCountOutputTypeCountMedicationsArgs
  }

  // Custom InputTypes
  /**
   * SantriCountOutputType without action
   */
  export type SantriCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SantriCountOutputType
     */
    select?: SantriCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * SantriCountOutputType without action
   */
  export type SantriCountOutputTypeCountWalisArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SantriWaliWhereInput
  }

  /**
   * SantriCountOutputType without action
   */
  export type SantriCountOutputTypeCountIzinArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: IzinWhereInput
  }

  /**
   * SantriCountOutputType without action
   */
  export type SantriCountOutputTypeCountCatatanHarianArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CatatanHarianWhereInput
  }

  /**
   * SantriCountOutputType without action
   */
  export type SantriCountOutputTypeCountInvoicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InvoiceWhereInput
  }

  /**
   * SantriCountOutputType without action
   */
  export type SantriCountOutputTypeCountPelanggaranArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PelanggaranWhereInput
  }

  /**
   * SantriCountOutputType without action
   */
  export type SantriCountOutputTypeCountPembinaanArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PembinaanWhereInput
  }

  /**
   * SantriCountOutputType without action
   */
  export type SantriCountOutputTypeCountKunjunganArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: KunjunganWhereInput
  }

  /**
   * SantriCountOutputType without action
   */
  export type SantriCountOutputTypeCountHealthRecordsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: HealthRecordWhereInput
  }

  /**
   * SantriCountOutputType without action
   */
  export type SantriCountOutputTypeCountMedicationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MedicationWhereInput
  }


  /**
   * Count Type WaliCountOutputType
   */

  export type WaliCountOutputType = {
    santris: number
  }

  export type WaliCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    santris?: boolean | WaliCountOutputTypeCountSantrisArgs
  }

  // Custom InputTypes
  /**
   * WaliCountOutputType without action
   */
  export type WaliCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WaliCountOutputType
     */
    select?: WaliCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * WaliCountOutputType without action
   */
  export type WaliCountOutputTypeCountSantrisArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SantriWaliWhereInput
  }


  /**
   * Count Type InvoiceCountOutputType
   */

  export type InvoiceCountOutputType = {
    lines: number
    payments: number
  }

  export type InvoiceCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    lines?: boolean | InvoiceCountOutputTypeCountLinesArgs
    payments?: boolean | InvoiceCountOutputTypeCountPaymentsArgs
  }

  // Custom InputTypes
  /**
   * InvoiceCountOutputType without action
   */
  export type InvoiceCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceCountOutputType
     */
    select?: InvoiceCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * InvoiceCountOutputType without action
   */
  export type InvoiceCountOutputTypeCountLinesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InvoiceLineWhereInput
  }

  /**
   * InvoiceCountOutputType without action
   */
  export type InvoiceCountOutputTypeCountPaymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PaymentWhereInput
  }


  /**
   * Count Type KunjunganCountOutputType
   */

  export type KunjunganCountOutputType = {
    tamu: number
  }

  export type KunjunganCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tamu?: boolean | KunjunganCountOutputTypeCountTamuArgs
  }

  // Custom InputTypes
  /**
   * KunjunganCountOutputType without action
   */
  export type KunjunganCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KunjunganCountOutputType
     */
    select?: KunjunganCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * KunjunganCountOutputType without action
   */
  export type KunjunganCountOutputTypeCountTamuArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TamuWhereInput
  }


  /**
   * Models
   */

  /**
   * Model Tenant
   */

  export type AggregateTenant = {
    _count: TenantCountAggregateOutputType | null
    _min: TenantMinAggregateOutputType | null
    _max: TenantMaxAggregateOutputType | null
  }

  export type TenantMinAggregateOutputType = {
    id: string | null
    name: string | null
    address: string | null
    phone: string | null
    adminUserId: string | null
    timezone: string | null
    plan: string | null
    billingContact: string | null
    status: string | null
    settings: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TenantMaxAggregateOutputType = {
    id: string | null
    name: string | null
    address: string | null
    phone: string | null
    adminUserId: string | null
    timezone: string | null
    plan: string | null
    billingContact: string | null
    status: string | null
    settings: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TenantCountAggregateOutputType = {
    id: number
    name: number
    address: number
    phone: number
    adminUserId: number
    timezone: number
    plan: number
    billingContact: number
    status: number
    settings: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type TenantMinAggregateInputType = {
    id?: true
    name?: true
    address?: true
    phone?: true
    adminUserId?: true
    timezone?: true
    plan?: true
    billingContact?: true
    status?: true
    settings?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TenantMaxAggregateInputType = {
    id?: true
    name?: true
    address?: true
    phone?: true
    adminUserId?: true
    timezone?: true
    plan?: true
    billingContact?: true
    status?: true
    settings?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TenantCountAggregateInputType = {
    id?: true
    name?: true
    address?: true
    phone?: true
    adminUserId?: true
    timezone?: true
    plan?: true
    billingContact?: true
    status?: true
    settings?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type TenantAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Tenant to aggregate.
     */
    where?: TenantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tenants to fetch.
     */
    orderBy?: TenantOrderByWithRelationInput | TenantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TenantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tenants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tenants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Tenants
    **/
    _count?: true | TenantCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TenantMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TenantMaxAggregateInputType
  }

  export type GetTenantAggregateType<T extends TenantAggregateArgs> = {
        [P in keyof T & keyof AggregateTenant]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTenant[P]>
      : GetScalarType<T[P], AggregateTenant[P]>
  }




  export type TenantGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TenantWhereInput
    orderBy?: TenantOrderByWithAggregationInput | TenantOrderByWithAggregationInput[]
    by: TenantScalarFieldEnum[] | TenantScalarFieldEnum
    having?: TenantScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TenantCountAggregateInputType | true
    _min?: TenantMinAggregateInputType
    _max?: TenantMaxAggregateInputType
  }

  export type TenantGroupByOutputType = {
    id: string
    name: string
    address: string | null
    phone: string | null
    adminUserId: string | null
    timezone: string
    plan: string
    billingContact: string | null
    status: string
    settings: string | null
    createdAt: Date
    updatedAt: Date
    _count: TenantCountAggregateOutputType | null
    _min: TenantMinAggregateOutputType | null
    _max: TenantMaxAggregateOutputType | null
  }

  type GetTenantGroupByPayload<T extends TenantGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TenantGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TenantGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TenantGroupByOutputType[P]>
            : GetScalarType<T[P], TenantGroupByOutputType[P]>
        }
      >
    >


  export type TenantSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    address?: boolean
    phone?: boolean
    adminUserId?: boolean
    timezone?: boolean
    plan?: boolean
    billingContact?: boolean
    status?: boolean
    settings?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    users?: boolean | Tenant$usersArgs<ExtArgs>
    santri?: boolean | Tenant$santriArgs<ExtArgs>
    wali?: boolean | Tenant$waliArgs<ExtArgs>
    izin?: boolean | Tenant$izinArgs<ExtArgs>
    catatanHarian?: boolean | Tenant$catatanHarianArgs<ExtArgs>
    pengumuman?: boolean | Tenant$pengumumanArgs<ExtArgs>
    invoices?: boolean | Tenant$invoicesArgs<ExtArgs>
    pelanggaran?: boolean | Tenant$pelanggaranArgs<ExtArgs>
    pembinaan?: boolean | Tenant$pembinaanArgs<ExtArgs>
    kunjungan?: boolean | Tenant$kunjunganArgs<ExtArgs>
    healthRecords?: boolean | Tenant$healthRecordsArgs<ExtArgs>
    auditLogs?: boolean | Tenant$auditLogsArgs<ExtArgs>
    notifications?: boolean | Tenant$notificationsArgs<ExtArgs>
    webhookEvents?: boolean | Tenant$webhookEventsArgs<ExtArgs>
    _count?: boolean | TenantCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tenant"]>

  export type TenantSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    address?: boolean
    phone?: boolean
    adminUserId?: boolean
    timezone?: boolean
    plan?: boolean
    billingContact?: boolean
    status?: boolean
    settings?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["tenant"]>

  export type TenantSelectScalar = {
    id?: boolean
    name?: boolean
    address?: boolean
    phone?: boolean
    adminUserId?: boolean
    timezone?: boolean
    plan?: boolean
    billingContact?: boolean
    status?: boolean
    settings?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type TenantInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | Tenant$usersArgs<ExtArgs>
    santri?: boolean | Tenant$santriArgs<ExtArgs>
    wali?: boolean | Tenant$waliArgs<ExtArgs>
    izin?: boolean | Tenant$izinArgs<ExtArgs>
    catatanHarian?: boolean | Tenant$catatanHarianArgs<ExtArgs>
    pengumuman?: boolean | Tenant$pengumumanArgs<ExtArgs>
    invoices?: boolean | Tenant$invoicesArgs<ExtArgs>
    pelanggaran?: boolean | Tenant$pelanggaranArgs<ExtArgs>
    pembinaan?: boolean | Tenant$pembinaanArgs<ExtArgs>
    kunjungan?: boolean | Tenant$kunjunganArgs<ExtArgs>
    healthRecords?: boolean | Tenant$healthRecordsArgs<ExtArgs>
    auditLogs?: boolean | Tenant$auditLogsArgs<ExtArgs>
    notifications?: boolean | Tenant$notificationsArgs<ExtArgs>
    webhookEvents?: boolean | Tenant$webhookEventsArgs<ExtArgs>
    _count?: boolean | TenantCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type TenantIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $TenantPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Tenant"
    objects: {
      users: Prisma.$UserPayload<ExtArgs>[]
      santri: Prisma.$SantriPayload<ExtArgs>[]
      wali: Prisma.$WaliPayload<ExtArgs>[]
      izin: Prisma.$IzinPayload<ExtArgs>[]
      catatanHarian: Prisma.$CatatanHarianPayload<ExtArgs>[]
      pengumuman: Prisma.$PengumumanPayload<ExtArgs>[]
      invoices: Prisma.$InvoicePayload<ExtArgs>[]
      pelanggaran: Prisma.$PelanggaranPayload<ExtArgs>[]
      pembinaan: Prisma.$PembinaanPayload<ExtArgs>[]
      kunjungan: Prisma.$KunjunganPayload<ExtArgs>[]
      healthRecords: Prisma.$HealthRecordPayload<ExtArgs>[]
      auditLogs: Prisma.$AuditLogPayload<ExtArgs>[]
      notifications: Prisma.$NotificationPayload<ExtArgs>[]
      webhookEvents: Prisma.$WebhookEventPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      address: string | null
      phone: string | null
      adminUserId: string | null
      timezone: string
      plan: string
      billingContact: string | null
      status: string
      settings: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["tenant"]>
    composites: {}
  }

  type TenantGetPayload<S extends boolean | null | undefined | TenantDefaultArgs> = $Result.GetResult<Prisma.$TenantPayload, S>

  type TenantCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<TenantFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: TenantCountAggregateInputType | true
    }

  export interface TenantDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Tenant'], meta: { name: 'Tenant' } }
    /**
     * Find zero or one Tenant that matches the filter.
     * @param {TenantFindUniqueArgs} args - Arguments to find a Tenant
     * @example
     * // Get one Tenant
     * const tenant = await prisma.tenant.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TenantFindUniqueArgs>(args: SelectSubset<T, TenantFindUniqueArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Tenant that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {TenantFindUniqueOrThrowArgs} args - Arguments to find a Tenant
     * @example
     * // Get one Tenant
     * const tenant = await prisma.tenant.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TenantFindUniqueOrThrowArgs>(args: SelectSubset<T, TenantFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Tenant that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenantFindFirstArgs} args - Arguments to find a Tenant
     * @example
     * // Get one Tenant
     * const tenant = await prisma.tenant.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TenantFindFirstArgs>(args?: SelectSubset<T, TenantFindFirstArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Tenant that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenantFindFirstOrThrowArgs} args - Arguments to find a Tenant
     * @example
     * // Get one Tenant
     * const tenant = await prisma.tenant.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TenantFindFirstOrThrowArgs>(args?: SelectSubset<T, TenantFindFirstOrThrowArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Tenants that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenantFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Tenants
     * const tenants = await prisma.tenant.findMany()
     * 
     * // Get first 10 Tenants
     * const tenants = await prisma.tenant.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const tenantWithIdOnly = await prisma.tenant.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TenantFindManyArgs>(args?: SelectSubset<T, TenantFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Tenant.
     * @param {TenantCreateArgs} args - Arguments to create a Tenant.
     * @example
     * // Create one Tenant
     * const Tenant = await prisma.tenant.create({
     *   data: {
     *     // ... data to create a Tenant
     *   }
     * })
     * 
     */
    create<T extends TenantCreateArgs>(args: SelectSubset<T, TenantCreateArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Tenants.
     * @param {TenantCreateManyArgs} args - Arguments to create many Tenants.
     * @example
     * // Create many Tenants
     * const tenant = await prisma.tenant.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TenantCreateManyArgs>(args?: SelectSubset<T, TenantCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Tenants and returns the data saved in the database.
     * @param {TenantCreateManyAndReturnArgs} args - Arguments to create many Tenants.
     * @example
     * // Create many Tenants
     * const tenant = await prisma.tenant.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Tenants and only return the `id`
     * const tenantWithIdOnly = await prisma.tenant.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TenantCreateManyAndReturnArgs>(args?: SelectSubset<T, TenantCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Tenant.
     * @param {TenantDeleteArgs} args - Arguments to delete one Tenant.
     * @example
     * // Delete one Tenant
     * const Tenant = await prisma.tenant.delete({
     *   where: {
     *     // ... filter to delete one Tenant
     *   }
     * })
     * 
     */
    delete<T extends TenantDeleteArgs>(args: SelectSubset<T, TenantDeleteArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Tenant.
     * @param {TenantUpdateArgs} args - Arguments to update one Tenant.
     * @example
     * // Update one Tenant
     * const tenant = await prisma.tenant.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TenantUpdateArgs>(args: SelectSubset<T, TenantUpdateArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Tenants.
     * @param {TenantDeleteManyArgs} args - Arguments to filter Tenants to delete.
     * @example
     * // Delete a few Tenants
     * const { count } = await prisma.tenant.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TenantDeleteManyArgs>(args?: SelectSubset<T, TenantDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tenants.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenantUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Tenants
     * const tenant = await prisma.tenant.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TenantUpdateManyArgs>(args: SelectSubset<T, TenantUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Tenant.
     * @param {TenantUpsertArgs} args - Arguments to update or create a Tenant.
     * @example
     * // Update or create a Tenant
     * const tenant = await prisma.tenant.upsert({
     *   create: {
     *     // ... data to create a Tenant
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Tenant we want to update
     *   }
     * })
     */
    upsert<T extends TenantUpsertArgs>(args: SelectSubset<T, TenantUpsertArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Tenants.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenantCountArgs} args - Arguments to filter Tenants to count.
     * @example
     * // Count the number of Tenants
     * const count = await prisma.tenant.count({
     *   where: {
     *     // ... the filter for the Tenants we want to count
     *   }
     * })
    **/
    count<T extends TenantCountArgs>(
      args?: Subset<T, TenantCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TenantCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Tenant.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenantAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TenantAggregateArgs>(args: Subset<T, TenantAggregateArgs>): Prisma.PrismaPromise<GetTenantAggregateType<T>>

    /**
     * Group by Tenant.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenantGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TenantGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TenantGroupByArgs['orderBy'] }
        : { orderBy?: TenantGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TenantGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTenantGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Tenant model
   */
  readonly fields: TenantFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Tenant.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TenantClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    users<T extends Tenant$usersArgs<ExtArgs> = {}>(args?: Subset<T, Tenant$usersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany"> | Null>
    santri<T extends Tenant$santriArgs<ExtArgs> = {}>(args?: Subset<T, Tenant$santriArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SantriPayload<ExtArgs>, T, "findMany"> | Null>
    wali<T extends Tenant$waliArgs<ExtArgs> = {}>(args?: Subset<T, Tenant$waliArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WaliPayload<ExtArgs>, T, "findMany"> | Null>
    izin<T extends Tenant$izinArgs<ExtArgs> = {}>(args?: Subset<T, Tenant$izinArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IzinPayload<ExtArgs>, T, "findMany"> | Null>
    catatanHarian<T extends Tenant$catatanHarianArgs<ExtArgs> = {}>(args?: Subset<T, Tenant$catatanHarianArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CatatanHarianPayload<ExtArgs>, T, "findMany"> | Null>
    pengumuman<T extends Tenant$pengumumanArgs<ExtArgs> = {}>(args?: Subset<T, Tenant$pengumumanArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PengumumanPayload<ExtArgs>, T, "findMany"> | Null>
    invoices<T extends Tenant$invoicesArgs<ExtArgs> = {}>(args?: Subset<T, Tenant$invoicesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findMany"> | Null>
    pelanggaran<T extends Tenant$pelanggaranArgs<ExtArgs> = {}>(args?: Subset<T, Tenant$pelanggaranArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PelanggaranPayload<ExtArgs>, T, "findMany"> | Null>
    pembinaan<T extends Tenant$pembinaanArgs<ExtArgs> = {}>(args?: Subset<T, Tenant$pembinaanArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PembinaanPayload<ExtArgs>, T, "findMany"> | Null>
    kunjungan<T extends Tenant$kunjunganArgs<ExtArgs> = {}>(args?: Subset<T, Tenant$kunjunganArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$KunjunganPayload<ExtArgs>, T, "findMany"> | Null>
    healthRecords<T extends Tenant$healthRecordsArgs<ExtArgs> = {}>(args?: Subset<T, Tenant$healthRecordsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HealthRecordPayload<ExtArgs>, T, "findMany"> | Null>
    auditLogs<T extends Tenant$auditLogsArgs<ExtArgs> = {}>(args?: Subset<T, Tenant$auditLogsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findMany"> | Null>
    notifications<T extends Tenant$notificationsArgs<ExtArgs> = {}>(args?: Subset<T, Tenant$notificationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findMany"> | Null>
    webhookEvents<T extends Tenant$webhookEventsArgs<ExtArgs> = {}>(args?: Subset<T, Tenant$webhookEventsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WebhookEventPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Tenant model
   */ 
  interface TenantFieldRefs {
    readonly id: FieldRef<"Tenant", 'String'>
    readonly name: FieldRef<"Tenant", 'String'>
    readonly address: FieldRef<"Tenant", 'String'>
    readonly phone: FieldRef<"Tenant", 'String'>
    readonly adminUserId: FieldRef<"Tenant", 'String'>
    readonly timezone: FieldRef<"Tenant", 'String'>
    readonly plan: FieldRef<"Tenant", 'String'>
    readonly billingContact: FieldRef<"Tenant", 'String'>
    readonly status: FieldRef<"Tenant", 'String'>
    readonly settings: FieldRef<"Tenant", 'String'>
    readonly createdAt: FieldRef<"Tenant", 'DateTime'>
    readonly updatedAt: FieldRef<"Tenant", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Tenant findUnique
   */
  export type TenantFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tenant
     */
    select?: TenantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantInclude<ExtArgs> | null
    /**
     * Filter, which Tenant to fetch.
     */
    where: TenantWhereUniqueInput
  }

  /**
   * Tenant findUniqueOrThrow
   */
  export type TenantFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tenant
     */
    select?: TenantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantInclude<ExtArgs> | null
    /**
     * Filter, which Tenant to fetch.
     */
    where: TenantWhereUniqueInput
  }

  /**
   * Tenant findFirst
   */
  export type TenantFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tenant
     */
    select?: TenantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantInclude<ExtArgs> | null
    /**
     * Filter, which Tenant to fetch.
     */
    where?: TenantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tenants to fetch.
     */
    orderBy?: TenantOrderByWithRelationInput | TenantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tenants.
     */
    cursor?: TenantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tenants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tenants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tenants.
     */
    distinct?: TenantScalarFieldEnum | TenantScalarFieldEnum[]
  }

  /**
   * Tenant findFirstOrThrow
   */
  export type TenantFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tenant
     */
    select?: TenantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantInclude<ExtArgs> | null
    /**
     * Filter, which Tenant to fetch.
     */
    where?: TenantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tenants to fetch.
     */
    orderBy?: TenantOrderByWithRelationInput | TenantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tenants.
     */
    cursor?: TenantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tenants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tenants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tenants.
     */
    distinct?: TenantScalarFieldEnum | TenantScalarFieldEnum[]
  }

  /**
   * Tenant findMany
   */
  export type TenantFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tenant
     */
    select?: TenantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantInclude<ExtArgs> | null
    /**
     * Filter, which Tenants to fetch.
     */
    where?: TenantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tenants to fetch.
     */
    orderBy?: TenantOrderByWithRelationInput | TenantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Tenants.
     */
    cursor?: TenantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tenants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tenants.
     */
    skip?: number
    distinct?: TenantScalarFieldEnum | TenantScalarFieldEnum[]
  }

  /**
   * Tenant create
   */
  export type TenantCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tenant
     */
    select?: TenantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantInclude<ExtArgs> | null
    /**
     * The data needed to create a Tenant.
     */
    data: XOR<TenantCreateInput, TenantUncheckedCreateInput>
  }

  /**
   * Tenant createMany
   */
  export type TenantCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Tenants.
     */
    data: TenantCreateManyInput | TenantCreateManyInput[]
  }

  /**
   * Tenant createManyAndReturn
   */
  export type TenantCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tenant
     */
    select?: TenantSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Tenants.
     */
    data: TenantCreateManyInput | TenantCreateManyInput[]
  }

  /**
   * Tenant update
   */
  export type TenantUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tenant
     */
    select?: TenantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantInclude<ExtArgs> | null
    /**
     * The data needed to update a Tenant.
     */
    data: XOR<TenantUpdateInput, TenantUncheckedUpdateInput>
    /**
     * Choose, which Tenant to update.
     */
    where: TenantWhereUniqueInput
  }

  /**
   * Tenant updateMany
   */
  export type TenantUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Tenants.
     */
    data: XOR<TenantUpdateManyMutationInput, TenantUncheckedUpdateManyInput>
    /**
     * Filter which Tenants to update
     */
    where?: TenantWhereInput
  }

  /**
   * Tenant upsert
   */
  export type TenantUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tenant
     */
    select?: TenantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantInclude<ExtArgs> | null
    /**
     * The filter to search for the Tenant to update in case it exists.
     */
    where: TenantWhereUniqueInput
    /**
     * In case the Tenant found by the `where` argument doesn't exist, create a new Tenant with this data.
     */
    create: XOR<TenantCreateInput, TenantUncheckedCreateInput>
    /**
     * In case the Tenant was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TenantUpdateInput, TenantUncheckedUpdateInput>
  }

  /**
   * Tenant delete
   */
  export type TenantDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tenant
     */
    select?: TenantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantInclude<ExtArgs> | null
    /**
     * Filter which Tenant to delete.
     */
    where: TenantWhereUniqueInput
  }

  /**
   * Tenant deleteMany
   */
  export type TenantDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Tenants to delete
     */
    where?: TenantWhereInput
  }

  /**
   * Tenant.users
   */
  export type Tenant$usersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    cursor?: UserWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * Tenant.santri
   */
  export type Tenant$santriArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Santri
     */
    select?: SantriSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SantriInclude<ExtArgs> | null
    where?: SantriWhereInput
    orderBy?: SantriOrderByWithRelationInput | SantriOrderByWithRelationInput[]
    cursor?: SantriWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SantriScalarFieldEnum | SantriScalarFieldEnum[]
  }

  /**
   * Tenant.wali
   */
  export type Tenant$waliArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Wali
     */
    select?: WaliSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WaliInclude<ExtArgs> | null
    where?: WaliWhereInput
    orderBy?: WaliOrderByWithRelationInput | WaliOrderByWithRelationInput[]
    cursor?: WaliWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WaliScalarFieldEnum | WaliScalarFieldEnum[]
  }

  /**
   * Tenant.izin
   */
  export type Tenant$izinArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Izin
     */
    select?: IzinSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IzinInclude<ExtArgs> | null
    where?: IzinWhereInput
    orderBy?: IzinOrderByWithRelationInput | IzinOrderByWithRelationInput[]
    cursor?: IzinWhereUniqueInput
    take?: number
    skip?: number
    distinct?: IzinScalarFieldEnum | IzinScalarFieldEnum[]
  }

  /**
   * Tenant.catatanHarian
   */
  export type Tenant$catatanHarianArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CatatanHarian
     */
    select?: CatatanHarianSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CatatanHarianInclude<ExtArgs> | null
    where?: CatatanHarianWhereInput
    orderBy?: CatatanHarianOrderByWithRelationInput | CatatanHarianOrderByWithRelationInput[]
    cursor?: CatatanHarianWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CatatanHarianScalarFieldEnum | CatatanHarianScalarFieldEnum[]
  }

  /**
   * Tenant.pengumuman
   */
  export type Tenant$pengumumanArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pengumuman
     */
    select?: PengumumanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PengumumanInclude<ExtArgs> | null
    where?: PengumumanWhereInput
    orderBy?: PengumumanOrderByWithRelationInput | PengumumanOrderByWithRelationInput[]
    cursor?: PengumumanWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PengumumanScalarFieldEnum | PengumumanScalarFieldEnum[]
  }

  /**
   * Tenant.invoices
   */
  export type Tenant$invoicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    where?: InvoiceWhereInput
    orderBy?: InvoiceOrderByWithRelationInput | InvoiceOrderByWithRelationInput[]
    cursor?: InvoiceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InvoiceScalarFieldEnum | InvoiceScalarFieldEnum[]
  }

  /**
   * Tenant.pelanggaran
   */
  export type Tenant$pelanggaranArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pelanggaran
     */
    select?: PelanggaranSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PelanggaranInclude<ExtArgs> | null
    where?: PelanggaranWhereInput
    orderBy?: PelanggaranOrderByWithRelationInput | PelanggaranOrderByWithRelationInput[]
    cursor?: PelanggaranWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PelanggaranScalarFieldEnum | PelanggaranScalarFieldEnum[]
  }

  /**
   * Tenant.pembinaan
   */
  export type Tenant$pembinaanArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pembinaan
     */
    select?: PembinaanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PembinaanInclude<ExtArgs> | null
    where?: PembinaanWhereInput
    orderBy?: PembinaanOrderByWithRelationInput | PembinaanOrderByWithRelationInput[]
    cursor?: PembinaanWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PembinaanScalarFieldEnum | PembinaanScalarFieldEnum[]
  }

  /**
   * Tenant.kunjungan
   */
  export type Tenant$kunjunganArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Kunjungan
     */
    select?: KunjunganSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KunjunganInclude<ExtArgs> | null
    where?: KunjunganWhereInput
    orderBy?: KunjunganOrderByWithRelationInput | KunjunganOrderByWithRelationInput[]
    cursor?: KunjunganWhereUniqueInput
    take?: number
    skip?: number
    distinct?: KunjunganScalarFieldEnum | KunjunganScalarFieldEnum[]
  }

  /**
   * Tenant.healthRecords
   */
  export type Tenant$healthRecordsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HealthRecord
     */
    select?: HealthRecordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HealthRecordInclude<ExtArgs> | null
    where?: HealthRecordWhereInput
    orderBy?: HealthRecordOrderByWithRelationInput | HealthRecordOrderByWithRelationInput[]
    cursor?: HealthRecordWhereUniqueInput
    take?: number
    skip?: number
    distinct?: HealthRecordScalarFieldEnum | HealthRecordScalarFieldEnum[]
  }

  /**
   * Tenant.auditLogs
   */
  export type Tenant$auditLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    where?: AuditLogWhereInput
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    cursor?: AuditLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * Tenant.notifications
   */
  export type Tenant$notificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    where?: NotificationWhereInput
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    cursor?: NotificationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Tenant.webhookEvents
   */
  export type Tenant$webhookEventsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WebhookEvent
     */
    select?: WebhookEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WebhookEventInclude<ExtArgs> | null
    where?: WebhookEventWhereInput
    orderBy?: WebhookEventOrderByWithRelationInput | WebhookEventOrderByWithRelationInput[]
    cursor?: WebhookEventWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WebhookEventScalarFieldEnum | WebhookEventScalarFieldEnum[]
  }

  /**
   * Tenant without action
   */
  export type TenantDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tenant
     */
    select?: TenantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantInclude<ExtArgs> | null
  }


  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    tenantId: string | null
    email: string | null
    passwordHash: string | null
    role: string | null
    name: string | null
    phone: string | null
    isActive: boolean | null
    lastLogin: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    tenantId: string | null
    email: string | null
    passwordHash: string | null
    role: string | null
    name: string | null
    phone: string | null
    isActive: boolean | null
    lastLogin: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    tenantId: number
    email: number
    passwordHash: number
    role: number
    name: number
    phone: number
    isActive: number
    lastLogin: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UserMinAggregateInputType = {
    id?: true
    tenantId?: true
    email?: true
    passwordHash?: true
    role?: true
    name?: true
    phone?: true
    isActive?: true
    lastLogin?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    tenantId?: true
    email?: true
    passwordHash?: true
    role?: true
    name?: true
    phone?: true
    isActive?: true
    lastLogin?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    tenantId?: true
    email?: true
    passwordHash?: true
    role?: true
    name?: true
    phone?: true
    isActive?: true
    lastLogin?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: string
    tenantId: string | null
    email: string
    passwordHash: string
    role: string
    name: string
    phone: string | null
    isActive: boolean
    lastLogin: Date | null
    createdAt: Date
    updatedAt: Date
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    email?: boolean
    passwordHash?: boolean
    role?: boolean
    name?: boolean
    phone?: boolean
    isActive?: boolean
    lastLogin?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | User$tenantArgs<ExtArgs>
    refreshTokens?: boolean | User$refreshTokensArgs<ExtArgs>
    auditLogs?: boolean | User$auditLogsArgs<ExtArgs>
    notifications?: boolean | User$notificationsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    email?: boolean
    passwordHash?: boolean
    role?: boolean
    name?: boolean
    phone?: boolean
    isActive?: boolean
    lastLogin?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | User$tenantArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    tenantId?: boolean
    email?: boolean
    passwordHash?: boolean
    role?: boolean
    name?: boolean
    phone?: boolean
    isActive?: boolean
    lastLogin?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | User$tenantArgs<ExtArgs>
    refreshTokens?: boolean | User$refreshTokensArgs<ExtArgs>
    auditLogs?: boolean | User$auditLogsArgs<ExtArgs>
    notifications?: boolean | User$notificationsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | User$tenantArgs<ExtArgs>
  }

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      tenant: Prisma.$TenantPayload<ExtArgs> | null
      refreshTokens: Prisma.$RefreshTokenPayload<ExtArgs>[]
      auditLogs: Prisma.$AuditLogPayload<ExtArgs>[]
      notifications: Prisma.$NotificationPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      tenantId: string | null
      email: string
      passwordHash: string
      role: string
      name: string
      phone: string | null
      isActive: boolean
      lastLogin: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    tenant<T extends User$tenantArgs<ExtArgs> = {}>(args?: Subset<T, User$tenantArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    refreshTokens<T extends User$refreshTokensArgs<ExtArgs> = {}>(args?: Subset<T, User$refreshTokensArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, "findMany"> | Null>
    auditLogs<T extends User$auditLogsArgs<ExtArgs> = {}>(args?: Subset<T, User$auditLogsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findMany"> | Null>
    notifications<T extends User$notificationsArgs<ExtArgs> = {}>(args?: Subset<T, User$notificationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */ 
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'String'>
    readonly tenantId: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly passwordHash: FieldRef<"User", 'String'>
    readonly role: FieldRef<"User", 'String'>
    readonly name: FieldRef<"User", 'String'>
    readonly phone: FieldRef<"User", 'String'>
    readonly isActive: FieldRef<"User", 'Boolean'>
    readonly lastLogin: FieldRef<"User", 'DateTime'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly updatedAt: FieldRef<"User", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
  }

  /**
   * User.tenant
   */
  export type User$tenantArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tenant
     */
    select?: TenantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantInclude<ExtArgs> | null
    where?: TenantWhereInput
  }

  /**
   * User.refreshTokens
   */
  export type User$refreshTokensArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenInclude<ExtArgs> | null
    where?: RefreshTokenWhereInput
    orderBy?: RefreshTokenOrderByWithRelationInput | RefreshTokenOrderByWithRelationInput[]
    cursor?: RefreshTokenWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RefreshTokenScalarFieldEnum | RefreshTokenScalarFieldEnum[]
  }

  /**
   * User.auditLogs
   */
  export type User$auditLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    where?: AuditLogWhereInput
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    cursor?: AuditLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * User.notifications
   */
  export type User$notificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    where?: NotificationWhereInput
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    cursor?: NotificationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model RefreshToken
   */

  export type AggregateRefreshToken = {
    _count: RefreshTokenCountAggregateOutputType | null
    _min: RefreshTokenMinAggregateOutputType | null
    _max: RefreshTokenMaxAggregateOutputType | null
  }

  export type RefreshTokenMinAggregateOutputType = {
    id: string | null
    userId: string | null
    token: string | null
    expiresAt: Date | null
    revoked: boolean | null
    createdAt: Date | null
  }

  export type RefreshTokenMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    token: string | null
    expiresAt: Date | null
    revoked: boolean | null
    createdAt: Date | null
  }

  export type RefreshTokenCountAggregateOutputType = {
    id: number
    userId: number
    token: number
    expiresAt: number
    revoked: number
    createdAt: number
    _all: number
  }


  export type RefreshTokenMinAggregateInputType = {
    id?: true
    userId?: true
    token?: true
    expiresAt?: true
    revoked?: true
    createdAt?: true
  }

  export type RefreshTokenMaxAggregateInputType = {
    id?: true
    userId?: true
    token?: true
    expiresAt?: true
    revoked?: true
    createdAt?: true
  }

  export type RefreshTokenCountAggregateInputType = {
    id?: true
    userId?: true
    token?: true
    expiresAt?: true
    revoked?: true
    createdAt?: true
    _all?: true
  }

  export type RefreshTokenAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RefreshToken to aggregate.
     */
    where?: RefreshTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RefreshTokens to fetch.
     */
    orderBy?: RefreshTokenOrderByWithRelationInput | RefreshTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RefreshTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RefreshTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RefreshTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RefreshTokens
    **/
    _count?: true | RefreshTokenCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RefreshTokenMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RefreshTokenMaxAggregateInputType
  }

  export type GetRefreshTokenAggregateType<T extends RefreshTokenAggregateArgs> = {
        [P in keyof T & keyof AggregateRefreshToken]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRefreshToken[P]>
      : GetScalarType<T[P], AggregateRefreshToken[P]>
  }




  export type RefreshTokenGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RefreshTokenWhereInput
    orderBy?: RefreshTokenOrderByWithAggregationInput | RefreshTokenOrderByWithAggregationInput[]
    by: RefreshTokenScalarFieldEnum[] | RefreshTokenScalarFieldEnum
    having?: RefreshTokenScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RefreshTokenCountAggregateInputType | true
    _min?: RefreshTokenMinAggregateInputType
    _max?: RefreshTokenMaxAggregateInputType
  }

  export type RefreshTokenGroupByOutputType = {
    id: string
    userId: string
    token: string
    expiresAt: Date
    revoked: boolean
    createdAt: Date
    _count: RefreshTokenCountAggregateOutputType | null
    _min: RefreshTokenMinAggregateOutputType | null
    _max: RefreshTokenMaxAggregateOutputType | null
  }

  type GetRefreshTokenGroupByPayload<T extends RefreshTokenGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RefreshTokenGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RefreshTokenGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RefreshTokenGroupByOutputType[P]>
            : GetScalarType<T[P], RefreshTokenGroupByOutputType[P]>
        }
      >
    >


  export type RefreshTokenSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    token?: boolean
    expiresAt?: boolean
    revoked?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["refreshToken"]>

  export type RefreshTokenSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    token?: boolean
    expiresAt?: boolean
    revoked?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["refreshToken"]>

  export type RefreshTokenSelectScalar = {
    id?: boolean
    userId?: boolean
    token?: boolean
    expiresAt?: boolean
    revoked?: boolean
    createdAt?: boolean
  }

  export type RefreshTokenInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type RefreshTokenIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $RefreshTokenPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "RefreshToken"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      token: string
      expiresAt: Date
      revoked: boolean
      createdAt: Date
    }, ExtArgs["result"]["refreshToken"]>
    composites: {}
  }

  type RefreshTokenGetPayload<S extends boolean | null | undefined | RefreshTokenDefaultArgs> = $Result.GetResult<Prisma.$RefreshTokenPayload, S>

  type RefreshTokenCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<RefreshTokenFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: RefreshTokenCountAggregateInputType | true
    }

  export interface RefreshTokenDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['RefreshToken'], meta: { name: 'RefreshToken' } }
    /**
     * Find zero or one RefreshToken that matches the filter.
     * @param {RefreshTokenFindUniqueArgs} args - Arguments to find a RefreshToken
     * @example
     * // Get one RefreshToken
     * const refreshToken = await prisma.refreshToken.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RefreshTokenFindUniqueArgs>(args: SelectSubset<T, RefreshTokenFindUniqueArgs<ExtArgs>>): Prisma__RefreshTokenClient<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one RefreshToken that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {RefreshTokenFindUniqueOrThrowArgs} args - Arguments to find a RefreshToken
     * @example
     * // Get one RefreshToken
     * const refreshToken = await prisma.refreshToken.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RefreshTokenFindUniqueOrThrowArgs>(args: SelectSubset<T, RefreshTokenFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RefreshTokenClient<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first RefreshToken that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RefreshTokenFindFirstArgs} args - Arguments to find a RefreshToken
     * @example
     * // Get one RefreshToken
     * const refreshToken = await prisma.refreshToken.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RefreshTokenFindFirstArgs>(args?: SelectSubset<T, RefreshTokenFindFirstArgs<ExtArgs>>): Prisma__RefreshTokenClient<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first RefreshToken that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RefreshTokenFindFirstOrThrowArgs} args - Arguments to find a RefreshToken
     * @example
     * // Get one RefreshToken
     * const refreshToken = await prisma.refreshToken.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RefreshTokenFindFirstOrThrowArgs>(args?: SelectSubset<T, RefreshTokenFindFirstOrThrowArgs<ExtArgs>>): Prisma__RefreshTokenClient<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more RefreshTokens that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RefreshTokenFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RefreshTokens
     * const refreshTokens = await prisma.refreshToken.findMany()
     * 
     * // Get first 10 RefreshTokens
     * const refreshTokens = await prisma.refreshToken.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const refreshTokenWithIdOnly = await prisma.refreshToken.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RefreshTokenFindManyArgs>(args?: SelectSubset<T, RefreshTokenFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a RefreshToken.
     * @param {RefreshTokenCreateArgs} args - Arguments to create a RefreshToken.
     * @example
     * // Create one RefreshToken
     * const RefreshToken = await prisma.refreshToken.create({
     *   data: {
     *     // ... data to create a RefreshToken
     *   }
     * })
     * 
     */
    create<T extends RefreshTokenCreateArgs>(args: SelectSubset<T, RefreshTokenCreateArgs<ExtArgs>>): Prisma__RefreshTokenClient<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many RefreshTokens.
     * @param {RefreshTokenCreateManyArgs} args - Arguments to create many RefreshTokens.
     * @example
     * // Create many RefreshTokens
     * const refreshToken = await prisma.refreshToken.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RefreshTokenCreateManyArgs>(args?: SelectSubset<T, RefreshTokenCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many RefreshTokens and returns the data saved in the database.
     * @param {RefreshTokenCreateManyAndReturnArgs} args - Arguments to create many RefreshTokens.
     * @example
     * // Create many RefreshTokens
     * const refreshToken = await prisma.refreshToken.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many RefreshTokens and only return the `id`
     * const refreshTokenWithIdOnly = await prisma.refreshToken.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RefreshTokenCreateManyAndReturnArgs>(args?: SelectSubset<T, RefreshTokenCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a RefreshToken.
     * @param {RefreshTokenDeleteArgs} args - Arguments to delete one RefreshToken.
     * @example
     * // Delete one RefreshToken
     * const RefreshToken = await prisma.refreshToken.delete({
     *   where: {
     *     // ... filter to delete one RefreshToken
     *   }
     * })
     * 
     */
    delete<T extends RefreshTokenDeleteArgs>(args: SelectSubset<T, RefreshTokenDeleteArgs<ExtArgs>>): Prisma__RefreshTokenClient<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one RefreshToken.
     * @param {RefreshTokenUpdateArgs} args - Arguments to update one RefreshToken.
     * @example
     * // Update one RefreshToken
     * const refreshToken = await prisma.refreshToken.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RefreshTokenUpdateArgs>(args: SelectSubset<T, RefreshTokenUpdateArgs<ExtArgs>>): Prisma__RefreshTokenClient<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more RefreshTokens.
     * @param {RefreshTokenDeleteManyArgs} args - Arguments to filter RefreshTokens to delete.
     * @example
     * // Delete a few RefreshTokens
     * const { count } = await prisma.refreshToken.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RefreshTokenDeleteManyArgs>(args?: SelectSubset<T, RefreshTokenDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RefreshTokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RefreshTokenUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RefreshTokens
     * const refreshToken = await prisma.refreshToken.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RefreshTokenUpdateManyArgs>(args: SelectSubset<T, RefreshTokenUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one RefreshToken.
     * @param {RefreshTokenUpsertArgs} args - Arguments to update or create a RefreshToken.
     * @example
     * // Update or create a RefreshToken
     * const refreshToken = await prisma.refreshToken.upsert({
     *   create: {
     *     // ... data to create a RefreshToken
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RefreshToken we want to update
     *   }
     * })
     */
    upsert<T extends RefreshTokenUpsertArgs>(args: SelectSubset<T, RefreshTokenUpsertArgs<ExtArgs>>): Prisma__RefreshTokenClient<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of RefreshTokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RefreshTokenCountArgs} args - Arguments to filter RefreshTokens to count.
     * @example
     * // Count the number of RefreshTokens
     * const count = await prisma.refreshToken.count({
     *   where: {
     *     // ... the filter for the RefreshTokens we want to count
     *   }
     * })
    **/
    count<T extends RefreshTokenCountArgs>(
      args?: Subset<T, RefreshTokenCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RefreshTokenCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RefreshToken.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RefreshTokenAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RefreshTokenAggregateArgs>(args: Subset<T, RefreshTokenAggregateArgs>): Prisma.PrismaPromise<GetRefreshTokenAggregateType<T>>

    /**
     * Group by RefreshToken.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RefreshTokenGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RefreshTokenGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RefreshTokenGroupByArgs['orderBy'] }
        : { orderBy?: RefreshTokenGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RefreshTokenGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRefreshTokenGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the RefreshToken model
   */
  readonly fields: RefreshTokenFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RefreshToken.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RefreshTokenClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the RefreshToken model
   */ 
  interface RefreshTokenFieldRefs {
    readonly id: FieldRef<"RefreshToken", 'String'>
    readonly userId: FieldRef<"RefreshToken", 'String'>
    readonly token: FieldRef<"RefreshToken", 'String'>
    readonly expiresAt: FieldRef<"RefreshToken", 'DateTime'>
    readonly revoked: FieldRef<"RefreshToken", 'Boolean'>
    readonly createdAt: FieldRef<"RefreshToken", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * RefreshToken findUnique
   */
  export type RefreshTokenFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenInclude<ExtArgs> | null
    /**
     * Filter, which RefreshToken to fetch.
     */
    where: RefreshTokenWhereUniqueInput
  }

  /**
   * RefreshToken findUniqueOrThrow
   */
  export type RefreshTokenFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenInclude<ExtArgs> | null
    /**
     * Filter, which RefreshToken to fetch.
     */
    where: RefreshTokenWhereUniqueInput
  }

  /**
   * RefreshToken findFirst
   */
  export type RefreshTokenFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenInclude<ExtArgs> | null
    /**
     * Filter, which RefreshToken to fetch.
     */
    where?: RefreshTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RefreshTokens to fetch.
     */
    orderBy?: RefreshTokenOrderByWithRelationInput | RefreshTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RefreshTokens.
     */
    cursor?: RefreshTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RefreshTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RefreshTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RefreshTokens.
     */
    distinct?: RefreshTokenScalarFieldEnum | RefreshTokenScalarFieldEnum[]
  }

  /**
   * RefreshToken findFirstOrThrow
   */
  export type RefreshTokenFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenInclude<ExtArgs> | null
    /**
     * Filter, which RefreshToken to fetch.
     */
    where?: RefreshTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RefreshTokens to fetch.
     */
    orderBy?: RefreshTokenOrderByWithRelationInput | RefreshTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RefreshTokens.
     */
    cursor?: RefreshTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RefreshTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RefreshTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RefreshTokens.
     */
    distinct?: RefreshTokenScalarFieldEnum | RefreshTokenScalarFieldEnum[]
  }

  /**
   * RefreshToken findMany
   */
  export type RefreshTokenFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenInclude<ExtArgs> | null
    /**
     * Filter, which RefreshTokens to fetch.
     */
    where?: RefreshTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RefreshTokens to fetch.
     */
    orderBy?: RefreshTokenOrderByWithRelationInput | RefreshTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RefreshTokens.
     */
    cursor?: RefreshTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RefreshTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RefreshTokens.
     */
    skip?: number
    distinct?: RefreshTokenScalarFieldEnum | RefreshTokenScalarFieldEnum[]
  }

  /**
   * RefreshToken create
   */
  export type RefreshTokenCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenInclude<ExtArgs> | null
    /**
     * The data needed to create a RefreshToken.
     */
    data: XOR<RefreshTokenCreateInput, RefreshTokenUncheckedCreateInput>
  }

  /**
   * RefreshToken createMany
   */
  export type RefreshTokenCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many RefreshTokens.
     */
    data: RefreshTokenCreateManyInput | RefreshTokenCreateManyInput[]
  }

  /**
   * RefreshToken createManyAndReturn
   */
  export type RefreshTokenCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many RefreshTokens.
     */
    data: RefreshTokenCreateManyInput | RefreshTokenCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * RefreshToken update
   */
  export type RefreshTokenUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenInclude<ExtArgs> | null
    /**
     * The data needed to update a RefreshToken.
     */
    data: XOR<RefreshTokenUpdateInput, RefreshTokenUncheckedUpdateInput>
    /**
     * Choose, which RefreshToken to update.
     */
    where: RefreshTokenWhereUniqueInput
  }

  /**
   * RefreshToken updateMany
   */
  export type RefreshTokenUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update RefreshTokens.
     */
    data: XOR<RefreshTokenUpdateManyMutationInput, RefreshTokenUncheckedUpdateManyInput>
    /**
     * Filter which RefreshTokens to update
     */
    where?: RefreshTokenWhereInput
  }

  /**
   * RefreshToken upsert
   */
  export type RefreshTokenUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenInclude<ExtArgs> | null
    /**
     * The filter to search for the RefreshToken to update in case it exists.
     */
    where: RefreshTokenWhereUniqueInput
    /**
     * In case the RefreshToken found by the `where` argument doesn't exist, create a new RefreshToken with this data.
     */
    create: XOR<RefreshTokenCreateInput, RefreshTokenUncheckedCreateInput>
    /**
     * In case the RefreshToken was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RefreshTokenUpdateInput, RefreshTokenUncheckedUpdateInput>
  }

  /**
   * RefreshToken delete
   */
  export type RefreshTokenDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenInclude<ExtArgs> | null
    /**
     * Filter which RefreshToken to delete.
     */
    where: RefreshTokenWhereUniqueInput
  }

  /**
   * RefreshToken deleteMany
   */
  export type RefreshTokenDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RefreshTokens to delete
     */
    where?: RefreshTokenWhereInput
  }

  /**
   * RefreshToken without action
   */
  export type RefreshTokenDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenInclude<ExtArgs> | null
  }


  /**
   * Model Santri
   */

  export type AggregateSantri = {
    _count: SantriCountAggregateOutputType | null
    _min: SantriMinAggregateOutputType | null
    _max: SantriMaxAggregateOutputType | null
  }

  export type SantriMinAggregateOutputType = {
    id: string | null
    tenantId: string | null
    nisn: string | null
    name: string | null
    gender: string | null
    dob: Date | null
    kelas: string | null
    room: string | null
    contact: string | null
    address: string | null
    photo: string | null
    status: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SantriMaxAggregateOutputType = {
    id: string | null
    tenantId: string | null
    nisn: string | null
    name: string | null
    gender: string | null
    dob: Date | null
    kelas: string | null
    room: string | null
    contact: string | null
    address: string | null
    photo: string | null
    status: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SantriCountAggregateOutputType = {
    id: number
    tenantId: number
    nisn: number
    name: number
    gender: number
    dob: number
    kelas: number
    room: number
    contact: number
    address: number
    photo: number
    status: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SantriMinAggregateInputType = {
    id?: true
    tenantId?: true
    nisn?: true
    name?: true
    gender?: true
    dob?: true
    kelas?: true
    room?: true
    contact?: true
    address?: true
    photo?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SantriMaxAggregateInputType = {
    id?: true
    tenantId?: true
    nisn?: true
    name?: true
    gender?: true
    dob?: true
    kelas?: true
    room?: true
    contact?: true
    address?: true
    photo?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SantriCountAggregateInputType = {
    id?: true
    tenantId?: true
    nisn?: true
    name?: true
    gender?: true
    dob?: true
    kelas?: true
    room?: true
    contact?: true
    address?: true
    photo?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SantriAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Santri to aggregate.
     */
    where?: SantriWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Santris to fetch.
     */
    orderBy?: SantriOrderByWithRelationInput | SantriOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SantriWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Santris from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Santris.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Santris
    **/
    _count?: true | SantriCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SantriMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SantriMaxAggregateInputType
  }

  export type GetSantriAggregateType<T extends SantriAggregateArgs> = {
        [P in keyof T & keyof AggregateSantri]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSantri[P]>
      : GetScalarType<T[P], AggregateSantri[P]>
  }




  export type SantriGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SantriWhereInput
    orderBy?: SantriOrderByWithAggregationInput | SantriOrderByWithAggregationInput[]
    by: SantriScalarFieldEnum[] | SantriScalarFieldEnum
    having?: SantriScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SantriCountAggregateInputType | true
    _min?: SantriMinAggregateInputType
    _max?: SantriMaxAggregateInputType
  }

  export type SantriGroupByOutputType = {
    id: string
    tenantId: string
    nisn: string | null
    name: string
    gender: string
    dob: Date | null
    kelas: string | null
    room: string | null
    contact: string | null
    address: string | null
    photo: string | null
    status: string
    createdAt: Date
    updatedAt: Date
    _count: SantriCountAggregateOutputType | null
    _min: SantriMinAggregateOutputType | null
    _max: SantriMaxAggregateOutputType | null
  }

  type GetSantriGroupByPayload<T extends SantriGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SantriGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SantriGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SantriGroupByOutputType[P]>
            : GetScalarType<T[P], SantriGroupByOutputType[P]>
        }
      >
    >


  export type SantriSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    nisn?: boolean
    name?: boolean
    gender?: boolean
    dob?: boolean
    kelas?: boolean
    room?: boolean
    contact?: boolean
    address?: boolean
    photo?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    walis?: boolean | Santri$walisArgs<ExtArgs>
    izin?: boolean | Santri$izinArgs<ExtArgs>
    catatanHarian?: boolean | Santri$catatanHarianArgs<ExtArgs>
    invoices?: boolean | Santri$invoicesArgs<ExtArgs>
    pelanggaran?: boolean | Santri$pelanggaranArgs<ExtArgs>
    pembinaan?: boolean | Santri$pembinaanArgs<ExtArgs>
    kunjungan?: boolean | Santri$kunjunganArgs<ExtArgs>
    healthRecords?: boolean | Santri$healthRecordsArgs<ExtArgs>
    medications?: boolean | Santri$medicationsArgs<ExtArgs>
    _count?: boolean | SantriCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["santri"]>

  export type SantriSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    nisn?: boolean
    name?: boolean
    gender?: boolean
    dob?: boolean
    kelas?: boolean
    room?: boolean
    contact?: boolean
    address?: boolean
    photo?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["santri"]>

  export type SantriSelectScalar = {
    id?: boolean
    tenantId?: boolean
    nisn?: boolean
    name?: boolean
    gender?: boolean
    dob?: boolean
    kelas?: boolean
    room?: boolean
    contact?: boolean
    address?: boolean
    photo?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type SantriInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    walis?: boolean | Santri$walisArgs<ExtArgs>
    izin?: boolean | Santri$izinArgs<ExtArgs>
    catatanHarian?: boolean | Santri$catatanHarianArgs<ExtArgs>
    invoices?: boolean | Santri$invoicesArgs<ExtArgs>
    pelanggaran?: boolean | Santri$pelanggaranArgs<ExtArgs>
    pembinaan?: boolean | Santri$pembinaanArgs<ExtArgs>
    kunjungan?: boolean | Santri$kunjunganArgs<ExtArgs>
    healthRecords?: boolean | Santri$healthRecordsArgs<ExtArgs>
    medications?: boolean | Santri$medicationsArgs<ExtArgs>
    _count?: boolean | SantriCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type SantriIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }

  export type $SantriPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Santri"
    objects: {
      tenant: Prisma.$TenantPayload<ExtArgs>
      walis: Prisma.$SantriWaliPayload<ExtArgs>[]
      izin: Prisma.$IzinPayload<ExtArgs>[]
      catatanHarian: Prisma.$CatatanHarianPayload<ExtArgs>[]
      invoices: Prisma.$InvoicePayload<ExtArgs>[]
      pelanggaran: Prisma.$PelanggaranPayload<ExtArgs>[]
      pembinaan: Prisma.$PembinaanPayload<ExtArgs>[]
      kunjungan: Prisma.$KunjunganPayload<ExtArgs>[]
      healthRecords: Prisma.$HealthRecordPayload<ExtArgs>[]
      medications: Prisma.$MedicationPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      tenantId: string
      nisn: string | null
      name: string
      gender: string
      dob: Date | null
      kelas: string | null
      room: string | null
      contact: string | null
      address: string | null
      photo: string | null
      status: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["santri"]>
    composites: {}
  }

  type SantriGetPayload<S extends boolean | null | undefined | SantriDefaultArgs> = $Result.GetResult<Prisma.$SantriPayload, S>

  type SantriCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<SantriFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: SantriCountAggregateInputType | true
    }

  export interface SantriDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Santri'], meta: { name: 'Santri' } }
    /**
     * Find zero or one Santri that matches the filter.
     * @param {SantriFindUniqueArgs} args - Arguments to find a Santri
     * @example
     * // Get one Santri
     * const santri = await prisma.santri.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SantriFindUniqueArgs>(args: SelectSubset<T, SantriFindUniqueArgs<ExtArgs>>): Prisma__SantriClient<$Result.GetResult<Prisma.$SantriPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Santri that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {SantriFindUniqueOrThrowArgs} args - Arguments to find a Santri
     * @example
     * // Get one Santri
     * const santri = await prisma.santri.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SantriFindUniqueOrThrowArgs>(args: SelectSubset<T, SantriFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SantriClient<$Result.GetResult<Prisma.$SantriPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Santri that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SantriFindFirstArgs} args - Arguments to find a Santri
     * @example
     * // Get one Santri
     * const santri = await prisma.santri.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SantriFindFirstArgs>(args?: SelectSubset<T, SantriFindFirstArgs<ExtArgs>>): Prisma__SantriClient<$Result.GetResult<Prisma.$SantriPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Santri that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SantriFindFirstOrThrowArgs} args - Arguments to find a Santri
     * @example
     * // Get one Santri
     * const santri = await prisma.santri.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SantriFindFirstOrThrowArgs>(args?: SelectSubset<T, SantriFindFirstOrThrowArgs<ExtArgs>>): Prisma__SantriClient<$Result.GetResult<Prisma.$SantriPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Santris that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SantriFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Santris
     * const santris = await prisma.santri.findMany()
     * 
     * // Get first 10 Santris
     * const santris = await prisma.santri.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const santriWithIdOnly = await prisma.santri.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SantriFindManyArgs>(args?: SelectSubset<T, SantriFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SantriPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Santri.
     * @param {SantriCreateArgs} args - Arguments to create a Santri.
     * @example
     * // Create one Santri
     * const Santri = await prisma.santri.create({
     *   data: {
     *     // ... data to create a Santri
     *   }
     * })
     * 
     */
    create<T extends SantriCreateArgs>(args: SelectSubset<T, SantriCreateArgs<ExtArgs>>): Prisma__SantriClient<$Result.GetResult<Prisma.$SantriPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Santris.
     * @param {SantriCreateManyArgs} args - Arguments to create many Santris.
     * @example
     * // Create many Santris
     * const santri = await prisma.santri.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SantriCreateManyArgs>(args?: SelectSubset<T, SantriCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Santris and returns the data saved in the database.
     * @param {SantriCreateManyAndReturnArgs} args - Arguments to create many Santris.
     * @example
     * // Create many Santris
     * const santri = await prisma.santri.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Santris and only return the `id`
     * const santriWithIdOnly = await prisma.santri.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SantriCreateManyAndReturnArgs>(args?: SelectSubset<T, SantriCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SantriPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Santri.
     * @param {SantriDeleteArgs} args - Arguments to delete one Santri.
     * @example
     * // Delete one Santri
     * const Santri = await prisma.santri.delete({
     *   where: {
     *     // ... filter to delete one Santri
     *   }
     * })
     * 
     */
    delete<T extends SantriDeleteArgs>(args: SelectSubset<T, SantriDeleteArgs<ExtArgs>>): Prisma__SantriClient<$Result.GetResult<Prisma.$SantriPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Santri.
     * @param {SantriUpdateArgs} args - Arguments to update one Santri.
     * @example
     * // Update one Santri
     * const santri = await prisma.santri.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SantriUpdateArgs>(args: SelectSubset<T, SantriUpdateArgs<ExtArgs>>): Prisma__SantriClient<$Result.GetResult<Prisma.$SantriPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Santris.
     * @param {SantriDeleteManyArgs} args - Arguments to filter Santris to delete.
     * @example
     * // Delete a few Santris
     * const { count } = await prisma.santri.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SantriDeleteManyArgs>(args?: SelectSubset<T, SantriDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Santris.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SantriUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Santris
     * const santri = await prisma.santri.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SantriUpdateManyArgs>(args: SelectSubset<T, SantriUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Santri.
     * @param {SantriUpsertArgs} args - Arguments to update or create a Santri.
     * @example
     * // Update or create a Santri
     * const santri = await prisma.santri.upsert({
     *   create: {
     *     // ... data to create a Santri
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Santri we want to update
     *   }
     * })
     */
    upsert<T extends SantriUpsertArgs>(args: SelectSubset<T, SantriUpsertArgs<ExtArgs>>): Prisma__SantriClient<$Result.GetResult<Prisma.$SantriPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Santris.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SantriCountArgs} args - Arguments to filter Santris to count.
     * @example
     * // Count the number of Santris
     * const count = await prisma.santri.count({
     *   where: {
     *     // ... the filter for the Santris we want to count
     *   }
     * })
    **/
    count<T extends SantriCountArgs>(
      args?: Subset<T, SantriCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SantriCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Santri.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SantriAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SantriAggregateArgs>(args: Subset<T, SantriAggregateArgs>): Prisma.PrismaPromise<GetSantriAggregateType<T>>

    /**
     * Group by Santri.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SantriGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SantriGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SantriGroupByArgs['orderBy'] }
        : { orderBy?: SantriGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SantriGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSantriGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Santri model
   */
  readonly fields: SantriFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Santri.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SantriClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    tenant<T extends TenantDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TenantDefaultArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    walis<T extends Santri$walisArgs<ExtArgs> = {}>(args?: Subset<T, Santri$walisArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SantriWaliPayload<ExtArgs>, T, "findMany"> | Null>
    izin<T extends Santri$izinArgs<ExtArgs> = {}>(args?: Subset<T, Santri$izinArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IzinPayload<ExtArgs>, T, "findMany"> | Null>
    catatanHarian<T extends Santri$catatanHarianArgs<ExtArgs> = {}>(args?: Subset<T, Santri$catatanHarianArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CatatanHarianPayload<ExtArgs>, T, "findMany"> | Null>
    invoices<T extends Santri$invoicesArgs<ExtArgs> = {}>(args?: Subset<T, Santri$invoicesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findMany"> | Null>
    pelanggaran<T extends Santri$pelanggaranArgs<ExtArgs> = {}>(args?: Subset<T, Santri$pelanggaranArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PelanggaranPayload<ExtArgs>, T, "findMany"> | Null>
    pembinaan<T extends Santri$pembinaanArgs<ExtArgs> = {}>(args?: Subset<T, Santri$pembinaanArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PembinaanPayload<ExtArgs>, T, "findMany"> | Null>
    kunjungan<T extends Santri$kunjunganArgs<ExtArgs> = {}>(args?: Subset<T, Santri$kunjunganArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$KunjunganPayload<ExtArgs>, T, "findMany"> | Null>
    healthRecords<T extends Santri$healthRecordsArgs<ExtArgs> = {}>(args?: Subset<T, Santri$healthRecordsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HealthRecordPayload<ExtArgs>, T, "findMany"> | Null>
    medications<T extends Santri$medicationsArgs<ExtArgs> = {}>(args?: Subset<T, Santri$medicationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MedicationPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Santri model
   */ 
  interface SantriFieldRefs {
    readonly id: FieldRef<"Santri", 'String'>
    readonly tenantId: FieldRef<"Santri", 'String'>
    readonly nisn: FieldRef<"Santri", 'String'>
    readonly name: FieldRef<"Santri", 'String'>
    readonly gender: FieldRef<"Santri", 'String'>
    readonly dob: FieldRef<"Santri", 'DateTime'>
    readonly kelas: FieldRef<"Santri", 'String'>
    readonly room: FieldRef<"Santri", 'String'>
    readonly contact: FieldRef<"Santri", 'String'>
    readonly address: FieldRef<"Santri", 'String'>
    readonly photo: FieldRef<"Santri", 'String'>
    readonly status: FieldRef<"Santri", 'String'>
    readonly createdAt: FieldRef<"Santri", 'DateTime'>
    readonly updatedAt: FieldRef<"Santri", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Santri findUnique
   */
  export type SantriFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Santri
     */
    select?: SantriSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SantriInclude<ExtArgs> | null
    /**
     * Filter, which Santri to fetch.
     */
    where: SantriWhereUniqueInput
  }

  /**
   * Santri findUniqueOrThrow
   */
  export type SantriFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Santri
     */
    select?: SantriSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SantriInclude<ExtArgs> | null
    /**
     * Filter, which Santri to fetch.
     */
    where: SantriWhereUniqueInput
  }

  /**
   * Santri findFirst
   */
  export type SantriFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Santri
     */
    select?: SantriSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SantriInclude<ExtArgs> | null
    /**
     * Filter, which Santri to fetch.
     */
    where?: SantriWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Santris to fetch.
     */
    orderBy?: SantriOrderByWithRelationInput | SantriOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Santris.
     */
    cursor?: SantriWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Santris from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Santris.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Santris.
     */
    distinct?: SantriScalarFieldEnum | SantriScalarFieldEnum[]
  }

  /**
   * Santri findFirstOrThrow
   */
  export type SantriFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Santri
     */
    select?: SantriSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SantriInclude<ExtArgs> | null
    /**
     * Filter, which Santri to fetch.
     */
    where?: SantriWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Santris to fetch.
     */
    orderBy?: SantriOrderByWithRelationInput | SantriOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Santris.
     */
    cursor?: SantriWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Santris from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Santris.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Santris.
     */
    distinct?: SantriScalarFieldEnum | SantriScalarFieldEnum[]
  }

  /**
   * Santri findMany
   */
  export type SantriFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Santri
     */
    select?: SantriSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SantriInclude<ExtArgs> | null
    /**
     * Filter, which Santris to fetch.
     */
    where?: SantriWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Santris to fetch.
     */
    orderBy?: SantriOrderByWithRelationInput | SantriOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Santris.
     */
    cursor?: SantriWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Santris from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Santris.
     */
    skip?: number
    distinct?: SantriScalarFieldEnum | SantriScalarFieldEnum[]
  }

  /**
   * Santri create
   */
  export type SantriCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Santri
     */
    select?: SantriSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SantriInclude<ExtArgs> | null
    /**
     * The data needed to create a Santri.
     */
    data: XOR<SantriCreateInput, SantriUncheckedCreateInput>
  }

  /**
   * Santri createMany
   */
  export type SantriCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Santris.
     */
    data: SantriCreateManyInput | SantriCreateManyInput[]
  }

  /**
   * Santri createManyAndReturn
   */
  export type SantriCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Santri
     */
    select?: SantriSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Santris.
     */
    data: SantriCreateManyInput | SantriCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SantriIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Santri update
   */
  export type SantriUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Santri
     */
    select?: SantriSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SantriInclude<ExtArgs> | null
    /**
     * The data needed to update a Santri.
     */
    data: XOR<SantriUpdateInput, SantriUncheckedUpdateInput>
    /**
     * Choose, which Santri to update.
     */
    where: SantriWhereUniqueInput
  }

  /**
   * Santri updateMany
   */
  export type SantriUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Santris.
     */
    data: XOR<SantriUpdateManyMutationInput, SantriUncheckedUpdateManyInput>
    /**
     * Filter which Santris to update
     */
    where?: SantriWhereInput
  }

  /**
   * Santri upsert
   */
  export type SantriUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Santri
     */
    select?: SantriSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SantriInclude<ExtArgs> | null
    /**
     * The filter to search for the Santri to update in case it exists.
     */
    where: SantriWhereUniqueInput
    /**
     * In case the Santri found by the `where` argument doesn't exist, create a new Santri with this data.
     */
    create: XOR<SantriCreateInput, SantriUncheckedCreateInput>
    /**
     * In case the Santri was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SantriUpdateInput, SantriUncheckedUpdateInput>
  }

  /**
   * Santri delete
   */
  export type SantriDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Santri
     */
    select?: SantriSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SantriInclude<ExtArgs> | null
    /**
     * Filter which Santri to delete.
     */
    where: SantriWhereUniqueInput
  }

  /**
   * Santri deleteMany
   */
  export type SantriDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Santris to delete
     */
    where?: SantriWhereInput
  }

  /**
   * Santri.walis
   */
  export type Santri$walisArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SantriWali
     */
    select?: SantriWaliSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SantriWaliInclude<ExtArgs> | null
    where?: SantriWaliWhereInput
    orderBy?: SantriWaliOrderByWithRelationInput | SantriWaliOrderByWithRelationInput[]
    cursor?: SantriWaliWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SantriWaliScalarFieldEnum | SantriWaliScalarFieldEnum[]
  }

  /**
   * Santri.izin
   */
  export type Santri$izinArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Izin
     */
    select?: IzinSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IzinInclude<ExtArgs> | null
    where?: IzinWhereInput
    orderBy?: IzinOrderByWithRelationInput | IzinOrderByWithRelationInput[]
    cursor?: IzinWhereUniqueInput
    take?: number
    skip?: number
    distinct?: IzinScalarFieldEnum | IzinScalarFieldEnum[]
  }

  /**
   * Santri.catatanHarian
   */
  export type Santri$catatanHarianArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CatatanHarian
     */
    select?: CatatanHarianSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CatatanHarianInclude<ExtArgs> | null
    where?: CatatanHarianWhereInput
    orderBy?: CatatanHarianOrderByWithRelationInput | CatatanHarianOrderByWithRelationInput[]
    cursor?: CatatanHarianWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CatatanHarianScalarFieldEnum | CatatanHarianScalarFieldEnum[]
  }

  /**
   * Santri.invoices
   */
  export type Santri$invoicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    where?: InvoiceWhereInput
    orderBy?: InvoiceOrderByWithRelationInput | InvoiceOrderByWithRelationInput[]
    cursor?: InvoiceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InvoiceScalarFieldEnum | InvoiceScalarFieldEnum[]
  }

  /**
   * Santri.pelanggaran
   */
  export type Santri$pelanggaranArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pelanggaran
     */
    select?: PelanggaranSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PelanggaranInclude<ExtArgs> | null
    where?: PelanggaranWhereInput
    orderBy?: PelanggaranOrderByWithRelationInput | PelanggaranOrderByWithRelationInput[]
    cursor?: PelanggaranWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PelanggaranScalarFieldEnum | PelanggaranScalarFieldEnum[]
  }

  /**
   * Santri.pembinaan
   */
  export type Santri$pembinaanArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pembinaan
     */
    select?: PembinaanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PembinaanInclude<ExtArgs> | null
    where?: PembinaanWhereInput
    orderBy?: PembinaanOrderByWithRelationInput | PembinaanOrderByWithRelationInput[]
    cursor?: PembinaanWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PembinaanScalarFieldEnum | PembinaanScalarFieldEnum[]
  }

  /**
   * Santri.kunjungan
   */
  export type Santri$kunjunganArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Kunjungan
     */
    select?: KunjunganSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KunjunganInclude<ExtArgs> | null
    where?: KunjunganWhereInput
    orderBy?: KunjunganOrderByWithRelationInput | KunjunganOrderByWithRelationInput[]
    cursor?: KunjunganWhereUniqueInput
    take?: number
    skip?: number
    distinct?: KunjunganScalarFieldEnum | KunjunganScalarFieldEnum[]
  }

  /**
   * Santri.healthRecords
   */
  export type Santri$healthRecordsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HealthRecord
     */
    select?: HealthRecordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HealthRecordInclude<ExtArgs> | null
    where?: HealthRecordWhereInput
    orderBy?: HealthRecordOrderByWithRelationInput | HealthRecordOrderByWithRelationInput[]
    cursor?: HealthRecordWhereUniqueInput
    take?: number
    skip?: number
    distinct?: HealthRecordScalarFieldEnum | HealthRecordScalarFieldEnum[]
  }

  /**
   * Santri.medications
   */
  export type Santri$medicationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Medication
     */
    select?: MedicationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicationInclude<ExtArgs> | null
    where?: MedicationWhereInput
    orderBy?: MedicationOrderByWithRelationInput | MedicationOrderByWithRelationInput[]
    cursor?: MedicationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MedicationScalarFieldEnum | MedicationScalarFieldEnum[]
  }

  /**
   * Santri without action
   */
  export type SantriDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Santri
     */
    select?: SantriSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SantriInclude<ExtArgs> | null
  }


  /**
   * Model Wali
   */

  export type AggregateWali = {
    _count: WaliCountAggregateOutputType | null
    _min: WaliMinAggregateOutputType | null
    _max: WaliMaxAggregateOutputType | null
  }

  export type WaliMinAggregateOutputType = {
    id: string | null
    tenantId: string | null
    name: string | null
    relation: string | null
    phone: string | null
    email: string | null
    address: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type WaliMaxAggregateOutputType = {
    id: string | null
    tenantId: string | null
    name: string | null
    relation: string | null
    phone: string | null
    email: string | null
    address: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type WaliCountAggregateOutputType = {
    id: number
    tenantId: number
    name: number
    relation: number
    phone: number
    email: number
    address: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type WaliMinAggregateInputType = {
    id?: true
    tenantId?: true
    name?: true
    relation?: true
    phone?: true
    email?: true
    address?: true
    createdAt?: true
    updatedAt?: true
  }

  export type WaliMaxAggregateInputType = {
    id?: true
    tenantId?: true
    name?: true
    relation?: true
    phone?: true
    email?: true
    address?: true
    createdAt?: true
    updatedAt?: true
  }

  export type WaliCountAggregateInputType = {
    id?: true
    tenantId?: true
    name?: true
    relation?: true
    phone?: true
    email?: true
    address?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type WaliAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Wali to aggregate.
     */
    where?: WaliWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Walis to fetch.
     */
    orderBy?: WaliOrderByWithRelationInput | WaliOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: WaliWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Walis from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Walis.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Walis
    **/
    _count?: true | WaliCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WaliMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WaliMaxAggregateInputType
  }

  export type GetWaliAggregateType<T extends WaliAggregateArgs> = {
        [P in keyof T & keyof AggregateWali]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWali[P]>
      : GetScalarType<T[P], AggregateWali[P]>
  }




  export type WaliGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WaliWhereInput
    orderBy?: WaliOrderByWithAggregationInput | WaliOrderByWithAggregationInput[]
    by: WaliScalarFieldEnum[] | WaliScalarFieldEnum
    having?: WaliScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WaliCountAggregateInputType | true
    _min?: WaliMinAggregateInputType
    _max?: WaliMaxAggregateInputType
  }

  export type WaliGroupByOutputType = {
    id: string
    tenantId: string
    name: string
    relation: string
    phone: string
    email: string | null
    address: string | null
    createdAt: Date
    updatedAt: Date
    _count: WaliCountAggregateOutputType | null
    _min: WaliMinAggregateOutputType | null
    _max: WaliMaxAggregateOutputType | null
  }

  type GetWaliGroupByPayload<T extends WaliGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<WaliGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WaliGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WaliGroupByOutputType[P]>
            : GetScalarType<T[P], WaliGroupByOutputType[P]>
        }
      >
    >


  export type WaliSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    name?: boolean
    relation?: boolean
    phone?: boolean
    email?: boolean
    address?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    santris?: boolean | Wali$santrisArgs<ExtArgs>
    _count?: boolean | WaliCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["wali"]>

  export type WaliSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    name?: boolean
    relation?: boolean
    phone?: boolean
    email?: boolean
    address?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["wali"]>

  export type WaliSelectScalar = {
    id?: boolean
    tenantId?: boolean
    name?: boolean
    relation?: boolean
    phone?: boolean
    email?: boolean
    address?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type WaliInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    santris?: boolean | Wali$santrisArgs<ExtArgs>
    _count?: boolean | WaliCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type WaliIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }

  export type $WaliPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Wali"
    objects: {
      tenant: Prisma.$TenantPayload<ExtArgs>
      santris: Prisma.$SantriWaliPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      tenantId: string
      name: string
      relation: string
      phone: string
      email: string | null
      address: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["wali"]>
    composites: {}
  }

  type WaliGetPayload<S extends boolean | null | undefined | WaliDefaultArgs> = $Result.GetResult<Prisma.$WaliPayload, S>

  type WaliCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<WaliFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: WaliCountAggregateInputType | true
    }

  export interface WaliDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Wali'], meta: { name: 'Wali' } }
    /**
     * Find zero or one Wali that matches the filter.
     * @param {WaliFindUniqueArgs} args - Arguments to find a Wali
     * @example
     * // Get one Wali
     * const wali = await prisma.wali.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends WaliFindUniqueArgs>(args: SelectSubset<T, WaliFindUniqueArgs<ExtArgs>>): Prisma__WaliClient<$Result.GetResult<Prisma.$WaliPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Wali that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {WaliFindUniqueOrThrowArgs} args - Arguments to find a Wali
     * @example
     * // Get one Wali
     * const wali = await prisma.wali.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends WaliFindUniqueOrThrowArgs>(args: SelectSubset<T, WaliFindUniqueOrThrowArgs<ExtArgs>>): Prisma__WaliClient<$Result.GetResult<Prisma.$WaliPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Wali that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WaliFindFirstArgs} args - Arguments to find a Wali
     * @example
     * // Get one Wali
     * const wali = await prisma.wali.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends WaliFindFirstArgs>(args?: SelectSubset<T, WaliFindFirstArgs<ExtArgs>>): Prisma__WaliClient<$Result.GetResult<Prisma.$WaliPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Wali that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WaliFindFirstOrThrowArgs} args - Arguments to find a Wali
     * @example
     * // Get one Wali
     * const wali = await prisma.wali.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends WaliFindFirstOrThrowArgs>(args?: SelectSubset<T, WaliFindFirstOrThrowArgs<ExtArgs>>): Prisma__WaliClient<$Result.GetResult<Prisma.$WaliPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Walis that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WaliFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Walis
     * const walis = await prisma.wali.findMany()
     * 
     * // Get first 10 Walis
     * const walis = await prisma.wali.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const waliWithIdOnly = await prisma.wali.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends WaliFindManyArgs>(args?: SelectSubset<T, WaliFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WaliPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Wali.
     * @param {WaliCreateArgs} args - Arguments to create a Wali.
     * @example
     * // Create one Wali
     * const Wali = await prisma.wali.create({
     *   data: {
     *     // ... data to create a Wali
     *   }
     * })
     * 
     */
    create<T extends WaliCreateArgs>(args: SelectSubset<T, WaliCreateArgs<ExtArgs>>): Prisma__WaliClient<$Result.GetResult<Prisma.$WaliPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Walis.
     * @param {WaliCreateManyArgs} args - Arguments to create many Walis.
     * @example
     * // Create many Walis
     * const wali = await prisma.wali.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends WaliCreateManyArgs>(args?: SelectSubset<T, WaliCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Walis and returns the data saved in the database.
     * @param {WaliCreateManyAndReturnArgs} args - Arguments to create many Walis.
     * @example
     * // Create many Walis
     * const wali = await prisma.wali.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Walis and only return the `id`
     * const waliWithIdOnly = await prisma.wali.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends WaliCreateManyAndReturnArgs>(args?: SelectSubset<T, WaliCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WaliPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Wali.
     * @param {WaliDeleteArgs} args - Arguments to delete one Wali.
     * @example
     * // Delete one Wali
     * const Wali = await prisma.wali.delete({
     *   where: {
     *     // ... filter to delete one Wali
     *   }
     * })
     * 
     */
    delete<T extends WaliDeleteArgs>(args: SelectSubset<T, WaliDeleteArgs<ExtArgs>>): Prisma__WaliClient<$Result.GetResult<Prisma.$WaliPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Wali.
     * @param {WaliUpdateArgs} args - Arguments to update one Wali.
     * @example
     * // Update one Wali
     * const wali = await prisma.wali.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends WaliUpdateArgs>(args: SelectSubset<T, WaliUpdateArgs<ExtArgs>>): Prisma__WaliClient<$Result.GetResult<Prisma.$WaliPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Walis.
     * @param {WaliDeleteManyArgs} args - Arguments to filter Walis to delete.
     * @example
     * // Delete a few Walis
     * const { count } = await prisma.wali.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends WaliDeleteManyArgs>(args?: SelectSubset<T, WaliDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Walis.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WaliUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Walis
     * const wali = await prisma.wali.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends WaliUpdateManyArgs>(args: SelectSubset<T, WaliUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Wali.
     * @param {WaliUpsertArgs} args - Arguments to update or create a Wali.
     * @example
     * // Update or create a Wali
     * const wali = await prisma.wali.upsert({
     *   create: {
     *     // ... data to create a Wali
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Wali we want to update
     *   }
     * })
     */
    upsert<T extends WaliUpsertArgs>(args: SelectSubset<T, WaliUpsertArgs<ExtArgs>>): Prisma__WaliClient<$Result.GetResult<Prisma.$WaliPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Walis.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WaliCountArgs} args - Arguments to filter Walis to count.
     * @example
     * // Count the number of Walis
     * const count = await prisma.wali.count({
     *   where: {
     *     // ... the filter for the Walis we want to count
     *   }
     * })
    **/
    count<T extends WaliCountArgs>(
      args?: Subset<T, WaliCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WaliCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Wali.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WaliAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WaliAggregateArgs>(args: Subset<T, WaliAggregateArgs>): Prisma.PrismaPromise<GetWaliAggregateType<T>>

    /**
     * Group by Wali.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WaliGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WaliGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WaliGroupByArgs['orderBy'] }
        : { orderBy?: WaliGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WaliGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWaliGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Wali model
   */
  readonly fields: WaliFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Wali.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__WaliClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    tenant<T extends TenantDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TenantDefaultArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    santris<T extends Wali$santrisArgs<ExtArgs> = {}>(args?: Subset<T, Wali$santrisArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SantriWaliPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Wali model
   */ 
  interface WaliFieldRefs {
    readonly id: FieldRef<"Wali", 'String'>
    readonly tenantId: FieldRef<"Wali", 'String'>
    readonly name: FieldRef<"Wali", 'String'>
    readonly relation: FieldRef<"Wali", 'String'>
    readonly phone: FieldRef<"Wali", 'String'>
    readonly email: FieldRef<"Wali", 'String'>
    readonly address: FieldRef<"Wali", 'String'>
    readonly createdAt: FieldRef<"Wali", 'DateTime'>
    readonly updatedAt: FieldRef<"Wali", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Wali findUnique
   */
  export type WaliFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Wali
     */
    select?: WaliSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WaliInclude<ExtArgs> | null
    /**
     * Filter, which Wali to fetch.
     */
    where: WaliWhereUniqueInput
  }

  /**
   * Wali findUniqueOrThrow
   */
  export type WaliFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Wali
     */
    select?: WaliSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WaliInclude<ExtArgs> | null
    /**
     * Filter, which Wali to fetch.
     */
    where: WaliWhereUniqueInput
  }

  /**
   * Wali findFirst
   */
  export type WaliFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Wali
     */
    select?: WaliSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WaliInclude<ExtArgs> | null
    /**
     * Filter, which Wali to fetch.
     */
    where?: WaliWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Walis to fetch.
     */
    orderBy?: WaliOrderByWithRelationInput | WaliOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Walis.
     */
    cursor?: WaliWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Walis from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Walis.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Walis.
     */
    distinct?: WaliScalarFieldEnum | WaliScalarFieldEnum[]
  }

  /**
   * Wali findFirstOrThrow
   */
  export type WaliFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Wali
     */
    select?: WaliSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WaliInclude<ExtArgs> | null
    /**
     * Filter, which Wali to fetch.
     */
    where?: WaliWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Walis to fetch.
     */
    orderBy?: WaliOrderByWithRelationInput | WaliOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Walis.
     */
    cursor?: WaliWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Walis from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Walis.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Walis.
     */
    distinct?: WaliScalarFieldEnum | WaliScalarFieldEnum[]
  }

  /**
   * Wali findMany
   */
  export type WaliFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Wali
     */
    select?: WaliSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WaliInclude<ExtArgs> | null
    /**
     * Filter, which Walis to fetch.
     */
    where?: WaliWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Walis to fetch.
     */
    orderBy?: WaliOrderByWithRelationInput | WaliOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Walis.
     */
    cursor?: WaliWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Walis from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Walis.
     */
    skip?: number
    distinct?: WaliScalarFieldEnum | WaliScalarFieldEnum[]
  }

  /**
   * Wali create
   */
  export type WaliCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Wali
     */
    select?: WaliSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WaliInclude<ExtArgs> | null
    /**
     * The data needed to create a Wali.
     */
    data: XOR<WaliCreateInput, WaliUncheckedCreateInput>
  }

  /**
   * Wali createMany
   */
  export type WaliCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Walis.
     */
    data: WaliCreateManyInput | WaliCreateManyInput[]
  }

  /**
   * Wali createManyAndReturn
   */
  export type WaliCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Wali
     */
    select?: WaliSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Walis.
     */
    data: WaliCreateManyInput | WaliCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WaliIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Wali update
   */
  export type WaliUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Wali
     */
    select?: WaliSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WaliInclude<ExtArgs> | null
    /**
     * The data needed to update a Wali.
     */
    data: XOR<WaliUpdateInput, WaliUncheckedUpdateInput>
    /**
     * Choose, which Wali to update.
     */
    where: WaliWhereUniqueInput
  }

  /**
   * Wali updateMany
   */
  export type WaliUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Walis.
     */
    data: XOR<WaliUpdateManyMutationInput, WaliUncheckedUpdateManyInput>
    /**
     * Filter which Walis to update
     */
    where?: WaliWhereInput
  }

  /**
   * Wali upsert
   */
  export type WaliUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Wali
     */
    select?: WaliSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WaliInclude<ExtArgs> | null
    /**
     * The filter to search for the Wali to update in case it exists.
     */
    where: WaliWhereUniqueInput
    /**
     * In case the Wali found by the `where` argument doesn't exist, create a new Wali with this data.
     */
    create: XOR<WaliCreateInput, WaliUncheckedCreateInput>
    /**
     * In case the Wali was found with the provided `where` argument, update it with this data.
     */
    update: XOR<WaliUpdateInput, WaliUncheckedUpdateInput>
  }

  /**
   * Wali delete
   */
  export type WaliDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Wali
     */
    select?: WaliSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WaliInclude<ExtArgs> | null
    /**
     * Filter which Wali to delete.
     */
    where: WaliWhereUniqueInput
  }

  /**
   * Wali deleteMany
   */
  export type WaliDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Walis to delete
     */
    where?: WaliWhereInput
  }

  /**
   * Wali.santris
   */
  export type Wali$santrisArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SantriWali
     */
    select?: SantriWaliSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SantriWaliInclude<ExtArgs> | null
    where?: SantriWaliWhereInput
    orderBy?: SantriWaliOrderByWithRelationInput | SantriWaliOrderByWithRelationInput[]
    cursor?: SantriWaliWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SantriWaliScalarFieldEnum | SantriWaliScalarFieldEnum[]
  }

  /**
   * Wali without action
   */
  export type WaliDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Wali
     */
    select?: WaliSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WaliInclude<ExtArgs> | null
  }


  /**
   * Model SantriWali
   */

  export type AggregateSantriWali = {
    _count: SantriWaliCountAggregateOutputType | null
    _min: SantriWaliMinAggregateOutputType | null
    _max: SantriWaliMaxAggregateOutputType | null
  }

  export type SantriWaliMinAggregateOutputType = {
    santriId: string | null
    waliId: string | null
    isPrimary: boolean | null
  }

  export type SantriWaliMaxAggregateOutputType = {
    santriId: string | null
    waliId: string | null
    isPrimary: boolean | null
  }

  export type SantriWaliCountAggregateOutputType = {
    santriId: number
    waliId: number
    isPrimary: number
    _all: number
  }


  export type SantriWaliMinAggregateInputType = {
    santriId?: true
    waliId?: true
    isPrimary?: true
  }

  export type SantriWaliMaxAggregateInputType = {
    santriId?: true
    waliId?: true
    isPrimary?: true
  }

  export type SantriWaliCountAggregateInputType = {
    santriId?: true
    waliId?: true
    isPrimary?: true
    _all?: true
  }

  export type SantriWaliAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SantriWali to aggregate.
     */
    where?: SantriWaliWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SantriWalis to fetch.
     */
    orderBy?: SantriWaliOrderByWithRelationInput | SantriWaliOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SantriWaliWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SantriWalis from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SantriWalis.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SantriWalis
    **/
    _count?: true | SantriWaliCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SantriWaliMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SantriWaliMaxAggregateInputType
  }

  export type GetSantriWaliAggregateType<T extends SantriWaliAggregateArgs> = {
        [P in keyof T & keyof AggregateSantriWali]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSantriWali[P]>
      : GetScalarType<T[P], AggregateSantriWali[P]>
  }




  export type SantriWaliGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SantriWaliWhereInput
    orderBy?: SantriWaliOrderByWithAggregationInput | SantriWaliOrderByWithAggregationInput[]
    by: SantriWaliScalarFieldEnum[] | SantriWaliScalarFieldEnum
    having?: SantriWaliScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SantriWaliCountAggregateInputType | true
    _min?: SantriWaliMinAggregateInputType
    _max?: SantriWaliMaxAggregateInputType
  }

  export type SantriWaliGroupByOutputType = {
    santriId: string
    waliId: string
    isPrimary: boolean
    _count: SantriWaliCountAggregateOutputType | null
    _min: SantriWaliMinAggregateOutputType | null
    _max: SantriWaliMaxAggregateOutputType | null
  }

  type GetSantriWaliGroupByPayload<T extends SantriWaliGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SantriWaliGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SantriWaliGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SantriWaliGroupByOutputType[P]>
            : GetScalarType<T[P], SantriWaliGroupByOutputType[P]>
        }
      >
    >


  export type SantriWaliSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    santriId?: boolean
    waliId?: boolean
    isPrimary?: boolean
    santri?: boolean | SantriDefaultArgs<ExtArgs>
    wali?: boolean | WaliDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["santriWali"]>

  export type SantriWaliSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    santriId?: boolean
    waliId?: boolean
    isPrimary?: boolean
    santri?: boolean | SantriDefaultArgs<ExtArgs>
    wali?: boolean | WaliDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["santriWali"]>

  export type SantriWaliSelectScalar = {
    santriId?: boolean
    waliId?: boolean
    isPrimary?: boolean
  }

  export type SantriWaliInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    santri?: boolean | SantriDefaultArgs<ExtArgs>
    wali?: boolean | WaliDefaultArgs<ExtArgs>
  }
  export type SantriWaliIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    santri?: boolean | SantriDefaultArgs<ExtArgs>
    wali?: boolean | WaliDefaultArgs<ExtArgs>
  }

  export type $SantriWaliPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SantriWali"
    objects: {
      santri: Prisma.$SantriPayload<ExtArgs>
      wali: Prisma.$WaliPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      santriId: string
      waliId: string
      isPrimary: boolean
    }, ExtArgs["result"]["santriWali"]>
    composites: {}
  }

  type SantriWaliGetPayload<S extends boolean | null | undefined | SantriWaliDefaultArgs> = $Result.GetResult<Prisma.$SantriWaliPayload, S>

  type SantriWaliCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<SantriWaliFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: SantriWaliCountAggregateInputType | true
    }

  export interface SantriWaliDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SantriWali'], meta: { name: 'SantriWali' } }
    /**
     * Find zero or one SantriWali that matches the filter.
     * @param {SantriWaliFindUniqueArgs} args - Arguments to find a SantriWali
     * @example
     * // Get one SantriWali
     * const santriWali = await prisma.santriWali.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SantriWaliFindUniqueArgs>(args: SelectSubset<T, SantriWaliFindUniqueArgs<ExtArgs>>): Prisma__SantriWaliClient<$Result.GetResult<Prisma.$SantriWaliPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one SantriWali that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {SantriWaliFindUniqueOrThrowArgs} args - Arguments to find a SantriWali
     * @example
     * // Get one SantriWali
     * const santriWali = await prisma.santriWali.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SantriWaliFindUniqueOrThrowArgs>(args: SelectSubset<T, SantriWaliFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SantriWaliClient<$Result.GetResult<Prisma.$SantriWaliPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first SantriWali that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SantriWaliFindFirstArgs} args - Arguments to find a SantriWali
     * @example
     * // Get one SantriWali
     * const santriWali = await prisma.santriWali.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SantriWaliFindFirstArgs>(args?: SelectSubset<T, SantriWaliFindFirstArgs<ExtArgs>>): Prisma__SantriWaliClient<$Result.GetResult<Prisma.$SantriWaliPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first SantriWali that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SantriWaliFindFirstOrThrowArgs} args - Arguments to find a SantriWali
     * @example
     * // Get one SantriWali
     * const santriWali = await prisma.santriWali.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SantriWaliFindFirstOrThrowArgs>(args?: SelectSubset<T, SantriWaliFindFirstOrThrowArgs<ExtArgs>>): Prisma__SantriWaliClient<$Result.GetResult<Prisma.$SantriWaliPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more SantriWalis that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SantriWaliFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SantriWalis
     * const santriWalis = await prisma.santriWali.findMany()
     * 
     * // Get first 10 SantriWalis
     * const santriWalis = await prisma.santriWali.findMany({ take: 10 })
     * 
     * // Only select the `santriId`
     * const santriWaliWithSantriIdOnly = await prisma.santriWali.findMany({ select: { santriId: true } })
     * 
     */
    findMany<T extends SantriWaliFindManyArgs>(args?: SelectSubset<T, SantriWaliFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SantriWaliPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a SantriWali.
     * @param {SantriWaliCreateArgs} args - Arguments to create a SantriWali.
     * @example
     * // Create one SantriWali
     * const SantriWali = await prisma.santriWali.create({
     *   data: {
     *     // ... data to create a SantriWali
     *   }
     * })
     * 
     */
    create<T extends SantriWaliCreateArgs>(args: SelectSubset<T, SantriWaliCreateArgs<ExtArgs>>): Prisma__SantriWaliClient<$Result.GetResult<Prisma.$SantriWaliPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many SantriWalis.
     * @param {SantriWaliCreateManyArgs} args - Arguments to create many SantriWalis.
     * @example
     * // Create many SantriWalis
     * const santriWali = await prisma.santriWali.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SantriWaliCreateManyArgs>(args?: SelectSubset<T, SantriWaliCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SantriWalis and returns the data saved in the database.
     * @param {SantriWaliCreateManyAndReturnArgs} args - Arguments to create many SantriWalis.
     * @example
     * // Create many SantriWalis
     * const santriWali = await prisma.santriWali.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SantriWalis and only return the `santriId`
     * const santriWaliWithSantriIdOnly = await prisma.santriWali.createManyAndReturn({ 
     *   select: { santriId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SantriWaliCreateManyAndReturnArgs>(args?: SelectSubset<T, SantriWaliCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SantriWaliPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a SantriWali.
     * @param {SantriWaliDeleteArgs} args - Arguments to delete one SantriWali.
     * @example
     * // Delete one SantriWali
     * const SantriWali = await prisma.santriWali.delete({
     *   where: {
     *     // ... filter to delete one SantriWali
     *   }
     * })
     * 
     */
    delete<T extends SantriWaliDeleteArgs>(args: SelectSubset<T, SantriWaliDeleteArgs<ExtArgs>>): Prisma__SantriWaliClient<$Result.GetResult<Prisma.$SantriWaliPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one SantriWali.
     * @param {SantriWaliUpdateArgs} args - Arguments to update one SantriWali.
     * @example
     * // Update one SantriWali
     * const santriWali = await prisma.santriWali.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SantriWaliUpdateArgs>(args: SelectSubset<T, SantriWaliUpdateArgs<ExtArgs>>): Prisma__SantriWaliClient<$Result.GetResult<Prisma.$SantriWaliPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more SantriWalis.
     * @param {SantriWaliDeleteManyArgs} args - Arguments to filter SantriWalis to delete.
     * @example
     * // Delete a few SantriWalis
     * const { count } = await prisma.santriWali.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SantriWaliDeleteManyArgs>(args?: SelectSubset<T, SantriWaliDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SantriWalis.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SantriWaliUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SantriWalis
     * const santriWali = await prisma.santriWali.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SantriWaliUpdateManyArgs>(args: SelectSubset<T, SantriWaliUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one SantriWali.
     * @param {SantriWaliUpsertArgs} args - Arguments to update or create a SantriWali.
     * @example
     * // Update or create a SantriWali
     * const santriWali = await prisma.santriWali.upsert({
     *   create: {
     *     // ... data to create a SantriWali
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SantriWali we want to update
     *   }
     * })
     */
    upsert<T extends SantriWaliUpsertArgs>(args: SelectSubset<T, SantriWaliUpsertArgs<ExtArgs>>): Prisma__SantriWaliClient<$Result.GetResult<Prisma.$SantriWaliPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of SantriWalis.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SantriWaliCountArgs} args - Arguments to filter SantriWalis to count.
     * @example
     * // Count the number of SantriWalis
     * const count = await prisma.santriWali.count({
     *   where: {
     *     // ... the filter for the SantriWalis we want to count
     *   }
     * })
    **/
    count<T extends SantriWaliCountArgs>(
      args?: Subset<T, SantriWaliCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SantriWaliCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SantriWali.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SantriWaliAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SantriWaliAggregateArgs>(args: Subset<T, SantriWaliAggregateArgs>): Prisma.PrismaPromise<GetSantriWaliAggregateType<T>>

    /**
     * Group by SantriWali.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SantriWaliGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SantriWaliGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SantriWaliGroupByArgs['orderBy'] }
        : { orderBy?: SantriWaliGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SantriWaliGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSantriWaliGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SantriWali model
   */
  readonly fields: SantriWaliFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SantriWali.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SantriWaliClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    santri<T extends SantriDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SantriDefaultArgs<ExtArgs>>): Prisma__SantriClient<$Result.GetResult<Prisma.$SantriPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    wali<T extends WaliDefaultArgs<ExtArgs> = {}>(args?: Subset<T, WaliDefaultArgs<ExtArgs>>): Prisma__WaliClient<$Result.GetResult<Prisma.$WaliPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SantriWali model
   */ 
  interface SantriWaliFieldRefs {
    readonly santriId: FieldRef<"SantriWali", 'String'>
    readonly waliId: FieldRef<"SantriWali", 'String'>
    readonly isPrimary: FieldRef<"SantriWali", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * SantriWali findUnique
   */
  export type SantriWaliFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SantriWali
     */
    select?: SantriWaliSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SantriWaliInclude<ExtArgs> | null
    /**
     * Filter, which SantriWali to fetch.
     */
    where: SantriWaliWhereUniqueInput
  }

  /**
   * SantriWali findUniqueOrThrow
   */
  export type SantriWaliFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SantriWali
     */
    select?: SantriWaliSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SantriWaliInclude<ExtArgs> | null
    /**
     * Filter, which SantriWali to fetch.
     */
    where: SantriWaliWhereUniqueInput
  }

  /**
   * SantriWali findFirst
   */
  export type SantriWaliFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SantriWali
     */
    select?: SantriWaliSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SantriWaliInclude<ExtArgs> | null
    /**
     * Filter, which SantriWali to fetch.
     */
    where?: SantriWaliWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SantriWalis to fetch.
     */
    orderBy?: SantriWaliOrderByWithRelationInput | SantriWaliOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SantriWalis.
     */
    cursor?: SantriWaliWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SantriWalis from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SantriWalis.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SantriWalis.
     */
    distinct?: SantriWaliScalarFieldEnum | SantriWaliScalarFieldEnum[]
  }

  /**
   * SantriWali findFirstOrThrow
   */
  export type SantriWaliFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SantriWali
     */
    select?: SantriWaliSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SantriWaliInclude<ExtArgs> | null
    /**
     * Filter, which SantriWali to fetch.
     */
    where?: SantriWaliWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SantriWalis to fetch.
     */
    orderBy?: SantriWaliOrderByWithRelationInput | SantriWaliOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SantriWalis.
     */
    cursor?: SantriWaliWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SantriWalis from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SantriWalis.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SantriWalis.
     */
    distinct?: SantriWaliScalarFieldEnum | SantriWaliScalarFieldEnum[]
  }

  /**
   * SantriWali findMany
   */
  export type SantriWaliFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SantriWali
     */
    select?: SantriWaliSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SantriWaliInclude<ExtArgs> | null
    /**
     * Filter, which SantriWalis to fetch.
     */
    where?: SantriWaliWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SantriWalis to fetch.
     */
    orderBy?: SantriWaliOrderByWithRelationInput | SantriWaliOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SantriWalis.
     */
    cursor?: SantriWaliWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SantriWalis from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SantriWalis.
     */
    skip?: number
    distinct?: SantriWaliScalarFieldEnum | SantriWaliScalarFieldEnum[]
  }

  /**
   * SantriWali create
   */
  export type SantriWaliCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SantriWali
     */
    select?: SantriWaliSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SantriWaliInclude<ExtArgs> | null
    /**
     * The data needed to create a SantriWali.
     */
    data: XOR<SantriWaliCreateInput, SantriWaliUncheckedCreateInput>
  }

  /**
   * SantriWali createMany
   */
  export type SantriWaliCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SantriWalis.
     */
    data: SantriWaliCreateManyInput | SantriWaliCreateManyInput[]
  }

  /**
   * SantriWali createManyAndReturn
   */
  export type SantriWaliCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SantriWali
     */
    select?: SantriWaliSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many SantriWalis.
     */
    data: SantriWaliCreateManyInput | SantriWaliCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SantriWaliIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * SantriWali update
   */
  export type SantriWaliUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SantriWali
     */
    select?: SantriWaliSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SantriWaliInclude<ExtArgs> | null
    /**
     * The data needed to update a SantriWali.
     */
    data: XOR<SantriWaliUpdateInput, SantriWaliUncheckedUpdateInput>
    /**
     * Choose, which SantriWali to update.
     */
    where: SantriWaliWhereUniqueInput
  }

  /**
   * SantriWali updateMany
   */
  export type SantriWaliUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SantriWalis.
     */
    data: XOR<SantriWaliUpdateManyMutationInput, SantriWaliUncheckedUpdateManyInput>
    /**
     * Filter which SantriWalis to update
     */
    where?: SantriWaliWhereInput
  }

  /**
   * SantriWali upsert
   */
  export type SantriWaliUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SantriWali
     */
    select?: SantriWaliSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SantriWaliInclude<ExtArgs> | null
    /**
     * The filter to search for the SantriWali to update in case it exists.
     */
    where: SantriWaliWhereUniqueInput
    /**
     * In case the SantriWali found by the `where` argument doesn't exist, create a new SantriWali with this data.
     */
    create: XOR<SantriWaliCreateInput, SantriWaliUncheckedCreateInput>
    /**
     * In case the SantriWali was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SantriWaliUpdateInput, SantriWaliUncheckedUpdateInput>
  }

  /**
   * SantriWali delete
   */
  export type SantriWaliDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SantriWali
     */
    select?: SantriWaliSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SantriWaliInclude<ExtArgs> | null
    /**
     * Filter which SantriWali to delete.
     */
    where: SantriWaliWhereUniqueInput
  }

  /**
   * SantriWali deleteMany
   */
  export type SantriWaliDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SantriWalis to delete
     */
    where?: SantriWaliWhereInput
  }

  /**
   * SantriWali without action
   */
  export type SantriWaliDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SantriWali
     */
    select?: SantriWaliSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SantriWaliInclude<ExtArgs> | null
  }


  /**
   * Model Izin
   */

  export type AggregateIzin = {
    _count: IzinCountAggregateOutputType | null
    _min: IzinMinAggregateOutputType | null
    _max: IzinMaxAggregateOutputType | null
  }

  export type IzinMinAggregateOutputType = {
    id: string | null
    tenantId: string | null
    santriId: string | null
    type: string | null
    reason: string | null
    startAt: Date | null
    endAt: Date | null
    status: string | null
    requestedBy: string | null
    approvedBy: string | null
    approvedAt: Date | null
    qrCodeData: string | null
    checkoutAt: Date | null
    checkoutBy: string | null
    checkinAt: Date | null
    checkinBy: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type IzinMaxAggregateOutputType = {
    id: string | null
    tenantId: string | null
    santriId: string | null
    type: string | null
    reason: string | null
    startAt: Date | null
    endAt: Date | null
    status: string | null
    requestedBy: string | null
    approvedBy: string | null
    approvedAt: Date | null
    qrCodeData: string | null
    checkoutAt: Date | null
    checkoutBy: string | null
    checkinAt: Date | null
    checkinBy: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type IzinCountAggregateOutputType = {
    id: number
    tenantId: number
    santriId: number
    type: number
    reason: number
    startAt: number
    endAt: number
    status: number
    requestedBy: number
    approvedBy: number
    approvedAt: number
    qrCodeData: number
    checkoutAt: number
    checkoutBy: number
    checkinAt: number
    checkinBy: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type IzinMinAggregateInputType = {
    id?: true
    tenantId?: true
    santriId?: true
    type?: true
    reason?: true
    startAt?: true
    endAt?: true
    status?: true
    requestedBy?: true
    approvedBy?: true
    approvedAt?: true
    qrCodeData?: true
    checkoutAt?: true
    checkoutBy?: true
    checkinAt?: true
    checkinBy?: true
    createdAt?: true
    updatedAt?: true
  }

  export type IzinMaxAggregateInputType = {
    id?: true
    tenantId?: true
    santriId?: true
    type?: true
    reason?: true
    startAt?: true
    endAt?: true
    status?: true
    requestedBy?: true
    approvedBy?: true
    approvedAt?: true
    qrCodeData?: true
    checkoutAt?: true
    checkoutBy?: true
    checkinAt?: true
    checkinBy?: true
    createdAt?: true
    updatedAt?: true
  }

  export type IzinCountAggregateInputType = {
    id?: true
    tenantId?: true
    santriId?: true
    type?: true
    reason?: true
    startAt?: true
    endAt?: true
    status?: true
    requestedBy?: true
    approvedBy?: true
    approvedAt?: true
    qrCodeData?: true
    checkoutAt?: true
    checkoutBy?: true
    checkinAt?: true
    checkinBy?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type IzinAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Izin to aggregate.
     */
    where?: IzinWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Izins to fetch.
     */
    orderBy?: IzinOrderByWithRelationInput | IzinOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: IzinWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Izins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Izins.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Izins
    **/
    _count?: true | IzinCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: IzinMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: IzinMaxAggregateInputType
  }

  export type GetIzinAggregateType<T extends IzinAggregateArgs> = {
        [P in keyof T & keyof AggregateIzin]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateIzin[P]>
      : GetScalarType<T[P], AggregateIzin[P]>
  }




  export type IzinGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: IzinWhereInput
    orderBy?: IzinOrderByWithAggregationInput | IzinOrderByWithAggregationInput[]
    by: IzinScalarFieldEnum[] | IzinScalarFieldEnum
    having?: IzinScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: IzinCountAggregateInputType | true
    _min?: IzinMinAggregateInputType
    _max?: IzinMaxAggregateInputType
  }

  export type IzinGroupByOutputType = {
    id: string
    tenantId: string
    santriId: string
    type: string
    reason: string
    startAt: Date
    endAt: Date
    status: string
    requestedBy: string
    approvedBy: string | null
    approvedAt: Date | null
    qrCodeData: string | null
    checkoutAt: Date | null
    checkoutBy: string | null
    checkinAt: Date | null
    checkinBy: string | null
    createdAt: Date
    updatedAt: Date
    _count: IzinCountAggregateOutputType | null
    _min: IzinMinAggregateOutputType | null
    _max: IzinMaxAggregateOutputType | null
  }

  type GetIzinGroupByPayload<T extends IzinGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<IzinGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof IzinGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], IzinGroupByOutputType[P]>
            : GetScalarType<T[P], IzinGroupByOutputType[P]>
        }
      >
    >


  export type IzinSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    santriId?: boolean
    type?: boolean
    reason?: boolean
    startAt?: boolean
    endAt?: boolean
    status?: boolean
    requestedBy?: boolean
    approvedBy?: boolean
    approvedAt?: boolean
    qrCodeData?: boolean
    checkoutAt?: boolean
    checkoutBy?: boolean
    checkinAt?: boolean
    checkinBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    santri?: boolean | SantriDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["izin"]>

  export type IzinSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    santriId?: boolean
    type?: boolean
    reason?: boolean
    startAt?: boolean
    endAt?: boolean
    status?: boolean
    requestedBy?: boolean
    approvedBy?: boolean
    approvedAt?: boolean
    qrCodeData?: boolean
    checkoutAt?: boolean
    checkoutBy?: boolean
    checkinAt?: boolean
    checkinBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    santri?: boolean | SantriDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["izin"]>

  export type IzinSelectScalar = {
    id?: boolean
    tenantId?: boolean
    santriId?: boolean
    type?: boolean
    reason?: boolean
    startAt?: boolean
    endAt?: boolean
    status?: boolean
    requestedBy?: boolean
    approvedBy?: boolean
    approvedAt?: boolean
    qrCodeData?: boolean
    checkoutAt?: boolean
    checkoutBy?: boolean
    checkinAt?: boolean
    checkinBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type IzinInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    santri?: boolean | SantriDefaultArgs<ExtArgs>
  }
  export type IzinIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    santri?: boolean | SantriDefaultArgs<ExtArgs>
  }

  export type $IzinPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Izin"
    objects: {
      tenant: Prisma.$TenantPayload<ExtArgs>
      santri: Prisma.$SantriPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      tenantId: string
      santriId: string
      type: string
      reason: string
      startAt: Date
      endAt: Date
      status: string
      requestedBy: string
      approvedBy: string | null
      approvedAt: Date | null
      qrCodeData: string | null
      checkoutAt: Date | null
      checkoutBy: string | null
      checkinAt: Date | null
      checkinBy: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["izin"]>
    composites: {}
  }

  type IzinGetPayload<S extends boolean | null | undefined | IzinDefaultArgs> = $Result.GetResult<Prisma.$IzinPayload, S>

  type IzinCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<IzinFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: IzinCountAggregateInputType | true
    }

  export interface IzinDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Izin'], meta: { name: 'Izin' } }
    /**
     * Find zero or one Izin that matches the filter.
     * @param {IzinFindUniqueArgs} args - Arguments to find a Izin
     * @example
     * // Get one Izin
     * const izin = await prisma.izin.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends IzinFindUniqueArgs>(args: SelectSubset<T, IzinFindUniqueArgs<ExtArgs>>): Prisma__IzinClient<$Result.GetResult<Prisma.$IzinPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Izin that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {IzinFindUniqueOrThrowArgs} args - Arguments to find a Izin
     * @example
     * // Get one Izin
     * const izin = await prisma.izin.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends IzinFindUniqueOrThrowArgs>(args: SelectSubset<T, IzinFindUniqueOrThrowArgs<ExtArgs>>): Prisma__IzinClient<$Result.GetResult<Prisma.$IzinPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Izin that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IzinFindFirstArgs} args - Arguments to find a Izin
     * @example
     * // Get one Izin
     * const izin = await prisma.izin.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends IzinFindFirstArgs>(args?: SelectSubset<T, IzinFindFirstArgs<ExtArgs>>): Prisma__IzinClient<$Result.GetResult<Prisma.$IzinPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Izin that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IzinFindFirstOrThrowArgs} args - Arguments to find a Izin
     * @example
     * // Get one Izin
     * const izin = await prisma.izin.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends IzinFindFirstOrThrowArgs>(args?: SelectSubset<T, IzinFindFirstOrThrowArgs<ExtArgs>>): Prisma__IzinClient<$Result.GetResult<Prisma.$IzinPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Izins that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IzinFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Izins
     * const izins = await prisma.izin.findMany()
     * 
     * // Get first 10 Izins
     * const izins = await prisma.izin.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const izinWithIdOnly = await prisma.izin.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends IzinFindManyArgs>(args?: SelectSubset<T, IzinFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IzinPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Izin.
     * @param {IzinCreateArgs} args - Arguments to create a Izin.
     * @example
     * // Create one Izin
     * const Izin = await prisma.izin.create({
     *   data: {
     *     // ... data to create a Izin
     *   }
     * })
     * 
     */
    create<T extends IzinCreateArgs>(args: SelectSubset<T, IzinCreateArgs<ExtArgs>>): Prisma__IzinClient<$Result.GetResult<Prisma.$IzinPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Izins.
     * @param {IzinCreateManyArgs} args - Arguments to create many Izins.
     * @example
     * // Create many Izins
     * const izin = await prisma.izin.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends IzinCreateManyArgs>(args?: SelectSubset<T, IzinCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Izins and returns the data saved in the database.
     * @param {IzinCreateManyAndReturnArgs} args - Arguments to create many Izins.
     * @example
     * // Create many Izins
     * const izin = await prisma.izin.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Izins and only return the `id`
     * const izinWithIdOnly = await prisma.izin.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends IzinCreateManyAndReturnArgs>(args?: SelectSubset<T, IzinCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IzinPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Izin.
     * @param {IzinDeleteArgs} args - Arguments to delete one Izin.
     * @example
     * // Delete one Izin
     * const Izin = await prisma.izin.delete({
     *   where: {
     *     // ... filter to delete one Izin
     *   }
     * })
     * 
     */
    delete<T extends IzinDeleteArgs>(args: SelectSubset<T, IzinDeleteArgs<ExtArgs>>): Prisma__IzinClient<$Result.GetResult<Prisma.$IzinPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Izin.
     * @param {IzinUpdateArgs} args - Arguments to update one Izin.
     * @example
     * // Update one Izin
     * const izin = await prisma.izin.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends IzinUpdateArgs>(args: SelectSubset<T, IzinUpdateArgs<ExtArgs>>): Prisma__IzinClient<$Result.GetResult<Prisma.$IzinPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Izins.
     * @param {IzinDeleteManyArgs} args - Arguments to filter Izins to delete.
     * @example
     * // Delete a few Izins
     * const { count } = await prisma.izin.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends IzinDeleteManyArgs>(args?: SelectSubset<T, IzinDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Izins.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IzinUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Izins
     * const izin = await prisma.izin.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends IzinUpdateManyArgs>(args: SelectSubset<T, IzinUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Izin.
     * @param {IzinUpsertArgs} args - Arguments to update or create a Izin.
     * @example
     * // Update or create a Izin
     * const izin = await prisma.izin.upsert({
     *   create: {
     *     // ... data to create a Izin
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Izin we want to update
     *   }
     * })
     */
    upsert<T extends IzinUpsertArgs>(args: SelectSubset<T, IzinUpsertArgs<ExtArgs>>): Prisma__IzinClient<$Result.GetResult<Prisma.$IzinPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Izins.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IzinCountArgs} args - Arguments to filter Izins to count.
     * @example
     * // Count the number of Izins
     * const count = await prisma.izin.count({
     *   where: {
     *     // ... the filter for the Izins we want to count
     *   }
     * })
    **/
    count<T extends IzinCountArgs>(
      args?: Subset<T, IzinCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], IzinCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Izin.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IzinAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends IzinAggregateArgs>(args: Subset<T, IzinAggregateArgs>): Prisma.PrismaPromise<GetIzinAggregateType<T>>

    /**
     * Group by Izin.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IzinGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends IzinGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: IzinGroupByArgs['orderBy'] }
        : { orderBy?: IzinGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, IzinGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetIzinGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Izin model
   */
  readonly fields: IzinFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Izin.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__IzinClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    tenant<T extends TenantDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TenantDefaultArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    santri<T extends SantriDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SantriDefaultArgs<ExtArgs>>): Prisma__SantriClient<$Result.GetResult<Prisma.$SantriPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Izin model
   */ 
  interface IzinFieldRefs {
    readonly id: FieldRef<"Izin", 'String'>
    readonly tenantId: FieldRef<"Izin", 'String'>
    readonly santriId: FieldRef<"Izin", 'String'>
    readonly type: FieldRef<"Izin", 'String'>
    readonly reason: FieldRef<"Izin", 'String'>
    readonly startAt: FieldRef<"Izin", 'DateTime'>
    readonly endAt: FieldRef<"Izin", 'DateTime'>
    readonly status: FieldRef<"Izin", 'String'>
    readonly requestedBy: FieldRef<"Izin", 'String'>
    readonly approvedBy: FieldRef<"Izin", 'String'>
    readonly approvedAt: FieldRef<"Izin", 'DateTime'>
    readonly qrCodeData: FieldRef<"Izin", 'String'>
    readonly checkoutAt: FieldRef<"Izin", 'DateTime'>
    readonly checkoutBy: FieldRef<"Izin", 'String'>
    readonly checkinAt: FieldRef<"Izin", 'DateTime'>
    readonly checkinBy: FieldRef<"Izin", 'String'>
    readonly createdAt: FieldRef<"Izin", 'DateTime'>
    readonly updatedAt: FieldRef<"Izin", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Izin findUnique
   */
  export type IzinFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Izin
     */
    select?: IzinSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IzinInclude<ExtArgs> | null
    /**
     * Filter, which Izin to fetch.
     */
    where: IzinWhereUniqueInput
  }

  /**
   * Izin findUniqueOrThrow
   */
  export type IzinFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Izin
     */
    select?: IzinSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IzinInclude<ExtArgs> | null
    /**
     * Filter, which Izin to fetch.
     */
    where: IzinWhereUniqueInput
  }

  /**
   * Izin findFirst
   */
  export type IzinFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Izin
     */
    select?: IzinSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IzinInclude<ExtArgs> | null
    /**
     * Filter, which Izin to fetch.
     */
    where?: IzinWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Izins to fetch.
     */
    orderBy?: IzinOrderByWithRelationInput | IzinOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Izins.
     */
    cursor?: IzinWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Izins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Izins.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Izins.
     */
    distinct?: IzinScalarFieldEnum | IzinScalarFieldEnum[]
  }

  /**
   * Izin findFirstOrThrow
   */
  export type IzinFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Izin
     */
    select?: IzinSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IzinInclude<ExtArgs> | null
    /**
     * Filter, which Izin to fetch.
     */
    where?: IzinWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Izins to fetch.
     */
    orderBy?: IzinOrderByWithRelationInput | IzinOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Izins.
     */
    cursor?: IzinWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Izins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Izins.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Izins.
     */
    distinct?: IzinScalarFieldEnum | IzinScalarFieldEnum[]
  }

  /**
   * Izin findMany
   */
  export type IzinFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Izin
     */
    select?: IzinSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IzinInclude<ExtArgs> | null
    /**
     * Filter, which Izins to fetch.
     */
    where?: IzinWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Izins to fetch.
     */
    orderBy?: IzinOrderByWithRelationInput | IzinOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Izins.
     */
    cursor?: IzinWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Izins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Izins.
     */
    skip?: number
    distinct?: IzinScalarFieldEnum | IzinScalarFieldEnum[]
  }

  /**
   * Izin create
   */
  export type IzinCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Izin
     */
    select?: IzinSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IzinInclude<ExtArgs> | null
    /**
     * The data needed to create a Izin.
     */
    data: XOR<IzinCreateInput, IzinUncheckedCreateInput>
  }

  /**
   * Izin createMany
   */
  export type IzinCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Izins.
     */
    data: IzinCreateManyInput | IzinCreateManyInput[]
  }

  /**
   * Izin createManyAndReturn
   */
  export type IzinCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Izin
     */
    select?: IzinSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Izins.
     */
    data: IzinCreateManyInput | IzinCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IzinIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Izin update
   */
  export type IzinUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Izin
     */
    select?: IzinSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IzinInclude<ExtArgs> | null
    /**
     * The data needed to update a Izin.
     */
    data: XOR<IzinUpdateInput, IzinUncheckedUpdateInput>
    /**
     * Choose, which Izin to update.
     */
    where: IzinWhereUniqueInput
  }

  /**
   * Izin updateMany
   */
  export type IzinUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Izins.
     */
    data: XOR<IzinUpdateManyMutationInput, IzinUncheckedUpdateManyInput>
    /**
     * Filter which Izins to update
     */
    where?: IzinWhereInput
  }

  /**
   * Izin upsert
   */
  export type IzinUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Izin
     */
    select?: IzinSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IzinInclude<ExtArgs> | null
    /**
     * The filter to search for the Izin to update in case it exists.
     */
    where: IzinWhereUniqueInput
    /**
     * In case the Izin found by the `where` argument doesn't exist, create a new Izin with this data.
     */
    create: XOR<IzinCreateInput, IzinUncheckedCreateInput>
    /**
     * In case the Izin was found with the provided `where` argument, update it with this data.
     */
    update: XOR<IzinUpdateInput, IzinUncheckedUpdateInput>
  }

  /**
   * Izin delete
   */
  export type IzinDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Izin
     */
    select?: IzinSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IzinInclude<ExtArgs> | null
    /**
     * Filter which Izin to delete.
     */
    where: IzinWhereUniqueInput
  }

  /**
   * Izin deleteMany
   */
  export type IzinDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Izins to delete
     */
    where?: IzinWhereInput
  }

  /**
   * Izin without action
   */
  export type IzinDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Izin
     */
    select?: IzinSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IzinInclude<ExtArgs> | null
  }


  /**
   * Model CatatanHarian
   */

  export type AggregateCatatanHarian = {
    _count: CatatanHarianCountAggregateOutputType | null
    _min: CatatanHarianMinAggregateOutputType | null
    _max: CatatanHarianMaxAggregateOutputType | null
  }

  export type CatatanHarianMinAggregateOutputType = {
    id: string | null
    tenantId: string | null
    santriId: string | null
    authorId: string | null
    date: Date | null
    content: string | null
    category: string | null
    attachments: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CatatanHarianMaxAggregateOutputType = {
    id: string | null
    tenantId: string | null
    santriId: string | null
    authorId: string | null
    date: Date | null
    content: string | null
    category: string | null
    attachments: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CatatanHarianCountAggregateOutputType = {
    id: number
    tenantId: number
    santriId: number
    authorId: number
    date: number
    content: number
    category: number
    attachments: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CatatanHarianMinAggregateInputType = {
    id?: true
    tenantId?: true
    santriId?: true
    authorId?: true
    date?: true
    content?: true
    category?: true
    attachments?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CatatanHarianMaxAggregateInputType = {
    id?: true
    tenantId?: true
    santriId?: true
    authorId?: true
    date?: true
    content?: true
    category?: true
    attachments?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CatatanHarianCountAggregateInputType = {
    id?: true
    tenantId?: true
    santriId?: true
    authorId?: true
    date?: true
    content?: true
    category?: true
    attachments?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CatatanHarianAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CatatanHarian to aggregate.
     */
    where?: CatatanHarianWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CatatanHarians to fetch.
     */
    orderBy?: CatatanHarianOrderByWithRelationInput | CatatanHarianOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CatatanHarianWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CatatanHarians from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CatatanHarians.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CatatanHarians
    **/
    _count?: true | CatatanHarianCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CatatanHarianMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CatatanHarianMaxAggregateInputType
  }

  export type GetCatatanHarianAggregateType<T extends CatatanHarianAggregateArgs> = {
        [P in keyof T & keyof AggregateCatatanHarian]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCatatanHarian[P]>
      : GetScalarType<T[P], AggregateCatatanHarian[P]>
  }




  export type CatatanHarianGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CatatanHarianWhereInput
    orderBy?: CatatanHarianOrderByWithAggregationInput | CatatanHarianOrderByWithAggregationInput[]
    by: CatatanHarianScalarFieldEnum[] | CatatanHarianScalarFieldEnum
    having?: CatatanHarianScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CatatanHarianCountAggregateInputType | true
    _min?: CatatanHarianMinAggregateInputType
    _max?: CatatanHarianMaxAggregateInputType
  }

  export type CatatanHarianGroupByOutputType = {
    id: string
    tenantId: string
    santriId: string
    authorId: string
    date: Date
    content: string
    category: string
    attachments: string | null
    createdAt: Date
    updatedAt: Date
    _count: CatatanHarianCountAggregateOutputType | null
    _min: CatatanHarianMinAggregateOutputType | null
    _max: CatatanHarianMaxAggregateOutputType | null
  }

  type GetCatatanHarianGroupByPayload<T extends CatatanHarianGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CatatanHarianGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CatatanHarianGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CatatanHarianGroupByOutputType[P]>
            : GetScalarType<T[P], CatatanHarianGroupByOutputType[P]>
        }
      >
    >


  export type CatatanHarianSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    santriId?: boolean
    authorId?: boolean
    date?: boolean
    content?: boolean
    category?: boolean
    attachments?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    santri?: boolean | SantriDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["catatanHarian"]>

  export type CatatanHarianSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    santriId?: boolean
    authorId?: boolean
    date?: boolean
    content?: boolean
    category?: boolean
    attachments?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    santri?: boolean | SantriDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["catatanHarian"]>

  export type CatatanHarianSelectScalar = {
    id?: boolean
    tenantId?: boolean
    santriId?: boolean
    authorId?: boolean
    date?: boolean
    content?: boolean
    category?: boolean
    attachments?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CatatanHarianInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    santri?: boolean | SantriDefaultArgs<ExtArgs>
  }
  export type CatatanHarianIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    santri?: boolean | SantriDefaultArgs<ExtArgs>
  }

  export type $CatatanHarianPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CatatanHarian"
    objects: {
      tenant: Prisma.$TenantPayload<ExtArgs>
      santri: Prisma.$SantriPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      tenantId: string
      santriId: string
      authorId: string
      date: Date
      content: string
      category: string
      attachments: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["catatanHarian"]>
    composites: {}
  }

  type CatatanHarianGetPayload<S extends boolean | null | undefined | CatatanHarianDefaultArgs> = $Result.GetResult<Prisma.$CatatanHarianPayload, S>

  type CatatanHarianCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CatatanHarianFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CatatanHarianCountAggregateInputType | true
    }

  export interface CatatanHarianDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CatatanHarian'], meta: { name: 'CatatanHarian' } }
    /**
     * Find zero or one CatatanHarian that matches the filter.
     * @param {CatatanHarianFindUniqueArgs} args - Arguments to find a CatatanHarian
     * @example
     * // Get one CatatanHarian
     * const catatanHarian = await prisma.catatanHarian.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CatatanHarianFindUniqueArgs>(args: SelectSubset<T, CatatanHarianFindUniqueArgs<ExtArgs>>): Prisma__CatatanHarianClient<$Result.GetResult<Prisma.$CatatanHarianPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one CatatanHarian that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {CatatanHarianFindUniqueOrThrowArgs} args - Arguments to find a CatatanHarian
     * @example
     * // Get one CatatanHarian
     * const catatanHarian = await prisma.catatanHarian.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CatatanHarianFindUniqueOrThrowArgs>(args: SelectSubset<T, CatatanHarianFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CatatanHarianClient<$Result.GetResult<Prisma.$CatatanHarianPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first CatatanHarian that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CatatanHarianFindFirstArgs} args - Arguments to find a CatatanHarian
     * @example
     * // Get one CatatanHarian
     * const catatanHarian = await prisma.catatanHarian.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CatatanHarianFindFirstArgs>(args?: SelectSubset<T, CatatanHarianFindFirstArgs<ExtArgs>>): Prisma__CatatanHarianClient<$Result.GetResult<Prisma.$CatatanHarianPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first CatatanHarian that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CatatanHarianFindFirstOrThrowArgs} args - Arguments to find a CatatanHarian
     * @example
     * // Get one CatatanHarian
     * const catatanHarian = await prisma.catatanHarian.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CatatanHarianFindFirstOrThrowArgs>(args?: SelectSubset<T, CatatanHarianFindFirstOrThrowArgs<ExtArgs>>): Prisma__CatatanHarianClient<$Result.GetResult<Prisma.$CatatanHarianPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more CatatanHarians that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CatatanHarianFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CatatanHarians
     * const catatanHarians = await prisma.catatanHarian.findMany()
     * 
     * // Get first 10 CatatanHarians
     * const catatanHarians = await prisma.catatanHarian.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const catatanHarianWithIdOnly = await prisma.catatanHarian.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CatatanHarianFindManyArgs>(args?: SelectSubset<T, CatatanHarianFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CatatanHarianPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a CatatanHarian.
     * @param {CatatanHarianCreateArgs} args - Arguments to create a CatatanHarian.
     * @example
     * // Create one CatatanHarian
     * const CatatanHarian = await prisma.catatanHarian.create({
     *   data: {
     *     // ... data to create a CatatanHarian
     *   }
     * })
     * 
     */
    create<T extends CatatanHarianCreateArgs>(args: SelectSubset<T, CatatanHarianCreateArgs<ExtArgs>>): Prisma__CatatanHarianClient<$Result.GetResult<Prisma.$CatatanHarianPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many CatatanHarians.
     * @param {CatatanHarianCreateManyArgs} args - Arguments to create many CatatanHarians.
     * @example
     * // Create many CatatanHarians
     * const catatanHarian = await prisma.catatanHarian.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CatatanHarianCreateManyArgs>(args?: SelectSubset<T, CatatanHarianCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CatatanHarians and returns the data saved in the database.
     * @param {CatatanHarianCreateManyAndReturnArgs} args - Arguments to create many CatatanHarians.
     * @example
     * // Create many CatatanHarians
     * const catatanHarian = await prisma.catatanHarian.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CatatanHarians and only return the `id`
     * const catatanHarianWithIdOnly = await prisma.catatanHarian.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CatatanHarianCreateManyAndReturnArgs>(args?: SelectSubset<T, CatatanHarianCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CatatanHarianPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a CatatanHarian.
     * @param {CatatanHarianDeleteArgs} args - Arguments to delete one CatatanHarian.
     * @example
     * // Delete one CatatanHarian
     * const CatatanHarian = await prisma.catatanHarian.delete({
     *   where: {
     *     // ... filter to delete one CatatanHarian
     *   }
     * })
     * 
     */
    delete<T extends CatatanHarianDeleteArgs>(args: SelectSubset<T, CatatanHarianDeleteArgs<ExtArgs>>): Prisma__CatatanHarianClient<$Result.GetResult<Prisma.$CatatanHarianPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one CatatanHarian.
     * @param {CatatanHarianUpdateArgs} args - Arguments to update one CatatanHarian.
     * @example
     * // Update one CatatanHarian
     * const catatanHarian = await prisma.catatanHarian.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CatatanHarianUpdateArgs>(args: SelectSubset<T, CatatanHarianUpdateArgs<ExtArgs>>): Prisma__CatatanHarianClient<$Result.GetResult<Prisma.$CatatanHarianPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more CatatanHarians.
     * @param {CatatanHarianDeleteManyArgs} args - Arguments to filter CatatanHarians to delete.
     * @example
     * // Delete a few CatatanHarians
     * const { count } = await prisma.catatanHarian.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CatatanHarianDeleteManyArgs>(args?: SelectSubset<T, CatatanHarianDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CatatanHarians.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CatatanHarianUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CatatanHarians
     * const catatanHarian = await prisma.catatanHarian.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CatatanHarianUpdateManyArgs>(args: SelectSubset<T, CatatanHarianUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one CatatanHarian.
     * @param {CatatanHarianUpsertArgs} args - Arguments to update or create a CatatanHarian.
     * @example
     * // Update or create a CatatanHarian
     * const catatanHarian = await prisma.catatanHarian.upsert({
     *   create: {
     *     // ... data to create a CatatanHarian
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CatatanHarian we want to update
     *   }
     * })
     */
    upsert<T extends CatatanHarianUpsertArgs>(args: SelectSubset<T, CatatanHarianUpsertArgs<ExtArgs>>): Prisma__CatatanHarianClient<$Result.GetResult<Prisma.$CatatanHarianPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of CatatanHarians.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CatatanHarianCountArgs} args - Arguments to filter CatatanHarians to count.
     * @example
     * // Count the number of CatatanHarians
     * const count = await prisma.catatanHarian.count({
     *   where: {
     *     // ... the filter for the CatatanHarians we want to count
     *   }
     * })
    **/
    count<T extends CatatanHarianCountArgs>(
      args?: Subset<T, CatatanHarianCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CatatanHarianCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CatatanHarian.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CatatanHarianAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CatatanHarianAggregateArgs>(args: Subset<T, CatatanHarianAggregateArgs>): Prisma.PrismaPromise<GetCatatanHarianAggregateType<T>>

    /**
     * Group by CatatanHarian.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CatatanHarianGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CatatanHarianGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CatatanHarianGroupByArgs['orderBy'] }
        : { orderBy?: CatatanHarianGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CatatanHarianGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCatatanHarianGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CatatanHarian model
   */
  readonly fields: CatatanHarianFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CatatanHarian.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CatatanHarianClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    tenant<T extends TenantDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TenantDefaultArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    santri<T extends SantriDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SantriDefaultArgs<ExtArgs>>): Prisma__SantriClient<$Result.GetResult<Prisma.$SantriPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CatatanHarian model
   */ 
  interface CatatanHarianFieldRefs {
    readonly id: FieldRef<"CatatanHarian", 'String'>
    readonly tenantId: FieldRef<"CatatanHarian", 'String'>
    readonly santriId: FieldRef<"CatatanHarian", 'String'>
    readonly authorId: FieldRef<"CatatanHarian", 'String'>
    readonly date: FieldRef<"CatatanHarian", 'DateTime'>
    readonly content: FieldRef<"CatatanHarian", 'String'>
    readonly category: FieldRef<"CatatanHarian", 'String'>
    readonly attachments: FieldRef<"CatatanHarian", 'String'>
    readonly createdAt: FieldRef<"CatatanHarian", 'DateTime'>
    readonly updatedAt: FieldRef<"CatatanHarian", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CatatanHarian findUnique
   */
  export type CatatanHarianFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CatatanHarian
     */
    select?: CatatanHarianSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CatatanHarianInclude<ExtArgs> | null
    /**
     * Filter, which CatatanHarian to fetch.
     */
    where: CatatanHarianWhereUniqueInput
  }

  /**
   * CatatanHarian findUniqueOrThrow
   */
  export type CatatanHarianFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CatatanHarian
     */
    select?: CatatanHarianSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CatatanHarianInclude<ExtArgs> | null
    /**
     * Filter, which CatatanHarian to fetch.
     */
    where: CatatanHarianWhereUniqueInput
  }

  /**
   * CatatanHarian findFirst
   */
  export type CatatanHarianFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CatatanHarian
     */
    select?: CatatanHarianSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CatatanHarianInclude<ExtArgs> | null
    /**
     * Filter, which CatatanHarian to fetch.
     */
    where?: CatatanHarianWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CatatanHarians to fetch.
     */
    orderBy?: CatatanHarianOrderByWithRelationInput | CatatanHarianOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CatatanHarians.
     */
    cursor?: CatatanHarianWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CatatanHarians from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CatatanHarians.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CatatanHarians.
     */
    distinct?: CatatanHarianScalarFieldEnum | CatatanHarianScalarFieldEnum[]
  }

  /**
   * CatatanHarian findFirstOrThrow
   */
  export type CatatanHarianFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CatatanHarian
     */
    select?: CatatanHarianSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CatatanHarianInclude<ExtArgs> | null
    /**
     * Filter, which CatatanHarian to fetch.
     */
    where?: CatatanHarianWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CatatanHarians to fetch.
     */
    orderBy?: CatatanHarianOrderByWithRelationInput | CatatanHarianOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CatatanHarians.
     */
    cursor?: CatatanHarianWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CatatanHarians from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CatatanHarians.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CatatanHarians.
     */
    distinct?: CatatanHarianScalarFieldEnum | CatatanHarianScalarFieldEnum[]
  }

  /**
   * CatatanHarian findMany
   */
  export type CatatanHarianFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CatatanHarian
     */
    select?: CatatanHarianSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CatatanHarianInclude<ExtArgs> | null
    /**
     * Filter, which CatatanHarians to fetch.
     */
    where?: CatatanHarianWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CatatanHarians to fetch.
     */
    orderBy?: CatatanHarianOrderByWithRelationInput | CatatanHarianOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CatatanHarians.
     */
    cursor?: CatatanHarianWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CatatanHarians from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CatatanHarians.
     */
    skip?: number
    distinct?: CatatanHarianScalarFieldEnum | CatatanHarianScalarFieldEnum[]
  }

  /**
   * CatatanHarian create
   */
  export type CatatanHarianCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CatatanHarian
     */
    select?: CatatanHarianSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CatatanHarianInclude<ExtArgs> | null
    /**
     * The data needed to create a CatatanHarian.
     */
    data: XOR<CatatanHarianCreateInput, CatatanHarianUncheckedCreateInput>
  }

  /**
   * CatatanHarian createMany
   */
  export type CatatanHarianCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CatatanHarians.
     */
    data: CatatanHarianCreateManyInput | CatatanHarianCreateManyInput[]
  }

  /**
   * CatatanHarian createManyAndReturn
   */
  export type CatatanHarianCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CatatanHarian
     */
    select?: CatatanHarianSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many CatatanHarians.
     */
    data: CatatanHarianCreateManyInput | CatatanHarianCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CatatanHarianIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CatatanHarian update
   */
  export type CatatanHarianUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CatatanHarian
     */
    select?: CatatanHarianSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CatatanHarianInclude<ExtArgs> | null
    /**
     * The data needed to update a CatatanHarian.
     */
    data: XOR<CatatanHarianUpdateInput, CatatanHarianUncheckedUpdateInput>
    /**
     * Choose, which CatatanHarian to update.
     */
    where: CatatanHarianWhereUniqueInput
  }

  /**
   * CatatanHarian updateMany
   */
  export type CatatanHarianUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CatatanHarians.
     */
    data: XOR<CatatanHarianUpdateManyMutationInput, CatatanHarianUncheckedUpdateManyInput>
    /**
     * Filter which CatatanHarians to update
     */
    where?: CatatanHarianWhereInput
  }

  /**
   * CatatanHarian upsert
   */
  export type CatatanHarianUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CatatanHarian
     */
    select?: CatatanHarianSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CatatanHarianInclude<ExtArgs> | null
    /**
     * The filter to search for the CatatanHarian to update in case it exists.
     */
    where: CatatanHarianWhereUniqueInput
    /**
     * In case the CatatanHarian found by the `where` argument doesn't exist, create a new CatatanHarian with this data.
     */
    create: XOR<CatatanHarianCreateInput, CatatanHarianUncheckedCreateInput>
    /**
     * In case the CatatanHarian was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CatatanHarianUpdateInput, CatatanHarianUncheckedUpdateInput>
  }

  /**
   * CatatanHarian delete
   */
  export type CatatanHarianDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CatatanHarian
     */
    select?: CatatanHarianSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CatatanHarianInclude<ExtArgs> | null
    /**
     * Filter which CatatanHarian to delete.
     */
    where: CatatanHarianWhereUniqueInput
  }

  /**
   * CatatanHarian deleteMany
   */
  export type CatatanHarianDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CatatanHarians to delete
     */
    where?: CatatanHarianWhereInput
  }

  /**
   * CatatanHarian without action
   */
  export type CatatanHarianDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CatatanHarian
     */
    select?: CatatanHarianSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CatatanHarianInclude<ExtArgs> | null
  }


  /**
   * Model Pengumuman
   */

  export type AggregatePengumuman = {
    _count: PengumumanCountAggregateOutputType | null
    _min: PengumumanMinAggregateOutputType | null
    _max: PengumumanMaxAggregateOutputType | null
  }

  export type PengumumanMinAggregateOutputType = {
    id: string | null
    tenantId: string | null
    title: string | null
    content: string | null
    audience: string | null
    pinnedUntil: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PengumumanMaxAggregateOutputType = {
    id: string | null
    tenantId: string | null
    title: string | null
    content: string | null
    audience: string | null
    pinnedUntil: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PengumumanCountAggregateOutputType = {
    id: number
    tenantId: number
    title: number
    content: number
    audience: number
    pinnedUntil: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PengumumanMinAggregateInputType = {
    id?: true
    tenantId?: true
    title?: true
    content?: true
    audience?: true
    pinnedUntil?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PengumumanMaxAggregateInputType = {
    id?: true
    tenantId?: true
    title?: true
    content?: true
    audience?: true
    pinnedUntil?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PengumumanCountAggregateInputType = {
    id?: true
    tenantId?: true
    title?: true
    content?: true
    audience?: true
    pinnedUntil?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PengumumanAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Pengumuman to aggregate.
     */
    where?: PengumumanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Pengumumen to fetch.
     */
    orderBy?: PengumumanOrderByWithRelationInput | PengumumanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PengumumanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Pengumumen from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Pengumumen.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Pengumumen
    **/
    _count?: true | PengumumanCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PengumumanMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PengumumanMaxAggregateInputType
  }

  export type GetPengumumanAggregateType<T extends PengumumanAggregateArgs> = {
        [P in keyof T & keyof AggregatePengumuman]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePengumuman[P]>
      : GetScalarType<T[P], AggregatePengumuman[P]>
  }




  export type PengumumanGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PengumumanWhereInput
    orderBy?: PengumumanOrderByWithAggregationInput | PengumumanOrderByWithAggregationInput[]
    by: PengumumanScalarFieldEnum[] | PengumumanScalarFieldEnum
    having?: PengumumanScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PengumumanCountAggregateInputType | true
    _min?: PengumumanMinAggregateInputType
    _max?: PengumumanMaxAggregateInputType
  }

  export type PengumumanGroupByOutputType = {
    id: string
    tenantId: string
    title: string
    content: string
    audience: string
    pinnedUntil: Date | null
    createdAt: Date
    updatedAt: Date
    _count: PengumumanCountAggregateOutputType | null
    _min: PengumumanMinAggregateOutputType | null
    _max: PengumumanMaxAggregateOutputType | null
  }

  type GetPengumumanGroupByPayload<T extends PengumumanGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PengumumanGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PengumumanGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PengumumanGroupByOutputType[P]>
            : GetScalarType<T[P], PengumumanGroupByOutputType[P]>
        }
      >
    >


  export type PengumumanSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    title?: boolean
    content?: boolean
    audience?: boolean
    pinnedUntil?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["pengumuman"]>

  export type PengumumanSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    title?: boolean
    content?: boolean
    audience?: boolean
    pinnedUntil?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["pengumuman"]>

  export type PengumumanSelectScalar = {
    id?: boolean
    tenantId?: boolean
    title?: boolean
    content?: boolean
    audience?: boolean
    pinnedUntil?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PengumumanInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }
  export type PengumumanIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }

  export type $PengumumanPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Pengumuman"
    objects: {
      tenant: Prisma.$TenantPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      tenantId: string
      title: string
      content: string
      audience: string
      pinnedUntil: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["pengumuman"]>
    composites: {}
  }

  type PengumumanGetPayload<S extends boolean | null | undefined | PengumumanDefaultArgs> = $Result.GetResult<Prisma.$PengumumanPayload, S>

  type PengumumanCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<PengumumanFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PengumumanCountAggregateInputType | true
    }

  export interface PengumumanDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Pengumuman'], meta: { name: 'Pengumuman' } }
    /**
     * Find zero or one Pengumuman that matches the filter.
     * @param {PengumumanFindUniqueArgs} args - Arguments to find a Pengumuman
     * @example
     * // Get one Pengumuman
     * const pengumuman = await prisma.pengumuman.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PengumumanFindUniqueArgs>(args: SelectSubset<T, PengumumanFindUniqueArgs<ExtArgs>>): Prisma__PengumumanClient<$Result.GetResult<Prisma.$PengumumanPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Pengumuman that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {PengumumanFindUniqueOrThrowArgs} args - Arguments to find a Pengumuman
     * @example
     * // Get one Pengumuman
     * const pengumuman = await prisma.pengumuman.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PengumumanFindUniqueOrThrowArgs>(args: SelectSubset<T, PengumumanFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PengumumanClient<$Result.GetResult<Prisma.$PengumumanPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Pengumuman that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PengumumanFindFirstArgs} args - Arguments to find a Pengumuman
     * @example
     * // Get one Pengumuman
     * const pengumuman = await prisma.pengumuman.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PengumumanFindFirstArgs>(args?: SelectSubset<T, PengumumanFindFirstArgs<ExtArgs>>): Prisma__PengumumanClient<$Result.GetResult<Prisma.$PengumumanPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Pengumuman that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PengumumanFindFirstOrThrowArgs} args - Arguments to find a Pengumuman
     * @example
     * // Get one Pengumuman
     * const pengumuman = await prisma.pengumuman.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PengumumanFindFirstOrThrowArgs>(args?: SelectSubset<T, PengumumanFindFirstOrThrowArgs<ExtArgs>>): Prisma__PengumumanClient<$Result.GetResult<Prisma.$PengumumanPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Pengumumen that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PengumumanFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Pengumumen
     * const pengumumen = await prisma.pengumuman.findMany()
     * 
     * // Get first 10 Pengumumen
     * const pengumumen = await prisma.pengumuman.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const pengumumanWithIdOnly = await prisma.pengumuman.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PengumumanFindManyArgs>(args?: SelectSubset<T, PengumumanFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PengumumanPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Pengumuman.
     * @param {PengumumanCreateArgs} args - Arguments to create a Pengumuman.
     * @example
     * // Create one Pengumuman
     * const Pengumuman = await prisma.pengumuman.create({
     *   data: {
     *     // ... data to create a Pengumuman
     *   }
     * })
     * 
     */
    create<T extends PengumumanCreateArgs>(args: SelectSubset<T, PengumumanCreateArgs<ExtArgs>>): Prisma__PengumumanClient<$Result.GetResult<Prisma.$PengumumanPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Pengumumen.
     * @param {PengumumanCreateManyArgs} args - Arguments to create many Pengumumen.
     * @example
     * // Create many Pengumumen
     * const pengumuman = await prisma.pengumuman.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PengumumanCreateManyArgs>(args?: SelectSubset<T, PengumumanCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Pengumumen and returns the data saved in the database.
     * @param {PengumumanCreateManyAndReturnArgs} args - Arguments to create many Pengumumen.
     * @example
     * // Create many Pengumumen
     * const pengumuman = await prisma.pengumuman.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Pengumumen and only return the `id`
     * const pengumumanWithIdOnly = await prisma.pengumuman.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PengumumanCreateManyAndReturnArgs>(args?: SelectSubset<T, PengumumanCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PengumumanPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Pengumuman.
     * @param {PengumumanDeleteArgs} args - Arguments to delete one Pengumuman.
     * @example
     * // Delete one Pengumuman
     * const Pengumuman = await prisma.pengumuman.delete({
     *   where: {
     *     // ... filter to delete one Pengumuman
     *   }
     * })
     * 
     */
    delete<T extends PengumumanDeleteArgs>(args: SelectSubset<T, PengumumanDeleteArgs<ExtArgs>>): Prisma__PengumumanClient<$Result.GetResult<Prisma.$PengumumanPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Pengumuman.
     * @param {PengumumanUpdateArgs} args - Arguments to update one Pengumuman.
     * @example
     * // Update one Pengumuman
     * const pengumuman = await prisma.pengumuman.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PengumumanUpdateArgs>(args: SelectSubset<T, PengumumanUpdateArgs<ExtArgs>>): Prisma__PengumumanClient<$Result.GetResult<Prisma.$PengumumanPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Pengumumen.
     * @param {PengumumanDeleteManyArgs} args - Arguments to filter Pengumumen to delete.
     * @example
     * // Delete a few Pengumumen
     * const { count } = await prisma.pengumuman.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PengumumanDeleteManyArgs>(args?: SelectSubset<T, PengumumanDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Pengumumen.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PengumumanUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Pengumumen
     * const pengumuman = await prisma.pengumuman.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PengumumanUpdateManyArgs>(args: SelectSubset<T, PengumumanUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Pengumuman.
     * @param {PengumumanUpsertArgs} args - Arguments to update or create a Pengumuman.
     * @example
     * // Update or create a Pengumuman
     * const pengumuman = await prisma.pengumuman.upsert({
     *   create: {
     *     // ... data to create a Pengumuman
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Pengumuman we want to update
     *   }
     * })
     */
    upsert<T extends PengumumanUpsertArgs>(args: SelectSubset<T, PengumumanUpsertArgs<ExtArgs>>): Prisma__PengumumanClient<$Result.GetResult<Prisma.$PengumumanPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Pengumumen.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PengumumanCountArgs} args - Arguments to filter Pengumumen to count.
     * @example
     * // Count the number of Pengumumen
     * const count = await prisma.pengumuman.count({
     *   where: {
     *     // ... the filter for the Pengumumen we want to count
     *   }
     * })
    **/
    count<T extends PengumumanCountArgs>(
      args?: Subset<T, PengumumanCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PengumumanCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Pengumuman.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PengumumanAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PengumumanAggregateArgs>(args: Subset<T, PengumumanAggregateArgs>): Prisma.PrismaPromise<GetPengumumanAggregateType<T>>

    /**
     * Group by Pengumuman.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PengumumanGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PengumumanGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PengumumanGroupByArgs['orderBy'] }
        : { orderBy?: PengumumanGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PengumumanGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPengumumanGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Pengumuman model
   */
  readonly fields: PengumumanFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Pengumuman.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PengumumanClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    tenant<T extends TenantDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TenantDefaultArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Pengumuman model
   */ 
  interface PengumumanFieldRefs {
    readonly id: FieldRef<"Pengumuman", 'String'>
    readonly tenantId: FieldRef<"Pengumuman", 'String'>
    readonly title: FieldRef<"Pengumuman", 'String'>
    readonly content: FieldRef<"Pengumuman", 'String'>
    readonly audience: FieldRef<"Pengumuman", 'String'>
    readonly pinnedUntil: FieldRef<"Pengumuman", 'DateTime'>
    readonly createdAt: FieldRef<"Pengumuman", 'DateTime'>
    readonly updatedAt: FieldRef<"Pengumuman", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Pengumuman findUnique
   */
  export type PengumumanFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pengumuman
     */
    select?: PengumumanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PengumumanInclude<ExtArgs> | null
    /**
     * Filter, which Pengumuman to fetch.
     */
    where: PengumumanWhereUniqueInput
  }

  /**
   * Pengumuman findUniqueOrThrow
   */
  export type PengumumanFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pengumuman
     */
    select?: PengumumanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PengumumanInclude<ExtArgs> | null
    /**
     * Filter, which Pengumuman to fetch.
     */
    where: PengumumanWhereUniqueInput
  }

  /**
   * Pengumuman findFirst
   */
  export type PengumumanFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pengumuman
     */
    select?: PengumumanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PengumumanInclude<ExtArgs> | null
    /**
     * Filter, which Pengumuman to fetch.
     */
    where?: PengumumanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Pengumumen to fetch.
     */
    orderBy?: PengumumanOrderByWithRelationInput | PengumumanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Pengumumen.
     */
    cursor?: PengumumanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Pengumumen from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Pengumumen.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Pengumumen.
     */
    distinct?: PengumumanScalarFieldEnum | PengumumanScalarFieldEnum[]
  }

  /**
   * Pengumuman findFirstOrThrow
   */
  export type PengumumanFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pengumuman
     */
    select?: PengumumanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PengumumanInclude<ExtArgs> | null
    /**
     * Filter, which Pengumuman to fetch.
     */
    where?: PengumumanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Pengumumen to fetch.
     */
    orderBy?: PengumumanOrderByWithRelationInput | PengumumanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Pengumumen.
     */
    cursor?: PengumumanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Pengumumen from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Pengumumen.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Pengumumen.
     */
    distinct?: PengumumanScalarFieldEnum | PengumumanScalarFieldEnum[]
  }

  /**
   * Pengumuman findMany
   */
  export type PengumumanFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pengumuman
     */
    select?: PengumumanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PengumumanInclude<ExtArgs> | null
    /**
     * Filter, which Pengumumen to fetch.
     */
    where?: PengumumanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Pengumumen to fetch.
     */
    orderBy?: PengumumanOrderByWithRelationInput | PengumumanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Pengumumen.
     */
    cursor?: PengumumanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Pengumumen from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Pengumumen.
     */
    skip?: number
    distinct?: PengumumanScalarFieldEnum | PengumumanScalarFieldEnum[]
  }

  /**
   * Pengumuman create
   */
  export type PengumumanCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pengumuman
     */
    select?: PengumumanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PengumumanInclude<ExtArgs> | null
    /**
     * The data needed to create a Pengumuman.
     */
    data: XOR<PengumumanCreateInput, PengumumanUncheckedCreateInput>
  }

  /**
   * Pengumuman createMany
   */
  export type PengumumanCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Pengumumen.
     */
    data: PengumumanCreateManyInput | PengumumanCreateManyInput[]
  }

  /**
   * Pengumuman createManyAndReturn
   */
  export type PengumumanCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pengumuman
     */
    select?: PengumumanSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Pengumumen.
     */
    data: PengumumanCreateManyInput | PengumumanCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PengumumanIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Pengumuman update
   */
  export type PengumumanUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pengumuman
     */
    select?: PengumumanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PengumumanInclude<ExtArgs> | null
    /**
     * The data needed to update a Pengumuman.
     */
    data: XOR<PengumumanUpdateInput, PengumumanUncheckedUpdateInput>
    /**
     * Choose, which Pengumuman to update.
     */
    where: PengumumanWhereUniqueInput
  }

  /**
   * Pengumuman updateMany
   */
  export type PengumumanUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Pengumumen.
     */
    data: XOR<PengumumanUpdateManyMutationInput, PengumumanUncheckedUpdateManyInput>
    /**
     * Filter which Pengumumen to update
     */
    where?: PengumumanWhereInput
  }

  /**
   * Pengumuman upsert
   */
  export type PengumumanUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pengumuman
     */
    select?: PengumumanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PengumumanInclude<ExtArgs> | null
    /**
     * The filter to search for the Pengumuman to update in case it exists.
     */
    where: PengumumanWhereUniqueInput
    /**
     * In case the Pengumuman found by the `where` argument doesn't exist, create a new Pengumuman with this data.
     */
    create: XOR<PengumumanCreateInput, PengumumanUncheckedCreateInput>
    /**
     * In case the Pengumuman was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PengumumanUpdateInput, PengumumanUncheckedUpdateInput>
  }

  /**
   * Pengumuman delete
   */
  export type PengumumanDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pengumuman
     */
    select?: PengumumanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PengumumanInclude<ExtArgs> | null
    /**
     * Filter which Pengumuman to delete.
     */
    where: PengumumanWhereUniqueInput
  }

  /**
   * Pengumuman deleteMany
   */
  export type PengumumanDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Pengumumen to delete
     */
    where?: PengumumanWhereInput
  }

  /**
   * Pengumuman without action
   */
  export type PengumumanDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pengumuman
     */
    select?: PengumumanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PengumumanInclude<ExtArgs> | null
  }


  /**
   * Model Invoice
   */

  export type AggregateInvoice = {
    _count: InvoiceCountAggregateOutputType | null
    _avg: InvoiceAvgAggregateOutputType | null
    _sum: InvoiceSumAggregateOutputType | null
    _min: InvoiceMinAggregateOutputType | null
    _max: InvoiceMaxAggregateOutputType | null
  }

  export type InvoiceAvgAggregateOutputType = {
    amountDue: number | null
  }

  export type InvoiceSumAggregateOutputType = {
    amountDue: number | null
  }

  export type InvoiceMinAggregateOutputType = {
    id: string | null
    tenantId: string | null
    santriId: string | null
    amountDue: number | null
    dueDate: Date | null
    status: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type InvoiceMaxAggregateOutputType = {
    id: string | null
    tenantId: string | null
    santriId: string | null
    amountDue: number | null
    dueDate: Date | null
    status: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type InvoiceCountAggregateOutputType = {
    id: number
    tenantId: number
    santriId: number
    amountDue: number
    dueDate: number
    status: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type InvoiceAvgAggregateInputType = {
    amountDue?: true
  }

  export type InvoiceSumAggregateInputType = {
    amountDue?: true
  }

  export type InvoiceMinAggregateInputType = {
    id?: true
    tenantId?: true
    santriId?: true
    amountDue?: true
    dueDate?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type InvoiceMaxAggregateInputType = {
    id?: true
    tenantId?: true
    santriId?: true
    amountDue?: true
    dueDate?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type InvoiceCountAggregateInputType = {
    id?: true
    tenantId?: true
    santriId?: true
    amountDue?: true
    dueDate?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type InvoiceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Invoice to aggregate.
     */
    where?: InvoiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Invoices to fetch.
     */
    orderBy?: InvoiceOrderByWithRelationInput | InvoiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: InvoiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Invoices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Invoices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Invoices
    **/
    _count?: true | InvoiceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: InvoiceAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: InvoiceSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InvoiceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InvoiceMaxAggregateInputType
  }

  export type GetInvoiceAggregateType<T extends InvoiceAggregateArgs> = {
        [P in keyof T & keyof AggregateInvoice]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInvoice[P]>
      : GetScalarType<T[P], AggregateInvoice[P]>
  }




  export type InvoiceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InvoiceWhereInput
    orderBy?: InvoiceOrderByWithAggregationInput | InvoiceOrderByWithAggregationInput[]
    by: InvoiceScalarFieldEnum[] | InvoiceScalarFieldEnum
    having?: InvoiceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InvoiceCountAggregateInputType | true
    _avg?: InvoiceAvgAggregateInputType
    _sum?: InvoiceSumAggregateInputType
    _min?: InvoiceMinAggregateInputType
    _max?: InvoiceMaxAggregateInputType
  }

  export type InvoiceGroupByOutputType = {
    id: string
    tenantId: string
    santriId: string
    amountDue: number
    dueDate: Date
    status: string
    createdAt: Date
    updatedAt: Date
    _count: InvoiceCountAggregateOutputType | null
    _avg: InvoiceAvgAggregateOutputType | null
    _sum: InvoiceSumAggregateOutputType | null
    _min: InvoiceMinAggregateOutputType | null
    _max: InvoiceMaxAggregateOutputType | null
  }

  type GetInvoiceGroupByPayload<T extends InvoiceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<InvoiceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InvoiceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InvoiceGroupByOutputType[P]>
            : GetScalarType<T[P], InvoiceGroupByOutputType[P]>
        }
      >
    >


  export type InvoiceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    santriId?: boolean
    amountDue?: boolean
    dueDate?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    santri?: boolean | SantriDefaultArgs<ExtArgs>
    lines?: boolean | Invoice$linesArgs<ExtArgs>
    payments?: boolean | Invoice$paymentsArgs<ExtArgs>
    _count?: boolean | InvoiceCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["invoice"]>

  export type InvoiceSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    santriId?: boolean
    amountDue?: boolean
    dueDate?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    santri?: boolean | SantriDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["invoice"]>

  export type InvoiceSelectScalar = {
    id?: boolean
    tenantId?: boolean
    santriId?: boolean
    amountDue?: boolean
    dueDate?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type InvoiceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    santri?: boolean | SantriDefaultArgs<ExtArgs>
    lines?: boolean | Invoice$linesArgs<ExtArgs>
    payments?: boolean | Invoice$paymentsArgs<ExtArgs>
    _count?: boolean | InvoiceCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type InvoiceIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    santri?: boolean | SantriDefaultArgs<ExtArgs>
  }

  export type $InvoicePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Invoice"
    objects: {
      tenant: Prisma.$TenantPayload<ExtArgs>
      santri: Prisma.$SantriPayload<ExtArgs>
      lines: Prisma.$InvoiceLinePayload<ExtArgs>[]
      payments: Prisma.$PaymentPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      tenantId: string
      santriId: string
      amountDue: number
      dueDate: Date
      status: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["invoice"]>
    composites: {}
  }

  type InvoiceGetPayload<S extends boolean | null | undefined | InvoiceDefaultArgs> = $Result.GetResult<Prisma.$InvoicePayload, S>

  type InvoiceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<InvoiceFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: InvoiceCountAggregateInputType | true
    }

  export interface InvoiceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Invoice'], meta: { name: 'Invoice' } }
    /**
     * Find zero or one Invoice that matches the filter.
     * @param {InvoiceFindUniqueArgs} args - Arguments to find a Invoice
     * @example
     * // Get one Invoice
     * const invoice = await prisma.invoice.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends InvoiceFindUniqueArgs>(args: SelectSubset<T, InvoiceFindUniqueArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Invoice that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {InvoiceFindUniqueOrThrowArgs} args - Arguments to find a Invoice
     * @example
     * // Get one Invoice
     * const invoice = await prisma.invoice.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends InvoiceFindUniqueOrThrowArgs>(args: SelectSubset<T, InvoiceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Invoice that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceFindFirstArgs} args - Arguments to find a Invoice
     * @example
     * // Get one Invoice
     * const invoice = await prisma.invoice.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends InvoiceFindFirstArgs>(args?: SelectSubset<T, InvoiceFindFirstArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Invoice that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceFindFirstOrThrowArgs} args - Arguments to find a Invoice
     * @example
     * // Get one Invoice
     * const invoice = await prisma.invoice.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends InvoiceFindFirstOrThrowArgs>(args?: SelectSubset<T, InvoiceFindFirstOrThrowArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Invoices that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Invoices
     * const invoices = await prisma.invoice.findMany()
     * 
     * // Get first 10 Invoices
     * const invoices = await prisma.invoice.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const invoiceWithIdOnly = await prisma.invoice.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends InvoiceFindManyArgs>(args?: SelectSubset<T, InvoiceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Invoice.
     * @param {InvoiceCreateArgs} args - Arguments to create a Invoice.
     * @example
     * // Create one Invoice
     * const Invoice = await prisma.invoice.create({
     *   data: {
     *     // ... data to create a Invoice
     *   }
     * })
     * 
     */
    create<T extends InvoiceCreateArgs>(args: SelectSubset<T, InvoiceCreateArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Invoices.
     * @param {InvoiceCreateManyArgs} args - Arguments to create many Invoices.
     * @example
     * // Create many Invoices
     * const invoice = await prisma.invoice.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends InvoiceCreateManyArgs>(args?: SelectSubset<T, InvoiceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Invoices and returns the data saved in the database.
     * @param {InvoiceCreateManyAndReturnArgs} args - Arguments to create many Invoices.
     * @example
     * // Create many Invoices
     * const invoice = await prisma.invoice.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Invoices and only return the `id`
     * const invoiceWithIdOnly = await prisma.invoice.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends InvoiceCreateManyAndReturnArgs>(args?: SelectSubset<T, InvoiceCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Invoice.
     * @param {InvoiceDeleteArgs} args - Arguments to delete one Invoice.
     * @example
     * // Delete one Invoice
     * const Invoice = await prisma.invoice.delete({
     *   where: {
     *     // ... filter to delete one Invoice
     *   }
     * })
     * 
     */
    delete<T extends InvoiceDeleteArgs>(args: SelectSubset<T, InvoiceDeleteArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Invoice.
     * @param {InvoiceUpdateArgs} args - Arguments to update one Invoice.
     * @example
     * // Update one Invoice
     * const invoice = await prisma.invoice.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends InvoiceUpdateArgs>(args: SelectSubset<T, InvoiceUpdateArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Invoices.
     * @param {InvoiceDeleteManyArgs} args - Arguments to filter Invoices to delete.
     * @example
     * // Delete a few Invoices
     * const { count } = await prisma.invoice.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends InvoiceDeleteManyArgs>(args?: SelectSubset<T, InvoiceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Invoices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Invoices
     * const invoice = await prisma.invoice.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends InvoiceUpdateManyArgs>(args: SelectSubset<T, InvoiceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Invoice.
     * @param {InvoiceUpsertArgs} args - Arguments to update or create a Invoice.
     * @example
     * // Update or create a Invoice
     * const invoice = await prisma.invoice.upsert({
     *   create: {
     *     // ... data to create a Invoice
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Invoice we want to update
     *   }
     * })
     */
    upsert<T extends InvoiceUpsertArgs>(args: SelectSubset<T, InvoiceUpsertArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Invoices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceCountArgs} args - Arguments to filter Invoices to count.
     * @example
     * // Count the number of Invoices
     * const count = await prisma.invoice.count({
     *   where: {
     *     // ... the filter for the Invoices we want to count
     *   }
     * })
    **/
    count<T extends InvoiceCountArgs>(
      args?: Subset<T, InvoiceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InvoiceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Invoice.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InvoiceAggregateArgs>(args: Subset<T, InvoiceAggregateArgs>): Prisma.PrismaPromise<GetInvoiceAggregateType<T>>

    /**
     * Group by Invoice.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends InvoiceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: InvoiceGroupByArgs['orderBy'] }
        : { orderBy?: InvoiceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, InvoiceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInvoiceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Invoice model
   */
  readonly fields: InvoiceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Invoice.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__InvoiceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    tenant<T extends TenantDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TenantDefaultArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    santri<T extends SantriDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SantriDefaultArgs<ExtArgs>>): Prisma__SantriClient<$Result.GetResult<Prisma.$SantriPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    lines<T extends Invoice$linesArgs<ExtArgs> = {}>(args?: Subset<T, Invoice$linesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvoiceLinePayload<ExtArgs>, T, "findMany"> | Null>
    payments<T extends Invoice$paymentsArgs<ExtArgs> = {}>(args?: Subset<T, Invoice$paymentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Invoice model
   */ 
  interface InvoiceFieldRefs {
    readonly id: FieldRef<"Invoice", 'String'>
    readonly tenantId: FieldRef<"Invoice", 'String'>
    readonly santriId: FieldRef<"Invoice", 'String'>
    readonly amountDue: FieldRef<"Invoice", 'Float'>
    readonly dueDate: FieldRef<"Invoice", 'DateTime'>
    readonly status: FieldRef<"Invoice", 'String'>
    readonly createdAt: FieldRef<"Invoice", 'DateTime'>
    readonly updatedAt: FieldRef<"Invoice", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Invoice findUnique
   */
  export type InvoiceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * Filter, which Invoice to fetch.
     */
    where: InvoiceWhereUniqueInput
  }

  /**
   * Invoice findUniqueOrThrow
   */
  export type InvoiceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * Filter, which Invoice to fetch.
     */
    where: InvoiceWhereUniqueInput
  }

  /**
   * Invoice findFirst
   */
  export type InvoiceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * Filter, which Invoice to fetch.
     */
    where?: InvoiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Invoices to fetch.
     */
    orderBy?: InvoiceOrderByWithRelationInput | InvoiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Invoices.
     */
    cursor?: InvoiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Invoices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Invoices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Invoices.
     */
    distinct?: InvoiceScalarFieldEnum | InvoiceScalarFieldEnum[]
  }

  /**
   * Invoice findFirstOrThrow
   */
  export type InvoiceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * Filter, which Invoice to fetch.
     */
    where?: InvoiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Invoices to fetch.
     */
    orderBy?: InvoiceOrderByWithRelationInput | InvoiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Invoices.
     */
    cursor?: InvoiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Invoices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Invoices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Invoices.
     */
    distinct?: InvoiceScalarFieldEnum | InvoiceScalarFieldEnum[]
  }

  /**
   * Invoice findMany
   */
  export type InvoiceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * Filter, which Invoices to fetch.
     */
    where?: InvoiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Invoices to fetch.
     */
    orderBy?: InvoiceOrderByWithRelationInput | InvoiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Invoices.
     */
    cursor?: InvoiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Invoices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Invoices.
     */
    skip?: number
    distinct?: InvoiceScalarFieldEnum | InvoiceScalarFieldEnum[]
  }

  /**
   * Invoice create
   */
  export type InvoiceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * The data needed to create a Invoice.
     */
    data: XOR<InvoiceCreateInput, InvoiceUncheckedCreateInput>
  }

  /**
   * Invoice createMany
   */
  export type InvoiceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Invoices.
     */
    data: InvoiceCreateManyInput | InvoiceCreateManyInput[]
  }

  /**
   * Invoice createManyAndReturn
   */
  export type InvoiceCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Invoices.
     */
    data: InvoiceCreateManyInput | InvoiceCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Invoice update
   */
  export type InvoiceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * The data needed to update a Invoice.
     */
    data: XOR<InvoiceUpdateInput, InvoiceUncheckedUpdateInput>
    /**
     * Choose, which Invoice to update.
     */
    where: InvoiceWhereUniqueInput
  }

  /**
   * Invoice updateMany
   */
  export type InvoiceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Invoices.
     */
    data: XOR<InvoiceUpdateManyMutationInput, InvoiceUncheckedUpdateManyInput>
    /**
     * Filter which Invoices to update
     */
    where?: InvoiceWhereInput
  }

  /**
   * Invoice upsert
   */
  export type InvoiceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * The filter to search for the Invoice to update in case it exists.
     */
    where: InvoiceWhereUniqueInput
    /**
     * In case the Invoice found by the `where` argument doesn't exist, create a new Invoice with this data.
     */
    create: XOR<InvoiceCreateInput, InvoiceUncheckedCreateInput>
    /**
     * In case the Invoice was found with the provided `where` argument, update it with this data.
     */
    update: XOR<InvoiceUpdateInput, InvoiceUncheckedUpdateInput>
  }

  /**
   * Invoice delete
   */
  export type InvoiceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * Filter which Invoice to delete.
     */
    where: InvoiceWhereUniqueInput
  }

  /**
   * Invoice deleteMany
   */
  export type InvoiceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Invoices to delete
     */
    where?: InvoiceWhereInput
  }

  /**
   * Invoice.lines
   */
  export type Invoice$linesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceLine
     */
    select?: InvoiceLineSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceLineInclude<ExtArgs> | null
    where?: InvoiceLineWhereInput
    orderBy?: InvoiceLineOrderByWithRelationInput | InvoiceLineOrderByWithRelationInput[]
    cursor?: InvoiceLineWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InvoiceLineScalarFieldEnum | InvoiceLineScalarFieldEnum[]
  }

  /**
   * Invoice.payments
   */
  export type Invoice$paymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    where?: PaymentWhereInput
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    cursor?: PaymentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * Invoice without action
   */
  export type InvoiceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
  }


  /**
   * Model InvoiceLine
   */

  export type AggregateInvoiceLine = {
    _count: InvoiceLineCountAggregateOutputType | null
    _avg: InvoiceLineAvgAggregateOutputType | null
    _sum: InvoiceLineSumAggregateOutputType | null
    _min: InvoiceLineMinAggregateOutputType | null
    _max: InvoiceLineMaxAggregateOutputType | null
  }

  export type InvoiceLineAvgAggregateOutputType = {
    amount: number | null
  }

  export type InvoiceLineSumAggregateOutputType = {
    amount: number | null
  }

  export type InvoiceLineMinAggregateOutputType = {
    id: string | null
    invoiceId: string | null
    description: string | null
    amount: number | null
    type: string | null
  }

  export type InvoiceLineMaxAggregateOutputType = {
    id: string | null
    invoiceId: string | null
    description: string | null
    amount: number | null
    type: string | null
  }

  export type InvoiceLineCountAggregateOutputType = {
    id: number
    invoiceId: number
    description: number
    amount: number
    type: number
    _all: number
  }


  export type InvoiceLineAvgAggregateInputType = {
    amount?: true
  }

  export type InvoiceLineSumAggregateInputType = {
    amount?: true
  }

  export type InvoiceLineMinAggregateInputType = {
    id?: true
    invoiceId?: true
    description?: true
    amount?: true
    type?: true
  }

  export type InvoiceLineMaxAggregateInputType = {
    id?: true
    invoiceId?: true
    description?: true
    amount?: true
    type?: true
  }

  export type InvoiceLineCountAggregateInputType = {
    id?: true
    invoiceId?: true
    description?: true
    amount?: true
    type?: true
    _all?: true
  }

  export type InvoiceLineAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which InvoiceLine to aggregate.
     */
    where?: InvoiceLineWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InvoiceLines to fetch.
     */
    orderBy?: InvoiceLineOrderByWithRelationInput | InvoiceLineOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: InvoiceLineWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InvoiceLines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InvoiceLines.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned InvoiceLines
    **/
    _count?: true | InvoiceLineCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: InvoiceLineAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: InvoiceLineSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InvoiceLineMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InvoiceLineMaxAggregateInputType
  }

  export type GetInvoiceLineAggregateType<T extends InvoiceLineAggregateArgs> = {
        [P in keyof T & keyof AggregateInvoiceLine]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInvoiceLine[P]>
      : GetScalarType<T[P], AggregateInvoiceLine[P]>
  }




  export type InvoiceLineGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InvoiceLineWhereInput
    orderBy?: InvoiceLineOrderByWithAggregationInput | InvoiceLineOrderByWithAggregationInput[]
    by: InvoiceLineScalarFieldEnum[] | InvoiceLineScalarFieldEnum
    having?: InvoiceLineScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InvoiceLineCountAggregateInputType | true
    _avg?: InvoiceLineAvgAggregateInputType
    _sum?: InvoiceLineSumAggregateInputType
    _min?: InvoiceLineMinAggregateInputType
    _max?: InvoiceLineMaxAggregateInputType
  }

  export type InvoiceLineGroupByOutputType = {
    id: string
    invoiceId: string
    description: string
    amount: number
    type: string
    _count: InvoiceLineCountAggregateOutputType | null
    _avg: InvoiceLineAvgAggregateOutputType | null
    _sum: InvoiceLineSumAggregateOutputType | null
    _min: InvoiceLineMinAggregateOutputType | null
    _max: InvoiceLineMaxAggregateOutputType | null
  }

  type GetInvoiceLineGroupByPayload<T extends InvoiceLineGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<InvoiceLineGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InvoiceLineGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InvoiceLineGroupByOutputType[P]>
            : GetScalarType<T[P], InvoiceLineGroupByOutputType[P]>
        }
      >
    >


  export type InvoiceLineSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    invoiceId?: boolean
    description?: boolean
    amount?: boolean
    type?: boolean
    invoice?: boolean | InvoiceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["invoiceLine"]>

  export type InvoiceLineSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    invoiceId?: boolean
    description?: boolean
    amount?: boolean
    type?: boolean
    invoice?: boolean | InvoiceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["invoiceLine"]>

  export type InvoiceLineSelectScalar = {
    id?: boolean
    invoiceId?: boolean
    description?: boolean
    amount?: boolean
    type?: boolean
  }

  export type InvoiceLineInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    invoice?: boolean | InvoiceDefaultArgs<ExtArgs>
  }
  export type InvoiceLineIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    invoice?: boolean | InvoiceDefaultArgs<ExtArgs>
  }

  export type $InvoiceLinePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "InvoiceLine"
    objects: {
      invoice: Prisma.$InvoicePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      invoiceId: string
      description: string
      amount: number
      type: string
    }, ExtArgs["result"]["invoiceLine"]>
    composites: {}
  }

  type InvoiceLineGetPayload<S extends boolean | null | undefined | InvoiceLineDefaultArgs> = $Result.GetResult<Prisma.$InvoiceLinePayload, S>

  type InvoiceLineCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<InvoiceLineFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: InvoiceLineCountAggregateInputType | true
    }

  export interface InvoiceLineDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['InvoiceLine'], meta: { name: 'InvoiceLine' } }
    /**
     * Find zero or one InvoiceLine that matches the filter.
     * @param {InvoiceLineFindUniqueArgs} args - Arguments to find a InvoiceLine
     * @example
     * // Get one InvoiceLine
     * const invoiceLine = await prisma.invoiceLine.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends InvoiceLineFindUniqueArgs>(args: SelectSubset<T, InvoiceLineFindUniqueArgs<ExtArgs>>): Prisma__InvoiceLineClient<$Result.GetResult<Prisma.$InvoiceLinePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one InvoiceLine that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {InvoiceLineFindUniqueOrThrowArgs} args - Arguments to find a InvoiceLine
     * @example
     * // Get one InvoiceLine
     * const invoiceLine = await prisma.invoiceLine.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends InvoiceLineFindUniqueOrThrowArgs>(args: SelectSubset<T, InvoiceLineFindUniqueOrThrowArgs<ExtArgs>>): Prisma__InvoiceLineClient<$Result.GetResult<Prisma.$InvoiceLinePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first InvoiceLine that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceLineFindFirstArgs} args - Arguments to find a InvoiceLine
     * @example
     * // Get one InvoiceLine
     * const invoiceLine = await prisma.invoiceLine.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends InvoiceLineFindFirstArgs>(args?: SelectSubset<T, InvoiceLineFindFirstArgs<ExtArgs>>): Prisma__InvoiceLineClient<$Result.GetResult<Prisma.$InvoiceLinePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first InvoiceLine that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceLineFindFirstOrThrowArgs} args - Arguments to find a InvoiceLine
     * @example
     * // Get one InvoiceLine
     * const invoiceLine = await prisma.invoiceLine.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends InvoiceLineFindFirstOrThrowArgs>(args?: SelectSubset<T, InvoiceLineFindFirstOrThrowArgs<ExtArgs>>): Prisma__InvoiceLineClient<$Result.GetResult<Prisma.$InvoiceLinePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more InvoiceLines that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceLineFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all InvoiceLines
     * const invoiceLines = await prisma.invoiceLine.findMany()
     * 
     * // Get first 10 InvoiceLines
     * const invoiceLines = await prisma.invoiceLine.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const invoiceLineWithIdOnly = await prisma.invoiceLine.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends InvoiceLineFindManyArgs>(args?: SelectSubset<T, InvoiceLineFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvoiceLinePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a InvoiceLine.
     * @param {InvoiceLineCreateArgs} args - Arguments to create a InvoiceLine.
     * @example
     * // Create one InvoiceLine
     * const InvoiceLine = await prisma.invoiceLine.create({
     *   data: {
     *     // ... data to create a InvoiceLine
     *   }
     * })
     * 
     */
    create<T extends InvoiceLineCreateArgs>(args: SelectSubset<T, InvoiceLineCreateArgs<ExtArgs>>): Prisma__InvoiceLineClient<$Result.GetResult<Prisma.$InvoiceLinePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many InvoiceLines.
     * @param {InvoiceLineCreateManyArgs} args - Arguments to create many InvoiceLines.
     * @example
     * // Create many InvoiceLines
     * const invoiceLine = await prisma.invoiceLine.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends InvoiceLineCreateManyArgs>(args?: SelectSubset<T, InvoiceLineCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many InvoiceLines and returns the data saved in the database.
     * @param {InvoiceLineCreateManyAndReturnArgs} args - Arguments to create many InvoiceLines.
     * @example
     * // Create many InvoiceLines
     * const invoiceLine = await prisma.invoiceLine.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many InvoiceLines and only return the `id`
     * const invoiceLineWithIdOnly = await prisma.invoiceLine.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends InvoiceLineCreateManyAndReturnArgs>(args?: SelectSubset<T, InvoiceLineCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvoiceLinePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a InvoiceLine.
     * @param {InvoiceLineDeleteArgs} args - Arguments to delete one InvoiceLine.
     * @example
     * // Delete one InvoiceLine
     * const InvoiceLine = await prisma.invoiceLine.delete({
     *   where: {
     *     // ... filter to delete one InvoiceLine
     *   }
     * })
     * 
     */
    delete<T extends InvoiceLineDeleteArgs>(args: SelectSubset<T, InvoiceLineDeleteArgs<ExtArgs>>): Prisma__InvoiceLineClient<$Result.GetResult<Prisma.$InvoiceLinePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one InvoiceLine.
     * @param {InvoiceLineUpdateArgs} args - Arguments to update one InvoiceLine.
     * @example
     * // Update one InvoiceLine
     * const invoiceLine = await prisma.invoiceLine.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends InvoiceLineUpdateArgs>(args: SelectSubset<T, InvoiceLineUpdateArgs<ExtArgs>>): Prisma__InvoiceLineClient<$Result.GetResult<Prisma.$InvoiceLinePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more InvoiceLines.
     * @param {InvoiceLineDeleteManyArgs} args - Arguments to filter InvoiceLines to delete.
     * @example
     * // Delete a few InvoiceLines
     * const { count } = await prisma.invoiceLine.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends InvoiceLineDeleteManyArgs>(args?: SelectSubset<T, InvoiceLineDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more InvoiceLines.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceLineUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many InvoiceLines
     * const invoiceLine = await prisma.invoiceLine.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends InvoiceLineUpdateManyArgs>(args: SelectSubset<T, InvoiceLineUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one InvoiceLine.
     * @param {InvoiceLineUpsertArgs} args - Arguments to update or create a InvoiceLine.
     * @example
     * // Update or create a InvoiceLine
     * const invoiceLine = await prisma.invoiceLine.upsert({
     *   create: {
     *     // ... data to create a InvoiceLine
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the InvoiceLine we want to update
     *   }
     * })
     */
    upsert<T extends InvoiceLineUpsertArgs>(args: SelectSubset<T, InvoiceLineUpsertArgs<ExtArgs>>): Prisma__InvoiceLineClient<$Result.GetResult<Prisma.$InvoiceLinePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of InvoiceLines.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceLineCountArgs} args - Arguments to filter InvoiceLines to count.
     * @example
     * // Count the number of InvoiceLines
     * const count = await prisma.invoiceLine.count({
     *   where: {
     *     // ... the filter for the InvoiceLines we want to count
     *   }
     * })
    **/
    count<T extends InvoiceLineCountArgs>(
      args?: Subset<T, InvoiceLineCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InvoiceLineCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a InvoiceLine.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceLineAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InvoiceLineAggregateArgs>(args: Subset<T, InvoiceLineAggregateArgs>): Prisma.PrismaPromise<GetInvoiceLineAggregateType<T>>

    /**
     * Group by InvoiceLine.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceLineGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends InvoiceLineGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: InvoiceLineGroupByArgs['orderBy'] }
        : { orderBy?: InvoiceLineGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, InvoiceLineGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInvoiceLineGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the InvoiceLine model
   */
  readonly fields: InvoiceLineFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for InvoiceLine.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__InvoiceLineClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    invoice<T extends InvoiceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, InvoiceDefaultArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the InvoiceLine model
   */ 
  interface InvoiceLineFieldRefs {
    readonly id: FieldRef<"InvoiceLine", 'String'>
    readonly invoiceId: FieldRef<"InvoiceLine", 'String'>
    readonly description: FieldRef<"InvoiceLine", 'String'>
    readonly amount: FieldRef<"InvoiceLine", 'Float'>
    readonly type: FieldRef<"InvoiceLine", 'String'>
  }
    

  // Custom InputTypes
  /**
   * InvoiceLine findUnique
   */
  export type InvoiceLineFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceLine
     */
    select?: InvoiceLineSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceLineInclude<ExtArgs> | null
    /**
     * Filter, which InvoiceLine to fetch.
     */
    where: InvoiceLineWhereUniqueInput
  }

  /**
   * InvoiceLine findUniqueOrThrow
   */
  export type InvoiceLineFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceLine
     */
    select?: InvoiceLineSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceLineInclude<ExtArgs> | null
    /**
     * Filter, which InvoiceLine to fetch.
     */
    where: InvoiceLineWhereUniqueInput
  }

  /**
   * InvoiceLine findFirst
   */
  export type InvoiceLineFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceLine
     */
    select?: InvoiceLineSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceLineInclude<ExtArgs> | null
    /**
     * Filter, which InvoiceLine to fetch.
     */
    where?: InvoiceLineWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InvoiceLines to fetch.
     */
    orderBy?: InvoiceLineOrderByWithRelationInput | InvoiceLineOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for InvoiceLines.
     */
    cursor?: InvoiceLineWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InvoiceLines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InvoiceLines.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of InvoiceLines.
     */
    distinct?: InvoiceLineScalarFieldEnum | InvoiceLineScalarFieldEnum[]
  }

  /**
   * InvoiceLine findFirstOrThrow
   */
  export type InvoiceLineFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceLine
     */
    select?: InvoiceLineSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceLineInclude<ExtArgs> | null
    /**
     * Filter, which InvoiceLine to fetch.
     */
    where?: InvoiceLineWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InvoiceLines to fetch.
     */
    orderBy?: InvoiceLineOrderByWithRelationInput | InvoiceLineOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for InvoiceLines.
     */
    cursor?: InvoiceLineWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InvoiceLines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InvoiceLines.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of InvoiceLines.
     */
    distinct?: InvoiceLineScalarFieldEnum | InvoiceLineScalarFieldEnum[]
  }

  /**
   * InvoiceLine findMany
   */
  export type InvoiceLineFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceLine
     */
    select?: InvoiceLineSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceLineInclude<ExtArgs> | null
    /**
     * Filter, which InvoiceLines to fetch.
     */
    where?: InvoiceLineWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InvoiceLines to fetch.
     */
    orderBy?: InvoiceLineOrderByWithRelationInput | InvoiceLineOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing InvoiceLines.
     */
    cursor?: InvoiceLineWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InvoiceLines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InvoiceLines.
     */
    skip?: number
    distinct?: InvoiceLineScalarFieldEnum | InvoiceLineScalarFieldEnum[]
  }

  /**
   * InvoiceLine create
   */
  export type InvoiceLineCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceLine
     */
    select?: InvoiceLineSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceLineInclude<ExtArgs> | null
    /**
     * The data needed to create a InvoiceLine.
     */
    data: XOR<InvoiceLineCreateInput, InvoiceLineUncheckedCreateInput>
  }

  /**
   * InvoiceLine createMany
   */
  export type InvoiceLineCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many InvoiceLines.
     */
    data: InvoiceLineCreateManyInput | InvoiceLineCreateManyInput[]
  }

  /**
   * InvoiceLine createManyAndReturn
   */
  export type InvoiceLineCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceLine
     */
    select?: InvoiceLineSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many InvoiceLines.
     */
    data: InvoiceLineCreateManyInput | InvoiceLineCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceLineIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * InvoiceLine update
   */
  export type InvoiceLineUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceLine
     */
    select?: InvoiceLineSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceLineInclude<ExtArgs> | null
    /**
     * The data needed to update a InvoiceLine.
     */
    data: XOR<InvoiceLineUpdateInput, InvoiceLineUncheckedUpdateInput>
    /**
     * Choose, which InvoiceLine to update.
     */
    where: InvoiceLineWhereUniqueInput
  }

  /**
   * InvoiceLine updateMany
   */
  export type InvoiceLineUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update InvoiceLines.
     */
    data: XOR<InvoiceLineUpdateManyMutationInput, InvoiceLineUncheckedUpdateManyInput>
    /**
     * Filter which InvoiceLines to update
     */
    where?: InvoiceLineWhereInput
  }

  /**
   * InvoiceLine upsert
   */
  export type InvoiceLineUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceLine
     */
    select?: InvoiceLineSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceLineInclude<ExtArgs> | null
    /**
     * The filter to search for the InvoiceLine to update in case it exists.
     */
    where: InvoiceLineWhereUniqueInput
    /**
     * In case the InvoiceLine found by the `where` argument doesn't exist, create a new InvoiceLine with this data.
     */
    create: XOR<InvoiceLineCreateInput, InvoiceLineUncheckedCreateInput>
    /**
     * In case the InvoiceLine was found with the provided `where` argument, update it with this data.
     */
    update: XOR<InvoiceLineUpdateInput, InvoiceLineUncheckedUpdateInput>
  }

  /**
   * InvoiceLine delete
   */
  export type InvoiceLineDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceLine
     */
    select?: InvoiceLineSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceLineInclude<ExtArgs> | null
    /**
     * Filter which InvoiceLine to delete.
     */
    where: InvoiceLineWhereUniqueInput
  }

  /**
   * InvoiceLine deleteMany
   */
  export type InvoiceLineDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which InvoiceLines to delete
     */
    where?: InvoiceLineWhereInput
  }

  /**
   * InvoiceLine without action
   */
  export type InvoiceLineDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceLine
     */
    select?: InvoiceLineSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceLineInclude<ExtArgs> | null
  }


  /**
   * Model Payment
   */

  export type AggregatePayment = {
    _count: PaymentCountAggregateOutputType | null
    _avg: PaymentAvgAggregateOutputType | null
    _sum: PaymentSumAggregateOutputType | null
    _min: PaymentMinAggregateOutputType | null
    _max: PaymentMaxAggregateOutputType | null
  }

  export type PaymentAvgAggregateOutputType = {
    amount: number | null
  }

  export type PaymentSumAggregateOutputType = {
    amount: number | null
  }

  export type PaymentMinAggregateOutputType = {
    id: string | null
    invoiceId: string | null
    method: string | null
    amount: number | null
    status: string | null
    transactionRef: string | null
    paidAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PaymentMaxAggregateOutputType = {
    id: string | null
    invoiceId: string | null
    method: string | null
    amount: number | null
    status: string | null
    transactionRef: string | null
    paidAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PaymentCountAggregateOutputType = {
    id: number
    invoiceId: number
    method: number
    amount: number
    status: number
    transactionRef: number
    paidAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PaymentAvgAggregateInputType = {
    amount?: true
  }

  export type PaymentSumAggregateInputType = {
    amount?: true
  }

  export type PaymentMinAggregateInputType = {
    id?: true
    invoiceId?: true
    method?: true
    amount?: true
    status?: true
    transactionRef?: true
    paidAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PaymentMaxAggregateInputType = {
    id?: true
    invoiceId?: true
    method?: true
    amount?: true
    status?: true
    transactionRef?: true
    paidAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PaymentCountAggregateInputType = {
    id?: true
    invoiceId?: true
    method?: true
    amount?: true
    status?: true
    transactionRef?: true
    paidAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PaymentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Payment to aggregate.
     */
    where?: PaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payments to fetch.
     */
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Payments
    **/
    _count?: true | PaymentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PaymentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PaymentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PaymentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PaymentMaxAggregateInputType
  }

  export type GetPaymentAggregateType<T extends PaymentAggregateArgs> = {
        [P in keyof T & keyof AggregatePayment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePayment[P]>
      : GetScalarType<T[P], AggregatePayment[P]>
  }




  export type PaymentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PaymentWhereInput
    orderBy?: PaymentOrderByWithAggregationInput | PaymentOrderByWithAggregationInput[]
    by: PaymentScalarFieldEnum[] | PaymentScalarFieldEnum
    having?: PaymentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PaymentCountAggregateInputType | true
    _avg?: PaymentAvgAggregateInputType
    _sum?: PaymentSumAggregateInputType
    _min?: PaymentMinAggregateInputType
    _max?: PaymentMaxAggregateInputType
  }

  export type PaymentGroupByOutputType = {
    id: string
    invoiceId: string
    method: string
    amount: number
    status: string
    transactionRef: string | null
    paidAt: Date | null
    createdAt: Date
    updatedAt: Date
    _count: PaymentCountAggregateOutputType | null
    _avg: PaymentAvgAggregateOutputType | null
    _sum: PaymentSumAggregateOutputType | null
    _min: PaymentMinAggregateOutputType | null
    _max: PaymentMaxAggregateOutputType | null
  }

  type GetPaymentGroupByPayload<T extends PaymentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PaymentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PaymentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PaymentGroupByOutputType[P]>
            : GetScalarType<T[P], PaymentGroupByOutputType[P]>
        }
      >
    >


  export type PaymentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    invoiceId?: boolean
    method?: boolean
    amount?: boolean
    status?: boolean
    transactionRef?: boolean
    paidAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    invoice?: boolean | InvoiceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["payment"]>

  export type PaymentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    invoiceId?: boolean
    method?: boolean
    amount?: boolean
    status?: boolean
    transactionRef?: boolean
    paidAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    invoice?: boolean | InvoiceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["payment"]>

  export type PaymentSelectScalar = {
    id?: boolean
    invoiceId?: boolean
    method?: boolean
    amount?: boolean
    status?: boolean
    transactionRef?: boolean
    paidAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PaymentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    invoice?: boolean | InvoiceDefaultArgs<ExtArgs>
  }
  export type PaymentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    invoice?: boolean | InvoiceDefaultArgs<ExtArgs>
  }

  export type $PaymentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Payment"
    objects: {
      invoice: Prisma.$InvoicePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      invoiceId: string
      method: string
      amount: number
      status: string
      transactionRef: string | null
      paidAt: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["payment"]>
    composites: {}
  }

  type PaymentGetPayload<S extends boolean | null | undefined | PaymentDefaultArgs> = $Result.GetResult<Prisma.$PaymentPayload, S>

  type PaymentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<PaymentFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PaymentCountAggregateInputType | true
    }

  export interface PaymentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Payment'], meta: { name: 'Payment' } }
    /**
     * Find zero or one Payment that matches the filter.
     * @param {PaymentFindUniqueArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PaymentFindUniqueArgs>(args: SelectSubset<T, PaymentFindUniqueArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Payment that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {PaymentFindUniqueOrThrowArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PaymentFindUniqueOrThrowArgs>(args: SelectSubset<T, PaymentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Payment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentFindFirstArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PaymentFindFirstArgs>(args?: SelectSubset<T, PaymentFindFirstArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Payment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentFindFirstOrThrowArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PaymentFindFirstOrThrowArgs>(args?: SelectSubset<T, PaymentFindFirstOrThrowArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Payments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Payments
     * const payments = await prisma.payment.findMany()
     * 
     * // Get first 10 Payments
     * const payments = await prisma.payment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const paymentWithIdOnly = await prisma.payment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PaymentFindManyArgs>(args?: SelectSubset<T, PaymentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Payment.
     * @param {PaymentCreateArgs} args - Arguments to create a Payment.
     * @example
     * // Create one Payment
     * const Payment = await prisma.payment.create({
     *   data: {
     *     // ... data to create a Payment
     *   }
     * })
     * 
     */
    create<T extends PaymentCreateArgs>(args: SelectSubset<T, PaymentCreateArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Payments.
     * @param {PaymentCreateManyArgs} args - Arguments to create many Payments.
     * @example
     * // Create many Payments
     * const payment = await prisma.payment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PaymentCreateManyArgs>(args?: SelectSubset<T, PaymentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Payments and returns the data saved in the database.
     * @param {PaymentCreateManyAndReturnArgs} args - Arguments to create many Payments.
     * @example
     * // Create many Payments
     * const payment = await prisma.payment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Payments and only return the `id`
     * const paymentWithIdOnly = await prisma.payment.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PaymentCreateManyAndReturnArgs>(args?: SelectSubset<T, PaymentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Payment.
     * @param {PaymentDeleteArgs} args - Arguments to delete one Payment.
     * @example
     * // Delete one Payment
     * const Payment = await prisma.payment.delete({
     *   where: {
     *     // ... filter to delete one Payment
     *   }
     * })
     * 
     */
    delete<T extends PaymentDeleteArgs>(args: SelectSubset<T, PaymentDeleteArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Payment.
     * @param {PaymentUpdateArgs} args - Arguments to update one Payment.
     * @example
     * // Update one Payment
     * const payment = await prisma.payment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PaymentUpdateArgs>(args: SelectSubset<T, PaymentUpdateArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Payments.
     * @param {PaymentDeleteManyArgs} args - Arguments to filter Payments to delete.
     * @example
     * // Delete a few Payments
     * const { count } = await prisma.payment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PaymentDeleteManyArgs>(args?: SelectSubset<T, PaymentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Payments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Payments
     * const payment = await prisma.payment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PaymentUpdateManyArgs>(args: SelectSubset<T, PaymentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Payment.
     * @param {PaymentUpsertArgs} args - Arguments to update or create a Payment.
     * @example
     * // Update or create a Payment
     * const payment = await prisma.payment.upsert({
     *   create: {
     *     // ... data to create a Payment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Payment we want to update
     *   }
     * })
     */
    upsert<T extends PaymentUpsertArgs>(args: SelectSubset<T, PaymentUpsertArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Payments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentCountArgs} args - Arguments to filter Payments to count.
     * @example
     * // Count the number of Payments
     * const count = await prisma.payment.count({
     *   where: {
     *     // ... the filter for the Payments we want to count
     *   }
     * })
    **/
    count<T extends PaymentCountArgs>(
      args?: Subset<T, PaymentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PaymentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Payment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PaymentAggregateArgs>(args: Subset<T, PaymentAggregateArgs>): Prisma.PrismaPromise<GetPaymentAggregateType<T>>

    /**
     * Group by Payment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PaymentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PaymentGroupByArgs['orderBy'] }
        : { orderBy?: PaymentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PaymentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPaymentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Payment model
   */
  readonly fields: PaymentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Payment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PaymentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    invoice<T extends InvoiceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, InvoiceDefaultArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Payment model
   */ 
  interface PaymentFieldRefs {
    readonly id: FieldRef<"Payment", 'String'>
    readonly invoiceId: FieldRef<"Payment", 'String'>
    readonly method: FieldRef<"Payment", 'String'>
    readonly amount: FieldRef<"Payment", 'Float'>
    readonly status: FieldRef<"Payment", 'String'>
    readonly transactionRef: FieldRef<"Payment", 'String'>
    readonly paidAt: FieldRef<"Payment", 'DateTime'>
    readonly createdAt: FieldRef<"Payment", 'DateTime'>
    readonly updatedAt: FieldRef<"Payment", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Payment findUnique
   */
  export type PaymentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payment to fetch.
     */
    where: PaymentWhereUniqueInput
  }

  /**
   * Payment findUniqueOrThrow
   */
  export type PaymentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payment to fetch.
     */
    where: PaymentWhereUniqueInput
  }

  /**
   * Payment findFirst
   */
  export type PaymentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payment to fetch.
     */
    where?: PaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payments to fetch.
     */
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Payments.
     */
    cursor?: PaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Payments.
     */
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * Payment findFirstOrThrow
   */
  export type PaymentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payment to fetch.
     */
    where?: PaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payments to fetch.
     */
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Payments.
     */
    cursor?: PaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Payments.
     */
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * Payment findMany
   */
  export type PaymentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payments to fetch.
     */
    where?: PaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payments to fetch.
     */
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Payments.
     */
    cursor?: PaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payments.
     */
    skip?: number
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * Payment create
   */
  export type PaymentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * The data needed to create a Payment.
     */
    data: XOR<PaymentCreateInput, PaymentUncheckedCreateInput>
  }

  /**
   * Payment createMany
   */
  export type PaymentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Payments.
     */
    data: PaymentCreateManyInput | PaymentCreateManyInput[]
  }

  /**
   * Payment createManyAndReturn
   */
  export type PaymentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Payments.
     */
    data: PaymentCreateManyInput | PaymentCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Payment update
   */
  export type PaymentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * The data needed to update a Payment.
     */
    data: XOR<PaymentUpdateInput, PaymentUncheckedUpdateInput>
    /**
     * Choose, which Payment to update.
     */
    where: PaymentWhereUniqueInput
  }

  /**
   * Payment updateMany
   */
  export type PaymentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Payments.
     */
    data: XOR<PaymentUpdateManyMutationInput, PaymentUncheckedUpdateManyInput>
    /**
     * Filter which Payments to update
     */
    where?: PaymentWhereInput
  }

  /**
   * Payment upsert
   */
  export type PaymentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * The filter to search for the Payment to update in case it exists.
     */
    where: PaymentWhereUniqueInput
    /**
     * In case the Payment found by the `where` argument doesn't exist, create a new Payment with this data.
     */
    create: XOR<PaymentCreateInput, PaymentUncheckedCreateInput>
    /**
     * In case the Payment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PaymentUpdateInput, PaymentUncheckedUpdateInput>
  }

  /**
   * Payment delete
   */
  export type PaymentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter which Payment to delete.
     */
    where: PaymentWhereUniqueInput
  }

  /**
   * Payment deleteMany
   */
  export type PaymentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Payments to delete
     */
    where?: PaymentWhereInput
  }

  /**
   * Payment without action
   */
  export type PaymentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
  }


  /**
   * Model Pelanggaran
   */

  export type AggregatePelanggaran = {
    _count: PelanggaranCountAggregateOutputType | null
    _avg: PelanggaranAvgAggregateOutputType | null
    _sum: PelanggaranSumAggregateOutputType | null
    _min: PelanggaranMinAggregateOutputType | null
    _max: PelanggaranMaxAggregateOutputType | null
  }

  export type PelanggaranAvgAggregateOutputType = {
    severity: number | null
    points: number | null
  }

  export type PelanggaranSumAggregateOutputType = {
    severity: number | null
    points: number | null
  }

  export type PelanggaranMinAggregateOutputType = {
    id: string | null
    tenantId: string | null
    santriId: string | null
    recordedBy: string | null
    category: string | null
    severity: number | null
    points: number | null
    description: string | null
    date: Date | null
    resolved: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PelanggaranMaxAggregateOutputType = {
    id: string | null
    tenantId: string | null
    santriId: string | null
    recordedBy: string | null
    category: string | null
    severity: number | null
    points: number | null
    description: string | null
    date: Date | null
    resolved: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PelanggaranCountAggregateOutputType = {
    id: number
    tenantId: number
    santriId: number
    recordedBy: number
    category: number
    severity: number
    points: number
    description: number
    date: number
    resolved: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PelanggaranAvgAggregateInputType = {
    severity?: true
    points?: true
  }

  export type PelanggaranSumAggregateInputType = {
    severity?: true
    points?: true
  }

  export type PelanggaranMinAggregateInputType = {
    id?: true
    tenantId?: true
    santriId?: true
    recordedBy?: true
    category?: true
    severity?: true
    points?: true
    description?: true
    date?: true
    resolved?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PelanggaranMaxAggregateInputType = {
    id?: true
    tenantId?: true
    santriId?: true
    recordedBy?: true
    category?: true
    severity?: true
    points?: true
    description?: true
    date?: true
    resolved?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PelanggaranCountAggregateInputType = {
    id?: true
    tenantId?: true
    santriId?: true
    recordedBy?: true
    category?: true
    severity?: true
    points?: true
    description?: true
    date?: true
    resolved?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PelanggaranAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Pelanggaran to aggregate.
     */
    where?: PelanggaranWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Pelanggarans to fetch.
     */
    orderBy?: PelanggaranOrderByWithRelationInput | PelanggaranOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PelanggaranWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Pelanggarans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Pelanggarans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Pelanggarans
    **/
    _count?: true | PelanggaranCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PelanggaranAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PelanggaranSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PelanggaranMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PelanggaranMaxAggregateInputType
  }

  export type GetPelanggaranAggregateType<T extends PelanggaranAggregateArgs> = {
        [P in keyof T & keyof AggregatePelanggaran]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePelanggaran[P]>
      : GetScalarType<T[P], AggregatePelanggaran[P]>
  }




  export type PelanggaranGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PelanggaranWhereInput
    orderBy?: PelanggaranOrderByWithAggregationInput | PelanggaranOrderByWithAggregationInput[]
    by: PelanggaranScalarFieldEnum[] | PelanggaranScalarFieldEnum
    having?: PelanggaranScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PelanggaranCountAggregateInputType | true
    _avg?: PelanggaranAvgAggregateInputType
    _sum?: PelanggaranSumAggregateInputType
    _min?: PelanggaranMinAggregateInputType
    _max?: PelanggaranMaxAggregateInputType
  }

  export type PelanggaranGroupByOutputType = {
    id: string
    tenantId: string
    santriId: string
    recordedBy: string
    category: string
    severity: number
    points: number
    description: string
    date: Date
    resolved: boolean
    createdAt: Date
    updatedAt: Date
    _count: PelanggaranCountAggregateOutputType | null
    _avg: PelanggaranAvgAggregateOutputType | null
    _sum: PelanggaranSumAggregateOutputType | null
    _min: PelanggaranMinAggregateOutputType | null
    _max: PelanggaranMaxAggregateOutputType | null
  }

  type GetPelanggaranGroupByPayload<T extends PelanggaranGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PelanggaranGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PelanggaranGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PelanggaranGroupByOutputType[P]>
            : GetScalarType<T[P], PelanggaranGroupByOutputType[P]>
        }
      >
    >


  export type PelanggaranSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    santriId?: boolean
    recordedBy?: boolean
    category?: boolean
    severity?: boolean
    points?: boolean
    description?: boolean
    date?: boolean
    resolved?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    santri?: boolean | SantriDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["pelanggaran"]>

  export type PelanggaranSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    santriId?: boolean
    recordedBy?: boolean
    category?: boolean
    severity?: boolean
    points?: boolean
    description?: boolean
    date?: boolean
    resolved?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    santri?: boolean | SantriDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["pelanggaran"]>

  export type PelanggaranSelectScalar = {
    id?: boolean
    tenantId?: boolean
    santriId?: boolean
    recordedBy?: boolean
    category?: boolean
    severity?: boolean
    points?: boolean
    description?: boolean
    date?: boolean
    resolved?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PelanggaranInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    santri?: boolean | SantriDefaultArgs<ExtArgs>
  }
  export type PelanggaranIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    santri?: boolean | SantriDefaultArgs<ExtArgs>
  }

  export type $PelanggaranPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Pelanggaran"
    objects: {
      tenant: Prisma.$TenantPayload<ExtArgs>
      santri: Prisma.$SantriPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      tenantId: string
      santriId: string
      recordedBy: string
      category: string
      severity: number
      points: number
      description: string
      date: Date
      resolved: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["pelanggaran"]>
    composites: {}
  }

  type PelanggaranGetPayload<S extends boolean | null | undefined | PelanggaranDefaultArgs> = $Result.GetResult<Prisma.$PelanggaranPayload, S>

  type PelanggaranCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<PelanggaranFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PelanggaranCountAggregateInputType | true
    }

  export interface PelanggaranDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Pelanggaran'], meta: { name: 'Pelanggaran' } }
    /**
     * Find zero or one Pelanggaran that matches the filter.
     * @param {PelanggaranFindUniqueArgs} args - Arguments to find a Pelanggaran
     * @example
     * // Get one Pelanggaran
     * const pelanggaran = await prisma.pelanggaran.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PelanggaranFindUniqueArgs>(args: SelectSubset<T, PelanggaranFindUniqueArgs<ExtArgs>>): Prisma__PelanggaranClient<$Result.GetResult<Prisma.$PelanggaranPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Pelanggaran that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {PelanggaranFindUniqueOrThrowArgs} args - Arguments to find a Pelanggaran
     * @example
     * // Get one Pelanggaran
     * const pelanggaran = await prisma.pelanggaran.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PelanggaranFindUniqueOrThrowArgs>(args: SelectSubset<T, PelanggaranFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PelanggaranClient<$Result.GetResult<Prisma.$PelanggaranPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Pelanggaran that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PelanggaranFindFirstArgs} args - Arguments to find a Pelanggaran
     * @example
     * // Get one Pelanggaran
     * const pelanggaran = await prisma.pelanggaran.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PelanggaranFindFirstArgs>(args?: SelectSubset<T, PelanggaranFindFirstArgs<ExtArgs>>): Prisma__PelanggaranClient<$Result.GetResult<Prisma.$PelanggaranPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Pelanggaran that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PelanggaranFindFirstOrThrowArgs} args - Arguments to find a Pelanggaran
     * @example
     * // Get one Pelanggaran
     * const pelanggaran = await prisma.pelanggaran.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PelanggaranFindFirstOrThrowArgs>(args?: SelectSubset<T, PelanggaranFindFirstOrThrowArgs<ExtArgs>>): Prisma__PelanggaranClient<$Result.GetResult<Prisma.$PelanggaranPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Pelanggarans that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PelanggaranFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Pelanggarans
     * const pelanggarans = await prisma.pelanggaran.findMany()
     * 
     * // Get first 10 Pelanggarans
     * const pelanggarans = await prisma.pelanggaran.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const pelanggaranWithIdOnly = await prisma.pelanggaran.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PelanggaranFindManyArgs>(args?: SelectSubset<T, PelanggaranFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PelanggaranPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Pelanggaran.
     * @param {PelanggaranCreateArgs} args - Arguments to create a Pelanggaran.
     * @example
     * // Create one Pelanggaran
     * const Pelanggaran = await prisma.pelanggaran.create({
     *   data: {
     *     // ... data to create a Pelanggaran
     *   }
     * })
     * 
     */
    create<T extends PelanggaranCreateArgs>(args: SelectSubset<T, PelanggaranCreateArgs<ExtArgs>>): Prisma__PelanggaranClient<$Result.GetResult<Prisma.$PelanggaranPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Pelanggarans.
     * @param {PelanggaranCreateManyArgs} args - Arguments to create many Pelanggarans.
     * @example
     * // Create many Pelanggarans
     * const pelanggaran = await prisma.pelanggaran.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PelanggaranCreateManyArgs>(args?: SelectSubset<T, PelanggaranCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Pelanggarans and returns the data saved in the database.
     * @param {PelanggaranCreateManyAndReturnArgs} args - Arguments to create many Pelanggarans.
     * @example
     * // Create many Pelanggarans
     * const pelanggaran = await prisma.pelanggaran.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Pelanggarans and only return the `id`
     * const pelanggaranWithIdOnly = await prisma.pelanggaran.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PelanggaranCreateManyAndReturnArgs>(args?: SelectSubset<T, PelanggaranCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PelanggaranPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Pelanggaran.
     * @param {PelanggaranDeleteArgs} args - Arguments to delete one Pelanggaran.
     * @example
     * // Delete one Pelanggaran
     * const Pelanggaran = await prisma.pelanggaran.delete({
     *   where: {
     *     // ... filter to delete one Pelanggaran
     *   }
     * })
     * 
     */
    delete<T extends PelanggaranDeleteArgs>(args: SelectSubset<T, PelanggaranDeleteArgs<ExtArgs>>): Prisma__PelanggaranClient<$Result.GetResult<Prisma.$PelanggaranPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Pelanggaran.
     * @param {PelanggaranUpdateArgs} args - Arguments to update one Pelanggaran.
     * @example
     * // Update one Pelanggaran
     * const pelanggaran = await prisma.pelanggaran.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PelanggaranUpdateArgs>(args: SelectSubset<T, PelanggaranUpdateArgs<ExtArgs>>): Prisma__PelanggaranClient<$Result.GetResult<Prisma.$PelanggaranPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Pelanggarans.
     * @param {PelanggaranDeleteManyArgs} args - Arguments to filter Pelanggarans to delete.
     * @example
     * // Delete a few Pelanggarans
     * const { count } = await prisma.pelanggaran.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PelanggaranDeleteManyArgs>(args?: SelectSubset<T, PelanggaranDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Pelanggarans.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PelanggaranUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Pelanggarans
     * const pelanggaran = await prisma.pelanggaran.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PelanggaranUpdateManyArgs>(args: SelectSubset<T, PelanggaranUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Pelanggaran.
     * @param {PelanggaranUpsertArgs} args - Arguments to update or create a Pelanggaran.
     * @example
     * // Update or create a Pelanggaran
     * const pelanggaran = await prisma.pelanggaran.upsert({
     *   create: {
     *     // ... data to create a Pelanggaran
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Pelanggaran we want to update
     *   }
     * })
     */
    upsert<T extends PelanggaranUpsertArgs>(args: SelectSubset<T, PelanggaranUpsertArgs<ExtArgs>>): Prisma__PelanggaranClient<$Result.GetResult<Prisma.$PelanggaranPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Pelanggarans.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PelanggaranCountArgs} args - Arguments to filter Pelanggarans to count.
     * @example
     * // Count the number of Pelanggarans
     * const count = await prisma.pelanggaran.count({
     *   where: {
     *     // ... the filter for the Pelanggarans we want to count
     *   }
     * })
    **/
    count<T extends PelanggaranCountArgs>(
      args?: Subset<T, PelanggaranCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PelanggaranCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Pelanggaran.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PelanggaranAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PelanggaranAggregateArgs>(args: Subset<T, PelanggaranAggregateArgs>): Prisma.PrismaPromise<GetPelanggaranAggregateType<T>>

    /**
     * Group by Pelanggaran.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PelanggaranGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PelanggaranGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PelanggaranGroupByArgs['orderBy'] }
        : { orderBy?: PelanggaranGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PelanggaranGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPelanggaranGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Pelanggaran model
   */
  readonly fields: PelanggaranFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Pelanggaran.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PelanggaranClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    tenant<T extends TenantDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TenantDefaultArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    santri<T extends SantriDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SantriDefaultArgs<ExtArgs>>): Prisma__SantriClient<$Result.GetResult<Prisma.$SantriPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Pelanggaran model
   */ 
  interface PelanggaranFieldRefs {
    readonly id: FieldRef<"Pelanggaran", 'String'>
    readonly tenantId: FieldRef<"Pelanggaran", 'String'>
    readonly santriId: FieldRef<"Pelanggaran", 'String'>
    readonly recordedBy: FieldRef<"Pelanggaran", 'String'>
    readonly category: FieldRef<"Pelanggaran", 'String'>
    readonly severity: FieldRef<"Pelanggaran", 'Int'>
    readonly points: FieldRef<"Pelanggaran", 'Int'>
    readonly description: FieldRef<"Pelanggaran", 'String'>
    readonly date: FieldRef<"Pelanggaran", 'DateTime'>
    readonly resolved: FieldRef<"Pelanggaran", 'Boolean'>
    readonly createdAt: FieldRef<"Pelanggaran", 'DateTime'>
    readonly updatedAt: FieldRef<"Pelanggaran", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Pelanggaran findUnique
   */
  export type PelanggaranFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pelanggaran
     */
    select?: PelanggaranSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PelanggaranInclude<ExtArgs> | null
    /**
     * Filter, which Pelanggaran to fetch.
     */
    where: PelanggaranWhereUniqueInput
  }

  /**
   * Pelanggaran findUniqueOrThrow
   */
  export type PelanggaranFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pelanggaran
     */
    select?: PelanggaranSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PelanggaranInclude<ExtArgs> | null
    /**
     * Filter, which Pelanggaran to fetch.
     */
    where: PelanggaranWhereUniqueInput
  }

  /**
   * Pelanggaran findFirst
   */
  export type PelanggaranFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pelanggaran
     */
    select?: PelanggaranSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PelanggaranInclude<ExtArgs> | null
    /**
     * Filter, which Pelanggaran to fetch.
     */
    where?: PelanggaranWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Pelanggarans to fetch.
     */
    orderBy?: PelanggaranOrderByWithRelationInput | PelanggaranOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Pelanggarans.
     */
    cursor?: PelanggaranWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Pelanggarans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Pelanggarans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Pelanggarans.
     */
    distinct?: PelanggaranScalarFieldEnum | PelanggaranScalarFieldEnum[]
  }

  /**
   * Pelanggaran findFirstOrThrow
   */
  export type PelanggaranFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pelanggaran
     */
    select?: PelanggaranSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PelanggaranInclude<ExtArgs> | null
    /**
     * Filter, which Pelanggaran to fetch.
     */
    where?: PelanggaranWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Pelanggarans to fetch.
     */
    orderBy?: PelanggaranOrderByWithRelationInput | PelanggaranOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Pelanggarans.
     */
    cursor?: PelanggaranWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Pelanggarans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Pelanggarans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Pelanggarans.
     */
    distinct?: PelanggaranScalarFieldEnum | PelanggaranScalarFieldEnum[]
  }

  /**
   * Pelanggaran findMany
   */
  export type PelanggaranFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pelanggaran
     */
    select?: PelanggaranSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PelanggaranInclude<ExtArgs> | null
    /**
     * Filter, which Pelanggarans to fetch.
     */
    where?: PelanggaranWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Pelanggarans to fetch.
     */
    orderBy?: PelanggaranOrderByWithRelationInput | PelanggaranOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Pelanggarans.
     */
    cursor?: PelanggaranWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Pelanggarans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Pelanggarans.
     */
    skip?: number
    distinct?: PelanggaranScalarFieldEnum | PelanggaranScalarFieldEnum[]
  }

  /**
   * Pelanggaran create
   */
  export type PelanggaranCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pelanggaran
     */
    select?: PelanggaranSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PelanggaranInclude<ExtArgs> | null
    /**
     * The data needed to create a Pelanggaran.
     */
    data: XOR<PelanggaranCreateInput, PelanggaranUncheckedCreateInput>
  }

  /**
   * Pelanggaran createMany
   */
  export type PelanggaranCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Pelanggarans.
     */
    data: PelanggaranCreateManyInput | PelanggaranCreateManyInput[]
  }

  /**
   * Pelanggaran createManyAndReturn
   */
  export type PelanggaranCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pelanggaran
     */
    select?: PelanggaranSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Pelanggarans.
     */
    data: PelanggaranCreateManyInput | PelanggaranCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PelanggaranIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Pelanggaran update
   */
  export type PelanggaranUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pelanggaran
     */
    select?: PelanggaranSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PelanggaranInclude<ExtArgs> | null
    /**
     * The data needed to update a Pelanggaran.
     */
    data: XOR<PelanggaranUpdateInput, PelanggaranUncheckedUpdateInput>
    /**
     * Choose, which Pelanggaran to update.
     */
    where: PelanggaranWhereUniqueInput
  }

  /**
   * Pelanggaran updateMany
   */
  export type PelanggaranUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Pelanggarans.
     */
    data: XOR<PelanggaranUpdateManyMutationInput, PelanggaranUncheckedUpdateManyInput>
    /**
     * Filter which Pelanggarans to update
     */
    where?: PelanggaranWhereInput
  }

  /**
   * Pelanggaran upsert
   */
  export type PelanggaranUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pelanggaran
     */
    select?: PelanggaranSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PelanggaranInclude<ExtArgs> | null
    /**
     * The filter to search for the Pelanggaran to update in case it exists.
     */
    where: PelanggaranWhereUniqueInput
    /**
     * In case the Pelanggaran found by the `where` argument doesn't exist, create a new Pelanggaran with this data.
     */
    create: XOR<PelanggaranCreateInput, PelanggaranUncheckedCreateInput>
    /**
     * In case the Pelanggaran was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PelanggaranUpdateInput, PelanggaranUncheckedUpdateInput>
  }

  /**
   * Pelanggaran delete
   */
  export type PelanggaranDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pelanggaran
     */
    select?: PelanggaranSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PelanggaranInclude<ExtArgs> | null
    /**
     * Filter which Pelanggaran to delete.
     */
    where: PelanggaranWhereUniqueInput
  }

  /**
   * Pelanggaran deleteMany
   */
  export type PelanggaranDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Pelanggarans to delete
     */
    where?: PelanggaranWhereInput
  }

  /**
   * Pelanggaran without action
   */
  export type PelanggaranDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pelanggaran
     */
    select?: PelanggaranSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PelanggaranInclude<ExtArgs> | null
  }


  /**
   * Model Pembinaan
   */

  export type AggregatePembinaan = {
    _count: PembinaanCountAggregateOutputType | null
    _min: PembinaanMinAggregateOutputType | null
    _max: PembinaanMaxAggregateOutputType | null
  }

  export type PembinaanMinAggregateOutputType = {
    id: string | null
    tenantId: string | null
    santriId: string | null
    plan: string | null
    targetDate: Date | null
    status: string | null
    assignedTo: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PembinaanMaxAggregateOutputType = {
    id: string | null
    tenantId: string | null
    santriId: string | null
    plan: string | null
    targetDate: Date | null
    status: string | null
    assignedTo: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PembinaanCountAggregateOutputType = {
    id: number
    tenantId: number
    santriId: number
    plan: number
    targetDate: number
    status: number
    assignedTo: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PembinaanMinAggregateInputType = {
    id?: true
    tenantId?: true
    santriId?: true
    plan?: true
    targetDate?: true
    status?: true
    assignedTo?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PembinaanMaxAggregateInputType = {
    id?: true
    tenantId?: true
    santriId?: true
    plan?: true
    targetDate?: true
    status?: true
    assignedTo?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PembinaanCountAggregateInputType = {
    id?: true
    tenantId?: true
    santriId?: true
    plan?: true
    targetDate?: true
    status?: true
    assignedTo?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PembinaanAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Pembinaan to aggregate.
     */
    where?: PembinaanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Pembinaans to fetch.
     */
    orderBy?: PembinaanOrderByWithRelationInput | PembinaanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PembinaanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Pembinaans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Pembinaans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Pembinaans
    **/
    _count?: true | PembinaanCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PembinaanMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PembinaanMaxAggregateInputType
  }

  export type GetPembinaanAggregateType<T extends PembinaanAggregateArgs> = {
        [P in keyof T & keyof AggregatePembinaan]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePembinaan[P]>
      : GetScalarType<T[P], AggregatePembinaan[P]>
  }




  export type PembinaanGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PembinaanWhereInput
    orderBy?: PembinaanOrderByWithAggregationInput | PembinaanOrderByWithAggregationInput[]
    by: PembinaanScalarFieldEnum[] | PembinaanScalarFieldEnum
    having?: PembinaanScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PembinaanCountAggregateInputType | true
    _min?: PembinaanMinAggregateInputType
    _max?: PembinaanMaxAggregateInputType
  }

  export type PembinaanGroupByOutputType = {
    id: string
    tenantId: string
    santriId: string
    plan: string
    targetDate: Date
    status: string
    assignedTo: string
    createdAt: Date
    updatedAt: Date
    _count: PembinaanCountAggregateOutputType | null
    _min: PembinaanMinAggregateOutputType | null
    _max: PembinaanMaxAggregateOutputType | null
  }

  type GetPembinaanGroupByPayload<T extends PembinaanGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PembinaanGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PembinaanGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PembinaanGroupByOutputType[P]>
            : GetScalarType<T[P], PembinaanGroupByOutputType[P]>
        }
      >
    >


  export type PembinaanSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    santriId?: boolean
    plan?: boolean
    targetDate?: boolean
    status?: boolean
    assignedTo?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    santri?: boolean | SantriDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["pembinaan"]>

  export type PembinaanSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    santriId?: boolean
    plan?: boolean
    targetDate?: boolean
    status?: boolean
    assignedTo?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    santri?: boolean | SantriDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["pembinaan"]>

  export type PembinaanSelectScalar = {
    id?: boolean
    tenantId?: boolean
    santriId?: boolean
    plan?: boolean
    targetDate?: boolean
    status?: boolean
    assignedTo?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PembinaanInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    santri?: boolean | SantriDefaultArgs<ExtArgs>
  }
  export type PembinaanIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    santri?: boolean | SantriDefaultArgs<ExtArgs>
  }

  export type $PembinaanPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Pembinaan"
    objects: {
      tenant: Prisma.$TenantPayload<ExtArgs>
      santri: Prisma.$SantriPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      tenantId: string
      santriId: string
      plan: string
      targetDate: Date
      status: string
      assignedTo: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["pembinaan"]>
    composites: {}
  }

  type PembinaanGetPayload<S extends boolean | null | undefined | PembinaanDefaultArgs> = $Result.GetResult<Prisma.$PembinaanPayload, S>

  type PembinaanCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<PembinaanFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PembinaanCountAggregateInputType | true
    }

  export interface PembinaanDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Pembinaan'], meta: { name: 'Pembinaan' } }
    /**
     * Find zero or one Pembinaan that matches the filter.
     * @param {PembinaanFindUniqueArgs} args - Arguments to find a Pembinaan
     * @example
     * // Get one Pembinaan
     * const pembinaan = await prisma.pembinaan.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PembinaanFindUniqueArgs>(args: SelectSubset<T, PembinaanFindUniqueArgs<ExtArgs>>): Prisma__PembinaanClient<$Result.GetResult<Prisma.$PembinaanPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Pembinaan that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {PembinaanFindUniqueOrThrowArgs} args - Arguments to find a Pembinaan
     * @example
     * // Get one Pembinaan
     * const pembinaan = await prisma.pembinaan.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PembinaanFindUniqueOrThrowArgs>(args: SelectSubset<T, PembinaanFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PembinaanClient<$Result.GetResult<Prisma.$PembinaanPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Pembinaan that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PembinaanFindFirstArgs} args - Arguments to find a Pembinaan
     * @example
     * // Get one Pembinaan
     * const pembinaan = await prisma.pembinaan.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PembinaanFindFirstArgs>(args?: SelectSubset<T, PembinaanFindFirstArgs<ExtArgs>>): Prisma__PembinaanClient<$Result.GetResult<Prisma.$PembinaanPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Pembinaan that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PembinaanFindFirstOrThrowArgs} args - Arguments to find a Pembinaan
     * @example
     * // Get one Pembinaan
     * const pembinaan = await prisma.pembinaan.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PembinaanFindFirstOrThrowArgs>(args?: SelectSubset<T, PembinaanFindFirstOrThrowArgs<ExtArgs>>): Prisma__PembinaanClient<$Result.GetResult<Prisma.$PembinaanPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Pembinaans that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PembinaanFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Pembinaans
     * const pembinaans = await prisma.pembinaan.findMany()
     * 
     * // Get first 10 Pembinaans
     * const pembinaans = await prisma.pembinaan.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const pembinaanWithIdOnly = await prisma.pembinaan.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PembinaanFindManyArgs>(args?: SelectSubset<T, PembinaanFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PembinaanPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Pembinaan.
     * @param {PembinaanCreateArgs} args - Arguments to create a Pembinaan.
     * @example
     * // Create one Pembinaan
     * const Pembinaan = await prisma.pembinaan.create({
     *   data: {
     *     // ... data to create a Pembinaan
     *   }
     * })
     * 
     */
    create<T extends PembinaanCreateArgs>(args: SelectSubset<T, PembinaanCreateArgs<ExtArgs>>): Prisma__PembinaanClient<$Result.GetResult<Prisma.$PembinaanPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Pembinaans.
     * @param {PembinaanCreateManyArgs} args - Arguments to create many Pembinaans.
     * @example
     * // Create many Pembinaans
     * const pembinaan = await prisma.pembinaan.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PembinaanCreateManyArgs>(args?: SelectSubset<T, PembinaanCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Pembinaans and returns the data saved in the database.
     * @param {PembinaanCreateManyAndReturnArgs} args - Arguments to create many Pembinaans.
     * @example
     * // Create many Pembinaans
     * const pembinaan = await prisma.pembinaan.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Pembinaans and only return the `id`
     * const pembinaanWithIdOnly = await prisma.pembinaan.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PembinaanCreateManyAndReturnArgs>(args?: SelectSubset<T, PembinaanCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PembinaanPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Pembinaan.
     * @param {PembinaanDeleteArgs} args - Arguments to delete one Pembinaan.
     * @example
     * // Delete one Pembinaan
     * const Pembinaan = await prisma.pembinaan.delete({
     *   where: {
     *     // ... filter to delete one Pembinaan
     *   }
     * })
     * 
     */
    delete<T extends PembinaanDeleteArgs>(args: SelectSubset<T, PembinaanDeleteArgs<ExtArgs>>): Prisma__PembinaanClient<$Result.GetResult<Prisma.$PembinaanPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Pembinaan.
     * @param {PembinaanUpdateArgs} args - Arguments to update one Pembinaan.
     * @example
     * // Update one Pembinaan
     * const pembinaan = await prisma.pembinaan.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PembinaanUpdateArgs>(args: SelectSubset<T, PembinaanUpdateArgs<ExtArgs>>): Prisma__PembinaanClient<$Result.GetResult<Prisma.$PembinaanPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Pembinaans.
     * @param {PembinaanDeleteManyArgs} args - Arguments to filter Pembinaans to delete.
     * @example
     * // Delete a few Pembinaans
     * const { count } = await prisma.pembinaan.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PembinaanDeleteManyArgs>(args?: SelectSubset<T, PembinaanDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Pembinaans.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PembinaanUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Pembinaans
     * const pembinaan = await prisma.pembinaan.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PembinaanUpdateManyArgs>(args: SelectSubset<T, PembinaanUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Pembinaan.
     * @param {PembinaanUpsertArgs} args - Arguments to update or create a Pembinaan.
     * @example
     * // Update or create a Pembinaan
     * const pembinaan = await prisma.pembinaan.upsert({
     *   create: {
     *     // ... data to create a Pembinaan
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Pembinaan we want to update
     *   }
     * })
     */
    upsert<T extends PembinaanUpsertArgs>(args: SelectSubset<T, PembinaanUpsertArgs<ExtArgs>>): Prisma__PembinaanClient<$Result.GetResult<Prisma.$PembinaanPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Pembinaans.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PembinaanCountArgs} args - Arguments to filter Pembinaans to count.
     * @example
     * // Count the number of Pembinaans
     * const count = await prisma.pembinaan.count({
     *   where: {
     *     // ... the filter for the Pembinaans we want to count
     *   }
     * })
    **/
    count<T extends PembinaanCountArgs>(
      args?: Subset<T, PembinaanCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PembinaanCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Pembinaan.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PembinaanAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PembinaanAggregateArgs>(args: Subset<T, PembinaanAggregateArgs>): Prisma.PrismaPromise<GetPembinaanAggregateType<T>>

    /**
     * Group by Pembinaan.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PembinaanGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PembinaanGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PembinaanGroupByArgs['orderBy'] }
        : { orderBy?: PembinaanGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PembinaanGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPembinaanGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Pembinaan model
   */
  readonly fields: PembinaanFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Pembinaan.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PembinaanClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    tenant<T extends TenantDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TenantDefaultArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    santri<T extends SantriDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SantriDefaultArgs<ExtArgs>>): Prisma__SantriClient<$Result.GetResult<Prisma.$SantriPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Pembinaan model
   */ 
  interface PembinaanFieldRefs {
    readonly id: FieldRef<"Pembinaan", 'String'>
    readonly tenantId: FieldRef<"Pembinaan", 'String'>
    readonly santriId: FieldRef<"Pembinaan", 'String'>
    readonly plan: FieldRef<"Pembinaan", 'String'>
    readonly targetDate: FieldRef<"Pembinaan", 'DateTime'>
    readonly status: FieldRef<"Pembinaan", 'String'>
    readonly assignedTo: FieldRef<"Pembinaan", 'String'>
    readonly createdAt: FieldRef<"Pembinaan", 'DateTime'>
    readonly updatedAt: FieldRef<"Pembinaan", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Pembinaan findUnique
   */
  export type PembinaanFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pembinaan
     */
    select?: PembinaanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PembinaanInclude<ExtArgs> | null
    /**
     * Filter, which Pembinaan to fetch.
     */
    where: PembinaanWhereUniqueInput
  }

  /**
   * Pembinaan findUniqueOrThrow
   */
  export type PembinaanFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pembinaan
     */
    select?: PembinaanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PembinaanInclude<ExtArgs> | null
    /**
     * Filter, which Pembinaan to fetch.
     */
    where: PembinaanWhereUniqueInput
  }

  /**
   * Pembinaan findFirst
   */
  export type PembinaanFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pembinaan
     */
    select?: PembinaanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PembinaanInclude<ExtArgs> | null
    /**
     * Filter, which Pembinaan to fetch.
     */
    where?: PembinaanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Pembinaans to fetch.
     */
    orderBy?: PembinaanOrderByWithRelationInput | PembinaanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Pembinaans.
     */
    cursor?: PembinaanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Pembinaans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Pembinaans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Pembinaans.
     */
    distinct?: PembinaanScalarFieldEnum | PembinaanScalarFieldEnum[]
  }

  /**
   * Pembinaan findFirstOrThrow
   */
  export type PembinaanFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pembinaan
     */
    select?: PembinaanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PembinaanInclude<ExtArgs> | null
    /**
     * Filter, which Pembinaan to fetch.
     */
    where?: PembinaanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Pembinaans to fetch.
     */
    orderBy?: PembinaanOrderByWithRelationInput | PembinaanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Pembinaans.
     */
    cursor?: PembinaanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Pembinaans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Pembinaans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Pembinaans.
     */
    distinct?: PembinaanScalarFieldEnum | PembinaanScalarFieldEnum[]
  }

  /**
   * Pembinaan findMany
   */
  export type PembinaanFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pembinaan
     */
    select?: PembinaanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PembinaanInclude<ExtArgs> | null
    /**
     * Filter, which Pembinaans to fetch.
     */
    where?: PembinaanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Pembinaans to fetch.
     */
    orderBy?: PembinaanOrderByWithRelationInput | PembinaanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Pembinaans.
     */
    cursor?: PembinaanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Pembinaans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Pembinaans.
     */
    skip?: number
    distinct?: PembinaanScalarFieldEnum | PembinaanScalarFieldEnum[]
  }

  /**
   * Pembinaan create
   */
  export type PembinaanCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pembinaan
     */
    select?: PembinaanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PembinaanInclude<ExtArgs> | null
    /**
     * The data needed to create a Pembinaan.
     */
    data: XOR<PembinaanCreateInput, PembinaanUncheckedCreateInput>
  }

  /**
   * Pembinaan createMany
   */
  export type PembinaanCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Pembinaans.
     */
    data: PembinaanCreateManyInput | PembinaanCreateManyInput[]
  }

  /**
   * Pembinaan createManyAndReturn
   */
  export type PembinaanCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pembinaan
     */
    select?: PembinaanSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Pembinaans.
     */
    data: PembinaanCreateManyInput | PembinaanCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PembinaanIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Pembinaan update
   */
  export type PembinaanUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pembinaan
     */
    select?: PembinaanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PembinaanInclude<ExtArgs> | null
    /**
     * The data needed to update a Pembinaan.
     */
    data: XOR<PembinaanUpdateInput, PembinaanUncheckedUpdateInput>
    /**
     * Choose, which Pembinaan to update.
     */
    where: PembinaanWhereUniqueInput
  }

  /**
   * Pembinaan updateMany
   */
  export type PembinaanUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Pembinaans.
     */
    data: XOR<PembinaanUpdateManyMutationInput, PembinaanUncheckedUpdateManyInput>
    /**
     * Filter which Pembinaans to update
     */
    where?: PembinaanWhereInput
  }

  /**
   * Pembinaan upsert
   */
  export type PembinaanUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pembinaan
     */
    select?: PembinaanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PembinaanInclude<ExtArgs> | null
    /**
     * The filter to search for the Pembinaan to update in case it exists.
     */
    where: PembinaanWhereUniqueInput
    /**
     * In case the Pembinaan found by the `where` argument doesn't exist, create a new Pembinaan with this data.
     */
    create: XOR<PembinaanCreateInput, PembinaanUncheckedCreateInput>
    /**
     * In case the Pembinaan was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PembinaanUpdateInput, PembinaanUncheckedUpdateInput>
  }

  /**
   * Pembinaan delete
   */
  export type PembinaanDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pembinaan
     */
    select?: PembinaanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PembinaanInclude<ExtArgs> | null
    /**
     * Filter which Pembinaan to delete.
     */
    where: PembinaanWhereUniqueInput
  }

  /**
   * Pembinaan deleteMany
   */
  export type PembinaanDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Pembinaans to delete
     */
    where?: PembinaanWhereInput
  }

  /**
   * Pembinaan without action
   */
  export type PembinaanDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pembinaan
     */
    select?: PembinaanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PembinaanInclude<ExtArgs> | null
  }


  /**
   * Model Kunjungan
   */

  export type AggregateKunjungan = {
    _count: KunjunganCountAggregateOutputType | null
    _avg: KunjunganAvgAggregateOutputType | null
    _sum: KunjunganSumAggregateOutputType | null
    _min: KunjunganMinAggregateOutputType | null
    _max: KunjunganMaxAggregateOutputType | null
  }

  export type KunjunganAvgAggregateOutputType = {
    visitorLimit: number | null
  }

  export type KunjunganSumAggregateOutputType = {
    visitorLimit: number | null
  }

  export type KunjunganMinAggregateOutputType = {
    id: string | null
    tenantId: string | null
    santriId: string | null
    scheduledAt: Date | null
    slot: string | null
    visitorLimit: number | null
    status: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type KunjunganMaxAggregateOutputType = {
    id: string | null
    tenantId: string | null
    santriId: string | null
    scheduledAt: Date | null
    slot: string | null
    visitorLimit: number | null
    status: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type KunjunganCountAggregateOutputType = {
    id: number
    tenantId: number
    santriId: number
    scheduledAt: number
    slot: number
    visitorLimit: number
    status: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type KunjunganAvgAggregateInputType = {
    visitorLimit?: true
  }

  export type KunjunganSumAggregateInputType = {
    visitorLimit?: true
  }

  export type KunjunganMinAggregateInputType = {
    id?: true
    tenantId?: true
    santriId?: true
    scheduledAt?: true
    slot?: true
    visitorLimit?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type KunjunganMaxAggregateInputType = {
    id?: true
    tenantId?: true
    santriId?: true
    scheduledAt?: true
    slot?: true
    visitorLimit?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type KunjunganCountAggregateInputType = {
    id?: true
    tenantId?: true
    santriId?: true
    scheduledAt?: true
    slot?: true
    visitorLimit?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type KunjunganAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Kunjungan to aggregate.
     */
    where?: KunjunganWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Kunjungans to fetch.
     */
    orderBy?: KunjunganOrderByWithRelationInput | KunjunganOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: KunjunganWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Kunjungans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Kunjungans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Kunjungans
    **/
    _count?: true | KunjunganCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: KunjunganAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: KunjunganSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: KunjunganMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: KunjunganMaxAggregateInputType
  }

  export type GetKunjunganAggregateType<T extends KunjunganAggregateArgs> = {
        [P in keyof T & keyof AggregateKunjungan]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateKunjungan[P]>
      : GetScalarType<T[P], AggregateKunjungan[P]>
  }




  export type KunjunganGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: KunjunganWhereInput
    orderBy?: KunjunganOrderByWithAggregationInput | KunjunganOrderByWithAggregationInput[]
    by: KunjunganScalarFieldEnum[] | KunjunganScalarFieldEnum
    having?: KunjunganScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: KunjunganCountAggregateInputType | true
    _avg?: KunjunganAvgAggregateInputType
    _sum?: KunjunganSumAggregateInputType
    _min?: KunjunganMinAggregateInputType
    _max?: KunjunganMaxAggregateInputType
  }

  export type KunjunganGroupByOutputType = {
    id: string
    tenantId: string
    santriId: string
    scheduledAt: Date
    slot: string
    visitorLimit: number
    status: string
    createdAt: Date
    updatedAt: Date
    _count: KunjunganCountAggregateOutputType | null
    _avg: KunjunganAvgAggregateOutputType | null
    _sum: KunjunganSumAggregateOutputType | null
    _min: KunjunganMinAggregateOutputType | null
    _max: KunjunganMaxAggregateOutputType | null
  }

  type GetKunjunganGroupByPayload<T extends KunjunganGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<KunjunganGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof KunjunganGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], KunjunganGroupByOutputType[P]>
            : GetScalarType<T[P], KunjunganGroupByOutputType[P]>
        }
      >
    >


  export type KunjunganSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    santriId?: boolean
    scheduledAt?: boolean
    slot?: boolean
    visitorLimit?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    santri?: boolean | SantriDefaultArgs<ExtArgs>
    tamu?: boolean | Kunjungan$tamuArgs<ExtArgs>
    _count?: boolean | KunjunganCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["kunjungan"]>

  export type KunjunganSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    santriId?: boolean
    scheduledAt?: boolean
    slot?: boolean
    visitorLimit?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    santri?: boolean | SantriDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["kunjungan"]>

  export type KunjunganSelectScalar = {
    id?: boolean
    tenantId?: boolean
    santriId?: boolean
    scheduledAt?: boolean
    slot?: boolean
    visitorLimit?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type KunjunganInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    santri?: boolean | SantriDefaultArgs<ExtArgs>
    tamu?: boolean | Kunjungan$tamuArgs<ExtArgs>
    _count?: boolean | KunjunganCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type KunjunganIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    santri?: boolean | SantriDefaultArgs<ExtArgs>
  }

  export type $KunjunganPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Kunjungan"
    objects: {
      tenant: Prisma.$TenantPayload<ExtArgs>
      santri: Prisma.$SantriPayload<ExtArgs>
      tamu: Prisma.$TamuPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      tenantId: string
      santriId: string
      scheduledAt: Date
      slot: string
      visitorLimit: number
      status: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["kunjungan"]>
    composites: {}
  }

  type KunjunganGetPayload<S extends boolean | null | undefined | KunjunganDefaultArgs> = $Result.GetResult<Prisma.$KunjunganPayload, S>

  type KunjunganCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<KunjunganFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: KunjunganCountAggregateInputType | true
    }

  export interface KunjunganDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Kunjungan'], meta: { name: 'Kunjungan' } }
    /**
     * Find zero or one Kunjungan that matches the filter.
     * @param {KunjunganFindUniqueArgs} args - Arguments to find a Kunjungan
     * @example
     * // Get one Kunjungan
     * const kunjungan = await prisma.kunjungan.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends KunjunganFindUniqueArgs>(args: SelectSubset<T, KunjunganFindUniqueArgs<ExtArgs>>): Prisma__KunjunganClient<$Result.GetResult<Prisma.$KunjunganPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Kunjungan that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {KunjunganFindUniqueOrThrowArgs} args - Arguments to find a Kunjungan
     * @example
     * // Get one Kunjungan
     * const kunjungan = await prisma.kunjungan.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends KunjunganFindUniqueOrThrowArgs>(args: SelectSubset<T, KunjunganFindUniqueOrThrowArgs<ExtArgs>>): Prisma__KunjunganClient<$Result.GetResult<Prisma.$KunjunganPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Kunjungan that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KunjunganFindFirstArgs} args - Arguments to find a Kunjungan
     * @example
     * // Get one Kunjungan
     * const kunjungan = await prisma.kunjungan.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends KunjunganFindFirstArgs>(args?: SelectSubset<T, KunjunganFindFirstArgs<ExtArgs>>): Prisma__KunjunganClient<$Result.GetResult<Prisma.$KunjunganPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Kunjungan that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KunjunganFindFirstOrThrowArgs} args - Arguments to find a Kunjungan
     * @example
     * // Get one Kunjungan
     * const kunjungan = await prisma.kunjungan.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends KunjunganFindFirstOrThrowArgs>(args?: SelectSubset<T, KunjunganFindFirstOrThrowArgs<ExtArgs>>): Prisma__KunjunganClient<$Result.GetResult<Prisma.$KunjunganPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Kunjungans that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KunjunganFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Kunjungans
     * const kunjungans = await prisma.kunjungan.findMany()
     * 
     * // Get first 10 Kunjungans
     * const kunjungans = await prisma.kunjungan.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const kunjunganWithIdOnly = await prisma.kunjungan.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends KunjunganFindManyArgs>(args?: SelectSubset<T, KunjunganFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$KunjunganPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Kunjungan.
     * @param {KunjunganCreateArgs} args - Arguments to create a Kunjungan.
     * @example
     * // Create one Kunjungan
     * const Kunjungan = await prisma.kunjungan.create({
     *   data: {
     *     // ... data to create a Kunjungan
     *   }
     * })
     * 
     */
    create<T extends KunjunganCreateArgs>(args: SelectSubset<T, KunjunganCreateArgs<ExtArgs>>): Prisma__KunjunganClient<$Result.GetResult<Prisma.$KunjunganPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Kunjungans.
     * @param {KunjunganCreateManyArgs} args - Arguments to create many Kunjungans.
     * @example
     * // Create many Kunjungans
     * const kunjungan = await prisma.kunjungan.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends KunjunganCreateManyArgs>(args?: SelectSubset<T, KunjunganCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Kunjungans and returns the data saved in the database.
     * @param {KunjunganCreateManyAndReturnArgs} args - Arguments to create many Kunjungans.
     * @example
     * // Create many Kunjungans
     * const kunjungan = await prisma.kunjungan.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Kunjungans and only return the `id`
     * const kunjunganWithIdOnly = await prisma.kunjungan.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends KunjunganCreateManyAndReturnArgs>(args?: SelectSubset<T, KunjunganCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$KunjunganPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Kunjungan.
     * @param {KunjunganDeleteArgs} args - Arguments to delete one Kunjungan.
     * @example
     * // Delete one Kunjungan
     * const Kunjungan = await prisma.kunjungan.delete({
     *   where: {
     *     // ... filter to delete one Kunjungan
     *   }
     * })
     * 
     */
    delete<T extends KunjunganDeleteArgs>(args: SelectSubset<T, KunjunganDeleteArgs<ExtArgs>>): Prisma__KunjunganClient<$Result.GetResult<Prisma.$KunjunganPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Kunjungan.
     * @param {KunjunganUpdateArgs} args - Arguments to update one Kunjungan.
     * @example
     * // Update one Kunjungan
     * const kunjungan = await prisma.kunjungan.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends KunjunganUpdateArgs>(args: SelectSubset<T, KunjunganUpdateArgs<ExtArgs>>): Prisma__KunjunganClient<$Result.GetResult<Prisma.$KunjunganPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Kunjungans.
     * @param {KunjunganDeleteManyArgs} args - Arguments to filter Kunjungans to delete.
     * @example
     * // Delete a few Kunjungans
     * const { count } = await prisma.kunjungan.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends KunjunganDeleteManyArgs>(args?: SelectSubset<T, KunjunganDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Kunjungans.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KunjunganUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Kunjungans
     * const kunjungan = await prisma.kunjungan.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends KunjunganUpdateManyArgs>(args: SelectSubset<T, KunjunganUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Kunjungan.
     * @param {KunjunganUpsertArgs} args - Arguments to update or create a Kunjungan.
     * @example
     * // Update or create a Kunjungan
     * const kunjungan = await prisma.kunjungan.upsert({
     *   create: {
     *     // ... data to create a Kunjungan
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Kunjungan we want to update
     *   }
     * })
     */
    upsert<T extends KunjunganUpsertArgs>(args: SelectSubset<T, KunjunganUpsertArgs<ExtArgs>>): Prisma__KunjunganClient<$Result.GetResult<Prisma.$KunjunganPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Kunjungans.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KunjunganCountArgs} args - Arguments to filter Kunjungans to count.
     * @example
     * // Count the number of Kunjungans
     * const count = await prisma.kunjungan.count({
     *   where: {
     *     // ... the filter for the Kunjungans we want to count
     *   }
     * })
    **/
    count<T extends KunjunganCountArgs>(
      args?: Subset<T, KunjunganCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], KunjunganCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Kunjungan.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KunjunganAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends KunjunganAggregateArgs>(args: Subset<T, KunjunganAggregateArgs>): Prisma.PrismaPromise<GetKunjunganAggregateType<T>>

    /**
     * Group by Kunjungan.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KunjunganGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends KunjunganGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: KunjunganGroupByArgs['orderBy'] }
        : { orderBy?: KunjunganGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, KunjunganGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetKunjunganGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Kunjungan model
   */
  readonly fields: KunjunganFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Kunjungan.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__KunjunganClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    tenant<T extends TenantDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TenantDefaultArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    santri<T extends SantriDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SantriDefaultArgs<ExtArgs>>): Prisma__SantriClient<$Result.GetResult<Prisma.$SantriPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    tamu<T extends Kunjungan$tamuArgs<ExtArgs> = {}>(args?: Subset<T, Kunjungan$tamuArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TamuPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Kunjungan model
   */ 
  interface KunjunganFieldRefs {
    readonly id: FieldRef<"Kunjungan", 'String'>
    readonly tenantId: FieldRef<"Kunjungan", 'String'>
    readonly santriId: FieldRef<"Kunjungan", 'String'>
    readonly scheduledAt: FieldRef<"Kunjungan", 'DateTime'>
    readonly slot: FieldRef<"Kunjungan", 'String'>
    readonly visitorLimit: FieldRef<"Kunjungan", 'Int'>
    readonly status: FieldRef<"Kunjungan", 'String'>
    readonly createdAt: FieldRef<"Kunjungan", 'DateTime'>
    readonly updatedAt: FieldRef<"Kunjungan", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Kunjungan findUnique
   */
  export type KunjunganFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Kunjungan
     */
    select?: KunjunganSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KunjunganInclude<ExtArgs> | null
    /**
     * Filter, which Kunjungan to fetch.
     */
    where: KunjunganWhereUniqueInput
  }

  /**
   * Kunjungan findUniqueOrThrow
   */
  export type KunjunganFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Kunjungan
     */
    select?: KunjunganSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KunjunganInclude<ExtArgs> | null
    /**
     * Filter, which Kunjungan to fetch.
     */
    where: KunjunganWhereUniqueInput
  }

  /**
   * Kunjungan findFirst
   */
  export type KunjunganFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Kunjungan
     */
    select?: KunjunganSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KunjunganInclude<ExtArgs> | null
    /**
     * Filter, which Kunjungan to fetch.
     */
    where?: KunjunganWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Kunjungans to fetch.
     */
    orderBy?: KunjunganOrderByWithRelationInput | KunjunganOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Kunjungans.
     */
    cursor?: KunjunganWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Kunjungans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Kunjungans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Kunjungans.
     */
    distinct?: KunjunganScalarFieldEnum | KunjunganScalarFieldEnum[]
  }

  /**
   * Kunjungan findFirstOrThrow
   */
  export type KunjunganFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Kunjungan
     */
    select?: KunjunganSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KunjunganInclude<ExtArgs> | null
    /**
     * Filter, which Kunjungan to fetch.
     */
    where?: KunjunganWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Kunjungans to fetch.
     */
    orderBy?: KunjunganOrderByWithRelationInput | KunjunganOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Kunjungans.
     */
    cursor?: KunjunganWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Kunjungans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Kunjungans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Kunjungans.
     */
    distinct?: KunjunganScalarFieldEnum | KunjunganScalarFieldEnum[]
  }

  /**
   * Kunjungan findMany
   */
  export type KunjunganFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Kunjungan
     */
    select?: KunjunganSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KunjunganInclude<ExtArgs> | null
    /**
     * Filter, which Kunjungans to fetch.
     */
    where?: KunjunganWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Kunjungans to fetch.
     */
    orderBy?: KunjunganOrderByWithRelationInput | KunjunganOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Kunjungans.
     */
    cursor?: KunjunganWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Kunjungans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Kunjungans.
     */
    skip?: number
    distinct?: KunjunganScalarFieldEnum | KunjunganScalarFieldEnum[]
  }

  /**
   * Kunjungan create
   */
  export type KunjunganCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Kunjungan
     */
    select?: KunjunganSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KunjunganInclude<ExtArgs> | null
    /**
     * The data needed to create a Kunjungan.
     */
    data: XOR<KunjunganCreateInput, KunjunganUncheckedCreateInput>
  }

  /**
   * Kunjungan createMany
   */
  export type KunjunganCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Kunjungans.
     */
    data: KunjunganCreateManyInput | KunjunganCreateManyInput[]
  }

  /**
   * Kunjungan createManyAndReturn
   */
  export type KunjunganCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Kunjungan
     */
    select?: KunjunganSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Kunjungans.
     */
    data: KunjunganCreateManyInput | KunjunganCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KunjunganIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Kunjungan update
   */
  export type KunjunganUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Kunjungan
     */
    select?: KunjunganSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KunjunganInclude<ExtArgs> | null
    /**
     * The data needed to update a Kunjungan.
     */
    data: XOR<KunjunganUpdateInput, KunjunganUncheckedUpdateInput>
    /**
     * Choose, which Kunjungan to update.
     */
    where: KunjunganWhereUniqueInput
  }

  /**
   * Kunjungan updateMany
   */
  export type KunjunganUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Kunjungans.
     */
    data: XOR<KunjunganUpdateManyMutationInput, KunjunganUncheckedUpdateManyInput>
    /**
     * Filter which Kunjungans to update
     */
    where?: KunjunganWhereInput
  }

  /**
   * Kunjungan upsert
   */
  export type KunjunganUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Kunjungan
     */
    select?: KunjunganSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KunjunganInclude<ExtArgs> | null
    /**
     * The filter to search for the Kunjungan to update in case it exists.
     */
    where: KunjunganWhereUniqueInput
    /**
     * In case the Kunjungan found by the `where` argument doesn't exist, create a new Kunjungan with this data.
     */
    create: XOR<KunjunganCreateInput, KunjunganUncheckedCreateInput>
    /**
     * In case the Kunjungan was found with the provided `where` argument, update it with this data.
     */
    update: XOR<KunjunganUpdateInput, KunjunganUncheckedUpdateInput>
  }

  /**
   * Kunjungan delete
   */
  export type KunjunganDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Kunjungan
     */
    select?: KunjunganSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KunjunganInclude<ExtArgs> | null
    /**
     * Filter which Kunjungan to delete.
     */
    where: KunjunganWhereUniqueInput
  }

  /**
   * Kunjungan deleteMany
   */
  export type KunjunganDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Kunjungans to delete
     */
    where?: KunjunganWhereInput
  }

  /**
   * Kunjungan.tamu
   */
  export type Kunjungan$tamuArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tamu
     */
    select?: TamuSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TamuInclude<ExtArgs> | null
    where?: TamuWhereInput
    orderBy?: TamuOrderByWithRelationInput | TamuOrderByWithRelationInput[]
    cursor?: TamuWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TamuScalarFieldEnum | TamuScalarFieldEnum[]
  }

  /**
   * Kunjungan without action
   */
  export type KunjunganDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Kunjungan
     */
    select?: KunjunganSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KunjunganInclude<ExtArgs> | null
  }


  /**
   * Model Tamu
   */

  export type AggregateTamu = {
    _count: TamuCountAggregateOutputType | null
    _min: TamuMinAggregateOutputType | null
    _max: TamuMaxAggregateOutputType | null
  }

  export type TamuMinAggregateOutputType = {
    id: string | null
    kunjunganId: string | null
    name: string | null
    phone: string | null
    idNumber: string | null
    checkinAt: Date | null
    createdAt: Date | null
  }

  export type TamuMaxAggregateOutputType = {
    id: string | null
    kunjunganId: string | null
    name: string | null
    phone: string | null
    idNumber: string | null
    checkinAt: Date | null
    createdAt: Date | null
  }

  export type TamuCountAggregateOutputType = {
    id: number
    kunjunganId: number
    name: number
    phone: number
    idNumber: number
    checkinAt: number
    createdAt: number
    _all: number
  }


  export type TamuMinAggregateInputType = {
    id?: true
    kunjunganId?: true
    name?: true
    phone?: true
    idNumber?: true
    checkinAt?: true
    createdAt?: true
  }

  export type TamuMaxAggregateInputType = {
    id?: true
    kunjunganId?: true
    name?: true
    phone?: true
    idNumber?: true
    checkinAt?: true
    createdAt?: true
  }

  export type TamuCountAggregateInputType = {
    id?: true
    kunjunganId?: true
    name?: true
    phone?: true
    idNumber?: true
    checkinAt?: true
    createdAt?: true
    _all?: true
  }

  export type TamuAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Tamu to aggregate.
     */
    where?: TamuWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tamus to fetch.
     */
    orderBy?: TamuOrderByWithRelationInput | TamuOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TamuWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tamus from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tamus.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Tamus
    **/
    _count?: true | TamuCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TamuMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TamuMaxAggregateInputType
  }

  export type GetTamuAggregateType<T extends TamuAggregateArgs> = {
        [P in keyof T & keyof AggregateTamu]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTamu[P]>
      : GetScalarType<T[P], AggregateTamu[P]>
  }




  export type TamuGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TamuWhereInput
    orderBy?: TamuOrderByWithAggregationInput | TamuOrderByWithAggregationInput[]
    by: TamuScalarFieldEnum[] | TamuScalarFieldEnum
    having?: TamuScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TamuCountAggregateInputType | true
    _min?: TamuMinAggregateInputType
    _max?: TamuMaxAggregateInputType
  }

  export type TamuGroupByOutputType = {
    id: string
    kunjunganId: string
    name: string
    phone: string | null
    idNumber: string | null
    checkinAt: Date | null
    createdAt: Date
    _count: TamuCountAggregateOutputType | null
    _min: TamuMinAggregateOutputType | null
    _max: TamuMaxAggregateOutputType | null
  }

  type GetTamuGroupByPayload<T extends TamuGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TamuGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TamuGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TamuGroupByOutputType[P]>
            : GetScalarType<T[P], TamuGroupByOutputType[P]>
        }
      >
    >


  export type TamuSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    kunjunganId?: boolean
    name?: boolean
    phone?: boolean
    idNumber?: boolean
    checkinAt?: boolean
    createdAt?: boolean
    kunjungan?: boolean | KunjunganDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tamu"]>

  export type TamuSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    kunjunganId?: boolean
    name?: boolean
    phone?: boolean
    idNumber?: boolean
    checkinAt?: boolean
    createdAt?: boolean
    kunjungan?: boolean | KunjunganDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tamu"]>

  export type TamuSelectScalar = {
    id?: boolean
    kunjunganId?: boolean
    name?: boolean
    phone?: boolean
    idNumber?: boolean
    checkinAt?: boolean
    createdAt?: boolean
  }

  export type TamuInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    kunjungan?: boolean | KunjunganDefaultArgs<ExtArgs>
  }
  export type TamuIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    kunjungan?: boolean | KunjunganDefaultArgs<ExtArgs>
  }

  export type $TamuPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Tamu"
    objects: {
      kunjungan: Prisma.$KunjunganPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      kunjunganId: string
      name: string
      phone: string | null
      idNumber: string | null
      checkinAt: Date | null
      createdAt: Date
    }, ExtArgs["result"]["tamu"]>
    composites: {}
  }

  type TamuGetPayload<S extends boolean | null | undefined | TamuDefaultArgs> = $Result.GetResult<Prisma.$TamuPayload, S>

  type TamuCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<TamuFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: TamuCountAggregateInputType | true
    }

  export interface TamuDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Tamu'], meta: { name: 'Tamu' } }
    /**
     * Find zero or one Tamu that matches the filter.
     * @param {TamuFindUniqueArgs} args - Arguments to find a Tamu
     * @example
     * // Get one Tamu
     * const tamu = await prisma.tamu.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TamuFindUniqueArgs>(args: SelectSubset<T, TamuFindUniqueArgs<ExtArgs>>): Prisma__TamuClient<$Result.GetResult<Prisma.$TamuPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Tamu that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {TamuFindUniqueOrThrowArgs} args - Arguments to find a Tamu
     * @example
     * // Get one Tamu
     * const tamu = await prisma.tamu.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TamuFindUniqueOrThrowArgs>(args: SelectSubset<T, TamuFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TamuClient<$Result.GetResult<Prisma.$TamuPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Tamu that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TamuFindFirstArgs} args - Arguments to find a Tamu
     * @example
     * // Get one Tamu
     * const tamu = await prisma.tamu.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TamuFindFirstArgs>(args?: SelectSubset<T, TamuFindFirstArgs<ExtArgs>>): Prisma__TamuClient<$Result.GetResult<Prisma.$TamuPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Tamu that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TamuFindFirstOrThrowArgs} args - Arguments to find a Tamu
     * @example
     * // Get one Tamu
     * const tamu = await prisma.tamu.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TamuFindFirstOrThrowArgs>(args?: SelectSubset<T, TamuFindFirstOrThrowArgs<ExtArgs>>): Prisma__TamuClient<$Result.GetResult<Prisma.$TamuPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Tamus that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TamuFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Tamus
     * const tamus = await prisma.tamu.findMany()
     * 
     * // Get first 10 Tamus
     * const tamus = await prisma.tamu.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const tamuWithIdOnly = await prisma.tamu.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TamuFindManyArgs>(args?: SelectSubset<T, TamuFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TamuPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Tamu.
     * @param {TamuCreateArgs} args - Arguments to create a Tamu.
     * @example
     * // Create one Tamu
     * const Tamu = await prisma.tamu.create({
     *   data: {
     *     // ... data to create a Tamu
     *   }
     * })
     * 
     */
    create<T extends TamuCreateArgs>(args: SelectSubset<T, TamuCreateArgs<ExtArgs>>): Prisma__TamuClient<$Result.GetResult<Prisma.$TamuPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Tamus.
     * @param {TamuCreateManyArgs} args - Arguments to create many Tamus.
     * @example
     * // Create many Tamus
     * const tamu = await prisma.tamu.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TamuCreateManyArgs>(args?: SelectSubset<T, TamuCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Tamus and returns the data saved in the database.
     * @param {TamuCreateManyAndReturnArgs} args - Arguments to create many Tamus.
     * @example
     * // Create many Tamus
     * const tamu = await prisma.tamu.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Tamus and only return the `id`
     * const tamuWithIdOnly = await prisma.tamu.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TamuCreateManyAndReturnArgs>(args?: SelectSubset<T, TamuCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TamuPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Tamu.
     * @param {TamuDeleteArgs} args - Arguments to delete one Tamu.
     * @example
     * // Delete one Tamu
     * const Tamu = await prisma.tamu.delete({
     *   where: {
     *     // ... filter to delete one Tamu
     *   }
     * })
     * 
     */
    delete<T extends TamuDeleteArgs>(args: SelectSubset<T, TamuDeleteArgs<ExtArgs>>): Prisma__TamuClient<$Result.GetResult<Prisma.$TamuPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Tamu.
     * @param {TamuUpdateArgs} args - Arguments to update one Tamu.
     * @example
     * // Update one Tamu
     * const tamu = await prisma.tamu.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TamuUpdateArgs>(args: SelectSubset<T, TamuUpdateArgs<ExtArgs>>): Prisma__TamuClient<$Result.GetResult<Prisma.$TamuPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Tamus.
     * @param {TamuDeleteManyArgs} args - Arguments to filter Tamus to delete.
     * @example
     * // Delete a few Tamus
     * const { count } = await prisma.tamu.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TamuDeleteManyArgs>(args?: SelectSubset<T, TamuDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tamus.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TamuUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Tamus
     * const tamu = await prisma.tamu.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TamuUpdateManyArgs>(args: SelectSubset<T, TamuUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Tamu.
     * @param {TamuUpsertArgs} args - Arguments to update or create a Tamu.
     * @example
     * // Update or create a Tamu
     * const tamu = await prisma.tamu.upsert({
     *   create: {
     *     // ... data to create a Tamu
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Tamu we want to update
     *   }
     * })
     */
    upsert<T extends TamuUpsertArgs>(args: SelectSubset<T, TamuUpsertArgs<ExtArgs>>): Prisma__TamuClient<$Result.GetResult<Prisma.$TamuPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Tamus.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TamuCountArgs} args - Arguments to filter Tamus to count.
     * @example
     * // Count the number of Tamus
     * const count = await prisma.tamu.count({
     *   where: {
     *     // ... the filter for the Tamus we want to count
     *   }
     * })
    **/
    count<T extends TamuCountArgs>(
      args?: Subset<T, TamuCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TamuCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Tamu.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TamuAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TamuAggregateArgs>(args: Subset<T, TamuAggregateArgs>): Prisma.PrismaPromise<GetTamuAggregateType<T>>

    /**
     * Group by Tamu.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TamuGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TamuGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TamuGroupByArgs['orderBy'] }
        : { orderBy?: TamuGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TamuGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTamuGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Tamu model
   */
  readonly fields: TamuFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Tamu.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TamuClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    kunjungan<T extends KunjunganDefaultArgs<ExtArgs> = {}>(args?: Subset<T, KunjunganDefaultArgs<ExtArgs>>): Prisma__KunjunganClient<$Result.GetResult<Prisma.$KunjunganPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Tamu model
   */ 
  interface TamuFieldRefs {
    readonly id: FieldRef<"Tamu", 'String'>
    readonly kunjunganId: FieldRef<"Tamu", 'String'>
    readonly name: FieldRef<"Tamu", 'String'>
    readonly phone: FieldRef<"Tamu", 'String'>
    readonly idNumber: FieldRef<"Tamu", 'String'>
    readonly checkinAt: FieldRef<"Tamu", 'DateTime'>
    readonly createdAt: FieldRef<"Tamu", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Tamu findUnique
   */
  export type TamuFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tamu
     */
    select?: TamuSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TamuInclude<ExtArgs> | null
    /**
     * Filter, which Tamu to fetch.
     */
    where: TamuWhereUniqueInput
  }

  /**
   * Tamu findUniqueOrThrow
   */
  export type TamuFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tamu
     */
    select?: TamuSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TamuInclude<ExtArgs> | null
    /**
     * Filter, which Tamu to fetch.
     */
    where: TamuWhereUniqueInput
  }

  /**
   * Tamu findFirst
   */
  export type TamuFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tamu
     */
    select?: TamuSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TamuInclude<ExtArgs> | null
    /**
     * Filter, which Tamu to fetch.
     */
    where?: TamuWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tamus to fetch.
     */
    orderBy?: TamuOrderByWithRelationInput | TamuOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tamus.
     */
    cursor?: TamuWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tamus from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tamus.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tamus.
     */
    distinct?: TamuScalarFieldEnum | TamuScalarFieldEnum[]
  }

  /**
   * Tamu findFirstOrThrow
   */
  export type TamuFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tamu
     */
    select?: TamuSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TamuInclude<ExtArgs> | null
    /**
     * Filter, which Tamu to fetch.
     */
    where?: TamuWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tamus to fetch.
     */
    orderBy?: TamuOrderByWithRelationInput | TamuOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tamus.
     */
    cursor?: TamuWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tamus from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tamus.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tamus.
     */
    distinct?: TamuScalarFieldEnum | TamuScalarFieldEnum[]
  }

  /**
   * Tamu findMany
   */
  export type TamuFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tamu
     */
    select?: TamuSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TamuInclude<ExtArgs> | null
    /**
     * Filter, which Tamus to fetch.
     */
    where?: TamuWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tamus to fetch.
     */
    orderBy?: TamuOrderByWithRelationInput | TamuOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Tamus.
     */
    cursor?: TamuWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tamus from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tamus.
     */
    skip?: number
    distinct?: TamuScalarFieldEnum | TamuScalarFieldEnum[]
  }

  /**
   * Tamu create
   */
  export type TamuCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tamu
     */
    select?: TamuSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TamuInclude<ExtArgs> | null
    /**
     * The data needed to create a Tamu.
     */
    data: XOR<TamuCreateInput, TamuUncheckedCreateInput>
  }

  /**
   * Tamu createMany
   */
  export type TamuCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Tamus.
     */
    data: TamuCreateManyInput | TamuCreateManyInput[]
  }

  /**
   * Tamu createManyAndReturn
   */
  export type TamuCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tamu
     */
    select?: TamuSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Tamus.
     */
    data: TamuCreateManyInput | TamuCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TamuIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Tamu update
   */
  export type TamuUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tamu
     */
    select?: TamuSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TamuInclude<ExtArgs> | null
    /**
     * The data needed to update a Tamu.
     */
    data: XOR<TamuUpdateInput, TamuUncheckedUpdateInput>
    /**
     * Choose, which Tamu to update.
     */
    where: TamuWhereUniqueInput
  }

  /**
   * Tamu updateMany
   */
  export type TamuUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Tamus.
     */
    data: XOR<TamuUpdateManyMutationInput, TamuUncheckedUpdateManyInput>
    /**
     * Filter which Tamus to update
     */
    where?: TamuWhereInput
  }

  /**
   * Tamu upsert
   */
  export type TamuUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tamu
     */
    select?: TamuSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TamuInclude<ExtArgs> | null
    /**
     * The filter to search for the Tamu to update in case it exists.
     */
    where: TamuWhereUniqueInput
    /**
     * In case the Tamu found by the `where` argument doesn't exist, create a new Tamu with this data.
     */
    create: XOR<TamuCreateInput, TamuUncheckedCreateInput>
    /**
     * In case the Tamu was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TamuUpdateInput, TamuUncheckedUpdateInput>
  }

  /**
   * Tamu delete
   */
  export type TamuDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tamu
     */
    select?: TamuSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TamuInclude<ExtArgs> | null
    /**
     * Filter which Tamu to delete.
     */
    where: TamuWhereUniqueInput
  }

  /**
   * Tamu deleteMany
   */
  export type TamuDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Tamus to delete
     */
    where?: TamuWhereInput
  }

  /**
   * Tamu without action
   */
  export type TamuDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tamu
     */
    select?: TamuSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TamuInclude<ExtArgs> | null
  }


  /**
   * Model HealthRecord
   */

  export type AggregateHealthRecord = {
    _count: HealthRecordCountAggregateOutputType | null
    _min: HealthRecordMinAggregateOutputType | null
    _max: HealthRecordMaxAggregateOutputType | null
  }

  export type HealthRecordMinAggregateOutputType = {
    id: string | null
    tenantId: string | null
    santriId: string | null
    recordedBy: string | null
    symptoms: string | null
    diagnosis: string | null
    actionTaken: string | null
    referred: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type HealthRecordMaxAggregateOutputType = {
    id: string | null
    tenantId: string | null
    santriId: string | null
    recordedBy: string | null
    symptoms: string | null
    diagnosis: string | null
    actionTaken: string | null
    referred: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type HealthRecordCountAggregateOutputType = {
    id: number
    tenantId: number
    santriId: number
    recordedBy: number
    symptoms: number
    diagnosis: number
    actionTaken: number
    referred: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type HealthRecordMinAggregateInputType = {
    id?: true
    tenantId?: true
    santriId?: true
    recordedBy?: true
    symptoms?: true
    diagnosis?: true
    actionTaken?: true
    referred?: true
    createdAt?: true
    updatedAt?: true
  }

  export type HealthRecordMaxAggregateInputType = {
    id?: true
    tenantId?: true
    santriId?: true
    recordedBy?: true
    symptoms?: true
    diagnosis?: true
    actionTaken?: true
    referred?: true
    createdAt?: true
    updatedAt?: true
  }

  export type HealthRecordCountAggregateInputType = {
    id?: true
    tenantId?: true
    santriId?: true
    recordedBy?: true
    symptoms?: true
    diagnosis?: true
    actionTaken?: true
    referred?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type HealthRecordAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which HealthRecord to aggregate.
     */
    where?: HealthRecordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HealthRecords to fetch.
     */
    orderBy?: HealthRecordOrderByWithRelationInput | HealthRecordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: HealthRecordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HealthRecords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HealthRecords.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned HealthRecords
    **/
    _count?: true | HealthRecordCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: HealthRecordMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: HealthRecordMaxAggregateInputType
  }

  export type GetHealthRecordAggregateType<T extends HealthRecordAggregateArgs> = {
        [P in keyof T & keyof AggregateHealthRecord]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateHealthRecord[P]>
      : GetScalarType<T[P], AggregateHealthRecord[P]>
  }




  export type HealthRecordGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: HealthRecordWhereInput
    orderBy?: HealthRecordOrderByWithAggregationInput | HealthRecordOrderByWithAggregationInput[]
    by: HealthRecordScalarFieldEnum[] | HealthRecordScalarFieldEnum
    having?: HealthRecordScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: HealthRecordCountAggregateInputType | true
    _min?: HealthRecordMinAggregateInputType
    _max?: HealthRecordMaxAggregateInputType
  }

  export type HealthRecordGroupByOutputType = {
    id: string
    tenantId: string
    santriId: string
    recordedBy: string
    symptoms: string
    diagnosis: string | null
    actionTaken: string | null
    referred: boolean
    createdAt: Date
    updatedAt: Date
    _count: HealthRecordCountAggregateOutputType | null
    _min: HealthRecordMinAggregateOutputType | null
    _max: HealthRecordMaxAggregateOutputType | null
  }

  type GetHealthRecordGroupByPayload<T extends HealthRecordGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<HealthRecordGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof HealthRecordGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], HealthRecordGroupByOutputType[P]>
            : GetScalarType<T[P], HealthRecordGroupByOutputType[P]>
        }
      >
    >


  export type HealthRecordSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    santriId?: boolean
    recordedBy?: boolean
    symptoms?: boolean
    diagnosis?: boolean
    actionTaken?: boolean
    referred?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    santri?: boolean | SantriDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["healthRecord"]>

  export type HealthRecordSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    santriId?: boolean
    recordedBy?: boolean
    symptoms?: boolean
    diagnosis?: boolean
    actionTaken?: boolean
    referred?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    santri?: boolean | SantriDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["healthRecord"]>

  export type HealthRecordSelectScalar = {
    id?: boolean
    tenantId?: boolean
    santriId?: boolean
    recordedBy?: boolean
    symptoms?: boolean
    diagnosis?: boolean
    actionTaken?: boolean
    referred?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type HealthRecordInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    santri?: boolean | SantriDefaultArgs<ExtArgs>
  }
  export type HealthRecordIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    santri?: boolean | SantriDefaultArgs<ExtArgs>
  }

  export type $HealthRecordPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "HealthRecord"
    objects: {
      tenant: Prisma.$TenantPayload<ExtArgs>
      santri: Prisma.$SantriPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      tenantId: string
      santriId: string
      recordedBy: string
      symptoms: string
      diagnosis: string | null
      actionTaken: string | null
      referred: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["healthRecord"]>
    composites: {}
  }

  type HealthRecordGetPayload<S extends boolean | null | undefined | HealthRecordDefaultArgs> = $Result.GetResult<Prisma.$HealthRecordPayload, S>

  type HealthRecordCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<HealthRecordFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: HealthRecordCountAggregateInputType | true
    }

  export interface HealthRecordDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['HealthRecord'], meta: { name: 'HealthRecord' } }
    /**
     * Find zero or one HealthRecord that matches the filter.
     * @param {HealthRecordFindUniqueArgs} args - Arguments to find a HealthRecord
     * @example
     * // Get one HealthRecord
     * const healthRecord = await prisma.healthRecord.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends HealthRecordFindUniqueArgs>(args: SelectSubset<T, HealthRecordFindUniqueArgs<ExtArgs>>): Prisma__HealthRecordClient<$Result.GetResult<Prisma.$HealthRecordPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one HealthRecord that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {HealthRecordFindUniqueOrThrowArgs} args - Arguments to find a HealthRecord
     * @example
     * // Get one HealthRecord
     * const healthRecord = await prisma.healthRecord.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends HealthRecordFindUniqueOrThrowArgs>(args: SelectSubset<T, HealthRecordFindUniqueOrThrowArgs<ExtArgs>>): Prisma__HealthRecordClient<$Result.GetResult<Prisma.$HealthRecordPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first HealthRecord that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HealthRecordFindFirstArgs} args - Arguments to find a HealthRecord
     * @example
     * // Get one HealthRecord
     * const healthRecord = await prisma.healthRecord.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends HealthRecordFindFirstArgs>(args?: SelectSubset<T, HealthRecordFindFirstArgs<ExtArgs>>): Prisma__HealthRecordClient<$Result.GetResult<Prisma.$HealthRecordPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first HealthRecord that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HealthRecordFindFirstOrThrowArgs} args - Arguments to find a HealthRecord
     * @example
     * // Get one HealthRecord
     * const healthRecord = await prisma.healthRecord.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends HealthRecordFindFirstOrThrowArgs>(args?: SelectSubset<T, HealthRecordFindFirstOrThrowArgs<ExtArgs>>): Prisma__HealthRecordClient<$Result.GetResult<Prisma.$HealthRecordPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more HealthRecords that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HealthRecordFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all HealthRecords
     * const healthRecords = await prisma.healthRecord.findMany()
     * 
     * // Get first 10 HealthRecords
     * const healthRecords = await prisma.healthRecord.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const healthRecordWithIdOnly = await prisma.healthRecord.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends HealthRecordFindManyArgs>(args?: SelectSubset<T, HealthRecordFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HealthRecordPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a HealthRecord.
     * @param {HealthRecordCreateArgs} args - Arguments to create a HealthRecord.
     * @example
     * // Create one HealthRecord
     * const HealthRecord = await prisma.healthRecord.create({
     *   data: {
     *     // ... data to create a HealthRecord
     *   }
     * })
     * 
     */
    create<T extends HealthRecordCreateArgs>(args: SelectSubset<T, HealthRecordCreateArgs<ExtArgs>>): Prisma__HealthRecordClient<$Result.GetResult<Prisma.$HealthRecordPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many HealthRecords.
     * @param {HealthRecordCreateManyArgs} args - Arguments to create many HealthRecords.
     * @example
     * // Create many HealthRecords
     * const healthRecord = await prisma.healthRecord.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends HealthRecordCreateManyArgs>(args?: SelectSubset<T, HealthRecordCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many HealthRecords and returns the data saved in the database.
     * @param {HealthRecordCreateManyAndReturnArgs} args - Arguments to create many HealthRecords.
     * @example
     * // Create many HealthRecords
     * const healthRecord = await prisma.healthRecord.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many HealthRecords and only return the `id`
     * const healthRecordWithIdOnly = await prisma.healthRecord.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends HealthRecordCreateManyAndReturnArgs>(args?: SelectSubset<T, HealthRecordCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HealthRecordPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a HealthRecord.
     * @param {HealthRecordDeleteArgs} args - Arguments to delete one HealthRecord.
     * @example
     * // Delete one HealthRecord
     * const HealthRecord = await prisma.healthRecord.delete({
     *   where: {
     *     // ... filter to delete one HealthRecord
     *   }
     * })
     * 
     */
    delete<T extends HealthRecordDeleteArgs>(args: SelectSubset<T, HealthRecordDeleteArgs<ExtArgs>>): Prisma__HealthRecordClient<$Result.GetResult<Prisma.$HealthRecordPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one HealthRecord.
     * @param {HealthRecordUpdateArgs} args - Arguments to update one HealthRecord.
     * @example
     * // Update one HealthRecord
     * const healthRecord = await prisma.healthRecord.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends HealthRecordUpdateArgs>(args: SelectSubset<T, HealthRecordUpdateArgs<ExtArgs>>): Prisma__HealthRecordClient<$Result.GetResult<Prisma.$HealthRecordPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more HealthRecords.
     * @param {HealthRecordDeleteManyArgs} args - Arguments to filter HealthRecords to delete.
     * @example
     * // Delete a few HealthRecords
     * const { count } = await prisma.healthRecord.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends HealthRecordDeleteManyArgs>(args?: SelectSubset<T, HealthRecordDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more HealthRecords.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HealthRecordUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many HealthRecords
     * const healthRecord = await prisma.healthRecord.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends HealthRecordUpdateManyArgs>(args: SelectSubset<T, HealthRecordUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one HealthRecord.
     * @param {HealthRecordUpsertArgs} args - Arguments to update or create a HealthRecord.
     * @example
     * // Update or create a HealthRecord
     * const healthRecord = await prisma.healthRecord.upsert({
     *   create: {
     *     // ... data to create a HealthRecord
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the HealthRecord we want to update
     *   }
     * })
     */
    upsert<T extends HealthRecordUpsertArgs>(args: SelectSubset<T, HealthRecordUpsertArgs<ExtArgs>>): Prisma__HealthRecordClient<$Result.GetResult<Prisma.$HealthRecordPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of HealthRecords.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HealthRecordCountArgs} args - Arguments to filter HealthRecords to count.
     * @example
     * // Count the number of HealthRecords
     * const count = await prisma.healthRecord.count({
     *   where: {
     *     // ... the filter for the HealthRecords we want to count
     *   }
     * })
    **/
    count<T extends HealthRecordCountArgs>(
      args?: Subset<T, HealthRecordCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], HealthRecordCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a HealthRecord.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HealthRecordAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends HealthRecordAggregateArgs>(args: Subset<T, HealthRecordAggregateArgs>): Prisma.PrismaPromise<GetHealthRecordAggregateType<T>>

    /**
     * Group by HealthRecord.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HealthRecordGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends HealthRecordGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: HealthRecordGroupByArgs['orderBy'] }
        : { orderBy?: HealthRecordGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, HealthRecordGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetHealthRecordGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the HealthRecord model
   */
  readonly fields: HealthRecordFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for HealthRecord.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__HealthRecordClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    tenant<T extends TenantDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TenantDefaultArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    santri<T extends SantriDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SantriDefaultArgs<ExtArgs>>): Prisma__SantriClient<$Result.GetResult<Prisma.$SantriPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the HealthRecord model
   */ 
  interface HealthRecordFieldRefs {
    readonly id: FieldRef<"HealthRecord", 'String'>
    readonly tenantId: FieldRef<"HealthRecord", 'String'>
    readonly santriId: FieldRef<"HealthRecord", 'String'>
    readonly recordedBy: FieldRef<"HealthRecord", 'String'>
    readonly symptoms: FieldRef<"HealthRecord", 'String'>
    readonly diagnosis: FieldRef<"HealthRecord", 'String'>
    readonly actionTaken: FieldRef<"HealthRecord", 'String'>
    readonly referred: FieldRef<"HealthRecord", 'Boolean'>
    readonly createdAt: FieldRef<"HealthRecord", 'DateTime'>
    readonly updatedAt: FieldRef<"HealthRecord", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * HealthRecord findUnique
   */
  export type HealthRecordFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HealthRecord
     */
    select?: HealthRecordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HealthRecordInclude<ExtArgs> | null
    /**
     * Filter, which HealthRecord to fetch.
     */
    where: HealthRecordWhereUniqueInput
  }

  /**
   * HealthRecord findUniqueOrThrow
   */
  export type HealthRecordFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HealthRecord
     */
    select?: HealthRecordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HealthRecordInclude<ExtArgs> | null
    /**
     * Filter, which HealthRecord to fetch.
     */
    where: HealthRecordWhereUniqueInput
  }

  /**
   * HealthRecord findFirst
   */
  export type HealthRecordFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HealthRecord
     */
    select?: HealthRecordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HealthRecordInclude<ExtArgs> | null
    /**
     * Filter, which HealthRecord to fetch.
     */
    where?: HealthRecordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HealthRecords to fetch.
     */
    orderBy?: HealthRecordOrderByWithRelationInput | HealthRecordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for HealthRecords.
     */
    cursor?: HealthRecordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HealthRecords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HealthRecords.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of HealthRecords.
     */
    distinct?: HealthRecordScalarFieldEnum | HealthRecordScalarFieldEnum[]
  }

  /**
   * HealthRecord findFirstOrThrow
   */
  export type HealthRecordFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HealthRecord
     */
    select?: HealthRecordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HealthRecordInclude<ExtArgs> | null
    /**
     * Filter, which HealthRecord to fetch.
     */
    where?: HealthRecordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HealthRecords to fetch.
     */
    orderBy?: HealthRecordOrderByWithRelationInput | HealthRecordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for HealthRecords.
     */
    cursor?: HealthRecordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HealthRecords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HealthRecords.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of HealthRecords.
     */
    distinct?: HealthRecordScalarFieldEnum | HealthRecordScalarFieldEnum[]
  }

  /**
   * HealthRecord findMany
   */
  export type HealthRecordFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HealthRecord
     */
    select?: HealthRecordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HealthRecordInclude<ExtArgs> | null
    /**
     * Filter, which HealthRecords to fetch.
     */
    where?: HealthRecordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HealthRecords to fetch.
     */
    orderBy?: HealthRecordOrderByWithRelationInput | HealthRecordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing HealthRecords.
     */
    cursor?: HealthRecordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HealthRecords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HealthRecords.
     */
    skip?: number
    distinct?: HealthRecordScalarFieldEnum | HealthRecordScalarFieldEnum[]
  }

  /**
   * HealthRecord create
   */
  export type HealthRecordCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HealthRecord
     */
    select?: HealthRecordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HealthRecordInclude<ExtArgs> | null
    /**
     * The data needed to create a HealthRecord.
     */
    data: XOR<HealthRecordCreateInput, HealthRecordUncheckedCreateInput>
  }

  /**
   * HealthRecord createMany
   */
  export type HealthRecordCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many HealthRecords.
     */
    data: HealthRecordCreateManyInput | HealthRecordCreateManyInput[]
  }

  /**
   * HealthRecord createManyAndReturn
   */
  export type HealthRecordCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HealthRecord
     */
    select?: HealthRecordSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many HealthRecords.
     */
    data: HealthRecordCreateManyInput | HealthRecordCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HealthRecordIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * HealthRecord update
   */
  export type HealthRecordUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HealthRecord
     */
    select?: HealthRecordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HealthRecordInclude<ExtArgs> | null
    /**
     * The data needed to update a HealthRecord.
     */
    data: XOR<HealthRecordUpdateInput, HealthRecordUncheckedUpdateInput>
    /**
     * Choose, which HealthRecord to update.
     */
    where: HealthRecordWhereUniqueInput
  }

  /**
   * HealthRecord updateMany
   */
  export type HealthRecordUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update HealthRecords.
     */
    data: XOR<HealthRecordUpdateManyMutationInput, HealthRecordUncheckedUpdateManyInput>
    /**
     * Filter which HealthRecords to update
     */
    where?: HealthRecordWhereInput
  }

  /**
   * HealthRecord upsert
   */
  export type HealthRecordUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HealthRecord
     */
    select?: HealthRecordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HealthRecordInclude<ExtArgs> | null
    /**
     * The filter to search for the HealthRecord to update in case it exists.
     */
    where: HealthRecordWhereUniqueInput
    /**
     * In case the HealthRecord found by the `where` argument doesn't exist, create a new HealthRecord with this data.
     */
    create: XOR<HealthRecordCreateInput, HealthRecordUncheckedCreateInput>
    /**
     * In case the HealthRecord was found with the provided `where` argument, update it with this data.
     */
    update: XOR<HealthRecordUpdateInput, HealthRecordUncheckedUpdateInput>
  }

  /**
   * HealthRecord delete
   */
  export type HealthRecordDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HealthRecord
     */
    select?: HealthRecordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HealthRecordInclude<ExtArgs> | null
    /**
     * Filter which HealthRecord to delete.
     */
    where: HealthRecordWhereUniqueInput
  }

  /**
   * HealthRecord deleteMany
   */
  export type HealthRecordDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which HealthRecords to delete
     */
    where?: HealthRecordWhereInput
  }

  /**
   * HealthRecord without action
   */
  export type HealthRecordDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HealthRecord
     */
    select?: HealthRecordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HealthRecordInclude<ExtArgs> | null
  }


  /**
   * Model Medication
   */

  export type AggregateMedication = {
    _count: MedicationCountAggregateOutputType | null
    _min: MedicationMinAggregateOutputType | null
    _max: MedicationMaxAggregateOutputType | null
  }

  export type MedicationMinAggregateOutputType = {
    id: string | null
    santriId: string | null
    medicineName: string | null
    dose: string | null
    schedule: string | null
    givenBy: string | null
    givenAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MedicationMaxAggregateOutputType = {
    id: string | null
    santriId: string | null
    medicineName: string | null
    dose: string | null
    schedule: string | null
    givenBy: string | null
    givenAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MedicationCountAggregateOutputType = {
    id: number
    santriId: number
    medicineName: number
    dose: number
    schedule: number
    givenBy: number
    givenAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type MedicationMinAggregateInputType = {
    id?: true
    santriId?: true
    medicineName?: true
    dose?: true
    schedule?: true
    givenBy?: true
    givenAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MedicationMaxAggregateInputType = {
    id?: true
    santriId?: true
    medicineName?: true
    dose?: true
    schedule?: true
    givenBy?: true
    givenAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MedicationCountAggregateInputType = {
    id?: true
    santriId?: true
    medicineName?: true
    dose?: true
    schedule?: true
    givenBy?: true
    givenAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type MedicationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Medication to aggregate.
     */
    where?: MedicationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Medications to fetch.
     */
    orderBy?: MedicationOrderByWithRelationInput | MedicationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MedicationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Medications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Medications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Medications
    **/
    _count?: true | MedicationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MedicationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MedicationMaxAggregateInputType
  }

  export type GetMedicationAggregateType<T extends MedicationAggregateArgs> = {
        [P in keyof T & keyof AggregateMedication]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMedication[P]>
      : GetScalarType<T[P], AggregateMedication[P]>
  }




  export type MedicationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MedicationWhereInput
    orderBy?: MedicationOrderByWithAggregationInput | MedicationOrderByWithAggregationInput[]
    by: MedicationScalarFieldEnum[] | MedicationScalarFieldEnum
    having?: MedicationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MedicationCountAggregateInputType | true
    _min?: MedicationMinAggregateInputType
    _max?: MedicationMaxAggregateInputType
  }

  export type MedicationGroupByOutputType = {
    id: string
    santriId: string
    medicineName: string
    dose: string
    schedule: string
    givenBy: string | null
    givenAt: Date | null
    createdAt: Date
    updatedAt: Date
    _count: MedicationCountAggregateOutputType | null
    _min: MedicationMinAggregateOutputType | null
    _max: MedicationMaxAggregateOutputType | null
  }

  type GetMedicationGroupByPayload<T extends MedicationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MedicationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MedicationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MedicationGroupByOutputType[P]>
            : GetScalarType<T[P], MedicationGroupByOutputType[P]>
        }
      >
    >


  export type MedicationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    santriId?: boolean
    medicineName?: boolean
    dose?: boolean
    schedule?: boolean
    givenBy?: boolean
    givenAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    santri?: boolean | SantriDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["medication"]>

  export type MedicationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    santriId?: boolean
    medicineName?: boolean
    dose?: boolean
    schedule?: boolean
    givenBy?: boolean
    givenAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    santri?: boolean | SantriDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["medication"]>

  export type MedicationSelectScalar = {
    id?: boolean
    santriId?: boolean
    medicineName?: boolean
    dose?: boolean
    schedule?: boolean
    givenBy?: boolean
    givenAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type MedicationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    santri?: boolean | SantriDefaultArgs<ExtArgs>
  }
  export type MedicationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    santri?: boolean | SantriDefaultArgs<ExtArgs>
  }

  export type $MedicationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Medication"
    objects: {
      santri: Prisma.$SantriPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      santriId: string
      medicineName: string
      dose: string
      schedule: string
      givenBy: string | null
      givenAt: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["medication"]>
    composites: {}
  }

  type MedicationGetPayload<S extends boolean | null | undefined | MedicationDefaultArgs> = $Result.GetResult<Prisma.$MedicationPayload, S>

  type MedicationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<MedicationFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: MedicationCountAggregateInputType | true
    }

  export interface MedicationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Medication'], meta: { name: 'Medication' } }
    /**
     * Find zero or one Medication that matches the filter.
     * @param {MedicationFindUniqueArgs} args - Arguments to find a Medication
     * @example
     * // Get one Medication
     * const medication = await prisma.medication.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MedicationFindUniqueArgs>(args: SelectSubset<T, MedicationFindUniqueArgs<ExtArgs>>): Prisma__MedicationClient<$Result.GetResult<Prisma.$MedicationPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Medication that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {MedicationFindUniqueOrThrowArgs} args - Arguments to find a Medication
     * @example
     * // Get one Medication
     * const medication = await prisma.medication.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MedicationFindUniqueOrThrowArgs>(args: SelectSubset<T, MedicationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MedicationClient<$Result.GetResult<Prisma.$MedicationPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Medication that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MedicationFindFirstArgs} args - Arguments to find a Medication
     * @example
     * // Get one Medication
     * const medication = await prisma.medication.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MedicationFindFirstArgs>(args?: SelectSubset<T, MedicationFindFirstArgs<ExtArgs>>): Prisma__MedicationClient<$Result.GetResult<Prisma.$MedicationPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Medication that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MedicationFindFirstOrThrowArgs} args - Arguments to find a Medication
     * @example
     * // Get one Medication
     * const medication = await prisma.medication.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MedicationFindFirstOrThrowArgs>(args?: SelectSubset<T, MedicationFindFirstOrThrowArgs<ExtArgs>>): Prisma__MedicationClient<$Result.GetResult<Prisma.$MedicationPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Medications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MedicationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Medications
     * const medications = await prisma.medication.findMany()
     * 
     * // Get first 10 Medications
     * const medications = await prisma.medication.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const medicationWithIdOnly = await prisma.medication.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MedicationFindManyArgs>(args?: SelectSubset<T, MedicationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MedicationPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Medication.
     * @param {MedicationCreateArgs} args - Arguments to create a Medication.
     * @example
     * // Create one Medication
     * const Medication = await prisma.medication.create({
     *   data: {
     *     // ... data to create a Medication
     *   }
     * })
     * 
     */
    create<T extends MedicationCreateArgs>(args: SelectSubset<T, MedicationCreateArgs<ExtArgs>>): Prisma__MedicationClient<$Result.GetResult<Prisma.$MedicationPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Medications.
     * @param {MedicationCreateManyArgs} args - Arguments to create many Medications.
     * @example
     * // Create many Medications
     * const medication = await prisma.medication.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MedicationCreateManyArgs>(args?: SelectSubset<T, MedicationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Medications and returns the data saved in the database.
     * @param {MedicationCreateManyAndReturnArgs} args - Arguments to create many Medications.
     * @example
     * // Create many Medications
     * const medication = await prisma.medication.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Medications and only return the `id`
     * const medicationWithIdOnly = await prisma.medication.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MedicationCreateManyAndReturnArgs>(args?: SelectSubset<T, MedicationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MedicationPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Medication.
     * @param {MedicationDeleteArgs} args - Arguments to delete one Medication.
     * @example
     * // Delete one Medication
     * const Medication = await prisma.medication.delete({
     *   where: {
     *     // ... filter to delete one Medication
     *   }
     * })
     * 
     */
    delete<T extends MedicationDeleteArgs>(args: SelectSubset<T, MedicationDeleteArgs<ExtArgs>>): Prisma__MedicationClient<$Result.GetResult<Prisma.$MedicationPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Medication.
     * @param {MedicationUpdateArgs} args - Arguments to update one Medication.
     * @example
     * // Update one Medication
     * const medication = await prisma.medication.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MedicationUpdateArgs>(args: SelectSubset<T, MedicationUpdateArgs<ExtArgs>>): Prisma__MedicationClient<$Result.GetResult<Prisma.$MedicationPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Medications.
     * @param {MedicationDeleteManyArgs} args - Arguments to filter Medications to delete.
     * @example
     * // Delete a few Medications
     * const { count } = await prisma.medication.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MedicationDeleteManyArgs>(args?: SelectSubset<T, MedicationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Medications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MedicationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Medications
     * const medication = await prisma.medication.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MedicationUpdateManyArgs>(args: SelectSubset<T, MedicationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Medication.
     * @param {MedicationUpsertArgs} args - Arguments to update or create a Medication.
     * @example
     * // Update or create a Medication
     * const medication = await prisma.medication.upsert({
     *   create: {
     *     // ... data to create a Medication
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Medication we want to update
     *   }
     * })
     */
    upsert<T extends MedicationUpsertArgs>(args: SelectSubset<T, MedicationUpsertArgs<ExtArgs>>): Prisma__MedicationClient<$Result.GetResult<Prisma.$MedicationPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Medications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MedicationCountArgs} args - Arguments to filter Medications to count.
     * @example
     * // Count the number of Medications
     * const count = await prisma.medication.count({
     *   where: {
     *     // ... the filter for the Medications we want to count
     *   }
     * })
    **/
    count<T extends MedicationCountArgs>(
      args?: Subset<T, MedicationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MedicationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Medication.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MedicationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MedicationAggregateArgs>(args: Subset<T, MedicationAggregateArgs>): Prisma.PrismaPromise<GetMedicationAggregateType<T>>

    /**
     * Group by Medication.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MedicationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MedicationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MedicationGroupByArgs['orderBy'] }
        : { orderBy?: MedicationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MedicationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMedicationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Medication model
   */
  readonly fields: MedicationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Medication.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MedicationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    santri<T extends SantriDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SantriDefaultArgs<ExtArgs>>): Prisma__SantriClient<$Result.GetResult<Prisma.$SantriPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Medication model
   */ 
  interface MedicationFieldRefs {
    readonly id: FieldRef<"Medication", 'String'>
    readonly santriId: FieldRef<"Medication", 'String'>
    readonly medicineName: FieldRef<"Medication", 'String'>
    readonly dose: FieldRef<"Medication", 'String'>
    readonly schedule: FieldRef<"Medication", 'String'>
    readonly givenBy: FieldRef<"Medication", 'String'>
    readonly givenAt: FieldRef<"Medication", 'DateTime'>
    readonly createdAt: FieldRef<"Medication", 'DateTime'>
    readonly updatedAt: FieldRef<"Medication", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Medication findUnique
   */
  export type MedicationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Medication
     */
    select?: MedicationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicationInclude<ExtArgs> | null
    /**
     * Filter, which Medication to fetch.
     */
    where: MedicationWhereUniqueInput
  }

  /**
   * Medication findUniqueOrThrow
   */
  export type MedicationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Medication
     */
    select?: MedicationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicationInclude<ExtArgs> | null
    /**
     * Filter, which Medication to fetch.
     */
    where: MedicationWhereUniqueInput
  }

  /**
   * Medication findFirst
   */
  export type MedicationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Medication
     */
    select?: MedicationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicationInclude<ExtArgs> | null
    /**
     * Filter, which Medication to fetch.
     */
    where?: MedicationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Medications to fetch.
     */
    orderBy?: MedicationOrderByWithRelationInput | MedicationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Medications.
     */
    cursor?: MedicationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Medications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Medications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Medications.
     */
    distinct?: MedicationScalarFieldEnum | MedicationScalarFieldEnum[]
  }

  /**
   * Medication findFirstOrThrow
   */
  export type MedicationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Medication
     */
    select?: MedicationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicationInclude<ExtArgs> | null
    /**
     * Filter, which Medication to fetch.
     */
    where?: MedicationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Medications to fetch.
     */
    orderBy?: MedicationOrderByWithRelationInput | MedicationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Medications.
     */
    cursor?: MedicationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Medications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Medications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Medications.
     */
    distinct?: MedicationScalarFieldEnum | MedicationScalarFieldEnum[]
  }

  /**
   * Medication findMany
   */
  export type MedicationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Medication
     */
    select?: MedicationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicationInclude<ExtArgs> | null
    /**
     * Filter, which Medications to fetch.
     */
    where?: MedicationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Medications to fetch.
     */
    orderBy?: MedicationOrderByWithRelationInput | MedicationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Medications.
     */
    cursor?: MedicationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Medications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Medications.
     */
    skip?: number
    distinct?: MedicationScalarFieldEnum | MedicationScalarFieldEnum[]
  }

  /**
   * Medication create
   */
  export type MedicationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Medication
     */
    select?: MedicationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicationInclude<ExtArgs> | null
    /**
     * The data needed to create a Medication.
     */
    data: XOR<MedicationCreateInput, MedicationUncheckedCreateInput>
  }

  /**
   * Medication createMany
   */
  export type MedicationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Medications.
     */
    data: MedicationCreateManyInput | MedicationCreateManyInput[]
  }

  /**
   * Medication createManyAndReturn
   */
  export type MedicationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Medication
     */
    select?: MedicationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Medications.
     */
    data: MedicationCreateManyInput | MedicationCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Medication update
   */
  export type MedicationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Medication
     */
    select?: MedicationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicationInclude<ExtArgs> | null
    /**
     * The data needed to update a Medication.
     */
    data: XOR<MedicationUpdateInput, MedicationUncheckedUpdateInput>
    /**
     * Choose, which Medication to update.
     */
    where: MedicationWhereUniqueInput
  }

  /**
   * Medication updateMany
   */
  export type MedicationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Medications.
     */
    data: XOR<MedicationUpdateManyMutationInput, MedicationUncheckedUpdateManyInput>
    /**
     * Filter which Medications to update
     */
    where?: MedicationWhereInput
  }

  /**
   * Medication upsert
   */
  export type MedicationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Medication
     */
    select?: MedicationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicationInclude<ExtArgs> | null
    /**
     * The filter to search for the Medication to update in case it exists.
     */
    where: MedicationWhereUniqueInput
    /**
     * In case the Medication found by the `where` argument doesn't exist, create a new Medication with this data.
     */
    create: XOR<MedicationCreateInput, MedicationUncheckedCreateInput>
    /**
     * In case the Medication was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MedicationUpdateInput, MedicationUncheckedUpdateInput>
  }

  /**
   * Medication delete
   */
  export type MedicationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Medication
     */
    select?: MedicationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicationInclude<ExtArgs> | null
    /**
     * Filter which Medication to delete.
     */
    where: MedicationWhereUniqueInput
  }

  /**
   * Medication deleteMany
   */
  export type MedicationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Medications to delete
     */
    where?: MedicationWhereInput
  }

  /**
   * Medication without action
   */
  export type MedicationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Medication
     */
    select?: MedicationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicationInclude<ExtArgs> | null
  }


  /**
   * Model AuditLog
   */

  export type AggregateAuditLog = {
    _count: AuditLogCountAggregateOutputType | null
    _min: AuditLogMinAggregateOutputType | null
    _max: AuditLogMaxAggregateOutputType | null
  }

  export type AuditLogMinAggregateOutputType = {
    id: string | null
    tenantId: string | null
    userId: string | null
    action: string | null
    entity: string | null
    entityId: string | null
    oldValue: string | null
    newValue: string | null
    ip: string | null
    createdAt: Date | null
  }

  export type AuditLogMaxAggregateOutputType = {
    id: string | null
    tenantId: string | null
    userId: string | null
    action: string | null
    entity: string | null
    entityId: string | null
    oldValue: string | null
    newValue: string | null
    ip: string | null
    createdAt: Date | null
  }

  export type AuditLogCountAggregateOutputType = {
    id: number
    tenantId: number
    userId: number
    action: number
    entity: number
    entityId: number
    oldValue: number
    newValue: number
    ip: number
    createdAt: number
    _all: number
  }


  export type AuditLogMinAggregateInputType = {
    id?: true
    tenantId?: true
    userId?: true
    action?: true
    entity?: true
    entityId?: true
    oldValue?: true
    newValue?: true
    ip?: true
    createdAt?: true
  }

  export type AuditLogMaxAggregateInputType = {
    id?: true
    tenantId?: true
    userId?: true
    action?: true
    entity?: true
    entityId?: true
    oldValue?: true
    newValue?: true
    ip?: true
    createdAt?: true
  }

  export type AuditLogCountAggregateInputType = {
    id?: true
    tenantId?: true
    userId?: true
    action?: true
    entity?: true
    entityId?: true
    oldValue?: true
    newValue?: true
    ip?: true
    createdAt?: true
    _all?: true
  }

  export type AuditLogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AuditLog to aggregate.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AuditLogs
    **/
    _count?: true | AuditLogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AuditLogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AuditLogMaxAggregateInputType
  }

  export type GetAuditLogAggregateType<T extends AuditLogAggregateArgs> = {
        [P in keyof T & keyof AggregateAuditLog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAuditLog[P]>
      : GetScalarType<T[P], AggregateAuditLog[P]>
  }




  export type AuditLogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AuditLogWhereInput
    orderBy?: AuditLogOrderByWithAggregationInput | AuditLogOrderByWithAggregationInput[]
    by: AuditLogScalarFieldEnum[] | AuditLogScalarFieldEnum
    having?: AuditLogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AuditLogCountAggregateInputType | true
    _min?: AuditLogMinAggregateInputType
    _max?: AuditLogMaxAggregateInputType
  }

  export type AuditLogGroupByOutputType = {
    id: string
    tenantId: string | null
    userId: string | null
    action: string
    entity: string
    entityId: string
    oldValue: string | null
    newValue: string | null
    ip: string | null
    createdAt: Date
    _count: AuditLogCountAggregateOutputType | null
    _min: AuditLogMinAggregateOutputType | null
    _max: AuditLogMaxAggregateOutputType | null
  }

  type GetAuditLogGroupByPayload<T extends AuditLogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AuditLogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AuditLogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AuditLogGroupByOutputType[P]>
            : GetScalarType<T[P], AuditLogGroupByOutputType[P]>
        }
      >
    >


  export type AuditLogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    userId?: boolean
    action?: boolean
    entity?: boolean
    entityId?: boolean
    oldValue?: boolean
    newValue?: boolean
    ip?: boolean
    createdAt?: boolean
    tenant?: boolean | AuditLog$tenantArgs<ExtArgs>
    user?: boolean | AuditLog$userArgs<ExtArgs>
  }, ExtArgs["result"]["auditLog"]>

  export type AuditLogSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    userId?: boolean
    action?: boolean
    entity?: boolean
    entityId?: boolean
    oldValue?: boolean
    newValue?: boolean
    ip?: boolean
    createdAt?: boolean
    tenant?: boolean | AuditLog$tenantArgs<ExtArgs>
    user?: boolean | AuditLog$userArgs<ExtArgs>
  }, ExtArgs["result"]["auditLog"]>

  export type AuditLogSelectScalar = {
    id?: boolean
    tenantId?: boolean
    userId?: boolean
    action?: boolean
    entity?: boolean
    entityId?: boolean
    oldValue?: boolean
    newValue?: boolean
    ip?: boolean
    createdAt?: boolean
  }

  export type AuditLogInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | AuditLog$tenantArgs<ExtArgs>
    user?: boolean | AuditLog$userArgs<ExtArgs>
  }
  export type AuditLogIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | AuditLog$tenantArgs<ExtArgs>
    user?: boolean | AuditLog$userArgs<ExtArgs>
  }

  export type $AuditLogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AuditLog"
    objects: {
      tenant: Prisma.$TenantPayload<ExtArgs> | null
      user: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      tenantId: string | null
      userId: string | null
      action: string
      entity: string
      entityId: string
      oldValue: string | null
      newValue: string | null
      ip: string | null
      createdAt: Date
    }, ExtArgs["result"]["auditLog"]>
    composites: {}
  }

  type AuditLogGetPayload<S extends boolean | null | undefined | AuditLogDefaultArgs> = $Result.GetResult<Prisma.$AuditLogPayload, S>

  type AuditLogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<AuditLogFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: AuditLogCountAggregateInputType | true
    }

  export interface AuditLogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AuditLog'], meta: { name: 'AuditLog' } }
    /**
     * Find zero or one AuditLog that matches the filter.
     * @param {AuditLogFindUniqueArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AuditLogFindUniqueArgs>(args: SelectSubset<T, AuditLogFindUniqueArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one AuditLog that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {AuditLogFindUniqueOrThrowArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AuditLogFindUniqueOrThrowArgs>(args: SelectSubset<T, AuditLogFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first AuditLog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogFindFirstArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AuditLogFindFirstArgs>(args?: SelectSubset<T, AuditLogFindFirstArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first AuditLog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogFindFirstOrThrowArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AuditLogFindFirstOrThrowArgs>(args?: SelectSubset<T, AuditLogFindFirstOrThrowArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more AuditLogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AuditLogs
     * const auditLogs = await prisma.auditLog.findMany()
     * 
     * // Get first 10 AuditLogs
     * const auditLogs = await prisma.auditLog.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const auditLogWithIdOnly = await prisma.auditLog.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AuditLogFindManyArgs>(args?: SelectSubset<T, AuditLogFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a AuditLog.
     * @param {AuditLogCreateArgs} args - Arguments to create a AuditLog.
     * @example
     * // Create one AuditLog
     * const AuditLog = await prisma.auditLog.create({
     *   data: {
     *     // ... data to create a AuditLog
     *   }
     * })
     * 
     */
    create<T extends AuditLogCreateArgs>(args: SelectSubset<T, AuditLogCreateArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many AuditLogs.
     * @param {AuditLogCreateManyArgs} args - Arguments to create many AuditLogs.
     * @example
     * // Create many AuditLogs
     * const auditLog = await prisma.auditLog.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AuditLogCreateManyArgs>(args?: SelectSubset<T, AuditLogCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AuditLogs and returns the data saved in the database.
     * @param {AuditLogCreateManyAndReturnArgs} args - Arguments to create many AuditLogs.
     * @example
     * // Create many AuditLogs
     * const auditLog = await prisma.auditLog.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AuditLogs and only return the `id`
     * const auditLogWithIdOnly = await prisma.auditLog.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AuditLogCreateManyAndReturnArgs>(args?: SelectSubset<T, AuditLogCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a AuditLog.
     * @param {AuditLogDeleteArgs} args - Arguments to delete one AuditLog.
     * @example
     * // Delete one AuditLog
     * const AuditLog = await prisma.auditLog.delete({
     *   where: {
     *     // ... filter to delete one AuditLog
     *   }
     * })
     * 
     */
    delete<T extends AuditLogDeleteArgs>(args: SelectSubset<T, AuditLogDeleteArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one AuditLog.
     * @param {AuditLogUpdateArgs} args - Arguments to update one AuditLog.
     * @example
     * // Update one AuditLog
     * const auditLog = await prisma.auditLog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AuditLogUpdateArgs>(args: SelectSubset<T, AuditLogUpdateArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more AuditLogs.
     * @param {AuditLogDeleteManyArgs} args - Arguments to filter AuditLogs to delete.
     * @example
     * // Delete a few AuditLogs
     * const { count } = await prisma.auditLog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AuditLogDeleteManyArgs>(args?: SelectSubset<T, AuditLogDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AuditLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AuditLogs
     * const auditLog = await prisma.auditLog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AuditLogUpdateManyArgs>(args: SelectSubset<T, AuditLogUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one AuditLog.
     * @param {AuditLogUpsertArgs} args - Arguments to update or create a AuditLog.
     * @example
     * // Update or create a AuditLog
     * const auditLog = await prisma.auditLog.upsert({
     *   create: {
     *     // ... data to create a AuditLog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AuditLog we want to update
     *   }
     * })
     */
    upsert<T extends AuditLogUpsertArgs>(args: SelectSubset<T, AuditLogUpsertArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of AuditLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogCountArgs} args - Arguments to filter AuditLogs to count.
     * @example
     * // Count the number of AuditLogs
     * const count = await prisma.auditLog.count({
     *   where: {
     *     // ... the filter for the AuditLogs we want to count
     *   }
     * })
    **/
    count<T extends AuditLogCountArgs>(
      args?: Subset<T, AuditLogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AuditLogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AuditLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AuditLogAggregateArgs>(args: Subset<T, AuditLogAggregateArgs>): Prisma.PrismaPromise<GetAuditLogAggregateType<T>>

    /**
     * Group by AuditLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AuditLogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AuditLogGroupByArgs['orderBy'] }
        : { orderBy?: AuditLogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AuditLogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAuditLogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AuditLog model
   */
  readonly fields: AuditLogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AuditLog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AuditLogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    tenant<T extends AuditLog$tenantArgs<ExtArgs> = {}>(args?: Subset<T, AuditLog$tenantArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    user<T extends AuditLog$userArgs<ExtArgs> = {}>(args?: Subset<T, AuditLog$userArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AuditLog model
   */ 
  interface AuditLogFieldRefs {
    readonly id: FieldRef<"AuditLog", 'String'>
    readonly tenantId: FieldRef<"AuditLog", 'String'>
    readonly userId: FieldRef<"AuditLog", 'String'>
    readonly action: FieldRef<"AuditLog", 'String'>
    readonly entity: FieldRef<"AuditLog", 'String'>
    readonly entityId: FieldRef<"AuditLog", 'String'>
    readonly oldValue: FieldRef<"AuditLog", 'String'>
    readonly newValue: FieldRef<"AuditLog", 'String'>
    readonly ip: FieldRef<"AuditLog", 'String'>
    readonly createdAt: FieldRef<"AuditLog", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AuditLog findUnique
   */
  export type AuditLogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog findUniqueOrThrow
   */
  export type AuditLogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog findFirst
   */
  export type AuditLogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AuditLogs.
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AuditLogs.
     */
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * AuditLog findFirstOrThrow
   */
  export type AuditLogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AuditLogs.
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AuditLogs.
     */
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * AuditLog findMany
   */
  export type AuditLogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLogs to fetch.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AuditLogs.
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * AuditLog create
   */
  export type AuditLogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * The data needed to create a AuditLog.
     */
    data: XOR<AuditLogCreateInput, AuditLogUncheckedCreateInput>
  }

  /**
   * AuditLog createMany
   */
  export type AuditLogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AuditLogs.
     */
    data: AuditLogCreateManyInput | AuditLogCreateManyInput[]
  }

  /**
   * AuditLog createManyAndReturn
   */
  export type AuditLogCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many AuditLogs.
     */
    data: AuditLogCreateManyInput | AuditLogCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AuditLog update
   */
  export type AuditLogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * The data needed to update a AuditLog.
     */
    data: XOR<AuditLogUpdateInput, AuditLogUncheckedUpdateInput>
    /**
     * Choose, which AuditLog to update.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog updateMany
   */
  export type AuditLogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AuditLogs.
     */
    data: XOR<AuditLogUpdateManyMutationInput, AuditLogUncheckedUpdateManyInput>
    /**
     * Filter which AuditLogs to update
     */
    where?: AuditLogWhereInput
  }

  /**
   * AuditLog upsert
   */
  export type AuditLogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * The filter to search for the AuditLog to update in case it exists.
     */
    where: AuditLogWhereUniqueInput
    /**
     * In case the AuditLog found by the `where` argument doesn't exist, create a new AuditLog with this data.
     */
    create: XOR<AuditLogCreateInput, AuditLogUncheckedCreateInput>
    /**
     * In case the AuditLog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AuditLogUpdateInput, AuditLogUncheckedUpdateInput>
  }

  /**
   * AuditLog delete
   */
  export type AuditLogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter which AuditLog to delete.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog deleteMany
   */
  export type AuditLogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AuditLogs to delete
     */
    where?: AuditLogWhereInput
  }

  /**
   * AuditLog.tenant
   */
  export type AuditLog$tenantArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tenant
     */
    select?: TenantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantInclude<ExtArgs> | null
    where?: TenantWhereInput
  }

  /**
   * AuditLog.user
   */
  export type AuditLog$userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * AuditLog without action
   */
  export type AuditLogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
  }


  /**
   * Model Notification
   */

  export type AggregateNotification = {
    _count: NotificationCountAggregateOutputType | null
    _min: NotificationMinAggregateOutputType | null
    _max: NotificationMaxAggregateOutputType | null
  }

  export type NotificationMinAggregateOutputType = {
    id: string | null
    tenantId: string | null
    userId: string | null
    type: string | null
    title: string | null
    body: string | null
    read: boolean | null
    createdAt: Date | null
  }

  export type NotificationMaxAggregateOutputType = {
    id: string | null
    tenantId: string | null
    userId: string | null
    type: string | null
    title: string | null
    body: string | null
    read: boolean | null
    createdAt: Date | null
  }

  export type NotificationCountAggregateOutputType = {
    id: number
    tenantId: number
    userId: number
    type: number
    title: number
    body: number
    read: number
    createdAt: number
    _all: number
  }


  export type NotificationMinAggregateInputType = {
    id?: true
    tenantId?: true
    userId?: true
    type?: true
    title?: true
    body?: true
    read?: true
    createdAt?: true
  }

  export type NotificationMaxAggregateInputType = {
    id?: true
    tenantId?: true
    userId?: true
    type?: true
    title?: true
    body?: true
    read?: true
    createdAt?: true
  }

  export type NotificationCountAggregateInputType = {
    id?: true
    tenantId?: true
    userId?: true
    type?: true
    title?: true
    body?: true
    read?: true
    createdAt?: true
    _all?: true
  }

  export type NotificationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Notification to aggregate.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Notifications
    **/
    _count?: true | NotificationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NotificationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NotificationMaxAggregateInputType
  }

  export type GetNotificationAggregateType<T extends NotificationAggregateArgs> = {
        [P in keyof T & keyof AggregateNotification]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNotification[P]>
      : GetScalarType<T[P], AggregateNotification[P]>
  }




  export type NotificationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationWhereInput
    orderBy?: NotificationOrderByWithAggregationInput | NotificationOrderByWithAggregationInput[]
    by: NotificationScalarFieldEnum[] | NotificationScalarFieldEnum
    having?: NotificationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NotificationCountAggregateInputType | true
    _min?: NotificationMinAggregateInputType
    _max?: NotificationMaxAggregateInputType
  }

  export type NotificationGroupByOutputType = {
    id: string
    tenantId: string
    userId: string
    type: string
    title: string
    body: string
    read: boolean
    createdAt: Date
    _count: NotificationCountAggregateOutputType | null
    _min: NotificationMinAggregateOutputType | null
    _max: NotificationMaxAggregateOutputType | null
  }

  type GetNotificationGroupByPayload<T extends NotificationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NotificationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NotificationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NotificationGroupByOutputType[P]>
            : GetScalarType<T[P], NotificationGroupByOutputType[P]>
        }
      >
    >


  export type NotificationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    userId?: boolean
    type?: boolean
    title?: boolean
    body?: boolean
    read?: boolean
    createdAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notification"]>

  export type NotificationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    userId?: boolean
    type?: boolean
    title?: boolean
    body?: boolean
    read?: boolean
    createdAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notification"]>

  export type NotificationSelectScalar = {
    id?: boolean
    tenantId?: boolean
    userId?: boolean
    type?: boolean
    title?: boolean
    body?: boolean
    read?: boolean
    createdAt?: boolean
  }

  export type NotificationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type NotificationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $NotificationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Notification"
    objects: {
      tenant: Prisma.$TenantPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      tenantId: string
      userId: string
      type: string
      title: string
      body: string
      read: boolean
      createdAt: Date
    }, ExtArgs["result"]["notification"]>
    composites: {}
  }

  type NotificationGetPayload<S extends boolean | null | undefined | NotificationDefaultArgs> = $Result.GetResult<Prisma.$NotificationPayload, S>

  type NotificationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<NotificationFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: NotificationCountAggregateInputType | true
    }

  export interface NotificationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Notification'], meta: { name: 'Notification' } }
    /**
     * Find zero or one Notification that matches the filter.
     * @param {NotificationFindUniqueArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends NotificationFindUniqueArgs>(args: SelectSubset<T, NotificationFindUniqueArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Notification that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {NotificationFindUniqueOrThrowArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends NotificationFindUniqueOrThrowArgs>(args: SelectSubset<T, NotificationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Notification that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindFirstArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends NotificationFindFirstArgs>(args?: SelectSubset<T, NotificationFindFirstArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Notification that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindFirstOrThrowArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends NotificationFindFirstOrThrowArgs>(args?: SelectSubset<T, NotificationFindFirstOrThrowArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Notifications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Notifications
     * const notifications = await prisma.notification.findMany()
     * 
     * // Get first 10 Notifications
     * const notifications = await prisma.notification.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const notificationWithIdOnly = await prisma.notification.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends NotificationFindManyArgs>(args?: SelectSubset<T, NotificationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Notification.
     * @param {NotificationCreateArgs} args - Arguments to create a Notification.
     * @example
     * // Create one Notification
     * const Notification = await prisma.notification.create({
     *   data: {
     *     // ... data to create a Notification
     *   }
     * })
     * 
     */
    create<T extends NotificationCreateArgs>(args: SelectSubset<T, NotificationCreateArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Notifications.
     * @param {NotificationCreateManyArgs} args - Arguments to create many Notifications.
     * @example
     * // Create many Notifications
     * const notification = await prisma.notification.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends NotificationCreateManyArgs>(args?: SelectSubset<T, NotificationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Notifications and returns the data saved in the database.
     * @param {NotificationCreateManyAndReturnArgs} args - Arguments to create many Notifications.
     * @example
     * // Create many Notifications
     * const notification = await prisma.notification.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Notifications and only return the `id`
     * const notificationWithIdOnly = await prisma.notification.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends NotificationCreateManyAndReturnArgs>(args?: SelectSubset<T, NotificationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Notification.
     * @param {NotificationDeleteArgs} args - Arguments to delete one Notification.
     * @example
     * // Delete one Notification
     * const Notification = await prisma.notification.delete({
     *   where: {
     *     // ... filter to delete one Notification
     *   }
     * })
     * 
     */
    delete<T extends NotificationDeleteArgs>(args: SelectSubset<T, NotificationDeleteArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Notification.
     * @param {NotificationUpdateArgs} args - Arguments to update one Notification.
     * @example
     * // Update one Notification
     * const notification = await prisma.notification.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends NotificationUpdateArgs>(args: SelectSubset<T, NotificationUpdateArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Notifications.
     * @param {NotificationDeleteManyArgs} args - Arguments to filter Notifications to delete.
     * @example
     * // Delete a few Notifications
     * const { count } = await prisma.notification.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends NotificationDeleteManyArgs>(args?: SelectSubset<T, NotificationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Notifications
     * const notification = await prisma.notification.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends NotificationUpdateManyArgs>(args: SelectSubset<T, NotificationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Notification.
     * @param {NotificationUpsertArgs} args - Arguments to update or create a Notification.
     * @example
     * // Update or create a Notification
     * const notification = await prisma.notification.upsert({
     *   create: {
     *     // ... data to create a Notification
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Notification we want to update
     *   }
     * })
     */
    upsert<T extends NotificationUpsertArgs>(args: SelectSubset<T, NotificationUpsertArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationCountArgs} args - Arguments to filter Notifications to count.
     * @example
     * // Count the number of Notifications
     * const count = await prisma.notification.count({
     *   where: {
     *     // ... the filter for the Notifications we want to count
     *   }
     * })
    **/
    count<T extends NotificationCountArgs>(
      args?: Subset<T, NotificationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NotificationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Notification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NotificationAggregateArgs>(args: Subset<T, NotificationAggregateArgs>): Prisma.PrismaPromise<GetNotificationAggregateType<T>>

    /**
     * Group by Notification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NotificationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NotificationGroupByArgs['orderBy'] }
        : { orderBy?: NotificationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NotificationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNotificationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Notification model
   */
  readonly fields: NotificationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Notification.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__NotificationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    tenant<T extends TenantDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TenantDefaultArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Notification model
   */ 
  interface NotificationFieldRefs {
    readonly id: FieldRef<"Notification", 'String'>
    readonly tenantId: FieldRef<"Notification", 'String'>
    readonly userId: FieldRef<"Notification", 'String'>
    readonly type: FieldRef<"Notification", 'String'>
    readonly title: FieldRef<"Notification", 'String'>
    readonly body: FieldRef<"Notification", 'String'>
    readonly read: FieldRef<"Notification", 'Boolean'>
    readonly createdAt: FieldRef<"Notification", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Notification findUnique
   */
  export type NotificationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification findUniqueOrThrow
   */
  export type NotificationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification findFirst
   */
  export type NotificationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Notifications.
     */
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification findFirstOrThrow
   */
  export type NotificationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Notifications.
     */
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification findMany
   */
  export type NotificationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notifications to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification create
   */
  export type NotificationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The data needed to create a Notification.
     */
    data: XOR<NotificationCreateInput, NotificationUncheckedCreateInput>
  }

  /**
   * Notification createMany
   */
  export type NotificationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Notifications.
     */
    data: NotificationCreateManyInput | NotificationCreateManyInput[]
  }

  /**
   * Notification createManyAndReturn
   */
  export type NotificationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Notifications.
     */
    data: NotificationCreateManyInput | NotificationCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Notification update
   */
  export type NotificationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The data needed to update a Notification.
     */
    data: XOR<NotificationUpdateInput, NotificationUncheckedUpdateInput>
    /**
     * Choose, which Notification to update.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification updateMany
   */
  export type NotificationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Notifications.
     */
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyInput>
    /**
     * Filter which Notifications to update
     */
    where?: NotificationWhereInput
  }

  /**
   * Notification upsert
   */
  export type NotificationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The filter to search for the Notification to update in case it exists.
     */
    where: NotificationWhereUniqueInput
    /**
     * In case the Notification found by the `where` argument doesn't exist, create a new Notification with this data.
     */
    create: XOR<NotificationCreateInput, NotificationUncheckedCreateInput>
    /**
     * In case the Notification was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NotificationUpdateInput, NotificationUncheckedUpdateInput>
  }

  /**
   * Notification delete
   */
  export type NotificationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter which Notification to delete.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification deleteMany
   */
  export type NotificationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Notifications to delete
     */
    where?: NotificationWhereInput
  }

  /**
   * Notification without action
   */
  export type NotificationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
  }


  /**
   * Model WebhookEvent
   */

  export type AggregateWebhookEvent = {
    _count: WebhookEventCountAggregateOutputType | null
    _min: WebhookEventMinAggregateOutputType | null
    _max: WebhookEventMaxAggregateOutputType | null
  }

  export type WebhookEventMinAggregateOutputType = {
    id: string | null
    tenantId: string | null
    eventType: string | null
    payload: string | null
    status: string | null
    error: string | null
    createdAt: Date | null
    processedAt: Date | null
  }

  export type WebhookEventMaxAggregateOutputType = {
    id: string | null
    tenantId: string | null
    eventType: string | null
    payload: string | null
    status: string | null
    error: string | null
    createdAt: Date | null
    processedAt: Date | null
  }

  export type WebhookEventCountAggregateOutputType = {
    id: number
    tenantId: number
    eventType: number
    payload: number
    status: number
    error: number
    createdAt: number
    processedAt: number
    _all: number
  }


  export type WebhookEventMinAggregateInputType = {
    id?: true
    tenantId?: true
    eventType?: true
    payload?: true
    status?: true
    error?: true
    createdAt?: true
    processedAt?: true
  }

  export type WebhookEventMaxAggregateInputType = {
    id?: true
    tenantId?: true
    eventType?: true
    payload?: true
    status?: true
    error?: true
    createdAt?: true
    processedAt?: true
  }

  export type WebhookEventCountAggregateInputType = {
    id?: true
    tenantId?: true
    eventType?: true
    payload?: true
    status?: true
    error?: true
    createdAt?: true
    processedAt?: true
    _all?: true
  }

  export type WebhookEventAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WebhookEvent to aggregate.
     */
    where?: WebhookEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WebhookEvents to fetch.
     */
    orderBy?: WebhookEventOrderByWithRelationInput | WebhookEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: WebhookEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WebhookEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WebhookEvents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned WebhookEvents
    **/
    _count?: true | WebhookEventCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WebhookEventMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WebhookEventMaxAggregateInputType
  }

  export type GetWebhookEventAggregateType<T extends WebhookEventAggregateArgs> = {
        [P in keyof T & keyof AggregateWebhookEvent]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWebhookEvent[P]>
      : GetScalarType<T[P], AggregateWebhookEvent[P]>
  }




  export type WebhookEventGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WebhookEventWhereInput
    orderBy?: WebhookEventOrderByWithAggregationInput | WebhookEventOrderByWithAggregationInput[]
    by: WebhookEventScalarFieldEnum[] | WebhookEventScalarFieldEnum
    having?: WebhookEventScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WebhookEventCountAggregateInputType | true
    _min?: WebhookEventMinAggregateInputType
    _max?: WebhookEventMaxAggregateInputType
  }

  export type WebhookEventGroupByOutputType = {
    id: string
    tenantId: string | null
    eventType: string
    payload: string
    status: string
    error: string | null
    createdAt: Date
    processedAt: Date | null
    _count: WebhookEventCountAggregateOutputType | null
    _min: WebhookEventMinAggregateOutputType | null
    _max: WebhookEventMaxAggregateOutputType | null
  }

  type GetWebhookEventGroupByPayload<T extends WebhookEventGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<WebhookEventGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WebhookEventGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WebhookEventGroupByOutputType[P]>
            : GetScalarType<T[P], WebhookEventGroupByOutputType[P]>
        }
      >
    >


  export type WebhookEventSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    eventType?: boolean
    payload?: boolean
    status?: boolean
    error?: boolean
    createdAt?: boolean
    processedAt?: boolean
    tenant?: boolean | WebhookEvent$tenantArgs<ExtArgs>
  }, ExtArgs["result"]["webhookEvent"]>

  export type WebhookEventSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    eventType?: boolean
    payload?: boolean
    status?: boolean
    error?: boolean
    createdAt?: boolean
    processedAt?: boolean
    tenant?: boolean | WebhookEvent$tenantArgs<ExtArgs>
  }, ExtArgs["result"]["webhookEvent"]>

  export type WebhookEventSelectScalar = {
    id?: boolean
    tenantId?: boolean
    eventType?: boolean
    payload?: boolean
    status?: boolean
    error?: boolean
    createdAt?: boolean
    processedAt?: boolean
  }

  export type WebhookEventInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | WebhookEvent$tenantArgs<ExtArgs>
  }
  export type WebhookEventIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | WebhookEvent$tenantArgs<ExtArgs>
  }

  export type $WebhookEventPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "WebhookEvent"
    objects: {
      tenant: Prisma.$TenantPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      tenantId: string | null
      eventType: string
      payload: string
      status: string
      error: string | null
      createdAt: Date
      processedAt: Date | null
    }, ExtArgs["result"]["webhookEvent"]>
    composites: {}
  }

  type WebhookEventGetPayload<S extends boolean | null | undefined | WebhookEventDefaultArgs> = $Result.GetResult<Prisma.$WebhookEventPayload, S>

  type WebhookEventCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<WebhookEventFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: WebhookEventCountAggregateInputType | true
    }

  export interface WebhookEventDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['WebhookEvent'], meta: { name: 'WebhookEvent' } }
    /**
     * Find zero or one WebhookEvent that matches the filter.
     * @param {WebhookEventFindUniqueArgs} args - Arguments to find a WebhookEvent
     * @example
     * // Get one WebhookEvent
     * const webhookEvent = await prisma.webhookEvent.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends WebhookEventFindUniqueArgs>(args: SelectSubset<T, WebhookEventFindUniqueArgs<ExtArgs>>): Prisma__WebhookEventClient<$Result.GetResult<Prisma.$WebhookEventPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one WebhookEvent that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {WebhookEventFindUniqueOrThrowArgs} args - Arguments to find a WebhookEvent
     * @example
     * // Get one WebhookEvent
     * const webhookEvent = await prisma.webhookEvent.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends WebhookEventFindUniqueOrThrowArgs>(args: SelectSubset<T, WebhookEventFindUniqueOrThrowArgs<ExtArgs>>): Prisma__WebhookEventClient<$Result.GetResult<Prisma.$WebhookEventPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first WebhookEvent that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WebhookEventFindFirstArgs} args - Arguments to find a WebhookEvent
     * @example
     * // Get one WebhookEvent
     * const webhookEvent = await prisma.webhookEvent.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends WebhookEventFindFirstArgs>(args?: SelectSubset<T, WebhookEventFindFirstArgs<ExtArgs>>): Prisma__WebhookEventClient<$Result.GetResult<Prisma.$WebhookEventPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first WebhookEvent that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WebhookEventFindFirstOrThrowArgs} args - Arguments to find a WebhookEvent
     * @example
     * // Get one WebhookEvent
     * const webhookEvent = await prisma.webhookEvent.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends WebhookEventFindFirstOrThrowArgs>(args?: SelectSubset<T, WebhookEventFindFirstOrThrowArgs<ExtArgs>>): Prisma__WebhookEventClient<$Result.GetResult<Prisma.$WebhookEventPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more WebhookEvents that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WebhookEventFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all WebhookEvents
     * const webhookEvents = await prisma.webhookEvent.findMany()
     * 
     * // Get first 10 WebhookEvents
     * const webhookEvents = await prisma.webhookEvent.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const webhookEventWithIdOnly = await prisma.webhookEvent.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends WebhookEventFindManyArgs>(args?: SelectSubset<T, WebhookEventFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WebhookEventPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a WebhookEvent.
     * @param {WebhookEventCreateArgs} args - Arguments to create a WebhookEvent.
     * @example
     * // Create one WebhookEvent
     * const WebhookEvent = await prisma.webhookEvent.create({
     *   data: {
     *     // ... data to create a WebhookEvent
     *   }
     * })
     * 
     */
    create<T extends WebhookEventCreateArgs>(args: SelectSubset<T, WebhookEventCreateArgs<ExtArgs>>): Prisma__WebhookEventClient<$Result.GetResult<Prisma.$WebhookEventPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many WebhookEvents.
     * @param {WebhookEventCreateManyArgs} args - Arguments to create many WebhookEvents.
     * @example
     * // Create many WebhookEvents
     * const webhookEvent = await prisma.webhookEvent.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends WebhookEventCreateManyArgs>(args?: SelectSubset<T, WebhookEventCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many WebhookEvents and returns the data saved in the database.
     * @param {WebhookEventCreateManyAndReturnArgs} args - Arguments to create many WebhookEvents.
     * @example
     * // Create many WebhookEvents
     * const webhookEvent = await prisma.webhookEvent.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many WebhookEvents and only return the `id`
     * const webhookEventWithIdOnly = await prisma.webhookEvent.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends WebhookEventCreateManyAndReturnArgs>(args?: SelectSubset<T, WebhookEventCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WebhookEventPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a WebhookEvent.
     * @param {WebhookEventDeleteArgs} args - Arguments to delete one WebhookEvent.
     * @example
     * // Delete one WebhookEvent
     * const WebhookEvent = await prisma.webhookEvent.delete({
     *   where: {
     *     // ... filter to delete one WebhookEvent
     *   }
     * })
     * 
     */
    delete<T extends WebhookEventDeleteArgs>(args: SelectSubset<T, WebhookEventDeleteArgs<ExtArgs>>): Prisma__WebhookEventClient<$Result.GetResult<Prisma.$WebhookEventPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one WebhookEvent.
     * @param {WebhookEventUpdateArgs} args - Arguments to update one WebhookEvent.
     * @example
     * // Update one WebhookEvent
     * const webhookEvent = await prisma.webhookEvent.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends WebhookEventUpdateArgs>(args: SelectSubset<T, WebhookEventUpdateArgs<ExtArgs>>): Prisma__WebhookEventClient<$Result.GetResult<Prisma.$WebhookEventPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more WebhookEvents.
     * @param {WebhookEventDeleteManyArgs} args - Arguments to filter WebhookEvents to delete.
     * @example
     * // Delete a few WebhookEvents
     * const { count } = await prisma.webhookEvent.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends WebhookEventDeleteManyArgs>(args?: SelectSubset<T, WebhookEventDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WebhookEvents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WebhookEventUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many WebhookEvents
     * const webhookEvent = await prisma.webhookEvent.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends WebhookEventUpdateManyArgs>(args: SelectSubset<T, WebhookEventUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one WebhookEvent.
     * @param {WebhookEventUpsertArgs} args - Arguments to update or create a WebhookEvent.
     * @example
     * // Update or create a WebhookEvent
     * const webhookEvent = await prisma.webhookEvent.upsert({
     *   create: {
     *     // ... data to create a WebhookEvent
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the WebhookEvent we want to update
     *   }
     * })
     */
    upsert<T extends WebhookEventUpsertArgs>(args: SelectSubset<T, WebhookEventUpsertArgs<ExtArgs>>): Prisma__WebhookEventClient<$Result.GetResult<Prisma.$WebhookEventPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of WebhookEvents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WebhookEventCountArgs} args - Arguments to filter WebhookEvents to count.
     * @example
     * // Count the number of WebhookEvents
     * const count = await prisma.webhookEvent.count({
     *   where: {
     *     // ... the filter for the WebhookEvents we want to count
     *   }
     * })
    **/
    count<T extends WebhookEventCountArgs>(
      args?: Subset<T, WebhookEventCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WebhookEventCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a WebhookEvent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WebhookEventAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WebhookEventAggregateArgs>(args: Subset<T, WebhookEventAggregateArgs>): Prisma.PrismaPromise<GetWebhookEventAggregateType<T>>

    /**
     * Group by WebhookEvent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WebhookEventGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WebhookEventGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WebhookEventGroupByArgs['orderBy'] }
        : { orderBy?: WebhookEventGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WebhookEventGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWebhookEventGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the WebhookEvent model
   */
  readonly fields: WebhookEventFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for WebhookEvent.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__WebhookEventClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    tenant<T extends WebhookEvent$tenantArgs<ExtArgs> = {}>(args?: Subset<T, WebhookEvent$tenantArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the WebhookEvent model
   */ 
  interface WebhookEventFieldRefs {
    readonly id: FieldRef<"WebhookEvent", 'String'>
    readonly tenantId: FieldRef<"WebhookEvent", 'String'>
    readonly eventType: FieldRef<"WebhookEvent", 'String'>
    readonly payload: FieldRef<"WebhookEvent", 'String'>
    readonly status: FieldRef<"WebhookEvent", 'String'>
    readonly error: FieldRef<"WebhookEvent", 'String'>
    readonly createdAt: FieldRef<"WebhookEvent", 'DateTime'>
    readonly processedAt: FieldRef<"WebhookEvent", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * WebhookEvent findUnique
   */
  export type WebhookEventFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WebhookEvent
     */
    select?: WebhookEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WebhookEventInclude<ExtArgs> | null
    /**
     * Filter, which WebhookEvent to fetch.
     */
    where: WebhookEventWhereUniqueInput
  }

  /**
   * WebhookEvent findUniqueOrThrow
   */
  export type WebhookEventFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WebhookEvent
     */
    select?: WebhookEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WebhookEventInclude<ExtArgs> | null
    /**
     * Filter, which WebhookEvent to fetch.
     */
    where: WebhookEventWhereUniqueInput
  }

  /**
   * WebhookEvent findFirst
   */
  export type WebhookEventFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WebhookEvent
     */
    select?: WebhookEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WebhookEventInclude<ExtArgs> | null
    /**
     * Filter, which WebhookEvent to fetch.
     */
    where?: WebhookEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WebhookEvents to fetch.
     */
    orderBy?: WebhookEventOrderByWithRelationInput | WebhookEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WebhookEvents.
     */
    cursor?: WebhookEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WebhookEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WebhookEvents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WebhookEvents.
     */
    distinct?: WebhookEventScalarFieldEnum | WebhookEventScalarFieldEnum[]
  }

  /**
   * WebhookEvent findFirstOrThrow
   */
  export type WebhookEventFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WebhookEvent
     */
    select?: WebhookEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WebhookEventInclude<ExtArgs> | null
    /**
     * Filter, which WebhookEvent to fetch.
     */
    where?: WebhookEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WebhookEvents to fetch.
     */
    orderBy?: WebhookEventOrderByWithRelationInput | WebhookEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WebhookEvents.
     */
    cursor?: WebhookEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WebhookEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WebhookEvents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WebhookEvents.
     */
    distinct?: WebhookEventScalarFieldEnum | WebhookEventScalarFieldEnum[]
  }

  /**
   * WebhookEvent findMany
   */
  export type WebhookEventFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WebhookEvent
     */
    select?: WebhookEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WebhookEventInclude<ExtArgs> | null
    /**
     * Filter, which WebhookEvents to fetch.
     */
    where?: WebhookEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WebhookEvents to fetch.
     */
    orderBy?: WebhookEventOrderByWithRelationInput | WebhookEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing WebhookEvents.
     */
    cursor?: WebhookEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WebhookEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WebhookEvents.
     */
    skip?: number
    distinct?: WebhookEventScalarFieldEnum | WebhookEventScalarFieldEnum[]
  }

  /**
   * WebhookEvent create
   */
  export type WebhookEventCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WebhookEvent
     */
    select?: WebhookEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WebhookEventInclude<ExtArgs> | null
    /**
     * The data needed to create a WebhookEvent.
     */
    data: XOR<WebhookEventCreateInput, WebhookEventUncheckedCreateInput>
  }

  /**
   * WebhookEvent createMany
   */
  export type WebhookEventCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many WebhookEvents.
     */
    data: WebhookEventCreateManyInput | WebhookEventCreateManyInput[]
  }

  /**
   * WebhookEvent createManyAndReturn
   */
  export type WebhookEventCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WebhookEvent
     */
    select?: WebhookEventSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many WebhookEvents.
     */
    data: WebhookEventCreateManyInput | WebhookEventCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WebhookEventIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * WebhookEvent update
   */
  export type WebhookEventUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WebhookEvent
     */
    select?: WebhookEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WebhookEventInclude<ExtArgs> | null
    /**
     * The data needed to update a WebhookEvent.
     */
    data: XOR<WebhookEventUpdateInput, WebhookEventUncheckedUpdateInput>
    /**
     * Choose, which WebhookEvent to update.
     */
    where: WebhookEventWhereUniqueInput
  }

  /**
   * WebhookEvent updateMany
   */
  export type WebhookEventUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update WebhookEvents.
     */
    data: XOR<WebhookEventUpdateManyMutationInput, WebhookEventUncheckedUpdateManyInput>
    /**
     * Filter which WebhookEvents to update
     */
    where?: WebhookEventWhereInput
  }

  /**
   * WebhookEvent upsert
   */
  export type WebhookEventUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WebhookEvent
     */
    select?: WebhookEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WebhookEventInclude<ExtArgs> | null
    /**
     * The filter to search for the WebhookEvent to update in case it exists.
     */
    where: WebhookEventWhereUniqueInput
    /**
     * In case the WebhookEvent found by the `where` argument doesn't exist, create a new WebhookEvent with this data.
     */
    create: XOR<WebhookEventCreateInput, WebhookEventUncheckedCreateInput>
    /**
     * In case the WebhookEvent was found with the provided `where` argument, update it with this data.
     */
    update: XOR<WebhookEventUpdateInput, WebhookEventUncheckedUpdateInput>
  }

  /**
   * WebhookEvent delete
   */
  export type WebhookEventDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WebhookEvent
     */
    select?: WebhookEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WebhookEventInclude<ExtArgs> | null
    /**
     * Filter which WebhookEvent to delete.
     */
    where: WebhookEventWhereUniqueInput
  }

  /**
   * WebhookEvent deleteMany
   */
  export type WebhookEventDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WebhookEvents to delete
     */
    where?: WebhookEventWhereInput
  }

  /**
   * WebhookEvent.tenant
   */
  export type WebhookEvent$tenantArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tenant
     */
    select?: TenantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantInclude<ExtArgs> | null
    where?: TenantWhereInput
  }

  /**
   * WebhookEvent without action
   */
  export type WebhookEventDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WebhookEvent
     */
    select?: WebhookEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WebhookEventInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const TenantScalarFieldEnum: {
    id: 'id',
    name: 'name',
    address: 'address',
    phone: 'phone',
    adminUserId: 'adminUserId',
    timezone: 'timezone',
    plan: 'plan',
    billingContact: 'billingContact',
    status: 'status',
    settings: 'settings',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type TenantScalarFieldEnum = (typeof TenantScalarFieldEnum)[keyof typeof TenantScalarFieldEnum]


  export const UserScalarFieldEnum: {
    id: 'id',
    tenantId: 'tenantId',
    email: 'email',
    passwordHash: 'passwordHash',
    role: 'role',
    name: 'name',
    phone: 'phone',
    isActive: 'isActive',
    lastLogin: 'lastLogin',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const RefreshTokenScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    token: 'token',
    expiresAt: 'expiresAt',
    revoked: 'revoked',
    createdAt: 'createdAt'
  };

  export type RefreshTokenScalarFieldEnum = (typeof RefreshTokenScalarFieldEnum)[keyof typeof RefreshTokenScalarFieldEnum]


  export const SantriScalarFieldEnum: {
    id: 'id',
    tenantId: 'tenantId',
    nisn: 'nisn',
    name: 'name',
    gender: 'gender',
    dob: 'dob',
    kelas: 'kelas',
    room: 'room',
    contact: 'contact',
    address: 'address',
    photo: 'photo',
    status: 'status',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SantriScalarFieldEnum = (typeof SantriScalarFieldEnum)[keyof typeof SantriScalarFieldEnum]


  export const WaliScalarFieldEnum: {
    id: 'id',
    tenantId: 'tenantId',
    name: 'name',
    relation: 'relation',
    phone: 'phone',
    email: 'email',
    address: 'address',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type WaliScalarFieldEnum = (typeof WaliScalarFieldEnum)[keyof typeof WaliScalarFieldEnum]


  export const SantriWaliScalarFieldEnum: {
    santriId: 'santriId',
    waliId: 'waliId',
    isPrimary: 'isPrimary'
  };

  export type SantriWaliScalarFieldEnum = (typeof SantriWaliScalarFieldEnum)[keyof typeof SantriWaliScalarFieldEnum]


  export const IzinScalarFieldEnum: {
    id: 'id',
    tenantId: 'tenantId',
    santriId: 'santriId',
    type: 'type',
    reason: 'reason',
    startAt: 'startAt',
    endAt: 'endAt',
    status: 'status',
    requestedBy: 'requestedBy',
    approvedBy: 'approvedBy',
    approvedAt: 'approvedAt',
    qrCodeData: 'qrCodeData',
    checkoutAt: 'checkoutAt',
    checkoutBy: 'checkoutBy',
    checkinAt: 'checkinAt',
    checkinBy: 'checkinBy',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type IzinScalarFieldEnum = (typeof IzinScalarFieldEnum)[keyof typeof IzinScalarFieldEnum]


  export const CatatanHarianScalarFieldEnum: {
    id: 'id',
    tenantId: 'tenantId',
    santriId: 'santriId',
    authorId: 'authorId',
    date: 'date',
    content: 'content',
    category: 'category',
    attachments: 'attachments',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CatatanHarianScalarFieldEnum = (typeof CatatanHarianScalarFieldEnum)[keyof typeof CatatanHarianScalarFieldEnum]


  export const PengumumanScalarFieldEnum: {
    id: 'id',
    tenantId: 'tenantId',
    title: 'title',
    content: 'content',
    audience: 'audience',
    pinnedUntil: 'pinnedUntil',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PengumumanScalarFieldEnum = (typeof PengumumanScalarFieldEnum)[keyof typeof PengumumanScalarFieldEnum]


  export const InvoiceScalarFieldEnum: {
    id: 'id',
    tenantId: 'tenantId',
    santriId: 'santriId',
    amountDue: 'amountDue',
    dueDate: 'dueDate',
    status: 'status',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type InvoiceScalarFieldEnum = (typeof InvoiceScalarFieldEnum)[keyof typeof InvoiceScalarFieldEnum]


  export const InvoiceLineScalarFieldEnum: {
    id: 'id',
    invoiceId: 'invoiceId',
    description: 'description',
    amount: 'amount',
    type: 'type'
  };

  export type InvoiceLineScalarFieldEnum = (typeof InvoiceLineScalarFieldEnum)[keyof typeof InvoiceLineScalarFieldEnum]


  export const PaymentScalarFieldEnum: {
    id: 'id',
    invoiceId: 'invoiceId',
    method: 'method',
    amount: 'amount',
    status: 'status',
    transactionRef: 'transactionRef',
    paidAt: 'paidAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PaymentScalarFieldEnum = (typeof PaymentScalarFieldEnum)[keyof typeof PaymentScalarFieldEnum]


  export const PelanggaranScalarFieldEnum: {
    id: 'id',
    tenantId: 'tenantId',
    santriId: 'santriId',
    recordedBy: 'recordedBy',
    category: 'category',
    severity: 'severity',
    points: 'points',
    description: 'description',
    date: 'date',
    resolved: 'resolved',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PelanggaranScalarFieldEnum = (typeof PelanggaranScalarFieldEnum)[keyof typeof PelanggaranScalarFieldEnum]


  export const PembinaanScalarFieldEnum: {
    id: 'id',
    tenantId: 'tenantId',
    santriId: 'santriId',
    plan: 'plan',
    targetDate: 'targetDate',
    status: 'status',
    assignedTo: 'assignedTo',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PembinaanScalarFieldEnum = (typeof PembinaanScalarFieldEnum)[keyof typeof PembinaanScalarFieldEnum]


  export const KunjunganScalarFieldEnum: {
    id: 'id',
    tenantId: 'tenantId',
    santriId: 'santriId',
    scheduledAt: 'scheduledAt',
    slot: 'slot',
    visitorLimit: 'visitorLimit',
    status: 'status',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type KunjunganScalarFieldEnum = (typeof KunjunganScalarFieldEnum)[keyof typeof KunjunganScalarFieldEnum]


  export const TamuScalarFieldEnum: {
    id: 'id',
    kunjunganId: 'kunjunganId',
    name: 'name',
    phone: 'phone',
    idNumber: 'idNumber',
    checkinAt: 'checkinAt',
    createdAt: 'createdAt'
  };

  export type TamuScalarFieldEnum = (typeof TamuScalarFieldEnum)[keyof typeof TamuScalarFieldEnum]


  export const HealthRecordScalarFieldEnum: {
    id: 'id',
    tenantId: 'tenantId',
    santriId: 'santriId',
    recordedBy: 'recordedBy',
    symptoms: 'symptoms',
    diagnosis: 'diagnosis',
    actionTaken: 'actionTaken',
    referred: 'referred',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type HealthRecordScalarFieldEnum = (typeof HealthRecordScalarFieldEnum)[keyof typeof HealthRecordScalarFieldEnum]


  export const MedicationScalarFieldEnum: {
    id: 'id',
    santriId: 'santriId',
    medicineName: 'medicineName',
    dose: 'dose',
    schedule: 'schedule',
    givenBy: 'givenBy',
    givenAt: 'givenAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type MedicationScalarFieldEnum = (typeof MedicationScalarFieldEnum)[keyof typeof MedicationScalarFieldEnum]


  export const AuditLogScalarFieldEnum: {
    id: 'id',
    tenantId: 'tenantId',
    userId: 'userId',
    action: 'action',
    entity: 'entity',
    entityId: 'entityId',
    oldValue: 'oldValue',
    newValue: 'newValue',
    ip: 'ip',
    createdAt: 'createdAt'
  };

  export type AuditLogScalarFieldEnum = (typeof AuditLogScalarFieldEnum)[keyof typeof AuditLogScalarFieldEnum]


  export const NotificationScalarFieldEnum: {
    id: 'id',
    tenantId: 'tenantId',
    userId: 'userId',
    type: 'type',
    title: 'title',
    body: 'body',
    read: 'read',
    createdAt: 'createdAt'
  };

  export type NotificationScalarFieldEnum = (typeof NotificationScalarFieldEnum)[keyof typeof NotificationScalarFieldEnum]


  export const WebhookEventScalarFieldEnum: {
    id: 'id',
    tenantId: 'tenantId',
    eventType: 'eventType',
    payload: 'payload',
    status: 'status',
    error: 'error',
    createdAt: 'createdAt',
    processedAt: 'processedAt'
  };

  export type WebhookEventScalarFieldEnum = (typeof WebhookEventScalarFieldEnum)[keyof typeof WebhookEventScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references 
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    
  /**
   * Deep Input Types
   */


  export type TenantWhereInput = {
    AND?: TenantWhereInput | TenantWhereInput[]
    OR?: TenantWhereInput[]
    NOT?: TenantWhereInput | TenantWhereInput[]
    id?: StringFilter<"Tenant"> | string
    name?: StringFilter<"Tenant"> | string
    address?: StringNullableFilter<"Tenant"> | string | null
    phone?: StringNullableFilter<"Tenant"> | string | null
    adminUserId?: StringNullableFilter<"Tenant"> | string | null
    timezone?: StringFilter<"Tenant"> | string
    plan?: StringFilter<"Tenant"> | string
    billingContact?: StringNullableFilter<"Tenant"> | string | null
    status?: StringFilter<"Tenant"> | string
    settings?: StringNullableFilter<"Tenant"> | string | null
    createdAt?: DateTimeFilter<"Tenant"> | Date | string
    updatedAt?: DateTimeFilter<"Tenant"> | Date | string
    users?: UserListRelationFilter
    santri?: SantriListRelationFilter
    wali?: WaliListRelationFilter
    izin?: IzinListRelationFilter
    catatanHarian?: CatatanHarianListRelationFilter
    pengumuman?: PengumumanListRelationFilter
    invoices?: InvoiceListRelationFilter
    pelanggaran?: PelanggaranListRelationFilter
    pembinaan?: PembinaanListRelationFilter
    kunjungan?: KunjunganListRelationFilter
    healthRecords?: HealthRecordListRelationFilter
    auditLogs?: AuditLogListRelationFilter
    notifications?: NotificationListRelationFilter
    webhookEvents?: WebhookEventListRelationFilter
  }

  export type TenantOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    address?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    adminUserId?: SortOrderInput | SortOrder
    timezone?: SortOrder
    plan?: SortOrder
    billingContact?: SortOrderInput | SortOrder
    status?: SortOrder
    settings?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    users?: UserOrderByRelationAggregateInput
    santri?: SantriOrderByRelationAggregateInput
    wali?: WaliOrderByRelationAggregateInput
    izin?: IzinOrderByRelationAggregateInput
    catatanHarian?: CatatanHarianOrderByRelationAggregateInput
    pengumuman?: PengumumanOrderByRelationAggregateInput
    invoices?: InvoiceOrderByRelationAggregateInput
    pelanggaran?: PelanggaranOrderByRelationAggregateInput
    pembinaan?: PembinaanOrderByRelationAggregateInput
    kunjungan?: KunjunganOrderByRelationAggregateInput
    healthRecords?: HealthRecordOrderByRelationAggregateInput
    auditLogs?: AuditLogOrderByRelationAggregateInput
    notifications?: NotificationOrderByRelationAggregateInput
    webhookEvents?: WebhookEventOrderByRelationAggregateInput
  }

  export type TenantWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: TenantWhereInput | TenantWhereInput[]
    OR?: TenantWhereInput[]
    NOT?: TenantWhereInput | TenantWhereInput[]
    name?: StringFilter<"Tenant"> | string
    address?: StringNullableFilter<"Tenant"> | string | null
    phone?: StringNullableFilter<"Tenant"> | string | null
    adminUserId?: StringNullableFilter<"Tenant"> | string | null
    timezone?: StringFilter<"Tenant"> | string
    plan?: StringFilter<"Tenant"> | string
    billingContact?: StringNullableFilter<"Tenant"> | string | null
    status?: StringFilter<"Tenant"> | string
    settings?: StringNullableFilter<"Tenant"> | string | null
    createdAt?: DateTimeFilter<"Tenant"> | Date | string
    updatedAt?: DateTimeFilter<"Tenant"> | Date | string
    users?: UserListRelationFilter
    santri?: SantriListRelationFilter
    wali?: WaliListRelationFilter
    izin?: IzinListRelationFilter
    catatanHarian?: CatatanHarianListRelationFilter
    pengumuman?: PengumumanListRelationFilter
    invoices?: InvoiceListRelationFilter
    pelanggaran?: PelanggaranListRelationFilter
    pembinaan?: PembinaanListRelationFilter
    kunjungan?: KunjunganListRelationFilter
    healthRecords?: HealthRecordListRelationFilter
    auditLogs?: AuditLogListRelationFilter
    notifications?: NotificationListRelationFilter
    webhookEvents?: WebhookEventListRelationFilter
  }, "id">

  export type TenantOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    address?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    adminUserId?: SortOrderInput | SortOrder
    timezone?: SortOrder
    plan?: SortOrder
    billingContact?: SortOrderInput | SortOrder
    status?: SortOrder
    settings?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: TenantCountOrderByAggregateInput
    _max?: TenantMaxOrderByAggregateInput
    _min?: TenantMinOrderByAggregateInput
  }

  export type TenantScalarWhereWithAggregatesInput = {
    AND?: TenantScalarWhereWithAggregatesInput | TenantScalarWhereWithAggregatesInput[]
    OR?: TenantScalarWhereWithAggregatesInput[]
    NOT?: TenantScalarWhereWithAggregatesInput | TenantScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Tenant"> | string
    name?: StringWithAggregatesFilter<"Tenant"> | string
    address?: StringNullableWithAggregatesFilter<"Tenant"> | string | null
    phone?: StringNullableWithAggregatesFilter<"Tenant"> | string | null
    adminUserId?: StringNullableWithAggregatesFilter<"Tenant"> | string | null
    timezone?: StringWithAggregatesFilter<"Tenant"> | string
    plan?: StringWithAggregatesFilter<"Tenant"> | string
    billingContact?: StringNullableWithAggregatesFilter<"Tenant"> | string | null
    status?: StringWithAggregatesFilter<"Tenant"> | string
    settings?: StringNullableWithAggregatesFilter<"Tenant"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Tenant"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Tenant"> | Date | string
  }

  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: StringFilter<"User"> | string
    tenantId?: StringNullableFilter<"User"> | string | null
    email?: StringFilter<"User"> | string
    passwordHash?: StringFilter<"User"> | string
    role?: StringFilter<"User"> | string
    name?: StringFilter<"User"> | string
    phone?: StringNullableFilter<"User"> | string | null
    isActive?: BoolFilter<"User"> | boolean
    lastLogin?: DateTimeNullableFilter<"User"> | Date | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    tenant?: XOR<TenantNullableRelationFilter, TenantWhereInput> | null
    refreshTokens?: RefreshTokenListRelationFilter
    auditLogs?: AuditLogListRelationFilter
    notifications?: NotificationListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    tenantId?: SortOrderInput | SortOrder
    email?: SortOrder
    passwordHash?: SortOrder
    role?: SortOrder
    name?: SortOrder
    phone?: SortOrderInput | SortOrder
    isActive?: SortOrder
    lastLogin?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    tenant?: TenantOrderByWithRelationInput
    refreshTokens?: RefreshTokenOrderByRelationAggregateInput
    auditLogs?: AuditLogOrderByRelationAggregateInput
    notifications?: NotificationOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    tenantId?: StringNullableFilter<"User"> | string | null
    passwordHash?: StringFilter<"User"> | string
    role?: StringFilter<"User"> | string
    name?: StringFilter<"User"> | string
    phone?: StringNullableFilter<"User"> | string | null
    isActive?: BoolFilter<"User"> | boolean
    lastLogin?: DateTimeNullableFilter<"User"> | Date | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    tenant?: XOR<TenantNullableRelationFilter, TenantWhereInput> | null
    refreshTokens?: RefreshTokenListRelationFilter
    auditLogs?: AuditLogListRelationFilter
    notifications?: NotificationListRelationFilter
  }, "id" | "email">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    tenantId?: SortOrderInput | SortOrder
    email?: SortOrder
    passwordHash?: SortOrder
    role?: SortOrder
    name?: SortOrder
    phone?: SortOrderInput | SortOrder
    isActive?: SortOrder
    lastLogin?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"User"> | string
    tenantId?: StringNullableWithAggregatesFilter<"User"> | string | null
    email?: StringWithAggregatesFilter<"User"> | string
    passwordHash?: StringWithAggregatesFilter<"User"> | string
    role?: StringWithAggregatesFilter<"User"> | string
    name?: StringWithAggregatesFilter<"User"> | string
    phone?: StringNullableWithAggregatesFilter<"User"> | string | null
    isActive?: BoolWithAggregatesFilter<"User"> | boolean
    lastLogin?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
  }

  export type RefreshTokenWhereInput = {
    AND?: RefreshTokenWhereInput | RefreshTokenWhereInput[]
    OR?: RefreshTokenWhereInput[]
    NOT?: RefreshTokenWhereInput | RefreshTokenWhereInput[]
    id?: StringFilter<"RefreshToken"> | string
    userId?: StringFilter<"RefreshToken"> | string
    token?: StringFilter<"RefreshToken"> | string
    expiresAt?: DateTimeFilter<"RefreshToken"> | Date | string
    revoked?: BoolFilter<"RefreshToken"> | boolean
    createdAt?: DateTimeFilter<"RefreshToken"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type RefreshTokenOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    token?: SortOrder
    expiresAt?: SortOrder
    revoked?: SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type RefreshTokenWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    token?: string
    AND?: RefreshTokenWhereInput | RefreshTokenWhereInput[]
    OR?: RefreshTokenWhereInput[]
    NOT?: RefreshTokenWhereInput | RefreshTokenWhereInput[]
    userId?: StringFilter<"RefreshToken"> | string
    expiresAt?: DateTimeFilter<"RefreshToken"> | Date | string
    revoked?: BoolFilter<"RefreshToken"> | boolean
    createdAt?: DateTimeFilter<"RefreshToken"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id" | "token">

  export type RefreshTokenOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    token?: SortOrder
    expiresAt?: SortOrder
    revoked?: SortOrder
    createdAt?: SortOrder
    _count?: RefreshTokenCountOrderByAggregateInput
    _max?: RefreshTokenMaxOrderByAggregateInput
    _min?: RefreshTokenMinOrderByAggregateInput
  }

  export type RefreshTokenScalarWhereWithAggregatesInput = {
    AND?: RefreshTokenScalarWhereWithAggregatesInput | RefreshTokenScalarWhereWithAggregatesInput[]
    OR?: RefreshTokenScalarWhereWithAggregatesInput[]
    NOT?: RefreshTokenScalarWhereWithAggregatesInput | RefreshTokenScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"RefreshToken"> | string
    userId?: StringWithAggregatesFilter<"RefreshToken"> | string
    token?: StringWithAggregatesFilter<"RefreshToken"> | string
    expiresAt?: DateTimeWithAggregatesFilter<"RefreshToken"> | Date | string
    revoked?: BoolWithAggregatesFilter<"RefreshToken"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"RefreshToken"> | Date | string
  }

  export type SantriWhereInput = {
    AND?: SantriWhereInput | SantriWhereInput[]
    OR?: SantriWhereInput[]
    NOT?: SantriWhereInput | SantriWhereInput[]
    id?: StringFilter<"Santri"> | string
    tenantId?: StringFilter<"Santri"> | string
    nisn?: StringNullableFilter<"Santri"> | string | null
    name?: StringFilter<"Santri"> | string
    gender?: StringFilter<"Santri"> | string
    dob?: DateTimeNullableFilter<"Santri"> | Date | string | null
    kelas?: StringNullableFilter<"Santri"> | string | null
    room?: StringNullableFilter<"Santri"> | string | null
    contact?: StringNullableFilter<"Santri"> | string | null
    address?: StringNullableFilter<"Santri"> | string | null
    photo?: StringNullableFilter<"Santri"> | string | null
    status?: StringFilter<"Santri"> | string
    createdAt?: DateTimeFilter<"Santri"> | Date | string
    updatedAt?: DateTimeFilter<"Santri"> | Date | string
    tenant?: XOR<TenantRelationFilter, TenantWhereInput>
    walis?: SantriWaliListRelationFilter
    izin?: IzinListRelationFilter
    catatanHarian?: CatatanHarianListRelationFilter
    invoices?: InvoiceListRelationFilter
    pelanggaran?: PelanggaranListRelationFilter
    pembinaan?: PembinaanListRelationFilter
    kunjungan?: KunjunganListRelationFilter
    healthRecords?: HealthRecordListRelationFilter
    medications?: MedicationListRelationFilter
  }

  export type SantriOrderByWithRelationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    nisn?: SortOrderInput | SortOrder
    name?: SortOrder
    gender?: SortOrder
    dob?: SortOrderInput | SortOrder
    kelas?: SortOrderInput | SortOrder
    room?: SortOrderInput | SortOrder
    contact?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    photo?: SortOrderInput | SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    tenant?: TenantOrderByWithRelationInput
    walis?: SantriWaliOrderByRelationAggregateInput
    izin?: IzinOrderByRelationAggregateInput
    catatanHarian?: CatatanHarianOrderByRelationAggregateInput
    invoices?: InvoiceOrderByRelationAggregateInput
    pelanggaran?: PelanggaranOrderByRelationAggregateInput
    pembinaan?: PembinaanOrderByRelationAggregateInput
    kunjungan?: KunjunganOrderByRelationAggregateInput
    healthRecords?: HealthRecordOrderByRelationAggregateInput
    medications?: MedicationOrderByRelationAggregateInput
  }

  export type SantriWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: SantriWhereInput | SantriWhereInput[]
    OR?: SantriWhereInput[]
    NOT?: SantriWhereInput | SantriWhereInput[]
    tenantId?: StringFilter<"Santri"> | string
    nisn?: StringNullableFilter<"Santri"> | string | null
    name?: StringFilter<"Santri"> | string
    gender?: StringFilter<"Santri"> | string
    dob?: DateTimeNullableFilter<"Santri"> | Date | string | null
    kelas?: StringNullableFilter<"Santri"> | string | null
    room?: StringNullableFilter<"Santri"> | string | null
    contact?: StringNullableFilter<"Santri"> | string | null
    address?: StringNullableFilter<"Santri"> | string | null
    photo?: StringNullableFilter<"Santri"> | string | null
    status?: StringFilter<"Santri"> | string
    createdAt?: DateTimeFilter<"Santri"> | Date | string
    updatedAt?: DateTimeFilter<"Santri"> | Date | string
    tenant?: XOR<TenantRelationFilter, TenantWhereInput>
    walis?: SantriWaliListRelationFilter
    izin?: IzinListRelationFilter
    catatanHarian?: CatatanHarianListRelationFilter
    invoices?: InvoiceListRelationFilter
    pelanggaran?: PelanggaranListRelationFilter
    pembinaan?: PembinaanListRelationFilter
    kunjungan?: KunjunganListRelationFilter
    healthRecords?: HealthRecordListRelationFilter
    medications?: MedicationListRelationFilter
  }, "id">

  export type SantriOrderByWithAggregationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    nisn?: SortOrderInput | SortOrder
    name?: SortOrder
    gender?: SortOrder
    dob?: SortOrderInput | SortOrder
    kelas?: SortOrderInput | SortOrder
    room?: SortOrderInput | SortOrder
    contact?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    photo?: SortOrderInput | SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: SantriCountOrderByAggregateInput
    _max?: SantriMaxOrderByAggregateInput
    _min?: SantriMinOrderByAggregateInput
  }

  export type SantriScalarWhereWithAggregatesInput = {
    AND?: SantriScalarWhereWithAggregatesInput | SantriScalarWhereWithAggregatesInput[]
    OR?: SantriScalarWhereWithAggregatesInput[]
    NOT?: SantriScalarWhereWithAggregatesInput | SantriScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Santri"> | string
    tenantId?: StringWithAggregatesFilter<"Santri"> | string
    nisn?: StringNullableWithAggregatesFilter<"Santri"> | string | null
    name?: StringWithAggregatesFilter<"Santri"> | string
    gender?: StringWithAggregatesFilter<"Santri"> | string
    dob?: DateTimeNullableWithAggregatesFilter<"Santri"> | Date | string | null
    kelas?: StringNullableWithAggregatesFilter<"Santri"> | string | null
    room?: StringNullableWithAggregatesFilter<"Santri"> | string | null
    contact?: StringNullableWithAggregatesFilter<"Santri"> | string | null
    address?: StringNullableWithAggregatesFilter<"Santri"> | string | null
    photo?: StringNullableWithAggregatesFilter<"Santri"> | string | null
    status?: StringWithAggregatesFilter<"Santri"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Santri"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Santri"> | Date | string
  }

  export type WaliWhereInput = {
    AND?: WaliWhereInput | WaliWhereInput[]
    OR?: WaliWhereInput[]
    NOT?: WaliWhereInput | WaliWhereInput[]
    id?: StringFilter<"Wali"> | string
    tenantId?: StringFilter<"Wali"> | string
    name?: StringFilter<"Wali"> | string
    relation?: StringFilter<"Wali"> | string
    phone?: StringFilter<"Wali"> | string
    email?: StringNullableFilter<"Wali"> | string | null
    address?: StringNullableFilter<"Wali"> | string | null
    createdAt?: DateTimeFilter<"Wali"> | Date | string
    updatedAt?: DateTimeFilter<"Wali"> | Date | string
    tenant?: XOR<TenantRelationFilter, TenantWhereInput>
    santris?: SantriWaliListRelationFilter
  }

  export type WaliOrderByWithRelationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    name?: SortOrder
    relation?: SortOrder
    phone?: SortOrder
    email?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    tenant?: TenantOrderByWithRelationInput
    santris?: SantriWaliOrderByRelationAggregateInput
  }

  export type WaliWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: WaliWhereInput | WaliWhereInput[]
    OR?: WaliWhereInput[]
    NOT?: WaliWhereInput | WaliWhereInput[]
    tenantId?: StringFilter<"Wali"> | string
    name?: StringFilter<"Wali"> | string
    relation?: StringFilter<"Wali"> | string
    phone?: StringFilter<"Wali"> | string
    email?: StringNullableFilter<"Wali"> | string | null
    address?: StringNullableFilter<"Wali"> | string | null
    createdAt?: DateTimeFilter<"Wali"> | Date | string
    updatedAt?: DateTimeFilter<"Wali"> | Date | string
    tenant?: XOR<TenantRelationFilter, TenantWhereInput>
    santris?: SantriWaliListRelationFilter
  }, "id">

  export type WaliOrderByWithAggregationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    name?: SortOrder
    relation?: SortOrder
    phone?: SortOrder
    email?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: WaliCountOrderByAggregateInput
    _max?: WaliMaxOrderByAggregateInput
    _min?: WaliMinOrderByAggregateInput
  }

  export type WaliScalarWhereWithAggregatesInput = {
    AND?: WaliScalarWhereWithAggregatesInput | WaliScalarWhereWithAggregatesInput[]
    OR?: WaliScalarWhereWithAggregatesInput[]
    NOT?: WaliScalarWhereWithAggregatesInput | WaliScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Wali"> | string
    tenantId?: StringWithAggregatesFilter<"Wali"> | string
    name?: StringWithAggregatesFilter<"Wali"> | string
    relation?: StringWithAggregatesFilter<"Wali"> | string
    phone?: StringWithAggregatesFilter<"Wali"> | string
    email?: StringNullableWithAggregatesFilter<"Wali"> | string | null
    address?: StringNullableWithAggregatesFilter<"Wali"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Wali"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Wali"> | Date | string
  }

  export type SantriWaliWhereInput = {
    AND?: SantriWaliWhereInput | SantriWaliWhereInput[]
    OR?: SantriWaliWhereInput[]
    NOT?: SantriWaliWhereInput | SantriWaliWhereInput[]
    santriId?: StringFilter<"SantriWali"> | string
    waliId?: StringFilter<"SantriWali"> | string
    isPrimary?: BoolFilter<"SantriWali"> | boolean
    santri?: XOR<SantriRelationFilter, SantriWhereInput>
    wali?: XOR<WaliRelationFilter, WaliWhereInput>
  }

  export type SantriWaliOrderByWithRelationInput = {
    santriId?: SortOrder
    waliId?: SortOrder
    isPrimary?: SortOrder
    santri?: SantriOrderByWithRelationInput
    wali?: WaliOrderByWithRelationInput
  }

  export type SantriWaliWhereUniqueInput = Prisma.AtLeast<{
    santriId_waliId?: SantriWaliSantriIdWaliIdCompoundUniqueInput
    AND?: SantriWaliWhereInput | SantriWaliWhereInput[]
    OR?: SantriWaliWhereInput[]
    NOT?: SantriWaliWhereInput | SantriWaliWhereInput[]
    santriId?: StringFilter<"SantriWali"> | string
    waliId?: StringFilter<"SantriWali"> | string
    isPrimary?: BoolFilter<"SantriWali"> | boolean
    santri?: XOR<SantriRelationFilter, SantriWhereInput>
    wali?: XOR<WaliRelationFilter, WaliWhereInput>
  }, "santriId_waliId">

  export type SantriWaliOrderByWithAggregationInput = {
    santriId?: SortOrder
    waliId?: SortOrder
    isPrimary?: SortOrder
    _count?: SantriWaliCountOrderByAggregateInput
    _max?: SantriWaliMaxOrderByAggregateInput
    _min?: SantriWaliMinOrderByAggregateInput
  }

  export type SantriWaliScalarWhereWithAggregatesInput = {
    AND?: SantriWaliScalarWhereWithAggregatesInput | SantriWaliScalarWhereWithAggregatesInput[]
    OR?: SantriWaliScalarWhereWithAggregatesInput[]
    NOT?: SantriWaliScalarWhereWithAggregatesInput | SantriWaliScalarWhereWithAggregatesInput[]
    santriId?: StringWithAggregatesFilter<"SantriWali"> | string
    waliId?: StringWithAggregatesFilter<"SantriWali"> | string
    isPrimary?: BoolWithAggregatesFilter<"SantriWali"> | boolean
  }

  export type IzinWhereInput = {
    AND?: IzinWhereInput | IzinWhereInput[]
    OR?: IzinWhereInput[]
    NOT?: IzinWhereInput | IzinWhereInput[]
    id?: StringFilter<"Izin"> | string
    tenantId?: StringFilter<"Izin"> | string
    santriId?: StringFilter<"Izin"> | string
    type?: StringFilter<"Izin"> | string
    reason?: StringFilter<"Izin"> | string
    startAt?: DateTimeFilter<"Izin"> | Date | string
    endAt?: DateTimeFilter<"Izin"> | Date | string
    status?: StringFilter<"Izin"> | string
    requestedBy?: StringFilter<"Izin"> | string
    approvedBy?: StringNullableFilter<"Izin"> | string | null
    approvedAt?: DateTimeNullableFilter<"Izin"> | Date | string | null
    qrCodeData?: StringNullableFilter<"Izin"> | string | null
    checkoutAt?: DateTimeNullableFilter<"Izin"> | Date | string | null
    checkoutBy?: StringNullableFilter<"Izin"> | string | null
    checkinAt?: DateTimeNullableFilter<"Izin"> | Date | string | null
    checkinBy?: StringNullableFilter<"Izin"> | string | null
    createdAt?: DateTimeFilter<"Izin"> | Date | string
    updatedAt?: DateTimeFilter<"Izin"> | Date | string
    tenant?: XOR<TenantRelationFilter, TenantWhereInput>
    santri?: XOR<SantriRelationFilter, SantriWhereInput>
  }

  export type IzinOrderByWithRelationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    santriId?: SortOrder
    type?: SortOrder
    reason?: SortOrder
    startAt?: SortOrder
    endAt?: SortOrder
    status?: SortOrder
    requestedBy?: SortOrder
    approvedBy?: SortOrderInput | SortOrder
    approvedAt?: SortOrderInput | SortOrder
    qrCodeData?: SortOrderInput | SortOrder
    checkoutAt?: SortOrderInput | SortOrder
    checkoutBy?: SortOrderInput | SortOrder
    checkinAt?: SortOrderInput | SortOrder
    checkinBy?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    tenant?: TenantOrderByWithRelationInput
    santri?: SantriOrderByWithRelationInput
  }

  export type IzinWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    qrCodeData?: string
    AND?: IzinWhereInput | IzinWhereInput[]
    OR?: IzinWhereInput[]
    NOT?: IzinWhereInput | IzinWhereInput[]
    tenantId?: StringFilter<"Izin"> | string
    santriId?: StringFilter<"Izin"> | string
    type?: StringFilter<"Izin"> | string
    reason?: StringFilter<"Izin"> | string
    startAt?: DateTimeFilter<"Izin"> | Date | string
    endAt?: DateTimeFilter<"Izin"> | Date | string
    status?: StringFilter<"Izin"> | string
    requestedBy?: StringFilter<"Izin"> | string
    approvedBy?: StringNullableFilter<"Izin"> | string | null
    approvedAt?: DateTimeNullableFilter<"Izin"> | Date | string | null
    checkoutAt?: DateTimeNullableFilter<"Izin"> | Date | string | null
    checkoutBy?: StringNullableFilter<"Izin"> | string | null
    checkinAt?: DateTimeNullableFilter<"Izin"> | Date | string | null
    checkinBy?: StringNullableFilter<"Izin"> | string | null
    createdAt?: DateTimeFilter<"Izin"> | Date | string
    updatedAt?: DateTimeFilter<"Izin"> | Date | string
    tenant?: XOR<TenantRelationFilter, TenantWhereInput>
    santri?: XOR<SantriRelationFilter, SantriWhereInput>
  }, "id" | "qrCodeData">

  export type IzinOrderByWithAggregationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    santriId?: SortOrder
    type?: SortOrder
    reason?: SortOrder
    startAt?: SortOrder
    endAt?: SortOrder
    status?: SortOrder
    requestedBy?: SortOrder
    approvedBy?: SortOrderInput | SortOrder
    approvedAt?: SortOrderInput | SortOrder
    qrCodeData?: SortOrderInput | SortOrder
    checkoutAt?: SortOrderInput | SortOrder
    checkoutBy?: SortOrderInput | SortOrder
    checkinAt?: SortOrderInput | SortOrder
    checkinBy?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: IzinCountOrderByAggregateInput
    _max?: IzinMaxOrderByAggregateInput
    _min?: IzinMinOrderByAggregateInput
  }

  export type IzinScalarWhereWithAggregatesInput = {
    AND?: IzinScalarWhereWithAggregatesInput | IzinScalarWhereWithAggregatesInput[]
    OR?: IzinScalarWhereWithAggregatesInput[]
    NOT?: IzinScalarWhereWithAggregatesInput | IzinScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Izin"> | string
    tenantId?: StringWithAggregatesFilter<"Izin"> | string
    santriId?: StringWithAggregatesFilter<"Izin"> | string
    type?: StringWithAggregatesFilter<"Izin"> | string
    reason?: StringWithAggregatesFilter<"Izin"> | string
    startAt?: DateTimeWithAggregatesFilter<"Izin"> | Date | string
    endAt?: DateTimeWithAggregatesFilter<"Izin"> | Date | string
    status?: StringWithAggregatesFilter<"Izin"> | string
    requestedBy?: StringWithAggregatesFilter<"Izin"> | string
    approvedBy?: StringNullableWithAggregatesFilter<"Izin"> | string | null
    approvedAt?: DateTimeNullableWithAggregatesFilter<"Izin"> | Date | string | null
    qrCodeData?: StringNullableWithAggregatesFilter<"Izin"> | string | null
    checkoutAt?: DateTimeNullableWithAggregatesFilter<"Izin"> | Date | string | null
    checkoutBy?: StringNullableWithAggregatesFilter<"Izin"> | string | null
    checkinAt?: DateTimeNullableWithAggregatesFilter<"Izin"> | Date | string | null
    checkinBy?: StringNullableWithAggregatesFilter<"Izin"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Izin"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Izin"> | Date | string
  }

  export type CatatanHarianWhereInput = {
    AND?: CatatanHarianWhereInput | CatatanHarianWhereInput[]
    OR?: CatatanHarianWhereInput[]
    NOT?: CatatanHarianWhereInput | CatatanHarianWhereInput[]
    id?: StringFilter<"CatatanHarian"> | string
    tenantId?: StringFilter<"CatatanHarian"> | string
    santriId?: StringFilter<"CatatanHarian"> | string
    authorId?: StringFilter<"CatatanHarian"> | string
    date?: DateTimeFilter<"CatatanHarian"> | Date | string
    content?: StringFilter<"CatatanHarian"> | string
    category?: StringFilter<"CatatanHarian"> | string
    attachments?: StringNullableFilter<"CatatanHarian"> | string | null
    createdAt?: DateTimeFilter<"CatatanHarian"> | Date | string
    updatedAt?: DateTimeFilter<"CatatanHarian"> | Date | string
    tenant?: XOR<TenantRelationFilter, TenantWhereInput>
    santri?: XOR<SantriRelationFilter, SantriWhereInput>
  }

  export type CatatanHarianOrderByWithRelationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    santriId?: SortOrder
    authorId?: SortOrder
    date?: SortOrder
    content?: SortOrder
    category?: SortOrder
    attachments?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    tenant?: TenantOrderByWithRelationInput
    santri?: SantriOrderByWithRelationInput
  }

  export type CatatanHarianWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CatatanHarianWhereInput | CatatanHarianWhereInput[]
    OR?: CatatanHarianWhereInput[]
    NOT?: CatatanHarianWhereInput | CatatanHarianWhereInput[]
    tenantId?: StringFilter<"CatatanHarian"> | string
    santriId?: StringFilter<"CatatanHarian"> | string
    authorId?: StringFilter<"CatatanHarian"> | string
    date?: DateTimeFilter<"CatatanHarian"> | Date | string
    content?: StringFilter<"CatatanHarian"> | string
    category?: StringFilter<"CatatanHarian"> | string
    attachments?: StringNullableFilter<"CatatanHarian"> | string | null
    createdAt?: DateTimeFilter<"CatatanHarian"> | Date | string
    updatedAt?: DateTimeFilter<"CatatanHarian"> | Date | string
    tenant?: XOR<TenantRelationFilter, TenantWhereInput>
    santri?: XOR<SantriRelationFilter, SantriWhereInput>
  }, "id">

  export type CatatanHarianOrderByWithAggregationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    santriId?: SortOrder
    authorId?: SortOrder
    date?: SortOrder
    content?: SortOrder
    category?: SortOrder
    attachments?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CatatanHarianCountOrderByAggregateInput
    _max?: CatatanHarianMaxOrderByAggregateInput
    _min?: CatatanHarianMinOrderByAggregateInput
  }

  export type CatatanHarianScalarWhereWithAggregatesInput = {
    AND?: CatatanHarianScalarWhereWithAggregatesInput | CatatanHarianScalarWhereWithAggregatesInput[]
    OR?: CatatanHarianScalarWhereWithAggregatesInput[]
    NOT?: CatatanHarianScalarWhereWithAggregatesInput | CatatanHarianScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CatatanHarian"> | string
    tenantId?: StringWithAggregatesFilter<"CatatanHarian"> | string
    santriId?: StringWithAggregatesFilter<"CatatanHarian"> | string
    authorId?: StringWithAggregatesFilter<"CatatanHarian"> | string
    date?: DateTimeWithAggregatesFilter<"CatatanHarian"> | Date | string
    content?: StringWithAggregatesFilter<"CatatanHarian"> | string
    category?: StringWithAggregatesFilter<"CatatanHarian"> | string
    attachments?: StringNullableWithAggregatesFilter<"CatatanHarian"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"CatatanHarian"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"CatatanHarian"> | Date | string
  }

  export type PengumumanWhereInput = {
    AND?: PengumumanWhereInput | PengumumanWhereInput[]
    OR?: PengumumanWhereInput[]
    NOT?: PengumumanWhereInput | PengumumanWhereInput[]
    id?: StringFilter<"Pengumuman"> | string
    tenantId?: StringFilter<"Pengumuman"> | string
    title?: StringFilter<"Pengumuman"> | string
    content?: StringFilter<"Pengumuman"> | string
    audience?: StringFilter<"Pengumuman"> | string
    pinnedUntil?: DateTimeNullableFilter<"Pengumuman"> | Date | string | null
    createdAt?: DateTimeFilter<"Pengumuman"> | Date | string
    updatedAt?: DateTimeFilter<"Pengumuman"> | Date | string
    tenant?: XOR<TenantRelationFilter, TenantWhereInput>
  }

  export type PengumumanOrderByWithRelationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    title?: SortOrder
    content?: SortOrder
    audience?: SortOrder
    pinnedUntil?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    tenant?: TenantOrderByWithRelationInput
  }

  export type PengumumanWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PengumumanWhereInput | PengumumanWhereInput[]
    OR?: PengumumanWhereInput[]
    NOT?: PengumumanWhereInput | PengumumanWhereInput[]
    tenantId?: StringFilter<"Pengumuman"> | string
    title?: StringFilter<"Pengumuman"> | string
    content?: StringFilter<"Pengumuman"> | string
    audience?: StringFilter<"Pengumuman"> | string
    pinnedUntil?: DateTimeNullableFilter<"Pengumuman"> | Date | string | null
    createdAt?: DateTimeFilter<"Pengumuman"> | Date | string
    updatedAt?: DateTimeFilter<"Pengumuman"> | Date | string
    tenant?: XOR<TenantRelationFilter, TenantWhereInput>
  }, "id">

  export type PengumumanOrderByWithAggregationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    title?: SortOrder
    content?: SortOrder
    audience?: SortOrder
    pinnedUntil?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PengumumanCountOrderByAggregateInput
    _max?: PengumumanMaxOrderByAggregateInput
    _min?: PengumumanMinOrderByAggregateInput
  }

  export type PengumumanScalarWhereWithAggregatesInput = {
    AND?: PengumumanScalarWhereWithAggregatesInput | PengumumanScalarWhereWithAggregatesInput[]
    OR?: PengumumanScalarWhereWithAggregatesInput[]
    NOT?: PengumumanScalarWhereWithAggregatesInput | PengumumanScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Pengumuman"> | string
    tenantId?: StringWithAggregatesFilter<"Pengumuman"> | string
    title?: StringWithAggregatesFilter<"Pengumuman"> | string
    content?: StringWithAggregatesFilter<"Pengumuman"> | string
    audience?: StringWithAggregatesFilter<"Pengumuman"> | string
    pinnedUntil?: DateTimeNullableWithAggregatesFilter<"Pengumuman"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Pengumuman"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Pengumuman"> | Date | string
  }

  export type InvoiceWhereInput = {
    AND?: InvoiceWhereInput | InvoiceWhereInput[]
    OR?: InvoiceWhereInput[]
    NOT?: InvoiceWhereInput | InvoiceWhereInput[]
    id?: StringFilter<"Invoice"> | string
    tenantId?: StringFilter<"Invoice"> | string
    santriId?: StringFilter<"Invoice"> | string
    amountDue?: FloatFilter<"Invoice"> | number
    dueDate?: DateTimeFilter<"Invoice"> | Date | string
    status?: StringFilter<"Invoice"> | string
    createdAt?: DateTimeFilter<"Invoice"> | Date | string
    updatedAt?: DateTimeFilter<"Invoice"> | Date | string
    tenant?: XOR<TenantRelationFilter, TenantWhereInput>
    santri?: XOR<SantriRelationFilter, SantriWhereInput>
    lines?: InvoiceLineListRelationFilter
    payments?: PaymentListRelationFilter
  }

  export type InvoiceOrderByWithRelationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    santriId?: SortOrder
    amountDue?: SortOrder
    dueDate?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    tenant?: TenantOrderByWithRelationInput
    santri?: SantriOrderByWithRelationInput
    lines?: InvoiceLineOrderByRelationAggregateInput
    payments?: PaymentOrderByRelationAggregateInput
  }

  export type InvoiceWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: InvoiceWhereInput | InvoiceWhereInput[]
    OR?: InvoiceWhereInput[]
    NOT?: InvoiceWhereInput | InvoiceWhereInput[]
    tenantId?: StringFilter<"Invoice"> | string
    santriId?: StringFilter<"Invoice"> | string
    amountDue?: FloatFilter<"Invoice"> | number
    dueDate?: DateTimeFilter<"Invoice"> | Date | string
    status?: StringFilter<"Invoice"> | string
    createdAt?: DateTimeFilter<"Invoice"> | Date | string
    updatedAt?: DateTimeFilter<"Invoice"> | Date | string
    tenant?: XOR<TenantRelationFilter, TenantWhereInput>
    santri?: XOR<SantriRelationFilter, SantriWhereInput>
    lines?: InvoiceLineListRelationFilter
    payments?: PaymentListRelationFilter
  }, "id">

  export type InvoiceOrderByWithAggregationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    santriId?: SortOrder
    amountDue?: SortOrder
    dueDate?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: InvoiceCountOrderByAggregateInput
    _avg?: InvoiceAvgOrderByAggregateInput
    _max?: InvoiceMaxOrderByAggregateInput
    _min?: InvoiceMinOrderByAggregateInput
    _sum?: InvoiceSumOrderByAggregateInput
  }

  export type InvoiceScalarWhereWithAggregatesInput = {
    AND?: InvoiceScalarWhereWithAggregatesInput | InvoiceScalarWhereWithAggregatesInput[]
    OR?: InvoiceScalarWhereWithAggregatesInput[]
    NOT?: InvoiceScalarWhereWithAggregatesInput | InvoiceScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Invoice"> | string
    tenantId?: StringWithAggregatesFilter<"Invoice"> | string
    santriId?: StringWithAggregatesFilter<"Invoice"> | string
    amountDue?: FloatWithAggregatesFilter<"Invoice"> | number
    dueDate?: DateTimeWithAggregatesFilter<"Invoice"> | Date | string
    status?: StringWithAggregatesFilter<"Invoice"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Invoice"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Invoice"> | Date | string
  }

  export type InvoiceLineWhereInput = {
    AND?: InvoiceLineWhereInput | InvoiceLineWhereInput[]
    OR?: InvoiceLineWhereInput[]
    NOT?: InvoiceLineWhereInput | InvoiceLineWhereInput[]
    id?: StringFilter<"InvoiceLine"> | string
    invoiceId?: StringFilter<"InvoiceLine"> | string
    description?: StringFilter<"InvoiceLine"> | string
    amount?: FloatFilter<"InvoiceLine"> | number
    type?: StringFilter<"InvoiceLine"> | string
    invoice?: XOR<InvoiceRelationFilter, InvoiceWhereInput>
  }

  export type InvoiceLineOrderByWithRelationInput = {
    id?: SortOrder
    invoiceId?: SortOrder
    description?: SortOrder
    amount?: SortOrder
    type?: SortOrder
    invoice?: InvoiceOrderByWithRelationInput
  }

  export type InvoiceLineWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: InvoiceLineWhereInput | InvoiceLineWhereInput[]
    OR?: InvoiceLineWhereInput[]
    NOT?: InvoiceLineWhereInput | InvoiceLineWhereInput[]
    invoiceId?: StringFilter<"InvoiceLine"> | string
    description?: StringFilter<"InvoiceLine"> | string
    amount?: FloatFilter<"InvoiceLine"> | number
    type?: StringFilter<"InvoiceLine"> | string
    invoice?: XOR<InvoiceRelationFilter, InvoiceWhereInput>
  }, "id">

  export type InvoiceLineOrderByWithAggregationInput = {
    id?: SortOrder
    invoiceId?: SortOrder
    description?: SortOrder
    amount?: SortOrder
    type?: SortOrder
    _count?: InvoiceLineCountOrderByAggregateInput
    _avg?: InvoiceLineAvgOrderByAggregateInput
    _max?: InvoiceLineMaxOrderByAggregateInput
    _min?: InvoiceLineMinOrderByAggregateInput
    _sum?: InvoiceLineSumOrderByAggregateInput
  }

  export type InvoiceLineScalarWhereWithAggregatesInput = {
    AND?: InvoiceLineScalarWhereWithAggregatesInput | InvoiceLineScalarWhereWithAggregatesInput[]
    OR?: InvoiceLineScalarWhereWithAggregatesInput[]
    NOT?: InvoiceLineScalarWhereWithAggregatesInput | InvoiceLineScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"InvoiceLine"> | string
    invoiceId?: StringWithAggregatesFilter<"InvoiceLine"> | string
    description?: StringWithAggregatesFilter<"InvoiceLine"> | string
    amount?: FloatWithAggregatesFilter<"InvoiceLine"> | number
    type?: StringWithAggregatesFilter<"InvoiceLine"> | string
  }

  export type PaymentWhereInput = {
    AND?: PaymentWhereInput | PaymentWhereInput[]
    OR?: PaymentWhereInput[]
    NOT?: PaymentWhereInput | PaymentWhereInput[]
    id?: StringFilter<"Payment"> | string
    invoiceId?: StringFilter<"Payment"> | string
    method?: StringFilter<"Payment"> | string
    amount?: FloatFilter<"Payment"> | number
    status?: StringFilter<"Payment"> | string
    transactionRef?: StringNullableFilter<"Payment"> | string | null
    paidAt?: DateTimeNullableFilter<"Payment"> | Date | string | null
    createdAt?: DateTimeFilter<"Payment"> | Date | string
    updatedAt?: DateTimeFilter<"Payment"> | Date | string
    invoice?: XOR<InvoiceRelationFilter, InvoiceWhereInput>
  }

  export type PaymentOrderByWithRelationInput = {
    id?: SortOrder
    invoiceId?: SortOrder
    method?: SortOrder
    amount?: SortOrder
    status?: SortOrder
    transactionRef?: SortOrderInput | SortOrder
    paidAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    invoice?: InvoiceOrderByWithRelationInput
  }

  export type PaymentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PaymentWhereInput | PaymentWhereInput[]
    OR?: PaymentWhereInput[]
    NOT?: PaymentWhereInput | PaymentWhereInput[]
    invoiceId?: StringFilter<"Payment"> | string
    method?: StringFilter<"Payment"> | string
    amount?: FloatFilter<"Payment"> | number
    status?: StringFilter<"Payment"> | string
    transactionRef?: StringNullableFilter<"Payment"> | string | null
    paidAt?: DateTimeNullableFilter<"Payment"> | Date | string | null
    createdAt?: DateTimeFilter<"Payment"> | Date | string
    updatedAt?: DateTimeFilter<"Payment"> | Date | string
    invoice?: XOR<InvoiceRelationFilter, InvoiceWhereInput>
  }, "id">

  export type PaymentOrderByWithAggregationInput = {
    id?: SortOrder
    invoiceId?: SortOrder
    method?: SortOrder
    amount?: SortOrder
    status?: SortOrder
    transactionRef?: SortOrderInput | SortOrder
    paidAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PaymentCountOrderByAggregateInput
    _avg?: PaymentAvgOrderByAggregateInput
    _max?: PaymentMaxOrderByAggregateInput
    _min?: PaymentMinOrderByAggregateInput
    _sum?: PaymentSumOrderByAggregateInput
  }

  export type PaymentScalarWhereWithAggregatesInput = {
    AND?: PaymentScalarWhereWithAggregatesInput | PaymentScalarWhereWithAggregatesInput[]
    OR?: PaymentScalarWhereWithAggregatesInput[]
    NOT?: PaymentScalarWhereWithAggregatesInput | PaymentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Payment"> | string
    invoiceId?: StringWithAggregatesFilter<"Payment"> | string
    method?: StringWithAggregatesFilter<"Payment"> | string
    amount?: FloatWithAggregatesFilter<"Payment"> | number
    status?: StringWithAggregatesFilter<"Payment"> | string
    transactionRef?: StringNullableWithAggregatesFilter<"Payment"> | string | null
    paidAt?: DateTimeNullableWithAggregatesFilter<"Payment"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Payment"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Payment"> | Date | string
  }

  export type PelanggaranWhereInput = {
    AND?: PelanggaranWhereInput | PelanggaranWhereInput[]
    OR?: PelanggaranWhereInput[]
    NOT?: PelanggaranWhereInput | PelanggaranWhereInput[]
    id?: StringFilter<"Pelanggaran"> | string
    tenantId?: StringFilter<"Pelanggaran"> | string
    santriId?: StringFilter<"Pelanggaran"> | string
    recordedBy?: StringFilter<"Pelanggaran"> | string
    category?: StringFilter<"Pelanggaran"> | string
    severity?: IntFilter<"Pelanggaran"> | number
    points?: IntFilter<"Pelanggaran"> | number
    description?: StringFilter<"Pelanggaran"> | string
    date?: DateTimeFilter<"Pelanggaran"> | Date | string
    resolved?: BoolFilter<"Pelanggaran"> | boolean
    createdAt?: DateTimeFilter<"Pelanggaran"> | Date | string
    updatedAt?: DateTimeFilter<"Pelanggaran"> | Date | string
    tenant?: XOR<TenantRelationFilter, TenantWhereInput>
    santri?: XOR<SantriRelationFilter, SantriWhereInput>
  }

  export type PelanggaranOrderByWithRelationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    santriId?: SortOrder
    recordedBy?: SortOrder
    category?: SortOrder
    severity?: SortOrder
    points?: SortOrder
    description?: SortOrder
    date?: SortOrder
    resolved?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    tenant?: TenantOrderByWithRelationInput
    santri?: SantriOrderByWithRelationInput
  }

  export type PelanggaranWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PelanggaranWhereInput | PelanggaranWhereInput[]
    OR?: PelanggaranWhereInput[]
    NOT?: PelanggaranWhereInput | PelanggaranWhereInput[]
    tenantId?: StringFilter<"Pelanggaran"> | string
    santriId?: StringFilter<"Pelanggaran"> | string
    recordedBy?: StringFilter<"Pelanggaran"> | string
    category?: StringFilter<"Pelanggaran"> | string
    severity?: IntFilter<"Pelanggaran"> | number
    points?: IntFilter<"Pelanggaran"> | number
    description?: StringFilter<"Pelanggaran"> | string
    date?: DateTimeFilter<"Pelanggaran"> | Date | string
    resolved?: BoolFilter<"Pelanggaran"> | boolean
    createdAt?: DateTimeFilter<"Pelanggaran"> | Date | string
    updatedAt?: DateTimeFilter<"Pelanggaran"> | Date | string
    tenant?: XOR<TenantRelationFilter, TenantWhereInput>
    santri?: XOR<SantriRelationFilter, SantriWhereInput>
  }, "id">

  export type PelanggaranOrderByWithAggregationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    santriId?: SortOrder
    recordedBy?: SortOrder
    category?: SortOrder
    severity?: SortOrder
    points?: SortOrder
    description?: SortOrder
    date?: SortOrder
    resolved?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PelanggaranCountOrderByAggregateInput
    _avg?: PelanggaranAvgOrderByAggregateInput
    _max?: PelanggaranMaxOrderByAggregateInput
    _min?: PelanggaranMinOrderByAggregateInput
    _sum?: PelanggaranSumOrderByAggregateInput
  }

  export type PelanggaranScalarWhereWithAggregatesInput = {
    AND?: PelanggaranScalarWhereWithAggregatesInput | PelanggaranScalarWhereWithAggregatesInput[]
    OR?: PelanggaranScalarWhereWithAggregatesInput[]
    NOT?: PelanggaranScalarWhereWithAggregatesInput | PelanggaranScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Pelanggaran"> | string
    tenantId?: StringWithAggregatesFilter<"Pelanggaran"> | string
    santriId?: StringWithAggregatesFilter<"Pelanggaran"> | string
    recordedBy?: StringWithAggregatesFilter<"Pelanggaran"> | string
    category?: StringWithAggregatesFilter<"Pelanggaran"> | string
    severity?: IntWithAggregatesFilter<"Pelanggaran"> | number
    points?: IntWithAggregatesFilter<"Pelanggaran"> | number
    description?: StringWithAggregatesFilter<"Pelanggaran"> | string
    date?: DateTimeWithAggregatesFilter<"Pelanggaran"> | Date | string
    resolved?: BoolWithAggregatesFilter<"Pelanggaran"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Pelanggaran"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Pelanggaran"> | Date | string
  }

  export type PembinaanWhereInput = {
    AND?: PembinaanWhereInput | PembinaanWhereInput[]
    OR?: PembinaanWhereInput[]
    NOT?: PembinaanWhereInput | PembinaanWhereInput[]
    id?: StringFilter<"Pembinaan"> | string
    tenantId?: StringFilter<"Pembinaan"> | string
    santriId?: StringFilter<"Pembinaan"> | string
    plan?: StringFilter<"Pembinaan"> | string
    targetDate?: DateTimeFilter<"Pembinaan"> | Date | string
    status?: StringFilter<"Pembinaan"> | string
    assignedTo?: StringFilter<"Pembinaan"> | string
    createdAt?: DateTimeFilter<"Pembinaan"> | Date | string
    updatedAt?: DateTimeFilter<"Pembinaan"> | Date | string
    tenant?: XOR<TenantRelationFilter, TenantWhereInput>
    santri?: XOR<SantriRelationFilter, SantriWhereInput>
  }

  export type PembinaanOrderByWithRelationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    santriId?: SortOrder
    plan?: SortOrder
    targetDate?: SortOrder
    status?: SortOrder
    assignedTo?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    tenant?: TenantOrderByWithRelationInput
    santri?: SantriOrderByWithRelationInput
  }

  export type PembinaanWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PembinaanWhereInput | PembinaanWhereInput[]
    OR?: PembinaanWhereInput[]
    NOT?: PembinaanWhereInput | PembinaanWhereInput[]
    tenantId?: StringFilter<"Pembinaan"> | string
    santriId?: StringFilter<"Pembinaan"> | string
    plan?: StringFilter<"Pembinaan"> | string
    targetDate?: DateTimeFilter<"Pembinaan"> | Date | string
    status?: StringFilter<"Pembinaan"> | string
    assignedTo?: StringFilter<"Pembinaan"> | string
    createdAt?: DateTimeFilter<"Pembinaan"> | Date | string
    updatedAt?: DateTimeFilter<"Pembinaan"> | Date | string
    tenant?: XOR<TenantRelationFilter, TenantWhereInput>
    santri?: XOR<SantriRelationFilter, SantriWhereInput>
  }, "id">

  export type PembinaanOrderByWithAggregationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    santriId?: SortOrder
    plan?: SortOrder
    targetDate?: SortOrder
    status?: SortOrder
    assignedTo?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PembinaanCountOrderByAggregateInput
    _max?: PembinaanMaxOrderByAggregateInput
    _min?: PembinaanMinOrderByAggregateInput
  }

  export type PembinaanScalarWhereWithAggregatesInput = {
    AND?: PembinaanScalarWhereWithAggregatesInput | PembinaanScalarWhereWithAggregatesInput[]
    OR?: PembinaanScalarWhereWithAggregatesInput[]
    NOT?: PembinaanScalarWhereWithAggregatesInput | PembinaanScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Pembinaan"> | string
    tenantId?: StringWithAggregatesFilter<"Pembinaan"> | string
    santriId?: StringWithAggregatesFilter<"Pembinaan"> | string
    plan?: StringWithAggregatesFilter<"Pembinaan"> | string
    targetDate?: DateTimeWithAggregatesFilter<"Pembinaan"> | Date | string
    status?: StringWithAggregatesFilter<"Pembinaan"> | string
    assignedTo?: StringWithAggregatesFilter<"Pembinaan"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Pembinaan"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Pembinaan"> | Date | string
  }

  export type KunjunganWhereInput = {
    AND?: KunjunganWhereInput | KunjunganWhereInput[]
    OR?: KunjunganWhereInput[]
    NOT?: KunjunganWhereInput | KunjunganWhereInput[]
    id?: StringFilter<"Kunjungan"> | string
    tenantId?: StringFilter<"Kunjungan"> | string
    santriId?: StringFilter<"Kunjungan"> | string
    scheduledAt?: DateTimeFilter<"Kunjungan"> | Date | string
    slot?: StringFilter<"Kunjungan"> | string
    visitorLimit?: IntFilter<"Kunjungan"> | number
    status?: StringFilter<"Kunjungan"> | string
    createdAt?: DateTimeFilter<"Kunjungan"> | Date | string
    updatedAt?: DateTimeFilter<"Kunjungan"> | Date | string
    tenant?: XOR<TenantRelationFilter, TenantWhereInput>
    santri?: XOR<SantriRelationFilter, SantriWhereInput>
    tamu?: TamuListRelationFilter
  }

  export type KunjunganOrderByWithRelationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    santriId?: SortOrder
    scheduledAt?: SortOrder
    slot?: SortOrder
    visitorLimit?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    tenant?: TenantOrderByWithRelationInput
    santri?: SantriOrderByWithRelationInput
    tamu?: TamuOrderByRelationAggregateInput
  }

  export type KunjunganWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: KunjunganWhereInput | KunjunganWhereInput[]
    OR?: KunjunganWhereInput[]
    NOT?: KunjunganWhereInput | KunjunganWhereInput[]
    tenantId?: StringFilter<"Kunjungan"> | string
    santriId?: StringFilter<"Kunjungan"> | string
    scheduledAt?: DateTimeFilter<"Kunjungan"> | Date | string
    slot?: StringFilter<"Kunjungan"> | string
    visitorLimit?: IntFilter<"Kunjungan"> | number
    status?: StringFilter<"Kunjungan"> | string
    createdAt?: DateTimeFilter<"Kunjungan"> | Date | string
    updatedAt?: DateTimeFilter<"Kunjungan"> | Date | string
    tenant?: XOR<TenantRelationFilter, TenantWhereInput>
    santri?: XOR<SantriRelationFilter, SantriWhereInput>
    tamu?: TamuListRelationFilter
  }, "id">

  export type KunjunganOrderByWithAggregationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    santriId?: SortOrder
    scheduledAt?: SortOrder
    slot?: SortOrder
    visitorLimit?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: KunjunganCountOrderByAggregateInput
    _avg?: KunjunganAvgOrderByAggregateInput
    _max?: KunjunganMaxOrderByAggregateInput
    _min?: KunjunganMinOrderByAggregateInput
    _sum?: KunjunganSumOrderByAggregateInput
  }

  export type KunjunganScalarWhereWithAggregatesInput = {
    AND?: KunjunganScalarWhereWithAggregatesInput | KunjunganScalarWhereWithAggregatesInput[]
    OR?: KunjunganScalarWhereWithAggregatesInput[]
    NOT?: KunjunganScalarWhereWithAggregatesInput | KunjunganScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Kunjungan"> | string
    tenantId?: StringWithAggregatesFilter<"Kunjungan"> | string
    santriId?: StringWithAggregatesFilter<"Kunjungan"> | string
    scheduledAt?: DateTimeWithAggregatesFilter<"Kunjungan"> | Date | string
    slot?: StringWithAggregatesFilter<"Kunjungan"> | string
    visitorLimit?: IntWithAggregatesFilter<"Kunjungan"> | number
    status?: StringWithAggregatesFilter<"Kunjungan"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Kunjungan"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Kunjungan"> | Date | string
  }

  export type TamuWhereInput = {
    AND?: TamuWhereInput | TamuWhereInput[]
    OR?: TamuWhereInput[]
    NOT?: TamuWhereInput | TamuWhereInput[]
    id?: StringFilter<"Tamu"> | string
    kunjunganId?: StringFilter<"Tamu"> | string
    name?: StringFilter<"Tamu"> | string
    phone?: StringNullableFilter<"Tamu"> | string | null
    idNumber?: StringNullableFilter<"Tamu"> | string | null
    checkinAt?: DateTimeNullableFilter<"Tamu"> | Date | string | null
    createdAt?: DateTimeFilter<"Tamu"> | Date | string
    kunjungan?: XOR<KunjunganRelationFilter, KunjunganWhereInput>
  }

  export type TamuOrderByWithRelationInput = {
    id?: SortOrder
    kunjunganId?: SortOrder
    name?: SortOrder
    phone?: SortOrderInput | SortOrder
    idNumber?: SortOrderInput | SortOrder
    checkinAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    kunjungan?: KunjunganOrderByWithRelationInput
  }

  export type TamuWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: TamuWhereInput | TamuWhereInput[]
    OR?: TamuWhereInput[]
    NOT?: TamuWhereInput | TamuWhereInput[]
    kunjunganId?: StringFilter<"Tamu"> | string
    name?: StringFilter<"Tamu"> | string
    phone?: StringNullableFilter<"Tamu"> | string | null
    idNumber?: StringNullableFilter<"Tamu"> | string | null
    checkinAt?: DateTimeNullableFilter<"Tamu"> | Date | string | null
    createdAt?: DateTimeFilter<"Tamu"> | Date | string
    kunjungan?: XOR<KunjunganRelationFilter, KunjunganWhereInput>
  }, "id">

  export type TamuOrderByWithAggregationInput = {
    id?: SortOrder
    kunjunganId?: SortOrder
    name?: SortOrder
    phone?: SortOrderInput | SortOrder
    idNumber?: SortOrderInput | SortOrder
    checkinAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: TamuCountOrderByAggregateInput
    _max?: TamuMaxOrderByAggregateInput
    _min?: TamuMinOrderByAggregateInput
  }

  export type TamuScalarWhereWithAggregatesInput = {
    AND?: TamuScalarWhereWithAggregatesInput | TamuScalarWhereWithAggregatesInput[]
    OR?: TamuScalarWhereWithAggregatesInput[]
    NOT?: TamuScalarWhereWithAggregatesInput | TamuScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Tamu"> | string
    kunjunganId?: StringWithAggregatesFilter<"Tamu"> | string
    name?: StringWithAggregatesFilter<"Tamu"> | string
    phone?: StringNullableWithAggregatesFilter<"Tamu"> | string | null
    idNumber?: StringNullableWithAggregatesFilter<"Tamu"> | string | null
    checkinAt?: DateTimeNullableWithAggregatesFilter<"Tamu"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Tamu"> | Date | string
  }

  export type HealthRecordWhereInput = {
    AND?: HealthRecordWhereInput | HealthRecordWhereInput[]
    OR?: HealthRecordWhereInput[]
    NOT?: HealthRecordWhereInput | HealthRecordWhereInput[]
    id?: StringFilter<"HealthRecord"> | string
    tenantId?: StringFilter<"HealthRecord"> | string
    santriId?: StringFilter<"HealthRecord"> | string
    recordedBy?: StringFilter<"HealthRecord"> | string
    symptoms?: StringFilter<"HealthRecord"> | string
    diagnosis?: StringNullableFilter<"HealthRecord"> | string | null
    actionTaken?: StringNullableFilter<"HealthRecord"> | string | null
    referred?: BoolFilter<"HealthRecord"> | boolean
    createdAt?: DateTimeFilter<"HealthRecord"> | Date | string
    updatedAt?: DateTimeFilter<"HealthRecord"> | Date | string
    tenant?: XOR<TenantRelationFilter, TenantWhereInput>
    santri?: XOR<SantriRelationFilter, SantriWhereInput>
  }

  export type HealthRecordOrderByWithRelationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    santriId?: SortOrder
    recordedBy?: SortOrder
    symptoms?: SortOrder
    diagnosis?: SortOrderInput | SortOrder
    actionTaken?: SortOrderInput | SortOrder
    referred?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    tenant?: TenantOrderByWithRelationInput
    santri?: SantriOrderByWithRelationInput
  }

  export type HealthRecordWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: HealthRecordWhereInput | HealthRecordWhereInput[]
    OR?: HealthRecordWhereInput[]
    NOT?: HealthRecordWhereInput | HealthRecordWhereInput[]
    tenantId?: StringFilter<"HealthRecord"> | string
    santriId?: StringFilter<"HealthRecord"> | string
    recordedBy?: StringFilter<"HealthRecord"> | string
    symptoms?: StringFilter<"HealthRecord"> | string
    diagnosis?: StringNullableFilter<"HealthRecord"> | string | null
    actionTaken?: StringNullableFilter<"HealthRecord"> | string | null
    referred?: BoolFilter<"HealthRecord"> | boolean
    createdAt?: DateTimeFilter<"HealthRecord"> | Date | string
    updatedAt?: DateTimeFilter<"HealthRecord"> | Date | string
    tenant?: XOR<TenantRelationFilter, TenantWhereInput>
    santri?: XOR<SantriRelationFilter, SantriWhereInput>
  }, "id">

  export type HealthRecordOrderByWithAggregationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    santriId?: SortOrder
    recordedBy?: SortOrder
    symptoms?: SortOrder
    diagnosis?: SortOrderInput | SortOrder
    actionTaken?: SortOrderInput | SortOrder
    referred?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: HealthRecordCountOrderByAggregateInput
    _max?: HealthRecordMaxOrderByAggregateInput
    _min?: HealthRecordMinOrderByAggregateInput
  }

  export type HealthRecordScalarWhereWithAggregatesInput = {
    AND?: HealthRecordScalarWhereWithAggregatesInput | HealthRecordScalarWhereWithAggregatesInput[]
    OR?: HealthRecordScalarWhereWithAggregatesInput[]
    NOT?: HealthRecordScalarWhereWithAggregatesInput | HealthRecordScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"HealthRecord"> | string
    tenantId?: StringWithAggregatesFilter<"HealthRecord"> | string
    santriId?: StringWithAggregatesFilter<"HealthRecord"> | string
    recordedBy?: StringWithAggregatesFilter<"HealthRecord"> | string
    symptoms?: StringWithAggregatesFilter<"HealthRecord"> | string
    diagnosis?: StringNullableWithAggregatesFilter<"HealthRecord"> | string | null
    actionTaken?: StringNullableWithAggregatesFilter<"HealthRecord"> | string | null
    referred?: BoolWithAggregatesFilter<"HealthRecord"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"HealthRecord"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"HealthRecord"> | Date | string
  }

  export type MedicationWhereInput = {
    AND?: MedicationWhereInput | MedicationWhereInput[]
    OR?: MedicationWhereInput[]
    NOT?: MedicationWhereInput | MedicationWhereInput[]
    id?: StringFilter<"Medication"> | string
    santriId?: StringFilter<"Medication"> | string
    medicineName?: StringFilter<"Medication"> | string
    dose?: StringFilter<"Medication"> | string
    schedule?: StringFilter<"Medication"> | string
    givenBy?: StringNullableFilter<"Medication"> | string | null
    givenAt?: DateTimeNullableFilter<"Medication"> | Date | string | null
    createdAt?: DateTimeFilter<"Medication"> | Date | string
    updatedAt?: DateTimeFilter<"Medication"> | Date | string
    santri?: XOR<SantriRelationFilter, SantriWhereInput>
  }

  export type MedicationOrderByWithRelationInput = {
    id?: SortOrder
    santriId?: SortOrder
    medicineName?: SortOrder
    dose?: SortOrder
    schedule?: SortOrder
    givenBy?: SortOrderInput | SortOrder
    givenAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    santri?: SantriOrderByWithRelationInput
  }

  export type MedicationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: MedicationWhereInput | MedicationWhereInput[]
    OR?: MedicationWhereInput[]
    NOT?: MedicationWhereInput | MedicationWhereInput[]
    santriId?: StringFilter<"Medication"> | string
    medicineName?: StringFilter<"Medication"> | string
    dose?: StringFilter<"Medication"> | string
    schedule?: StringFilter<"Medication"> | string
    givenBy?: StringNullableFilter<"Medication"> | string | null
    givenAt?: DateTimeNullableFilter<"Medication"> | Date | string | null
    createdAt?: DateTimeFilter<"Medication"> | Date | string
    updatedAt?: DateTimeFilter<"Medication"> | Date | string
    santri?: XOR<SantriRelationFilter, SantriWhereInput>
  }, "id">

  export type MedicationOrderByWithAggregationInput = {
    id?: SortOrder
    santriId?: SortOrder
    medicineName?: SortOrder
    dose?: SortOrder
    schedule?: SortOrder
    givenBy?: SortOrderInput | SortOrder
    givenAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: MedicationCountOrderByAggregateInput
    _max?: MedicationMaxOrderByAggregateInput
    _min?: MedicationMinOrderByAggregateInput
  }

  export type MedicationScalarWhereWithAggregatesInput = {
    AND?: MedicationScalarWhereWithAggregatesInput | MedicationScalarWhereWithAggregatesInput[]
    OR?: MedicationScalarWhereWithAggregatesInput[]
    NOT?: MedicationScalarWhereWithAggregatesInput | MedicationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Medication"> | string
    santriId?: StringWithAggregatesFilter<"Medication"> | string
    medicineName?: StringWithAggregatesFilter<"Medication"> | string
    dose?: StringWithAggregatesFilter<"Medication"> | string
    schedule?: StringWithAggregatesFilter<"Medication"> | string
    givenBy?: StringNullableWithAggregatesFilter<"Medication"> | string | null
    givenAt?: DateTimeNullableWithAggregatesFilter<"Medication"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Medication"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Medication"> | Date | string
  }

  export type AuditLogWhereInput = {
    AND?: AuditLogWhereInput | AuditLogWhereInput[]
    OR?: AuditLogWhereInput[]
    NOT?: AuditLogWhereInput | AuditLogWhereInput[]
    id?: StringFilter<"AuditLog"> | string
    tenantId?: StringNullableFilter<"AuditLog"> | string | null
    userId?: StringNullableFilter<"AuditLog"> | string | null
    action?: StringFilter<"AuditLog"> | string
    entity?: StringFilter<"AuditLog"> | string
    entityId?: StringFilter<"AuditLog"> | string
    oldValue?: StringNullableFilter<"AuditLog"> | string | null
    newValue?: StringNullableFilter<"AuditLog"> | string | null
    ip?: StringNullableFilter<"AuditLog"> | string | null
    createdAt?: DateTimeFilter<"AuditLog"> | Date | string
    tenant?: XOR<TenantNullableRelationFilter, TenantWhereInput> | null
    user?: XOR<UserNullableRelationFilter, UserWhereInput> | null
  }

  export type AuditLogOrderByWithRelationInput = {
    id?: SortOrder
    tenantId?: SortOrderInput | SortOrder
    userId?: SortOrderInput | SortOrder
    action?: SortOrder
    entity?: SortOrder
    entityId?: SortOrder
    oldValue?: SortOrderInput | SortOrder
    newValue?: SortOrderInput | SortOrder
    ip?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    tenant?: TenantOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type AuditLogWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AuditLogWhereInput | AuditLogWhereInput[]
    OR?: AuditLogWhereInput[]
    NOT?: AuditLogWhereInput | AuditLogWhereInput[]
    tenantId?: StringNullableFilter<"AuditLog"> | string | null
    userId?: StringNullableFilter<"AuditLog"> | string | null
    action?: StringFilter<"AuditLog"> | string
    entity?: StringFilter<"AuditLog"> | string
    entityId?: StringFilter<"AuditLog"> | string
    oldValue?: StringNullableFilter<"AuditLog"> | string | null
    newValue?: StringNullableFilter<"AuditLog"> | string | null
    ip?: StringNullableFilter<"AuditLog"> | string | null
    createdAt?: DateTimeFilter<"AuditLog"> | Date | string
    tenant?: XOR<TenantNullableRelationFilter, TenantWhereInput> | null
    user?: XOR<UserNullableRelationFilter, UserWhereInput> | null
  }, "id">

  export type AuditLogOrderByWithAggregationInput = {
    id?: SortOrder
    tenantId?: SortOrderInput | SortOrder
    userId?: SortOrderInput | SortOrder
    action?: SortOrder
    entity?: SortOrder
    entityId?: SortOrder
    oldValue?: SortOrderInput | SortOrder
    newValue?: SortOrderInput | SortOrder
    ip?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: AuditLogCountOrderByAggregateInput
    _max?: AuditLogMaxOrderByAggregateInput
    _min?: AuditLogMinOrderByAggregateInput
  }

  export type AuditLogScalarWhereWithAggregatesInput = {
    AND?: AuditLogScalarWhereWithAggregatesInput | AuditLogScalarWhereWithAggregatesInput[]
    OR?: AuditLogScalarWhereWithAggregatesInput[]
    NOT?: AuditLogScalarWhereWithAggregatesInput | AuditLogScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AuditLog"> | string
    tenantId?: StringNullableWithAggregatesFilter<"AuditLog"> | string | null
    userId?: StringNullableWithAggregatesFilter<"AuditLog"> | string | null
    action?: StringWithAggregatesFilter<"AuditLog"> | string
    entity?: StringWithAggregatesFilter<"AuditLog"> | string
    entityId?: StringWithAggregatesFilter<"AuditLog"> | string
    oldValue?: StringNullableWithAggregatesFilter<"AuditLog"> | string | null
    newValue?: StringNullableWithAggregatesFilter<"AuditLog"> | string | null
    ip?: StringNullableWithAggregatesFilter<"AuditLog"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"AuditLog"> | Date | string
  }

  export type NotificationWhereInput = {
    AND?: NotificationWhereInput | NotificationWhereInput[]
    OR?: NotificationWhereInput[]
    NOT?: NotificationWhereInput | NotificationWhereInput[]
    id?: StringFilter<"Notification"> | string
    tenantId?: StringFilter<"Notification"> | string
    userId?: StringFilter<"Notification"> | string
    type?: StringFilter<"Notification"> | string
    title?: StringFilter<"Notification"> | string
    body?: StringFilter<"Notification"> | string
    read?: BoolFilter<"Notification"> | boolean
    createdAt?: DateTimeFilter<"Notification"> | Date | string
    tenant?: XOR<TenantRelationFilter, TenantWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type NotificationOrderByWithRelationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    title?: SortOrder
    body?: SortOrder
    read?: SortOrder
    createdAt?: SortOrder
    tenant?: TenantOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type NotificationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: NotificationWhereInput | NotificationWhereInput[]
    OR?: NotificationWhereInput[]
    NOT?: NotificationWhereInput | NotificationWhereInput[]
    tenantId?: StringFilter<"Notification"> | string
    userId?: StringFilter<"Notification"> | string
    type?: StringFilter<"Notification"> | string
    title?: StringFilter<"Notification"> | string
    body?: StringFilter<"Notification"> | string
    read?: BoolFilter<"Notification"> | boolean
    createdAt?: DateTimeFilter<"Notification"> | Date | string
    tenant?: XOR<TenantRelationFilter, TenantWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id">

  export type NotificationOrderByWithAggregationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    title?: SortOrder
    body?: SortOrder
    read?: SortOrder
    createdAt?: SortOrder
    _count?: NotificationCountOrderByAggregateInput
    _max?: NotificationMaxOrderByAggregateInput
    _min?: NotificationMinOrderByAggregateInput
  }

  export type NotificationScalarWhereWithAggregatesInput = {
    AND?: NotificationScalarWhereWithAggregatesInput | NotificationScalarWhereWithAggregatesInput[]
    OR?: NotificationScalarWhereWithAggregatesInput[]
    NOT?: NotificationScalarWhereWithAggregatesInput | NotificationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Notification"> | string
    tenantId?: StringWithAggregatesFilter<"Notification"> | string
    userId?: StringWithAggregatesFilter<"Notification"> | string
    type?: StringWithAggregatesFilter<"Notification"> | string
    title?: StringWithAggregatesFilter<"Notification"> | string
    body?: StringWithAggregatesFilter<"Notification"> | string
    read?: BoolWithAggregatesFilter<"Notification"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Notification"> | Date | string
  }

  export type WebhookEventWhereInput = {
    AND?: WebhookEventWhereInput | WebhookEventWhereInput[]
    OR?: WebhookEventWhereInput[]
    NOT?: WebhookEventWhereInput | WebhookEventWhereInput[]
    id?: StringFilter<"WebhookEvent"> | string
    tenantId?: StringNullableFilter<"WebhookEvent"> | string | null
    eventType?: StringFilter<"WebhookEvent"> | string
    payload?: StringFilter<"WebhookEvent"> | string
    status?: StringFilter<"WebhookEvent"> | string
    error?: StringNullableFilter<"WebhookEvent"> | string | null
    createdAt?: DateTimeFilter<"WebhookEvent"> | Date | string
    processedAt?: DateTimeNullableFilter<"WebhookEvent"> | Date | string | null
    tenant?: XOR<TenantNullableRelationFilter, TenantWhereInput> | null
  }

  export type WebhookEventOrderByWithRelationInput = {
    id?: SortOrder
    tenantId?: SortOrderInput | SortOrder
    eventType?: SortOrder
    payload?: SortOrder
    status?: SortOrder
    error?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    processedAt?: SortOrderInput | SortOrder
    tenant?: TenantOrderByWithRelationInput
  }

  export type WebhookEventWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: WebhookEventWhereInput | WebhookEventWhereInput[]
    OR?: WebhookEventWhereInput[]
    NOT?: WebhookEventWhereInput | WebhookEventWhereInput[]
    tenantId?: StringNullableFilter<"WebhookEvent"> | string | null
    eventType?: StringFilter<"WebhookEvent"> | string
    payload?: StringFilter<"WebhookEvent"> | string
    status?: StringFilter<"WebhookEvent"> | string
    error?: StringNullableFilter<"WebhookEvent"> | string | null
    createdAt?: DateTimeFilter<"WebhookEvent"> | Date | string
    processedAt?: DateTimeNullableFilter<"WebhookEvent"> | Date | string | null
    tenant?: XOR<TenantNullableRelationFilter, TenantWhereInput> | null
  }, "id">

  export type WebhookEventOrderByWithAggregationInput = {
    id?: SortOrder
    tenantId?: SortOrderInput | SortOrder
    eventType?: SortOrder
    payload?: SortOrder
    status?: SortOrder
    error?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    processedAt?: SortOrderInput | SortOrder
    _count?: WebhookEventCountOrderByAggregateInput
    _max?: WebhookEventMaxOrderByAggregateInput
    _min?: WebhookEventMinOrderByAggregateInput
  }

  export type WebhookEventScalarWhereWithAggregatesInput = {
    AND?: WebhookEventScalarWhereWithAggregatesInput | WebhookEventScalarWhereWithAggregatesInput[]
    OR?: WebhookEventScalarWhereWithAggregatesInput[]
    NOT?: WebhookEventScalarWhereWithAggregatesInput | WebhookEventScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"WebhookEvent"> | string
    tenantId?: StringNullableWithAggregatesFilter<"WebhookEvent"> | string | null
    eventType?: StringWithAggregatesFilter<"WebhookEvent"> | string
    payload?: StringWithAggregatesFilter<"WebhookEvent"> | string
    status?: StringWithAggregatesFilter<"WebhookEvent"> | string
    error?: StringNullableWithAggregatesFilter<"WebhookEvent"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"WebhookEvent"> | Date | string
    processedAt?: DateTimeNullableWithAggregatesFilter<"WebhookEvent"> | Date | string | null
  }

  export type TenantCreateInput = {
    id?: string
    name: string
    address?: string | null
    phone?: string | null
    adminUserId?: string | null
    timezone?: string
    plan?: string
    billingContact?: string | null
    status?: string
    settings?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutTenantInput
    santri?: SantriCreateNestedManyWithoutTenantInput
    wali?: WaliCreateNestedManyWithoutTenantInput
    izin?: IzinCreateNestedManyWithoutTenantInput
    catatanHarian?: CatatanHarianCreateNestedManyWithoutTenantInput
    pengumuman?: PengumumanCreateNestedManyWithoutTenantInput
    invoices?: InvoiceCreateNestedManyWithoutTenantInput
    pelanggaran?: PelanggaranCreateNestedManyWithoutTenantInput
    pembinaan?: PembinaanCreateNestedManyWithoutTenantInput
    kunjungan?: KunjunganCreateNestedManyWithoutTenantInput
    healthRecords?: HealthRecordCreateNestedManyWithoutTenantInput
    auditLogs?: AuditLogCreateNestedManyWithoutTenantInput
    notifications?: NotificationCreateNestedManyWithoutTenantInput
    webhookEvents?: WebhookEventCreateNestedManyWithoutTenantInput
  }

  export type TenantUncheckedCreateInput = {
    id?: string
    name: string
    address?: string | null
    phone?: string | null
    adminUserId?: string | null
    timezone?: string
    plan?: string
    billingContact?: string | null
    status?: string
    settings?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutTenantInput
    santri?: SantriUncheckedCreateNestedManyWithoutTenantInput
    wali?: WaliUncheckedCreateNestedManyWithoutTenantInput
    izin?: IzinUncheckedCreateNestedManyWithoutTenantInput
    catatanHarian?: CatatanHarianUncheckedCreateNestedManyWithoutTenantInput
    pengumuman?: PengumumanUncheckedCreateNestedManyWithoutTenantInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutTenantInput
    pelanggaran?: PelanggaranUncheckedCreateNestedManyWithoutTenantInput
    pembinaan?: PembinaanUncheckedCreateNestedManyWithoutTenantInput
    kunjungan?: KunjunganUncheckedCreateNestedManyWithoutTenantInput
    healthRecords?: HealthRecordUncheckedCreateNestedManyWithoutTenantInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutTenantInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutTenantInput
    webhookEvents?: WebhookEventUncheckedCreateNestedManyWithoutTenantInput
  }

  export type TenantUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    adminUserId?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    plan?: StringFieldUpdateOperationsInput | string
    billingContact?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    settings?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutTenantNestedInput
    santri?: SantriUpdateManyWithoutTenantNestedInput
    wali?: WaliUpdateManyWithoutTenantNestedInput
    izin?: IzinUpdateManyWithoutTenantNestedInput
    catatanHarian?: CatatanHarianUpdateManyWithoutTenantNestedInput
    pengumuman?: PengumumanUpdateManyWithoutTenantNestedInput
    invoices?: InvoiceUpdateManyWithoutTenantNestedInput
    pelanggaran?: PelanggaranUpdateManyWithoutTenantNestedInput
    pembinaan?: PembinaanUpdateManyWithoutTenantNestedInput
    kunjungan?: KunjunganUpdateManyWithoutTenantNestedInput
    healthRecords?: HealthRecordUpdateManyWithoutTenantNestedInput
    auditLogs?: AuditLogUpdateManyWithoutTenantNestedInput
    notifications?: NotificationUpdateManyWithoutTenantNestedInput
    webhookEvents?: WebhookEventUpdateManyWithoutTenantNestedInput
  }

  export type TenantUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    adminUserId?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    plan?: StringFieldUpdateOperationsInput | string
    billingContact?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    settings?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutTenantNestedInput
    santri?: SantriUncheckedUpdateManyWithoutTenantNestedInput
    wali?: WaliUncheckedUpdateManyWithoutTenantNestedInput
    izin?: IzinUncheckedUpdateManyWithoutTenantNestedInput
    catatanHarian?: CatatanHarianUncheckedUpdateManyWithoutTenantNestedInput
    pengumuman?: PengumumanUncheckedUpdateManyWithoutTenantNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutTenantNestedInput
    pelanggaran?: PelanggaranUncheckedUpdateManyWithoutTenantNestedInput
    pembinaan?: PembinaanUncheckedUpdateManyWithoutTenantNestedInput
    kunjungan?: KunjunganUncheckedUpdateManyWithoutTenantNestedInput
    healthRecords?: HealthRecordUncheckedUpdateManyWithoutTenantNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutTenantNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutTenantNestedInput
    webhookEvents?: WebhookEventUncheckedUpdateManyWithoutTenantNestedInput
  }

  export type TenantCreateManyInput = {
    id?: string
    name: string
    address?: string | null
    phone?: string | null
    adminUserId?: string | null
    timezone?: string
    plan?: string
    billingContact?: string | null
    status?: string
    settings?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TenantUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    adminUserId?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    plan?: StringFieldUpdateOperationsInput | string
    billingContact?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    settings?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TenantUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    adminUserId?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    plan?: StringFieldUpdateOperationsInput | string
    billingContact?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    settings?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserCreateInput = {
    id?: string
    email: string
    passwordHash: string
    role?: string
    name: string
    phone?: string | null
    isActive?: boolean
    lastLogin?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant?: TenantCreateNestedOneWithoutUsersInput
    refreshTokens?: RefreshTokenCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateInput = {
    id?: string
    tenantId?: string | null
    email: string
    passwordHash: string
    role?: string
    name: string
    phone?: string | null
    isActive?: boolean
    lastLogin?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    refreshTokens?: RefreshTokenUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneWithoutUsersNestedInput
    refreshTokens?: RefreshTokenUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    refreshTokens?: RefreshTokenUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateManyInput = {
    id?: string
    tenantId?: string | null
    email: string
    passwordHash: string
    role?: string
    name: string
    phone?: string | null
    isActive?: boolean
    lastLogin?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RefreshTokenCreateInput = {
    id?: string
    token: string
    expiresAt: Date | string
    revoked?: boolean
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutRefreshTokensInput
  }

  export type RefreshTokenUncheckedCreateInput = {
    id?: string
    userId: string
    token: string
    expiresAt: Date | string
    revoked?: boolean
    createdAt?: Date | string
  }

  export type RefreshTokenUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    revoked?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutRefreshTokensNestedInput
  }

  export type RefreshTokenUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    revoked?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RefreshTokenCreateManyInput = {
    id?: string
    userId: string
    token: string
    expiresAt: Date | string
    revoked?: boolean
    createdAt?: Date | string
  }

  export type RefreshTokenUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    revoked?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RefreshTokenUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    revoked?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SantriCreateInput = {
    id?: string
    nisn?: string | null
    name: string
    gender: string
    dob?: Date | string | null
    kelas?: string | null
    room?: string | null
    contact?: string | null
    address?: string | null
    photo?: string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutSantriInput
    walis?: SantriWaliCreateNestedManyWithoutSantriInput
    izin?: IzinCreateNestedManyWithoutSantriInput
    catatanHarian?: CatatanHarianCreateNestedManyWithoutSantriInput
    invoices?: InvoiceCreateNestedManyWithoutSantriInput
    pelanggaran?: PelanggaranCreateNestedManyWithoutSantriInput
    pembinaan?: PembinaanCreateNestedManyWithoutSantriInput
    kunjungan?: KunjunganCreateNestedManyWithoutSantriInput
    healthRecords?: HealthRecordCreateNestedManyWithoutSantriInput
    medications?: MedicationCreateNestedManyWithoutSantriInput
  }

  export type SantriUncheckedCreateInput = {
    id?: string
    tenantId: string
    nisn?: string | null
    name: string
    gender: string
    dob?: Date | string | null
    kelas?: string | null
    room?: string | null
    contact?: string | null
    address?: string | null
    photo?: string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    walis?: SantriWaliUncheckedCreateNestedManyWithoutSantriInput
    izin?: IzinUncheckedCreateNestedManyWithoutSantriInput
    catatanHarian?: CatatanHarianUncheckedCreateNestedManyWithoutSantriInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutSantriInput
    pelanggaran?: PelanggaranUncheckedCreateNestedManyWithoutSantriInput
    pembinaan?: PembinaanUncheckedCreateNestedManyWithoutSantriInput
    kunjungan?: KunjunganUncheckedCreateNestedManyWithoutSantriInput
    healthRecords?: HealthRecordUncheckedCreateNestedManyWithoutSantriInput
    medications?: MedicationUncheckedCreateNestedManyWithoutSantriInput
  }

  export type SantriUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    nisn?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    gender?: StringFieldUpdateOperationsInput | string
    dob?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    kelas?: NullableStringFieldUpdateOperationsInput | string | null
    room?: NullableStringFieldUpdateOperationsInput | string | null
    contact?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutSantriNestedInput
    walis?: SantriWaliUpdateManyWithoutSantriNestedInput
    izin?: IzinUpdateManyWithoutSantriNestedInput
    catatanHarian?: CatatanHarianUpdateManyWithoutSantriNestedInput
    invoices?: InvoiceUpdateManyWithoutSantriNestedInput
    pelanggaran?: PelanggaranUpdateManyWithoutSantriNestedInput
    pembinaan?: PembinaanUpdateManyWithoutSantriNestedInput
    kunjungan?: KunjunganUpdateManyWithoutSantriNestedInput
    healthRecords?: HealthRecordUpdateManyWithoutSantriNestedInput
    medications?: MedicationUpdateManyWithoutSantriNestedInput
  }

  export type SantriUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    nisn?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    gender?: StringFieldUpdateOperationsInput | string
    dob?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    kelas?: NullableStringFieldUpdateOperationsInput | string | null
    room?: NullableStringFieldUpdateOperationsInput | string | null
    contact?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    walis?: SantriWaliUncheckedUpdateManyWithoutSantriNestedInput
    izin?: IzinUncheckedUpdateManyWithoutSantriNestedInput
    catatanHarian?: CatatanHarianUncheckedUpdateManyWithoutSantriNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutSantriNestedInput
    pelanggaran?: PelanggaranUncheckedUpdateManyWithoutSantriNestedInput
    pembinaan?: PembinaanUncheckedUpdateManyWithoutSantriNestedInput
    kunjungan?: KunjunganUncheckedUpdateManyWithoutSantriNestedInput
    healthRecords?: HealthRecordUncheckedUpdateManyWithoutSantriNestedInput
    medications?: MedicationUncheckedUpdateManyWithoutSantriNestedInput
  }

  export type SantriCreateManyInput = {
    id?: string
    tenantId: string
    nisn?: string | null
    name: string
    gender: string
    dob?: Date | string | null
    kelas?: string | null
    room?: string | null
    contact?: string | null
    address?: string | null
    photo?: string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SantriUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    nisn?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    gender?: StringFieldUpdateOperationsInput | string
    dob?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    kelas?: NullableStringFieldUpdateOperationsInput | string | null
    room?: NullableStringFieldUpdateOperationsInput | string | null
    contact?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SantriUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    nisn?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    gender?: StringFieldUpdateOperationsInput | string
    dob?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    kelas?: NullableStringFieldUpdateOperationsInput | string | null
    room?: NullableStringFieldUpdateOperationsInput | string | null
    contact?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WaliCreateInput = {
    id?: string
    name: string
    relation: string
    phone: string
    email?: string | null
    address?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutWaliInput
    santris?: SantriWaliCreateNestedManyWithoutWaliInput
  }

  export type WaliUncheckedCreateInput = {
    id?: string
    tenantId: string
    name: string
    relation: string
    phone: string
    email?: string | null
    address?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    santris?: SantriWaliUncheckedCreateNestedManyWithoutWaliInput
  }

  export type WaliUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    relation?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutWaliNestedInput
    santris?: SantriWaliUpdateManyWithoutWaliNestedInput
  }

  export type WaliUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    relation?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    santris?: SantriWaliUncheckedUpdateManyWithoutWaliNestedInput
  }

  export type WaliCreateManyInput = {
    id?: string
    tenantId: string
    name: string
    relation: string
    phone: string
    email?: string | null
    address?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WaliUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    relation?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WaliUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    relation?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SantriWaliCreateInput = {
    isPrimary?: boolean
    santri: SantriCreateNestedOneWithoutWalisInput
    wali: WaliCreateNestedOneWithoutSantrisInput
  }

  export type SantriWaliUncheckedCreateInput = {
    santriId: string
    waliId: string
    isPrimary?: boolean
  }

  export type SantriWaliUpdateInput = {
    isPrimary?: BoolFieldUpdateOperationsInput | boolean
    santri?: SantriUpdateOneRequiredWithoutWalisNestedInput
    wali?: WaliUpdateOneRequiredWithoutSantrisNestedInput
  }

  export type SantriWaliUncheckedUpdateInput = {
    santriId?: StringFieldUpdateOperationsInput | string
    waliId?: StringFieldUpdateOperationsInput | string
    isPrimary?: BoolFieldUpdateOperationsInput | boolean
  }

  export type SantriWaliCreateManyInput = {
    santriId: string
    waliId: string
    isPrimary?: boolean
  }

  export type SantriWaliUpdateManyMutationInput = {
    isPrimary?: BoolFieldUpdateOperationsInput | boolean
  }

  export type SantriWaliUncheckedUpdateManyInput = {
    santriId?: StringFieldUpdateOperationsInput | string
    waliId?: StringFieldUpdateOperationsInput | string
    isPrimary?: BoolFieldUpdateOperationsInput | boolean
  }

  export type IzinCreateInput = {
    id?: string
    type: string
    reason: string
    startAt: Date | string
    endAt: Date | string
    status?: string
    requestedBy: string
    approvedBy?: string | null
    approvedAt?: Date | string | null
    qrCodeData?: string | null
    checkoutAt?: Date | string | null
    checkoutBy?: string | null
    checkinAt?: Date | string | null
    checkinBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutIzinInput
    santri: SantriCreateNestedOneWithoutIzinInput
  }

  export type IzinUncheckedCreateInput = {
    id?: string
    tenantId: string
    santriId: string
    type: string
    reason: string
    startAt: Date | string
    endAt: Date | string
    status?: string
    requestedBy: string
    approvedBy?: string | null
    approvedAt?: Date | string | null
    qrCodeData?: string | null
    checkoutAt?: Date | string | null
    checkoutBy?: string | null
    checkinAt?: Date | string | null
    checkinBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type IzinUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    reason?: StringFieldUpdateOperationsInput | string
    startAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    requestedBy?: StringFieldUpdateOperationsInput | string
    approvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    qrCodeData?: NullableStringFieldUpdateOperationsInput | string | null
    checkoutAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    checkoutBy?: NullableStringFieldUpdateOperationsInput | string | null
    checkinAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    checkinBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutIzinNestedInput
    santri?: SantriUpdateOneRequiredWithoutIzinNestedInput
  }

  export type IzinUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    santriId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    reason?: StringFieldUpdateOperationsInput | string
    startAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    requestedBy?: StringFieldUpdateOperationsInput | string
    approvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    qrCodeData?: NullableStringFieldUpdateOperationsInput | string | null
    checkoutAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    checkoutBy?: NullableStringFieldUpdateOperationsInput | string | null
    checkinAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    checkinBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IzinCreateManyInput = {
    id?: string
    tenantId: string
    santriId: string
    type: string
    reason: string
    startAt: Date | string
    endAt: Date | string
    status?: string
    requestedBy: string
    approvedBy?: string | null
    approvedAt?: Date | string | null
    qrCodeData?: string | null
    checkoutAt?: Date | string | null
    checkoutBy?: string | null
    checkinAt?: Date | string | null
    checkinBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type IzinUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    reason?: StringFieldUpdateOperationsInput | string
    startAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    requestedBy?: StringFieldUpdateOperationsInput | string
    approvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    qrCodeData?: NullableStringFieldUpdateOperationsInput | string | null
    checkoutAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    checkoutBy?: NullableStringFieldUpdateOperationsInput | string | null
    checkinAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    checkinBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IzinUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    santriId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    reason?: StringFieldUpdateOperationsInput | string
    startAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    requestedBy?: StringFieldUpdateOperationsInput | string
    approvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    qrCodeData?: NullableStringFieldUpdateOperationsInput | string | null
    checkoutAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    checkoutBy?: NullableStringFieldUpdateOperationsInput | string | null
    checkinAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    checkinBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CatatanHarianCreateInput = {
    id?: string
    authorId: string
    date?: Date | string
    content: string
    category: string
    attachments?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutCatatanHarianInput
    santri: SantriCreateNestedOneWithoutCatatanHarianInput
  }

  export type CatatanHarianUncheckedCreateInput = {
    id?: string
    tenantId: string
    santriId: string
    authorId: string
    date?: Date | string
    content: string
    category: string
    attachments?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CatatanHarianUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    content?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    attachments?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutCatatanHarianNestedInput
    santri?: SantriUpdateOneRequiredWithoutCatatanHarianNestedInput
  }

  export type CatatanHarianUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    santriId?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    content?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    attachments?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CatatanHarianCreateManyInput = {
    id?: string
    tenantId: string
    santriId: string
    authorId: string
    date?: Date | string
    content: string
    category: string
    attachments?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CatatanHarianUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    content?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    attachments?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CatatanHarianUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    santriId?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    content?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    attachments?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PengumumanCreateInput = {
    id?: string
    title: string
    content: string
    audience: string
    pinnedUntil?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutPengumumanInput
  }

  export type PengumumanUncheckedCreateInput = {
    id?: string
    tenantId: string
    title: string
    content: string
    audience: string
    pinnedUntil?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PengumumanUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    audience?: StringFieldUpdateOperationsInput | string
    pinnedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutPengumumanNestedInput
  }

  export type PengumumanUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    audience?: StringFieldUpdateOperationsInput | string
    pinnedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PengumumanCreateManyInput = {
    id?: string
    tenantId: string
    title: string
    content: string
    audience: string
    pinnedUntil?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PengumumanUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    audience?: StringFieldUpdateOperationsInput | string
    pinnedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PengumumanUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    audience?: StringFieldUpdateOperationsInput | string
    pinnedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvoiceCreateInput = {
    id?: string
    amountDue: number
    dueDate: Date | string
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutInvoicesInput
    santri: SantriCreateNestedOneWithoutInvoicesInput
    lines?: InvoiceLineCreateNestedManyWithoutInvoiceInput
    payments?: PaymentCreateNestedManyWithoutInvoiceInput
  }

  export type InvoiceUncheckedCreateInput = {
    id?: string
    tenantId: string
    santriId: string
    amountDue: number
    dueDate: Date | string
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    lines?: InvoiceLineUncheckedCreateNestedManyWithoutInvoiceInput
    payments?: PaymentUncheckedCreateNestedManyWithoutInvoiceInput
  }

  export type InvoiceUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    amountDue?: FloatFieldUpdateOperationsInput | number
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutInvoicesNestedInput
    santri?: SantriUpdateOneRequiredWithoutInvoicesNestedInput
    lines?: InvoiceLineUpdateManyWithoutInvoiceNestedInput
    payments?: PaymentUpdateManyWithoutInvoiceNestedInput
  }

  export type InvoiceUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    santriId?: StringFieldUpdateOperationsInput | string
    amountDue?: FloatFieldUpdateOperationsInput | number
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lines?: InvoiceLineUncheckedUpdateManyWithoutInvoiceNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutInvoiceNestedInput
  }

  export type InvoiceCreateManyInput = {
    id?: string
    tenantId: string
    santriId: string
    amountDue: number
    dueDate: Date | string
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InvoiceUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    amountDue?: FloatFieldUpdateOperationsInput | number
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvoiceUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    santriId?: StringFieldUpdateOperationsInput | string
    amountDue?: FloatFieldUpdateOperationsInput | number
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvoiceLineCreateInput = {
    id?: string
    description: string
    amount: number
    type: string
    invoice: InvoiceCreateNestedOneWithoutLinesInput
  }

  export type InvoiceLineUncheckedCreateInput = {
    id?: string
    invoiceId: string
    description: string
    amount: number
    type: string
  }

  export type InvoiceLineUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    invoice?: InvoiceUpdateOneRequiredWithoutLinesNestedInput
  }

  export type InvoiceLineUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceId?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
  }

  export type InvoiceLineCreateManyInput = {
    id?: string
    invoiceId: string
    description: string
    amount: number
    type: string
  }

  export type InvoiceLineUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
  }

  export type InvoiceLineUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceId?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
  }

  export type PaymentCreateInput = {
    id?: string
    method: string
    amount: number
    status?: string
    transactionRef?: string | null
    paidAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    invoice: InvoiceCreateNestedOneWithoutPaymentsInput
  }

  export type PaymentUncheckedCreateInput = {
    id?: string
    invoiceId: string
    method: string
    amount: number
    status?: string
    transactionRef?: string | null
    paidAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PaymentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    method?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    transactionRef?: NullableStringFieldUpdateOperationsInput | string | null
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    invoice?: InvoiceUpdateOneRequiredWithoutPaymentsNestedInput
  }

  export type PaymentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceId?: StringFieldUpdateOperationsInput | string
    method?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    transactionRef?: NullableStringFieldUpdateOperationsInput | string | null
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentCreateManyInput = {
    id?: string
    invoiceId: string
    method: string
    amount: number
    status?: string
    transactionRef?: string | null
    paidAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PaymentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    method?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    transactionRef?: NullableStringFieldUpdateOperationsInput | string | null
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoiceId?: StringFieldUpdateOperationsInput | string
    method?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    transactionRef?: NullableStringFieldUpdateOperationsInput | string | null
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PelanggaranCreateInput = {
    id?: string
    recordedBy: string
    category: string
    severity: number
    points?: number
    description: string
    date?: Date | string
    resolved?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutPelanggaranInput
    santri: SantriCreateNestedOneWithoutPelanggaranInput
  }

  export type PelanggaranUncheckedCreateInput = {
    id?: string
    tenantId: string
    santriId: string
    recordedBy: string
    category: string
    severity: number
    points?: number
    description: string
    date?: Date | string
    resolved?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PelanggaranUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    recordedBy?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    severity?: IntFieldUpdateOperationsInput | number
    points?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    resolved?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutPelanggaranNestedInput
    santri?: SantriUpdateOneRequiredWithoutPelanggaranNestedInput
  }

  export type PelanggaranUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    santriId?: StringFieldUpdateOperationsInput | string
    recordedBy?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    severity?: IntFieldUpdateOperationsInput | number
    points?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    resolved?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PelanggaranCreateManyInput = {
    id?: string
    tenantId: string
    santriId: string
    recordedBy: string
    category: string
    severity: number
    points?: number
    description: string
    date?: Date | string
    resolved?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PelanggaranUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    recordedBy?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    severity?: IntFieldUpdateOperationsInput | number
    points?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    resolved?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PelanggaranUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    santriId?: StringFieldUpdateOperationsInput | string
    recordedBy?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    severity?: IntFieldUpdateOperationsInput | number
    points?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    resolved?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PembinaanCreateInput = {
    id?: string
    plan: string
    targetDate: Date | string
    status?: string
    assignedTo: string
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutPembinaanInput
    santri: SantriCreateNestedOneWithoutPembinaanInput
  }

  export type PembinaanUncheckedCreateInput = {
    id?: string
    tenantId: string
    santriId: string
    plan: string
    targetDate: Date | string
    status?: string
    assignedTo: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PembinaanUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    plan?: StringFieldUpdateOperationsInput | string
    targetDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    assignedTo?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutPembinaanNestedInput
    santri?: SantriUpdateOneRequiredWithoutPembinaanNestedInput
  }

  export type PembinaanUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    santriId?: StringFieldUpdateOperationsInput | string
    plan?: StringFieldUpdateOperationsInput | string
    targetDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    assignedTo?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PembinaanCreateManyInput = {
    id?: string
    tenantId: string
    santriId: string
    plan: string
    targetDate: Date | string
    status?: string
    assignedTo: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PembinaanUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    plan?: StringFieldUpdateOperationsInput | string
    targetDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    assignedTo?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PembinaanUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    santriId?: StringFieldUpdateOperationsInput | string
    plan?: StringFieldUpdateOperationsInput | string
    targetDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    assignedTo?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type KunjunganCreateInput = {
    id?: string
    scheduledAt: Date | string
    slot: string
    visitorLimit?: number
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutKunjunganInput
    santri: SantriCreateNestedOneWithoutKunjunganInput
    tamu?: TamuCreateNestedManyWithoutKunjunganInput
  }

  export type KunjunganUncheckedCreateInput = {
    id?: string
    tenantId: string
    santriId: string
    scheduledAt: Date | string
    slot: string
    visitorLimit?: number
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    tamu?: TamuUncheckedCreateNestedManyWithoutKunjunganInput
  }

  export type KunjunganUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    scheduledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    slot?: StringFieldUpdateOperationsInput | string
    visitorLimit?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutKunjunganNestedInput
    santri?: SantriUpdateOneRequiredWithoutKunjunganNestedInput
    tamu?: TamuUpdateManyWithoutKunjunganNestedInput
  }

  export type KunjunganUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    santriId?: StringFieldUpdateOperationsInput | string
    scheduledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    slot?: StringFieldUpdateOperationsInput | string
    visitorLimit?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tamu?: TamuUncheckedUpdateManyWithoutKunjunganNestedInput
  }

  export type KunjunganCreateManyInput = {
    id?: string
    tenantId: string
    santriId: string
    scheduledAt: Date | string
    slot: string
    visitorLimit?: number
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type KunjunganUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    scheduledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    slot?: StringFieldUpdateOperationsInput | string
    visitorLimit?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type KunjunganUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    santriId?: StringFieldUpdateOperationsInput | string
    scheduledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    slot?: StringFieldUpdateOperationsInput | string
    visitorLimit?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TamuCreateInput = {
    id?: string
    name: string
    phone?: string | null
    idNumber?: string | null
    checkinAt?: Date | string | null
    createdAt?: Date | string
    kunjungan: KunjunganCreateNestedOneWithoutTamuInput
  }

  export type TamuUncheckedCreateInput = {
    id?: string
    kunjunganId: string
    name: string
    phone?: string | null
    idNumber?: string | null
    checkinAt?: Date | string | null
    createdAt?: Date | string
  }

  export type TamuUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    idNumber?: NullableStringFieldUpdateOperationsInput | string | null
    checkinAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    kunjungan?: KunjunganUpdateOneRequiredWithoutTamuNestedInput
  }

  export type TamuUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    kunjunganId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    idNumber?: NullableStringFieldUpdateOperationsInput | string | null
    checkinAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TamuCreateManyInput = {
    id?: string
    kunjunganId: string
    name: string
    phone?: string | null
    idNumber?: string | null
    checkinAt?: Date | string | null
    createdAt?: Date | string
  }

  export type TamuUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    idNumber?: NullableStringFieldUpdateOperationsInput | string | null
    checkinAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TamuUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    kunjunganId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    idNumber?: NullableStringFieldUpdateOperationsInput | string | null
    checkinAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HealthRecordCreateInput = {
    id?: string
    recordedBy: string
    symptoms: string
    diagnosis?: string | null
    actionTaken?: string | null
    referred?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutHealthRecordsInput
    santri: SantriCreateNestedOneWithoutHealthRecordsInput
  }

  export type HealthRecordUncheckedCreateInput = {
    id?: string
    tenantId: string
    santriId: string
    recordedBy: string
    symptoms: string
    diagnosis?: string | null
    actionTaken?: string | null
    referred?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type HealthRecordUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    recordedBy?: StringFieldUpdateOperationsInput | string
    symptoms?: StringFieldUpdateOperationsInput | string
    diagnosis?: NullableStringFieldUpdateOperationsInput | string | null
    actionTaken?: NullableStringFieldUpdateOperationsInput | string | null
    referred?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutHealthRecordsNestedInput
    santri?: SantriUpdateOneRequiredWithoutHealthRecordsNestedInput
  }

  export type HealthRecordUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    santriId?: StringFieldUpdateOperationsInput | string
    recordedBy?: StringFieldUpdateOperationsInput | string
    symptoms?: StringFieldUpdateOperationsInput | string
    diagnosis?: NullableStringFieldUpdateOperationsInput | string | null
    actionTaken?: NullableStringFieldUpdateOperationsInput | string | null
    referred?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HealthRecordCreateManyInput = {
    id?: string
    tenantId: string
    santriId: string
    recordedBy: string
    symptoms: string
    diagnosis?: string | null
    actionTaken?: string | null
    referred?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type HealthRecordUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    recordedBy?: StringFieldUpdateOperationsInput | string
    symptoms?: StringFieldUpdateOperationsInput | string
    diagnosis?: NullableStringFieldUpdateOperationsInput | string | null
    actionTaken?: NullableStringFieldUpdateOperationsInput | string | null
    referred?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HealthRecordUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    santriId?: StringFieldUpdateOperationsInput | string
    recordedBy?: StringFieldUpdateOperationsInput | string
    symptoms?: StringFieldUpdateOperationsInput | string
    diagnosis?: NullableStringFieldUpdateOperationsInput | string | null
    actionTaken?: NullableStringFieldUpdateOperationsInput | string | null
    referred?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MedicationCreateInput = {
    id?: string
    medicineName: string
    dose: string
    schedule: string
    givenBy?: string | null
    givenAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    santri: SantriCreateNestedOneWithoutMedicationsInput
  }

  export type MedicationUncheckedCreateInput = {
    id?: string
    santriId: string
    medicineName: string
    dose: string
    schedule: string
    givenBy?: string | null
    givenAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MedicationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    medicineName?: StringFieldUpdateOperationsInput | string
    dose?: StringFieldUpdateOperationsInput | string
    schedule?: StringFieldUpdateOperationsInput | string
    givenBy?: NullableStringFieldUpdateOperationsInput | string | null
    givenAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    santri?: SantriUpdateOneRequiredWithoutMedicationsNestedInput
  }

  export type MedicationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    santriId?: StringFieldUpdateOperationsInput | string
    medicineName?: StringFieldUpdateOperationsInput | string
    dose?: StringFieldUpdateOperationsInput | string
    schedule?: StringFieldUpdateOperationsInput | string
    givenBy?: NullableStringFieldUpdateOperationsInput | string | null
    givenAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MedicationCreateManyInput = {
    id?: string
    santriId: string
    medicineName: string
    dose: string
    schedule: string
    givenBy?: string | null
    givenAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MedicationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    medicineName?: StringFieldUpdateOperationsInput | string
    dose?: StringFieldUpdateOperationsInput | string
    schedule?: StringFieldUpdateOperationsInput | string
    givenBy?: NullableStringFieldUpdateOperationsInput | string | null
    givenAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MedicationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    santriId?: StringFieldUpdateOperationsInput | string
    medicineName?: StringFieldUpdateOperationsInput | string
    dose?: StringFieldUpdateOperationsInput | string
    schedule?: StringFieldUpdateOperationsInput | string
    givenBy?: NullableStringFieldUpdateOperationsInput | string | null
    givenAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogCreateInput = {
    id?: string
    action: string
    entity: string
    entityId: string
    oldValue?: string | null
    newValue?: string | null
    ip?: string | null
    createdAt?: Date | string
    tenant?: TenantCreateNestedOneWithoutAuditLogsInput
    user?: UserCreateNestedOneWithoutAuditLogsInput
  }

  export type AuditLogUncheckedCreateInput = {
    id?: string
    tenantId?: string | null
    userId?: string | null
    action: string
    entity: string
    entityId: string
    oldValue?: string | null
    newValue?: string | null
    ip?: string | null
    createdAt?: Date | string
  }

  export type AuditLogUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    entity?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    oldValue?: NullableStringFieldUpdateOperationsInput | string | null
    newValue?: NullableStringFieldUpdateOperationsInput | string | null
    ip?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneWithoutAuditLogsNestedInput
    user?: UserUpdateOneWithoutAuditLogsNestedInput
  }

  export type AuditLogUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    action?: StringFieldUpdateOperationsInput | string
    entity?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    oldValue?: NullableStringFieldUpdateOperationsInput | string | null
    newValue?: NullableStringFieldUpdateOperationsInput | string | null
    ip?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogCreateManyInput = {
    id?: string
    tenantId?: string | null
    userId?: string | null
    action: string
    entity: string
    entityId: string
    oldValue?: string | null
    newValue?: string | null
    ip?: string | null
    createdAt?: Date | string
  }

  export type AuditLogUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    entity?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    oldValue?: NullableStringFieldUpdateOperationsInput | string | null
    newValue?: NullableStringFieldUpdateOperationsInput | string | null
    ip?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    action?: StringFieldUpdateOperationsInput | string
    entity?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    oldValue?: NullableStringFieldUpdateOperationsInput | string | null
    newValue?: NullableStringFieldUpdateOperationsInput | string | null
    ip?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationCreateInput = {
    id?: string
    type: string
    title: string
    body: string
    read?: boolean
    createdAt?: Date | string
    tenant: TenantCreateNestedOneWithoutNotificationsInput
    user: UserCreateNestedOneWithoutNotificationsInput
  }

  export type NotificationUncheckedCreateInput = {
    id?: string
    tenantId: string
    userId: string
    type: string
    title: string
    body: string
    read?: boolean
    createdAt?: Date | string
  }

  export type NotificationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    read?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutNotificationsNestedInput
    user?: UserUpdateOneRequiredWithoutNotificationsNestedInput
  }

  export type NotificationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    read?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationCreateManyInput = {
    id?: string
    tenantId: string
    userId: string
    type: string
    title: string
    body: string
    read?: boolean
    createdAt?: Date | string
  }

  export type NotificationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    read?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    read?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WebhookEventCreateInput = {
    id?: string
    eventType: string
    payload: string
    status?: string
    error?: string | null
    createdAt?: Date | string
    processedAt?: Date | string | null
    tenant?: TenantCreateNestedOneWithoutWebhookEventsInput
  }

  export type WebhookEventUncheckedCreateInput = {
    id?: string
    tenantId?: string | null
    eventType: string
    payload: string
    status?: string
    error?: string | null
    createdAt?: Date | string
    processedAt?: Date | string | null
  }

  export type WebhookEventUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    eventType?: StringFieldUpdateOperationsInput | string
    payload?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    error?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tenant?: TenantUpdateOneWithoutWebhookEventsNestedInput
  }

  export type WebhookEventUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: NullableStringFieldUpdateOperationsInput | string | null
    eventType?: StringFieldUpdateOperationsInput | string
    payload?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    error?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type WebhookEventCreateManyInput = {
    id?: string
    tenantId?: string | null
    eventType: string
    payload: string
    status?: string
    error?: string | null
    createdAt?: Date | string
    processedAt?: Date | string | null
  }

  export type WebhookEventUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    eventType?: StringFieldUpdateOperationsInput | string
    payload?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    error?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type WebhookEventUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: NullableStringFieldUpdateOperationsInput | string | null
    eventType?: StringFieldUpdateOperationsInput | string
    payload?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    error?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type UserListRelationFilter = {
    every?: UserWhereInput
    some?: UserWhereInput
    none?: UserWhereInput
  }

  export type SantriListRelationFilter = {
    every?: SantriWhereInput
    some?: SantriWhereInput
    none?: SantriWhereInput
  }

  export type WaliListRelationFilter = {
    every?: WaliWhereInput
    some?: WaliWhereInput
    none?: WaliWhereInput
  }

  export type IzinListRelationFilter = {
    every?: IzinWhereInput
    some?: IzinWhereInput
    none?: IzinWhereInput
  }

  export type CatatanHarianListRelationFilter = {
    every?: CatatanHarianWhereInput
    some?: CatatanHarianWhereInput
    none?: CatatanHarianWhereInput
  }

  export type PengumumanListRelationFilter = {
    every?: PengumumanWhereInput
    some?: PengumumanWhereInput
    none?: PengumumanWhereInput
  }

  export type InvoiceListRelationFilter = {
    every?: InvoiceWhereInput
    some?: InvoiceWhereInput
    none?: InvoiceWhereInput
  }

  export type PelanggaranListRelationFilter = {
    every?: PelanggaranWhereInput
    some?: PelanggaranWhereInput
    none?: PelanggaranWhereInput
  }

  export type PembinaanListRelationFilter = {
    every?: PembinaanWhereInput
    some?: PembinaanWhereInput
    none?: PembinaanWhereInput
  }

  export type KunjunganListRelationFilter = {
    every?: KunjunganWhereInput
    some?: KunjunganWhereInput
    none?: KunjunganWhereInput
  }

  export type HealthRecordListRelationFilter = {
    every?: HealthRecordWhereInput
    some?: HealthRecordWhereInput
    none?: HealthRecordWhereInput
  }

  export type AuditLogListRelationFilter = {
    every?: AuditLogWhereInput
    some?: AuditLogWhereInput
    none?: AuditLogWhereInput
  }

  export type NotificationListRelationFilter = {
    every?: NotificationWhereInput
    some?: NotificationWhereInput
    none?: NotificationWhereInput
  }

  export type WebhookEventListRelationFilter = {
    every?: WebhookEventWhereInput
    some?: WebhookEventWhereInput
    none?: WebhookEventWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type UserOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SantriOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type WaliOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type IzinOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CatatanHarianOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PengumumanOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type InvoiceOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PelanggaranOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PembinaanOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type KunjunganOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type HealthRecordOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AuditLogOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type NotificationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type WebhookEventOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TenantCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    address?: SortOrder
    phone?: SortOrder
    adminUserId?: SortOrder
    timezone?: SortOrder
    plan?: SortOrder
    billingContact?: SortOrder
    status?: SortOrder
    settings?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TenantMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    address?: SortOrder
    phone?: SortOrder
    adminUserId?: SortOrder
    timezone?: SortOrder
    plan?: SortOrder
    billingContact?: SortOrder
    status?: SortOrder
    settings?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TenantMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    address?: SortOrder
    phone?: SortOrder
    adminUserId?: SortOrder
    timezone?: SortOrder
    plan?: SortOrder
    billingContact?: SortOrder
    status?: SortOrder
    settings?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type TenantNullableRelationFilter = {
    is?: TenantWhereInput | null
    isNot?: TenantWhereInput | null
  }

  export type RefreshTokenListRelationFilter = {
    every?: RefreshTokenWhereInput
    some?: RefreshTokenWhereInput
    none?: RefreshTokenWhereInput
  }

  export type RefreshTokenOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    email?: SortOrder
    passwordHash?: SortOrder
    role?: SortOrder
    name?: SortOrder
    phone?: SortOrder
    isActive?: SortOrder
    lastLogin?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    email?: SortOrder
    passwordHash?: SortOrder
    role?: SortOrder
    name?: SortOrder
    phone?: SortOrder
    isActive?: SortOrder
    lastLogin?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    email?: SortOrder
    passwordHash?: SortOrder
    role?: SortOrder
    name?: SortOrder
    phone?: SortOrder
    isActive?: SortOrder
    lastLogin?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type UserRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type RefreshTokenCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    token?: SortOrder
    expiresAt?: SortOrder
    revoked?: SortOrder
    createdAt?: SortOrder
  }

  export type RefreshTokenMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    token?: SortOrder
    expiresAt?: SortOrder
    revoked?: SortOrder
    createdAt?: SortOrder
  }

  export type RefreshTokenMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    token?: SortOrder
    expiresAt?: SortOrder
    revoked?: SortOrder
    createdAt?: SortOrder
  }

  export type TenantRelationFilter = {
    is?: TenantWhereInput
    isNot?: TenantWhereInput
  }

  export type SantriWaliListRelationFilter = {
    every?: SantriWaliWhereInput
    some?: SantriWaliWhereInput
    none?: SantriWaliWhereInput
  }

  export type MedicationListRelationFilter = {
    every?: MedicationWhereInput
    some?: MedicationWhereInput
    none?: MedicationWhereInput
  }

  export type SantriWaliOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MedicationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SantriCountOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    nisn?: SortOrder
    name?: SortOrder
    gender?: SortOrder
    dob?: SortOrder
    kelas?: SortOrder
    room?: SortOrder
    contact?: SortOrder
    address?: SortOrder
    photo?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SantriMaxOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    nisn?: SortOrder
    name?: SortOrder
    gender?: SortOrder
    dob?: SortOrder
    kelas?: SortOrder
    room?: SortOrder
    contact?: SortOrder
    address?: SortOrder
    photo?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SantriMinOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    nisn?: SortOrder
    name?: SortOrder
    gender?: SortOrder
    dob?: SortOrder
    kelas?: SortOrder
    room?: SortOrder
    contact?: SortOrder
    address?: SortOrder
    photo?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type WaliCountOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    name?: SortOrder
    relation?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    address?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type WaliMaxOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    name?: SortOrder
    relation?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    address?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type WaliMinOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    name?: SortOrder
    relation?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    address?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SantriRelationFilter = {
    is?: SantriWhereInput
    isNot?: SantriWhereInput
  }

  export type WaliRelationFilter = {
    is?: WaliWhereInput
    isNot?: WaliWhereInput
  }

  export type SantriWaliSantriIdWaliIdCompoundUniqueInput = {
    santriId: string
    waliId: string
  }

  export type SantriWaliCountOrderByAggregateInput = {
    santriId?: SortOrder
    waliId?: SortOrder
    isPrimary?: SortOrder
  }

  export type SantriWaliMaxOrderByAggregateInput = {
    santriId?: SortOrder
    waliId?: SortOrder
    isPrimary?: SortOrder
  }

  export type SantriWaliMinOrderByAggregateInput = {
    santriId?: SortOrder
    waliId?: SortOrder
    isPrimary?: SortOrder
  }

  export type IzinCountOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    santriId?: SortOrder
    type?: SortOrder
    reason?: SortOrder
    startAt?: SortOrder
    endAt?: SortOrder
    status?: SortOrder
    requestedBy?: SortOrder
    approvedBy?: SortOrder
    approvedAt?: SortOrder
    qrCodeData?: SortOrder
    checkoutAt?: SortOrder
    checkoutBy?: SortOrder
    checkinAt?: SortOrder
    checkinBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type IzinMaxOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    santriId?: SortOrder
    type?: SortOrder
    reason?: SortOrder
    startAt?: SortOrder
    endAt?: SortOrder
    status?: SortOrder
    requestedBy?: SortOrder
    approvedBy?: SortOrder
    approvedAt?: SortOrder
    qrCodeData?: SortOrder
    checkoutAt?: SortOrder
    checkoutBy?: SortOrder
    checkinAt?: SortOrder
    checkinBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type IzinMinOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    santriId?: SortOrder
    type?: SortOrder
    reason?: SortOrder
    startAt?: SortOrder
    endAt?: SortOrder
    status?: SortOrder
    requestedBy?: SortOrder
    approvedBy?: SortOrder
    approvedAt?: SortOrder
    qrCodeData?: SortOrder
    checkoutAt?: SortOrder
    checkoutBy?: SortOrder
    checkinAt?: SortOrder
    checkinBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CatatanHarianCountOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    santriId?: SortOrder
    authorId?: SortOrder
    date?: SortOrder
    content?: SortOrder
    category?: SortOrder
    attachments?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CatatanHarianMaxOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    santriId?: SortOrder
    authorId?: SortOrder
    date?: SortOrder
    content?: SortOrder
    category?: SortOrder
    attachments?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CatatanHarianMinOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    santriId?: SortOrder
    authorId?: SortOrder
    date?: SortOrder
    content?: SortOrder
    category?: SortOrder
    attachments?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PengumumanCountOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    title?: SortOrder
    content?: SortOrder
    audience?: SortOrder
    pinnedUntil?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PengumumanMaxOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    title?: SortOrder
    content?: SortOrder
    audience?: SortOrder
    pinnedUntil?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PengumumanMinOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    title?: SortOrder
    content?: SortOrder
    audience?: SortOrder
    pinnedUntil?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type InvoiceLineListRelationFilter = {
    every?: InvoiceLineWhereInput
    some?: InvoiceLineWhereInput
    none?: InvoiceLineWhereInput
  }

  export type PaymentListRelationFilter = {
    every?: PaymentWhereInput
    some?: PaymentWhereInput
    none?: PaymentWhereInput
  }

  export type InvoiceLineOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PaymentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type InvoiceCountOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    santriId?: SortOrder
    amountDue?: SortOrder
    dueDate?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type InvoiceAvgOrderByAggregateInput = {
    amountDue?: SortOrder
  }

  export type InvoiceMaxOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    santriId?: SortOrder
    amountDue?: SortOrder
    dueDate?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type InvoiceMinOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    santriId?: SortOrder
    amountDue?: SortOrder
    dueDate?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type InvoiceSumOrderByAggregateInput = {
    amountDue?: SortOrder
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type InvoiceRelationFilter = {
    is?: InvoiceWhereInput
    isNot?: InvoiceWhereInput
  }

  export type InvoiceLineCountOrderByAggregateInput = {
    id?: SortOrder
    invoiceId?: SortOrder
    description?: SortOrder
    amount?: SortOrder
    type?: SortOrder
  }

  export type InvoiceLineAvgOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type InvoiceLineMaxOrderByAggregateInput = {
    id?: SortOrder
    invoiceId?: SortOrder
    description?: SortOrder
    amount?: SortOrder
    type?: SortOrder
  }

  export type InvoiceLineMinOrderByAggregateInput = {
    id?: SortOrder
    invoiceId?: SortOrder
    description?: SortOrder
    amount?: SortOrder
    type?: SortOrder
  }

  export type InvoiceLineSumOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type PaymentCountOrderByAggregateInput = {
    id?: SortOrder
    invoiceId?: SortOrder
    method?: SortOrder
    amount?: SortOrder
    status?: SortOrder
    transactionRef?: SortOrder
    paidAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PaymentAvgOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type PaymentMaxOrderByAggregateInput = {
    id?: SortOrder
    invoiceId?: SortOrder
    method?: SortOrder
    amount?: SortOrder
    status?: SortOrder
    transactionRef?: SortOrder
    paidAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PaymentMinOrderByAggregateInput = {
    id?: SortOrder
    invoiceId?: SortOrder
    method?: SortOrder
    amount?: SortOrder
    status?: SortOrder
    transactionRef?: SortOrder
    paidAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PaymentSumOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type PelanggaranCountOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    santriId?: SortOrder
    recordedBy?: SortOrder
    category?: SortOrder
    severity?: SortOrder
    points?: SortOrder
    description?: SortOrder
    date?: SortOrder
    resolved?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PelanggaranAvgOrderByAggregateInput = {
    severity?: SortOrder
    points?: SortOrder
  }

  export type PelanggaranMaxOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    santriId?: SortOrder
    recordedBy?: SortOrder
    category?: SortOrder
    severity?: SortOrder
    points?: SortOrder
    description?: SortOrder
    date?: SortOrder
    resolved?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PelanggaranMinOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    santriId?: SortOrder
    recordedBy?: SortOrder
    category?: SortOrder
    severity?: SortOrder
    points?: SortOrder
    description?: SortOrder
    date?: SortOrder
    resolved?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PelanggaranSumOrderByAggregateInput = {
    severity?: SortOrder
    points?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type PembinaanCountOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    santriId?: SortOrder
    plan?: SortOrder
    targetDate?: SortOrder
    status?: SortOrder
    assignedTo?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PembinaanMaxOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    santriId?: SortOrder
    plan?: SortOrder
    targetDate?: SortOrder
    status?: SortOrder
    assignedTo?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PembinaanMinOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    santriId?: SortOrder
    plan?: SortOrder
    targetDate?: SortOrder
    status?: SortOrder
    assignedTo?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TamuListRelationFilter = {
    every?: TamuWhereInput
    some?: TamuWhereInput
    none?: TamuWhereInput
  }

  export type TamuOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type KunjunganCountOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    santriId?: SortOrder
    scheduledAt?: SortOrder
    slot?: SortOrder
    visitorLimit?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type KunjunganAvgOrderByAggregateInput = {
    visitorLimit?: SortOrder
  }

  export type KunjunganMaxOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    santriId?: SortOrder
    scheduledAt?: SortOrder
    slot?: SortOrder
    visitorLimit?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type KunjunganMinOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    santriId?: SortOrder
    scheduledAt?: SortOrder
    slot?: SortOrder
    visitorLimit?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type KunjunganSumOrderByAggregateInput = {
    visitorLimit?: SortOrder
  }

  export type KunjunganRelationFilter = {
    is?: KunjunganWhereInput
    isNot?: KunjunganWhereInput
  }

  export type TamuCountOrderByAggregateInput = {
    id?: SortOrder
    kunjunganId?: SortOrder
    name?: SortOrder
    phone?: SortOrder
    idNumber?: SortOrder
    checkinAt?: SortOrder
    createdAt?: SortOrder
  }

  export type TamuMaxOrderByAggregateInput = {
    id?: SortOrder
    kunjunganId?: SortOrder
    name?: SortOrder
    phone?: SortOrder
    idNumber?: SortOrder
    checkinAt?: SortOrder
    createdAt?: SortOrder
  }

  export type TamuMinOrderByAggregateInput = {
    id?: SortOrder
    kunjunganId?: SortOrder
    name?: SortOrder
    phone?: SortOrder
    idNumber?: SortOrder
    checkinAt?: SortOrder
    createdAt?: SortOrder
  }

  export type HealthRecordCountOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    santriId?: SortOrder
    recordedBy?: SortOrder
    symptoms?: SortOrder
    diagnosis?: SortOrder
    actionTaken?: SortOrder
    referred?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type HealthRecordMaxOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    santriId?: SortOrder
    recordedBy?: SortOrder
    symptoms?: SortOrder
    diagnosis?: SortOrder
    actionTaken?: SortOrder
    referred?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type HealthRecordMinOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    santriId?: SortOrder
    recordedBy?: SortOrder
    symptoms?: SortOrder
    diagnosis?: SortOrder
    actionTaken?: SortOrder
    referred?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MedicationCountOrderByAggregateInput = {
    id?: SortOrder
    santriId?: SortOrder
    medicineName?: SortOrder
    dose?: SortOrder
    schedule?: SortOrder
    givenBy?: SortOrder
    givenAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MedicationMaxOrderByAggregateInput = {
    id?: SortOrder
    santriId?: SortOrder
    medicineName?: SortOrder
    dose?: SortOrder
    schedule?: SortOrder
    givenBy?: SortOrder
    givenAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MedicationMinOrderByAggregateInput = {
    id?: SortOrder
    santriId?: SortOrder
    medicineName?: SortOrder
    dose?: SortOrder
    schedule?: SortOrder
    givenBy?: SortOrder
    givenAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserNullableRelationFilter = {
    is?: UserWhereInput | null
    isNot?: UserWhereInput | null
  }

  export type AuditLogCountOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    userId?: SortOrder
    action?: SortOrder
    entity?: SortOrder
    entityId?: SortOrder
    oldValue?: SortOrder
    newValue?: SortOrder
    ip?: SortOrder
    createdAt?: SortOrder
  }

  export type AuditLogMaxOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    userId?: SortOrder
    action?: SortOrder
    entity?: SortOrder
    entityId?: SortOrder
    oldValue?: SortOrder
    newValue?: SortOrder
    ip?: SortOrder
    createdAt?: SortOrder
  }

  export type AuditLogMinOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    userId?: SortOrder
    action?: SortOrder
    entity?: SortOrder
    entityId?: SortOrder
    oldValue?: SortOrder
    newValue?: SortOrder
    ip?: SortOrder
    createdAt?: SortOrder
  }

  export type NotificationCountOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    title?: SortOrder
    body?: SortOrder
    read?: SortOrder
    createdAt?: SortOrder
  }

  export type NotificationMaxOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    title?: SortOrder
    body?: SortOrder
    read?: SortOrder
    createdAt?: SortOrder
  }

  export type NotificationMinOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    title?: SortOrder
    body?: SortOrder
    read?: SortOrder
    createdAt?: SortOrder
  }

  export type WebhookEventCountOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    eventType?: SortOrder
    payload?: SortOrder
    status?: SortOrder
    error?: SortOrder
    createdAt?: SortOrder
    processedAt?: SortOrder
  }

  export type WebhookEventMaxOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    eventType?: SortOrder
    payload?: SortOrder
    status?: SortOrder
    error?: SortOrder
    createdAt?: SortOrder
    processedAt?: SortOrder
  }

  export type WebhookEventMinOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    eventType?: SortOrder
    payload?: SortOrder
    status?: SortOrder
    error?: SortOrder
    createdAt?: SortOrder
    processedAt?: SortOrder
  }

  export type UserCreateNestedManyWithoutTenantInput = {
    create?: XOR<UserCreateWithoutTenantInput, UserUncheckedCreateWithoutTenantInput> | UserCreateWithoutTenantInput[] | UserUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: UserCreateOrConnectWithoutTenantInput | UserCreateOrConnectWithoutTenantInput[]
    createMany?: UserCreateManyTenantInputEnvelope
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type SantriCreateNestedManyWithoutTenantInput = {
    create?: XOR<SantriCreateWithoutTenantInput, SantriUncheckedCreateWithoutTenantInput> | SantriCreateWithoutTenantInput[] | SantriUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: SantriCreateOrConnectWithoutTenantInput | SantriCreateOrConnectWithoutTenantInput[]
    createMany?: SantriCreateManyTenantInputEnvelope
    connect?: SantriWhereUniqueInput | SantriWhereUniqueInput[]
  }

  export type WaliCreateNestedManyWithoutTenantInput = {
    create?: XOR<WaliCreateWithoutTenantInput, WaliUncheckedCreateWithoutTenantInput> | WaliCreateWithoutTenantInput[] | WaliUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: WaliCreateOrConnectWithoutTenantInput | WaliCreateOrConnectWithoutTenantInput[]
    createMany?: WaliCreateManyTenantInputEnvelope
    connect?: WaliWhereUniqueInput | WaliWhereUniqueInput[]
  }

  export type IzinCreateNestedManyWithoutTenantInput = {
    create?: XOR<IzinCreateWithoutTenantInput, IzinUncheckedCreateWithoutTenantInput> | IzinCreateWithoutTenantInput[] | IzinUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: IzinCreateOrConnectWithoutTenantInput | IzinCreateOrConnectWithoutTenantInput[]
    createMany?: IzinCreateManyTenantInputEnvelope
    connect?: IzinWhereUniqueInput | IzinWhereUniqueInput[]
  }

  export type CatatanHarianCreateNestedManyWithoutTenantInput = {
    create?: XOR<CatatanHarianCreateWithoutTenantInput, CatatanHarianUncheckedCreateWithoutTenantInput> | CatatanHarianCreateWithoutTenantInput[] | CatatanHarianUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: CatatanHarianCreateOrConnectWithoutTenantInput | CatatanHarianCreateOrConnectWithoutTenantInput[]
    createMany?: CatatanHarianCreateManyTenantInputEnvelope
    connect?: CatatanHarianWhereUniqueInput | CatatanHarianWhereUniqueInput[]
  }

  export type PengumumanCreateNestedManyWithoutTenantInput = {
    create?: XOR<PengumumanCreateWithoutTenantInput, PengumumanUncheckedCreateWithoutTenantInput> | PengumumanCreateWithoutTenantInput[] | PengumumanUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: PengumumanCreateOrConnectWithoutTenantInput | PengumumanCreateOrConnectWithoutTenantInput[]
    createMany?: PengumumanCreateManyTenantInputEnvelope
    connect?: PengumumanWhereUniqueInput | PengumumanWhereUniqueInput[]
  }

  export type InvoiceCreateNestedManyWithoutTenantInput = {
    create?: XOR<InvoiceCreateWithoutTenantInput, InvoiceUncheckedCreateWithoutTenantInput> | InvoiceCreateWithoutTenantInput[] | InvoiceUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: InvoiceCreateOrConnectWithoutTenantInput | InvoiceCreateOrConnectWithoutTenantInput[]
    createMany?: InvoiceCreateManyTenantInputEnvelope
    connect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
  }

  export type PelanggaranCreateNestedManyWithoutTenantInput = {
    create?: XOR<PelanggaranCreateWithoutTenantInput, PelanggaranUncheckedCreateWithoutTenantInput> | PelanggaranCreateWithoutTenantInput[] | PelanggaranUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: PelanggaranCreateOrConnectWithoutTenantInput | PelanggaranCreateOrConnectWithoutTenantInput[]
    createMany?: PelanggaranCreateManyTenantInputEnvelope
    connect?: PelanggaranWhereUniqueInput | PelanggaranWhereUniqueInput[]
  }

  export type PembinaanCreateNestedManyWithoutTenantInput = {
    create?: XOR<PembinaanCreateWithoutTenantInput, PembinaanUncheckedCreateWithoutTenantInput> | PembinaanCreateWithoutTenantInput[] | PembinaanUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: PembinaanCreateOrConnectWithoutTenantInput | PembinaanCreateOrConnectWithoutTenantInput[]
    createMany?: PembinaanCreateManyTenantInputEnvelope
    connect?: PembinaanWhereUniqueInput | PembinaanWhereUniqueInput[]
  }

  export type KunjunganCreateNestedManyWithoutTenantInput = {
    create?: XOR<KunjunganCreateWithoutTenantInput, KunjunganUncheckedCreateWithoutTenantInput> | KunjunganCreateWithoutTenantInput[] | KunjunganUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: KunjunganCreateOrConnectWithoutTenantInput | KunjunganCreateOrConnectWithoutTenantInput[]
    createMany?: KunjunganCreateManyTenantInputEnvelope
    connect?: KunjunganWhereUniqueInput | KunjunganWhereUniqueInput[]
  }

  export type HealthRecordCreateNestedManyWithoutTenantInput = {
    create?: XOR<HealthRecordCreateWithoutTenantInput, HealthRecordUncheckedCreateWithoutTenantInput> | HealthRecordCreateWithoutTenantInput[] | HealthRecordUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: HealthRecordCreateOrConnectWithoutTenantInput | HealthRecordCreateOrConnectWithoutTenantInput[]
    createMany?: HealthRecordCreateManyTenantInputEnvelope
    connect?: HealthRecordWhereUniqueInput | HealthRecordWhereUniqueInput[]
  }

  export type AuditLogCreateNestedManyWithoutTenantInput = {
    create?: XOR<AuditLogCreateWithoutTenantInput, AuditLogUncheckedCreateWithoutTenantInput> | AuditLogCreateWithoutTenantInput[] | AuditLogUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutTenantInput | AuditLogCreateOrConnectWithoutTenantInput[]
    createMany?: AuditLogCreateManyTenantInputEnvelope
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
  }

  export type NotificationCreateNestedManyWithoutTenantInput = {
    create?: XOR<NotificationCreateWithoutTenantInput, NotificationUncheckedCreateWithoutTenantInput> | NotificationCreateWithoutTenantInput[] | NotificationUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutTenantInput | NotificationCreateOrConnectWithoutTenantInput[]
    createMany?: NotificationCreateManyTenantInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type WebhookEventCreateNestedManyWithoutTenantInput = {
    create?: XOR<WebhookEventCreateWithoutTenantInput, WebhookEventUncheckedCreateWithoutTenantInput> | WebhookEventCreateWithoutTenantInput[] | WebhookEventUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: WebhookEventCreateOrConnectWithoutTenantInput | WebhookEventCreateOrConnectWithoutTenantInput[]
    createMany?: WebhookEventCreateManyTenantInputEnvelope
    connect?: WebhookEventWhereUniqueInput | WebhookEventWhereUniqueInput[]
  }

  export type UserUncheckedCreateNestedManyWithoutTenantInput = {
    create?: XOR<UserCreateWithoutTenantInput, UserUncheckedCreateWithoutTenantInput> | UserCreateWithoutTenantInput[] | UserUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: UserCreateOrConnectWithoutTenantInput | UserCreateOrConnectWithoutTenantInput[]
    createMany?: UserCreateManyTenantInputEnvelope
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type SantriUncheckedCreateNestedManyWithoutTenantInput = {
    create?: XOR<SantriCreateWithoutTenantInput, SantriUncheckedCreateWithoutTenantInput> | SantriCreateWithoutTenantInput[] | SantriUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: SantriCreateOrConnectWithoutTenantInput | SantriCreateOrConnectWithoutTenantInput[]
    createMany?: SantriCreateManyTenantInputEnvelope
    connect?: SantriWhereUniqueInput | SantriWhereUniqueInput[]
  }

  export type WaliUncheckedCreateNestedManyWithoutTenantInput = {
    create?: XOR<WaliCreateWithoutTenantInput, WaliUncheckedCreateWithoutTenantInput> | WaliCreateWithoutTenantInput[] | WaliUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: WaliCreateOrConnectWithoutTenantInput | WaliCreateOrConnectWithoutTenantInput[]
    createMany?: WaliCreateManyTenantInputEnvelope
    connect?: WaliWhereUniqueInput | WaliWhereUniqueInput[]
  }

  export type IzinUncheckedCreateNestedManyWithoutTenantInput = {
    create?: XOR<IzinCreateWithoutTenantInput, IzinUncheckedCreateWithoutTenantInput> | IzinCreateWithoutTenantInput[] | IzinUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: IzinCreateOrConnectWithoutTenantInput | IzinCreateOrConnectWithoutTenantInput[]
    createMany?: IzinCreateManyTenantInputEnvelope
    connect?: IzinWhereUniqueInput | IzinWhereUniqueInput[]
  }

  export type CatatanHarianUncheckedCreateNestedManyWithoutTenantInput = {
    create?: XOR<CatatanHarianCreateWithoutTenantInput, CatatanHarianUncheckedCreateWithoutTenantInput> | CatatanHarianCreateWithoutTenantInput[] | CatatanHarianUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: CatatanHarianCreateOrConnectWithoutTenantInput | CatatanHarianCreateOrConnectWithoutTenantInput[]
    createMany?: CatatanHarianCreateManyTenantInputEnvelope
    connect?: CatatanHarianWhereUniqueInput | CatatanHarianWhereUniqueInput[]
  }

  export type PengumumanUncheckedCreateNestedManyWithoutTenantInput = {
    create?: XOR<PengumumanCreateWithoutTenantInput, PengumumanUncheckedCreateWithoutTenantInput> | PengumumanCreateWithoutTenantInput[] | PengumumanUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: PengumumanCreateOrConnectWithoutTenantInput | PengumumanCreateOrConnectWithoutTenantInput[]
    createMany?: PengumumanCreateManyTenantInputEnvelope
    connect?: PengumumanWhereUniqueInput | PengumumanWhereUniqueInput[]
  }

  export type InvoiceUncheckedCreateNestedManyWithoutTenantInput = {
    create?: XOR<InvoiceCreateWithoutTenantInput, InvoiceUncheckedCreateWithoutTenantInput> | InvoiceCreateWithoutTenantInput[] | InvoiceUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: InvoiceCreateOrConnectWithoutTenantInput | InvoiceCreateOrConnectWithoutTenantInput[]
    createMany?: InvoiceCreateManyTenantInputEnvelope
    connect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
  }

  export type PelanggaranUncheckedCreateNestedManyWithoutTenantInput = {
    create?: XOR<PelanggaranCreateWithoutTenantInput, PelanggaranUncheckedCreateWithoutTenantInput> | PelanggaranCreateWithoutTenantInput[] | PelanggaranUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: PelanggaranCreateOrConnectWithoutTenantInput | PelanggaranCreateOrConnectWithoutTenantInput[]
    createMany?: PelanggaranCreateManyTenantInputEnvelope
    connect?: PelanggaranWhereUniqueInput | PelanggaranWhereUniqueInput[]
  }

  export type PembinaanUncheckedCreateNestedManyWithoutTenantInput = {
    create?: XOR<PembinaanCreateWithoutTenantInput, PembinaanUncheckedCreateWithoutTenantInput> | PembinaanCreateWithoutTenantInput[] | PembinaanUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: PembinaanCreateOrConnectWithoutTenantInput | PembinaanCreateOrConnectWithoutTenantInput[]
    createMany?: PembinaanCreateManyTenantInputEnvelope
    connect?: PembinaanWhereUniqueInput | PembinaanWhereUniqueInput[]
  }

  export type KunjunganUncheckedCreateNestedManyWithoutTenantInput = {
    create?: XOR<KunjunganCreateWithoutTenantInput, KunjunganUncheckedCreateWithoutTenantInput> | KunjunganCreateWithoutTenantInput[] | KunjunganUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: KunjunganCreateOrConnectWithoutTenantInput | KunjunganCreateOrConnectWithoutTenantInput[]
    createMany?: KunjunganCreateManyTenantInputEnvelope
    connect?: KunjunganWhereUniqueInput | KunjunganWhereUniqueInput[]
  }

  export type HealthRecordUncheckedCreateNestedManyWithoutTenantInput = {
    create?: XOR<HealthRecordCreateWithoutTenantInput, HealthRecordUncheckedCreateWithoutTenantInput> | HealthRecordCreateWithoutTenantInput[] | HealthRecordUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: HealthRecordCreateOrConnectWithoutTenantInput | HealthRecordCreateOrConnectWithoutTenantInput[]
    createMany?: HealthRecordCreateManyTenantInputEnvelope
    connect?: HealthRecordWhereUniqueInput | HealthRecordWhereUniqueInput[]
  }

  export type AuditLogUncheckedCreateNestedManyWithoutTenantInput = {
    create?: XOR<AuditLogCreateWithoutTenantInput, AuditLogUncheckedCreateWithoutTenantInput> | AuditLogCreateWithoutTenantInput[] | AuditLogUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutTenantInput | AuditLogCreateOrConnectWithoutTenantInput[]
    createMany?: AuditLogCreateManyTenantInputEnvelope
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
  }

  export type NotificationUncheckedCreateNestedManyWithoutTenantInput = {
    create?: XOR<NotificationCreateWithoutTenantInput, NotificationUncheckedCreateWithoutTenantInput> | NotificationCreateWithoutTenantInput[] | NotificationUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutTenantInput | NotificationCreateOrConnectWithoutTenantInput[]
    createMany?: NotificationCreateManyTenantInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type WebhookEventUncheckedCreateNestedManyWithoutTenantInput = {
    create?: XOR<WebhookEventCreateWithoutTenantInput, WebhookEventUncheckedCreateWithoutTenantInput> | WebhookEventCreateWithoutTenantInput[] | WebhookEventUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: WebhookEventCreateOrConnectWithoutTenantInput | WebhookEventCreateOrConnectWithoutTenantInput[]
    createMany?: WebhookEventCreateManyTenantInputEnvelope
    connect?: WebhookEventWhereUniqueInput | WebhookEventWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type UserUpdateManyWithoutTenantNestedInput = {
    create?: XOR<UserCreateWithoutTenantInput, UserUncheckedCreateWithoutTenantInput> | UserCreateWithoutTenantInput[] | UserUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: UserCreateOrConnectWithoutTenantInput | UserCreateOrConnectWithoutTenantInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutTenantInput | UserUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: UserCreateManyTenantInputEnvelope
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutTenantInput | UserUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: UserUpdateManyWithWhereWithoutTenantInput | UserUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type SantriUpdateManyWithoutTenantNestedInput = {
    create?: XOR<SantriCreateWithoutTenantInput, SantriUncheckedCreateWithoutTenantInput> | SantriCreateWithoutTenantInput[] | SantriUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: SantriCreateOrConnectWithoutTenantInput | SantriCreateOrConnectWithoutTenantInput[]
    upsert?: SantriUpsertWithWhereUniqueWithoutTenantInput | SantriUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: SantriCreateManyTenantInputEnvelope
    set?: SantriWhereUniqueInput | SantriWhereUniqueInput[]
    disconnect?: SantriWhereUniqueInput | SantriWhereUniqueInput[]
    delete?: SantriWhereUniqueInput | SantriWhereUniqueInput[]
    connect?: SantriWhereUniqueInput | SantriWhereUniqueInput[]
    update?: SantriUpdateWithWhereUniqueWithoutTenantInput | SantriUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: SantriUpdateManyWithWhereWithoutTenantInput | SantriUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: SantriScalarWhereInput | SantriScalarWhereInput[]
  }

  export type WaliUpdateManyWithoutTenantNestedInput = {
    create?: XOR<WaliCreateWithoutTenantInput, WaliUncheckedCreateWithoutTenantInput> | WaliCreateWithoutTenantInput[] | WaliUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: WaliCreateOrConnectWithoutTenantInput | WaliCreateOrConnectWithoutTenantInput[]
    upsert?: WaliUpsertWithWhereUniqueWithoutTenantInput | WaliUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: WaliCreateManyTenantInputEnvelope
    set?: WaliWhereUniqueInput | WaliWhereUniqueInput[]
    disconnect?: WaliWhereUniqueInput | WaliWhereUniqueInput[]
    delete?: WaliWhereUniqueInput | WaliWhereUniqueInput[]
    connect?: WaliWhereUniqueInput | WaliWhereUniqueInput[]
    update?: WaliUpdateWithWhereUniqueWithoutTenantInput | WaliUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: WaliUpdateManyWithWhereWithoutTenantInput | WaliUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: WaliScalarWhereInput | WaliScalarWhereInput[]
  }

  export type IzinUpdateManyWithoutTenantNestedInput = {
    create?: XOR<IzinCreateWithoutTenantInput, IzinUncheckedCreateWithoutTenantInput> | IzinCreateWithoutTenantInput[] | IzinUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: IzinCreateOrConnectWithoutTenantInput | IzinCreateOrConnectWithoutTenantInput[]
    upsert?: IzinUpsertWithWhereUniqueWithoutTenantInput | IzinUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: IzinCreateManyTenantInputEnvelope
    set?: IzinWhereUniqueInput | IzinWhereUniqueInput[]
    disconnect?: IzinWhereUniqueInput | IzinWhereUniqueInput[]
    delete?: IzinWhereUniqueInput | IzinWhereUniqueInput[]
    connect?: IzinWhereUniqueInput | IzinWhereUniqueInput[]
    update?: IzinUpdateWithWhereUniqueWithoutTenantInput | IzinUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: IzinUpdateManyWithWhereWithoutTenantInput | IzinUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: IzinScalarWhereInput | IzinScalarWhereInput[]
  }

  export type CatatanHarianUpdateManyWithoutTenantNestedInput = {
    create?: XOR<CatatanHarianCreateWithoutTenantInput, CatatanHarianUncheckedCreateWithoutTenantInput> | CatatanHarianCreateWithoutTenantInput[] | CatatanHarianUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: CatatanHarianCreateOrConnectWithoutTenantInput | CatatanHarianCreateOrConnectWithoutTenantInput[]
    upsert?: CatatanHarianUpsertWithWhereUniqueWithoutTenantInput | CatatanHarianUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: CatatanHarianCreateManyTenantInputEnvelope
    set?: CatatanHarianWhereUniqueInput | CatatanHarianWhereUniqueInput[]
    disconnect?: CatatanHarianWhereUniqueInput | CatatanHarianWhereUniqueInput[]
    delete?: CatatanHarianWhereUniqueInput | CatatanHarianWhereUniqueInput[]
    connect?: CatatanHarianWhereUniqueInput | CatatanHarianWhereUniqueInput[]
    update?: CatatanHarianUpdateWithWhereUniqueWithoutTenantInput | CatatanHarianUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: CatatanHarianUpdateManyWithWhereWithoutTenantInput | CatatanHarianUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: CatatanHarianScalarWhereInput | CatatanHarianScalarWhereInput[]
  }

  export type PengumumanUpdateManyWithoutTenantNestedInput = {
    create?: XOR<PengumumanCreateWithoutTenantInput, PengumumanUncheckedCreateWithoutTenantInput> | PengumumanCreateWithoutTenantInput[] | PengumumanUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: PengumumanCreateOrConnectWithoutTenantInput | PengumumanCreateOrConnectWithoutTenantInput[]
    upsert?: PengumumanUpsertWithWhereUniqueWithoutTenantInput | PengumumanUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: PengumumanCreateManyTenantInputEnvelope
    set?: PengumumanWhereUniqueInput | PengumumanWhereUniqueInput[]
    disconnect?: PengumumanWhereUniqueInput | PengumumanWhereUniqueInput[]
    delete?: PengumumanWhereUniqueInput | PengumumanWhereUniqueInput[]
    connect?: PengumumanWhereUniqueInput | PengumumanWhereUniqueInput[]
    update?: PengumumanUpdateWithWhereUniqueWithoutTenantInput | PengumumanUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: PengumumanUpdateManyWithWhereWithoutTenantInput | PengumumanUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: PengumumanScalarWhereInput | PengumumanScalarWhereInput[]
  }

  export type InvoiceUpdateManyWithoutTenantNestedInput = {
    create?: XOR<InvoiceCreateWithoutTenantInput, InvoiceUncheckedCreateWithoutTenantInput> | InvoiceCreateWithoutTenantInput[] | InvoiceUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: InvoiceCreateOrConnectWithoutTenantInput | InvoiceCreateOrConnectWithoutTenantInput[]
    upsert?: InvoiceUpsertWithWhereUniqueWithoutTenantInput | InvoiceUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: InvoiceCreateManyTenantInputEnvelope
    set?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    disconnect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    delete?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    connect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    update?: InvoiceUpdateWithWhereUniqueWithoutTenantInput | InvoiceUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: InvoiceUpdateManyWithWhereWithoutTenantInput | InvoiceUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: InvoiceScalarWhereInput | InvoiceScalarWhereInput[]
  }

  export type PelanggaranUpdateManyWithoutTenantNestedInput = {
    create?: XOR<PelanggaranCreateWithoutTenantInput, PelanggaranUncheckedCreateWithoutTenantInput> | PelanggaranCreateWithoutTenantInput[] | PelanggaranUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: PelanggaranCreateOrConnectWithoutTenantInput | PelanggaranCreateOrConnectWithoutTenantInput[]
    upsert?: PelanggaranUpsertWithWhereUniqueWithoutTenantInput | PelanggaranUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: PelanggaranCreateManyTenantInputEnvelope
    set?: PelanggaranWhereUniqueInput | PelanggaranWhereUniqueInput[]
    disconnect?: PelanggaranWhereUniqueInput | PelanggaranWhereUniqueInput[]
    delete?: PelanggaranWhereUniqueInput | PelanggaranWhereUniqueInput[]
    connect?: PelanggaranWhereUniqueInput | PelanggaranWhereUniqueInput[]
    update?: PelanggaranUpdateWithWhereUniqueWithoutTenantInput | PelanggaranUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: PelanggaranUpdateManyWithWhereWithoutTenantInput | PelanggaranUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: PelanggaranScalarWhereInput | PelanggaranScalarWhereInput[]
  }

  export type PembinaanUpdateManyWithoutTenantNestedInput = {
    create?: XOR<PembinaanCreateWithoutTenantInput, PembinaanUncheckedCreateWithoutTenantInput> | PembinaanCreateWithoutTenantInput[] | PembinaanUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: PembinaanCreateOrConnectWithoutTenantInput | PembinaanCreateOrConnectWithoutTenantInput[]
    upsert?: PembinaanUpsertWithWhereUniqueWithoutTenantInput | PembinaanUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: PembinaanCreateManyTenantInputEnvelope
    set?: PembinaanWhereUniqueInput | PembinaanWhereUniqueInput[]
    disconnect?: PembinaanWhereUniqueInput | PembinaanWhereUniqueInput[]
    delete?: PembinaanWhereUniqueInput | PembinaanWhereUniqueInput[]
    connect?: PembinaanWhereUniqueInput | PembinaanWhereUniqueInput[]
    update?: PembinaanUpdateWithWhereUniqueWithoutTenantInput | PembinaanUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: PembinaanUpdateManyWithWhereWithoutTenantInput | PembinaanUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: PembinaanScalarWhereInput | PembinaanScalarWhereInput[]
  }

  export type KunjunganUpdateManyWithoutTenantNestedInput = {
    create?: XOR<KunjunganCreateWithoutTenantInput, KunjunganUncheckedCreateWithoutTenantInput> | KunjunganCreateWithoutTenantInput[] | KunjunganUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: KunjunganCreateOrConnectWithoutTenantInput | KunjunganCreateOrConnectWithoutTenantInput[]
    upsert?: KunjunganUpsertWithWhereUniqueWithoutTenantInput | KunjunganUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: KunjunganCreateManyTenantInputEnvelope
    set?: KunjunganWhereUniqueInput | KunjunganWhereUniqueInput[]
    disconnect?: KunjunganWhereUniqueInput | KunjunganWhereUniqueInput[]
    delete?: KunjunganWhereUniqueInput | KunjunganWhereUniqueInput[]
    connect?: KunjunganWhereUniqueInput | KunjunganWhereUniqueInput[]
    update?: KunjunganUpdateWithWhereUniqueWithoutTenantInput | KunjunganUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: KunjunganUpdateManyWithWhereWithoutTenantInput | KunjunganUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: KunjunganScalarWhereInput | KunjunganScalarWhereInput[]
  }

  export type HealthRecordUpdateManyWithoutTenantNestedInput = {
    create?: XOR<HealthRecordCreateWithoutTenantInput, HealthRecordUncheckedCreateWithoutTenantInput> | HealthRecordCreateWithoutTenantInput[] | HealthRecordUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: HealthRecordCreateOrConnectWithoutTenantInput | HealthRecordCreateOrConnectWithoutTenantInput[]
    upsert?: HealthRecordUpsertWithWhereUniqueWithoutTenantInput | HealthRecordUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: HealthRecordCreateManyTenantInputEnvelope
    set?: HealthRecordWhereUniqueInput | HealthRecordWhereUniqueInput[]
    disconnect?: HealthRecordWhereUniqueInput | HealthRecordWhereUniqueInput[]
    delete?: HealthRecordWhereUniqueInput | HealthRecordWhereUniqueInput[]
    connect?: HealthRecordWhereUniqueInput | HealthRecordWhereUniqueInput[]
    update?: HealthRecordUpdateWithWhereUniqueWithoutTenantInput | HealthRecordUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: HealthRecordUpdateManyWithWhereWithoutTenantInput | HealthRecordUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: HealthRecordScalarWhereInput | HealthRecordScalarWhereInput[]
  }

  export type AuditLogUpdateManyWithoutTenantNestedInput = {
    create?: XOR<AuditLogCreateWithoutTenantInput, AuditLogUncheckedCreateWithoutTenantInput> | AuditLogCreateWithoutTenantInput[] | AuditLogUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutTenantInput | AuditLogCreateOrConnectWithoutTenantInput[]
    upsert?: AuditLogUpsertWithWhereUniqueWithoutTenantInput | AuditLogUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: AuditLogCreateManyTenantInputEnvelope
    set?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    disconnect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    delete?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    update?: AuditLogUpdateWithWhereUniqueWithoutTenantInput | AuditLogUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: AuditLogUpdateManyWithWhereWithoutTenantInput | AuditLogUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
  }

  export type NotificationUpdateManyWithoutTenantNestedInput = {
    create?: XOR<NotificationCreateWithoutTenantInput, NotificationUncheckedCreateWithoutTenantInput> | NotificationCreateWithoutTenantInput[] | NotificationUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutTenantInput | NotificationCreateOrConnectWithoutTenantInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutTenantInput | NotificationUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: NotificationCreateManyTenantInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutTenantInput | NotificationUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutTenantInput | NotificationUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type WebhookEventUpdateManyWithoutTenantNestedInput = {
    create?: XOR<WebhookEventCreateWithoutTenantInput, WebhookEventUncheckedCreateWithoutTenantInput> | WebhookEventCreateWithoutTenantInput[] | WebhookEventUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: WebhookEventCreateOrConnectWithoutTenantInput | WebhookEventCreateOrConnectWithoutTenantInput[]
    upsert?: WebhookEventUpsertWithWhereUniqueWithoutTenantInput | WebhookEventUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: WebhookEventCreateManyTenantInputEnvelope
    set?: WebhookEventWhereUniqueInput | WebhookEventWhereUniqueInput[]
    disconnect?: WebhookEventWhereUniqueInput | WebhookEventWhereUniqueInput[]
    delete?: WebhookEventWhereUniqueInput | WebhookEventWhereUniqueInput[]
    connect?: WebhookEventWhereUniqueInput | WebhookEventWhereUniqueInput[]
    update?: WebhookEventUpdateWithWhereUniqueWithoutTenantInput | WebhookEventUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: WebhookEventUpdateManyWithWhereWithoutTenantInput | WebhookEventUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: WebhookEventScalarWhereInput | WebhookEventScalarWhereInput[]
  }

  export type UserUncheckedUpdateManyWithoutTenantNestedInput = {
    create?: XOR<UserCreateWithoutTenantInput, UserUncheckedCreateWithoutTenantInput> | UserCreateWithoutTenantInput[] | UserUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: UserCreateOrConnectWithoutTenantInput | UserCreateOrConnectWithoutTenantInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutTenantInput | UserUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: UserCreateManyTenantInputEnvelope
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutTenantInput | UserUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: UserUpdateManyWithWhereWithoutTenantInput | UserUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type SantriUncheckedUpdateManyWithoutTenantNestedInput = {
    create?: XOR<SantriCreateWithoutTenantInput, SantriUncheckedCreateWithoutTenantInput> | SantriCreateWithoutTenantInput[] | SantriUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: SantriCreateOrConnectWithoutTenantInput | SantriCreateOrConnectWithoutTenantInput[]
    upsert?: SantriUpsertWithWhereUniqueWithoutTenantInput | SantriUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: SantriCreateManyTenantInputEnvelope
    set?: SantriWhereUniqueInput | SantriWhereUniqueInput[]
    disconnect?: SantriWhereUniqueInput | SantriWhereUniqueInput[]
    delete?: SantriWhereUniqueInput | SantriWhereUniqueInput[]
    connect?: SantriWhereUniqueInput | SantriWhereUniqueInput[]
    update?: SantriUpdateWithWhereUniqueWithoutTenantInput | SantriUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: SantriUpdateManyWithWhereWithoutTenantInput | SantriUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: SantriScalarWhereInput | SantriScalarWhereInput[]
  }

  export type WaliUncheckedUpdateManyWithoutTenantNestedInput = {
    create?: XOR<WaliCreateWithoutTenantInput, WaliUncheckedCreateWithoutTenantInput> | WaliCreateWithoutTenantInput[] | WaliUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: WaliCreateOrConnectWithoutTenantInput | WaliCreateOrConnectWithoutTenantInput[]
    upsert?: WaliUpsertWithWhereUniqueWithoutTenantInput | WaliUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: WaliCreateManyTenantInputEnvelope
    set?: WaliWhereUniqueInput | WaliWhereUniqueInput[]
    disconnect?: WaliWhereUniqueInput | WaliWhereUniqueInput[]
    delete?: WaliWhereUniqueInput | WaliWhereUniqueInput[]
    connect?: WaliWhereUniqueInput | WaliWhereUniqueInput[]
    update?: WaliUpdateWithWhereUniqueWithoutTenantInput | WaliUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: WaliUpdateManyWithWhereWithoutTenantInput | WaliUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: WaliScalarWhereInput | WaliScalarWhereInput[]
  }

  export type IzinUncheckedUpdateManyWithoutTenantNestedInput = {
    create?: XOR<IzinCreateWithoutTenantInput, IzinUncheckedCreateWithoutTenantInput> | IzinCreateWithoutTenantInput[] | IzinUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: IzinCreateOrConnectWithoutTenantInput | IzinCreateOrConnectWithoutTenantInput[]
    upsert?: IzinUpsertWithWhereUniqueWithoutTenantInput | IzinUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: IzinCreateManyTenantInputEnvelope
    set?: IzinWhereUniqueInput | IzinWhereUniqueInput[]
    disconnect?: IzinWhereUniqueInput | IzinWhereUniqueInput[]
    delete?: IzinWhereUniqueInput | IzinWhereUniqueInput[]
    connect?: IzinWhereUniqueInput | IzinWhereUniqueInput[]
    update?: IzinUpdateWithWhereUniqueWithoutTenantInput | IzinUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: IzinUpdateManyWithWhereWithoutTenantInput | IzinUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: IzinScalarWhereInput | IzinScalarWhereInput[]
  }

  export type CatatanHarianUncheckedUpdateManyWithoutTenantNestedInput = {
    create?: XOR<CatatanHarianCreateWithoutTenantInput, CatatanHarianUncheckedCreateWithoutTenantInput> | CatatanHarianCreateWithoutTenantInput[] | CatatanHarianUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: CatatanHarianCreateOrConnectWithoutTenantInput | CatatanHarianCreateOrConnectWithoutTenantInput[]
    upsert?: CatatanHarianUpsertWithWhereUniqueWithoutTenantInput | CatatanHarianUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: CatatanHarianCreateManyTenantInputEnvelope
    set?: CatatanHarianWhereUniqueInput | CatatanHarianWhereUniqueInput[]
    disconnect?: CatatanHarianWhereUniqueInput | CatatanHarianWhereUniqueInput[]
    delete?: CatatanHarianWhereUniqueInput | CatatanHarianWhereUniqueInput[]
    connect?: CatatanHarianWhereUniqueInput | CatatanHarianWhereUniqueInput[]
    update?: CatatanHarianUpdateWithWhereUniqueWithoutTenantInput | CatatanHarianUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: CatatanHarianUpdateManyWithWhereWithoutTenantInput | CatatanHarianUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: CatatanHarianScalarWhereInput | CatatanHarianScalarWhereInput[]
  }

  export type PengumumanUncheckedUpdateManyWithoutTenantNestedInput = {
    create?: XOR<PengumumanCreateWithoutTenantInput, PengumumanUncheckedCreateWithoutTenantInput> | PengumumanCreateWithoutTenantInput[] | PengumumanUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: PengumumanCreateOrConnectWithoutTenantInput | PengumumanCreateOrConnectWithoutTenantInput[]
    upsert?: PengumumanUpsertWithWhereUniqueWithoutTenantInput | PengumumanUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: PengumumanCreateManyTenantInputEnvelope
    set?: PengumumanWhereUniqueInput | PengumumanWhereUniqueInput[]
    disconnect?: PengumumanWhereUniqueInput | PengumumanWhereUniqueInput[]
    delete?: PengumumanWhereUniqueInput | PengumumanWhereUniqueInput[]
    connect?: PengumumanWhereUniqueInput | PengumumanWhereUniqueInput[]
    update?: PengumumanUpdateWithWhereUniqueWithoutTenantInput | PengumumanUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: PengumumanUpdateManyWithWhereWithoutTenantInput | PengumumanUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: PengumumanScalarWhereInput | PengumumanScalarWhereInput[]
  }

  export type InvoiceUncheckedUpdateManyWithoutTenantNestedInput = {
    create?: XOR<InvoiceCreateWithoutTenantInput, InvoiceUncheckedCreateWithoutTenantInput> | InvoiceCreateWithoutTenantInput[] | InvoiceUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: InvoiceCreateOrConnectWithoutTenantInput | InvoiceCreateOrConnectWithoutTenantInput[]
    upsert?: InvoiceUpsertWithWhereUniqueWithoutTenantInput | InvoiceUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: InvoiceCreateManyTenantInputEnvelope
    set?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    disconnect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    delete?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    connect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    update?: InvoiceUpdateWithWhereUniqueWithoutTenantInput | InvoiceUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: InvoiceUpdateManyWithWhereWithoutTenantInput | InvoiceUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: InvoiceScalarWhereInput | InvoiceScalarWhereInput[]
  }

  export type PelanggaranUncheckedUpdateManyWithoutTenantNestedInput = {
    create?: XOR<PelanggaranCreateWithoutTenantInput, PelanggaranUncheckedCreateWithoutTenantInput> | PelanggaranCreateWithoutTenantInput[] | PelanggaranUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: PelanggaranCreateOrConnectWithoutTenantInput | PelanggaranCreateOrConnectWithoutTenantInput[]
    upsert?: PelanggaranUpsertWithWhereUniqueWithoutTenantInput | PelanggaranUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: PelanggaranCreateManyTenantInputEnvelope
    set?: PelanggaranWhereUniqueInput | PelanggaranWhereUniqueInput[]
    disconnect?: PelanggaranWhereUniqueInput | PelanggaranWhereUniqueInput[]
    delete?: PelanggaranWhereUniqueInput | PelanggaranWhereUniqueInput[]
    connect?: PelanggaranWhereUniqueInput | PelanggaranWhereUniqueInput[]
    update?: PelanggaranUpdateWithWhereUniqueWithoutTenantInput | PelanggaranUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: PelanggaranUpdateManyWithWhereWithoutTenantInput | PelanggaranUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: PelanggaranScalarWhereInput | PelanggaranScalarWhereInput[]
  }

  export type PembinaanUncheckedUpdateManyWithoutTenantNestedInput = {
    create?: XOR<PembinaanCreateWithoutTenantInput, PembinaanUncheckedCreateWithoutTenantInput> | PembinaanCreateWithoutTenantInput[] | PembinaanUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: PembinaanCreateOrConnectWithoutTenantInput | PembinaanCreateOrConnectWithoutTenantInput[]
    upsert?: PembinaanUpsertWithWhereUniqueWithoutTenantInput | PembinaanUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: PembinaanCreateManyTenantInputEnvelope
    set?: PembinaanWhereUniqueInput | PembinaanWhereUniqueInput[]
    disconnect?: PembinaanWhereUniqueInput | PembinaanWhereUniqueInput[]
    delete?: PembinaanWhereUniqueInput | PembinaanWhereUniqueInput[]
    connect?: PembinaanWhereUniqueInput | PembinaanWhereUniqueInput[]
    update?: PembinaanUpdateWithWhereUniqueWithoutTenantInput | PembinaanUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: PembinaanUpdateManyWithWhereWithoutTenantInput | PembinaanUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: PembinaanScalarWhereInput | PembinaanScalarWhereInput[]
  }

  export type KunjunganUncheckedUpdateManyWithoutTenantNestedInput = {
    create?: XOR<KunjunganCreateWithoutTenantInput, KunjunganUncheckedCreateWithoutTenantInput> | KunjunganCreateWithoutTenantInput[] | KunjunganUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: KunjunganCreateOrConnectWithoutTenantInput | KunjunganCreateOrConnectWithoutTenantInput[]
    upsert?: KunjunganUpsertWithWhereUniqueWithoutTenantInput | KunjunganUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: KunjunganCreateManyTenantInputEnvelope
    set?: KunjunganWhereUniqueInput | KunjunganWhereUniqueInput[]
    disconnect?: KunjunganWhereUniqueInput | KunjunganWhereUniqueInput[]
    delete?: KunjunganWhereUniqueInput | KunjunganWhereUniqueInput[]
    connect?: KunjunganWhereUniqueInput | KunjunganWhereUniqueInput[]
    update?: KunjunganUpdateWithWhereUniqueWithoutTenantInput | KunjunganUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: KunjunganUpdateManyWithWhereWithoutTenantInput | KunjunganUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: KunjunganScalarWhereInput | KunjunganScalarWhereInput[]
  }

  export type HealthRecordUncheckedUpdateManyWithoutTenantNestedInput = {
    create?: XOR<HealthRecordCreateWithoutTenantInput, HealthRecordUncheckedCreateWithoutTenantInput> | HealthRecordCreateWithoutTenantInput[] | HealthRecordUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: HealthRecordCreateOrConnectWithoutTenantInput | HealthRecordCreateOrConnectWithoutTenantInput[]
    upsert?: HealthRecordUpsertWithWhereUniqueWithoutTenantInput | HealthRecordUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: HealthRecordCreateManyTenantInputEnvelope
    set?: HealthRecordWhereUniqueInput | HealthRecordWhereUniqueInput[]
    disconnect?: HealthRecordWhereUniqueInput | HealthRecordWhereUniqueInput[]
    delete?: HealthRecordWhereUniqueInput | HealthRecordWhereUniqueInput[]
    connect?: HealthRecordWhereUniqueInput | HealthRecordWhereUniqueInput[]
    update?: HealthRecordUpdateWithWhereUniqueWithoutTenantInput | HealthRecordUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: HealthRecordUpdateManyWithWhereWithoutTenantInput | HealthRecordUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: HealthRecordScalarWhereInput | HealthRecordScalarWhereInput[]
  }

  export type AuditLogUncheckedUpdateManyWithoutTenantNestedInput = {
    create?: XOR<AuditLogCreateWithoutTenantInput, AuditLogUncheckedCreateWithoutTenantInput> | AuditLogCreateWithoutTenantInput[] | AuditLogUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutTenantInput | AuditLogCreateOrConnectWithoutTenantInput[]
    upsert?: AuditLogUpsertWithWhereUniqueWithoutTenantInput | AuditLogUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: AuditLogCreateManyTenantInputEnvelope
    set?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    disconnect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    delete?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    update?: AuditLogUpdateWithWhereUniqueWithoutTenantInput | AuditLogUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: AuditLogUpdateManyWithWhereWithoutTenantInput | AuditLogUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
  }

  export type NotificationUncheckedUpdateManyWithoutTenantNestedInput = {
    create?: XOR<NotificationCreateWithoutTenantInput, NotificationUncheckedCreateWithoutTenantInput> | NotificationCreateWithoutTenantInput[] | NotificationUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutTenantInput | NotificationCreateOrConnectWithoutTenantInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutTenantInput | NotificationUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: NotificationCreateManyTenantInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutTenantInput | NotificationUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutTenantInput | NotificationUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type WebhookEventUncheckedUpdateManyWithoutTenantNestedInput = {
    create?: XOR<WebhookEventCreateWithoutTenantInput, WebhookEventUncheckedCreateWithoutTenantInput> | WebhookEventCreateWithoutTenantInput[] | WebhookEventUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: WebhookEventCreateOrConnectWithoutTenantInput | WebhookEventCreateOrConnectWithoutTenantInput[]
    upsert?: WebhookEventUpsertWithWhereUniqueWithoutTenantInput | WebhookEventUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: WebhookEventCreateManyTenantInputEnvelope
    set?: WebhookEventWhereUniqueInput | WebhookEventWhereUniqueInput[]
    disconnect?: WebhookEventWhereUniqueInput | WebhookEventWhereUniqueInput[]
    delete?: WebhookEventWhereUniqueInput | WebhookEventWhereUniqueInput[]
    connect?: WebhookEventWhereUniqueInput | WebhookEventWhereUniqueInput[]
    update?: WebhookEventUpdateWithWhereUniqueWithoutTenantInput | WebhookEventUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: WebhookEventUpdateManyWithWhereWithoutTenantInput | WebhookEventUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: WebhookEventScalarWhereInput | WebhookEventScalarWhereInput[]
  }

  export type TenantCreateNestedOneWithoutUsersInput = {
    create?: XOR<TenantCreateWithoutUsersInput, TenantUncheckedCreateWithoutUsersInput>
    connectOrCreate?: TenantCreateOrConnectWithoutUsersInput
    connect?: TenantWhereUniqueInput
  }

  export type RefreshTokenCreateNestedManyWithoutUserInput = {
    create?: XOR<RefreshTokenCreateWithoutUserInput, RefreshTokenUncheckedCreateWithoutUserInput> | RefreshTokenCreateWithoutUserInput[] | RefreshTokenUncheckedCreateWithoutUserInput[]
    connectOrCreate?: RefreshTokenCreateOrConnectWithoutUserInput | RefreshTokenCreateOrConnectWithoutUserInput[]
    createMany?: RefreshTokenCreateManyUserInputEnvelope
    connect?: RefreshTokenWhereUniqueInput | RefreshTokenWhereUniqueInput[]
  }

  export type AuditLogCreateNestedManyWithoutUserInput = {
    create?: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput> | AuditLogCreateWithoutUserInput[] | AuditLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutUserInput | AuditLogCreateOrConnectWithoutUserInput[]
    createMany?: AuditLogCreateManyUserInputEnvelope
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
  }

  export type NotificationCreateNestedManyWithoutUserInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type RefreshTokenUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<RefreshTokenCreateWithoutUserInput, RefreshTokenUncheckedCreateWithoutUserInput> | RefreshTokenCreateWithoutUserInput[] | RefreshTokenUncheckedCreateWithoutUserInput[]
    connectOrCreate?: RefreshTokenCreateOrConnectWithoutUserInput | RefreshTokenCreateOrConnectWithoutUserInput[]
    createMany?: RefreshTokenCreateManyUserInputEnvelope
    connect?: RefreshTokenWhereUniqueInput | RefreshTokenWhereUniqueInput[]
  }

  export type AuditLogUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput> | AuditLogCreateWithoutUserInput[] | AuditLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutUserInput | AuditLogCreateOrConnectWithoutUserInput[]
    createMany?: AuditLogCreateManyUserInputEnvelope
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
  }

  export type NotificationUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type TenantUpdateOneWithoutUsersNestedInput = {
    create?: XOR<TenantCreateWithoutUsersInput, TenantUncheckedCreateWithoutUsersInput>
    connectOrCreate?: TenantCreateOrConnectWithoutUsersInput
    upsert?: TenantUpsertWithoutUsersInput
    disconnect?: TenantWhereInput | boolean
    delete?: TenantWhereInput | boolean
    connect?: TenantWhereUniqueInput
    update?: XOR<XOR<TenantUpdateToOneWithWhereWithoutUsersInput, TenantUpdateWithoutUsersInput>, TenantUncheckedUpdateWithoutUsersInput>
  }

  export type RefreshTokenUpdateManyWithoutUserNestedInput = {
    create?: XOR<RefreshTokenCreateWithoutUserInput, RefreshTokenUncheckedCreateWithoutUserInput> | RefreshTokenCreateWithoutUserInput[] | RefreshTokenUncheckedCreateWithoutUserInput[]
    connectOrCreate?: RefreshTokenCreateOrConnectWithoutUserInput | RefreshTokenCreateOrConnectWithoutUserInput[]
    upsert?: RefreshTokenUpsertWithWhereUniqueWithoutUserInput | RefreshTokenUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: RefreshTokenCreateManyUserInputEnvelope
    set?: RefreshTokenWhereUniqueInput | RefreshTokenWhereUniqueInput[]
    disconnect?: RefreshTokenWhereUniqueInput | RefreshTokenWhereUniqueInput[]
    delete?: RefreshTokenWhereUniqueInput | RefreshTokenWhereUniqueInput[]
    connect?: RefreshTokenWhereUniqueInput | RefreshTokenWhereUniqueInput[]
    update?: RefreshTokenUpdateWithWhereUniqueWithoutUserInput | RefreshTokenUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: RefreshTokenUpdateManyWithWhereWithoutUserInput | RefreshTokenUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: RefreshTokenScalarWhereInput | RefreshTokenScalarWhereInput[]
  }

  export type AuditLogUpdateManyWithoutUserNestedInput = {
    create?: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput> | AuditLogCreateWithoutUserInput[] | AuditLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutUserInput | AuditLogCreateOrConnectWithoutUserInput[]
    upsert?: AuditLogUpsertWithWhereUniqueWithoutUserInput | AuditLogUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AuditLogCreateManyUserInputEnvelope
    set?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    disconnect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    delete?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    update?: AuditLogUpdateWithWhereUniqueWithoutUserInput | AuditLogUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AuditLogUpdateManyWithWhereWithoutUserInput | AuditLogUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
  }

  export type NotificationUpdateManyWithoutUserNestedInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutUserInput | NotificationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutUserInput | NotificationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutUserInput | NotificationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type RefreshTokenUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<RefreshTokenCreateWithoutUserInput, RefreshTokenUncheckedCreateWithoutUserInput> | RefreshTokenCreateWithoutUserInput[] | RefreshTokenUncheckedCreateWithoutUserInput[]
    connectOrCreate?: RefreshTokenCreateOrConnectWithoutUserInput | RefreshTokenCreateOrConnectWithoutUserInput[]
    upsert?: RefreshTokenUpsertWithWhereUniqueWithoutUserInput | RefreshTokenUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: RefreshTokenCreateManyUserInputEnvelope
    set?: RefreshTokenWhereUniqueInput | RefreshTokenWhereUniqueInput[]
    disconnect?: RefreshTokenWhereUniqueInput | RefreshTokenWhereUniqueInput[]
    delete?: RefreshTokenWhereUniqueInput | RefreshTokenWhereUniqueInput[]
    connect?: RefreshTokenWhereUniqueInput | RefreshTokenWhereUniqueInput[]
    update?: RefreshTokenUpdateWithWhereUniqueWithoutUserInput | RefreshTokenUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: RefreshTokenUpdateManyWithWhereWithoutUserInput | RefreshTokenUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: RefreshTokenScalarWhereInput | RefreshTokenScalarWhereInput[]
  }

  export type AuditLogUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput> | AuditLogCreateWithoutUserInput[] | AuditLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutUserInput | AuditLogCreateOrConnectWithoutUserInput[]
    upsert?: AuditLogUpsertWithWhereUniqueWithoutUserInput | AuditLogUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AuditLogCreateManyUserInputEnvelope
    set?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    disconnect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    delete?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    update?: AuditLogUpdateWithWhereUniqueWithoutUserInput | AuditLogUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AuditLogUpdateManyWithWhereWithoutUserInput | AuditLogUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
  }

  export type NotificationUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutUserInput | NotificationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutUserInput | NotificationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutUserInput | NotificationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutRefreshTokensInput = {
    create?: XOR<UserCreateWithoutRefreshTokensInput, UserUncheckedCreateWithoutRefreshTokensInput>
    connectOrCreate?: UserCreateOrConnectWithoutRefreshTokensInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutRefreshTokensNestedInput = {
    create?: XOR<UserCreateWithoutRefreshTokensInput, UserUncheckedCreateWithoutRefreshTokensInput>
    connectOrCreate?: UserCreateOrConnectWithoutRefreshTokensInput
    upsert?: UserUpsertWithoutRefreshTokensInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutRefreshTokensInput, UserUpdateWithoutRefreshTokensInput>, UserUncheckedUpdateWithoutRefreshTokensInput>
  }

  export type TenantCreateNestedOneWithoutSantriInput = {
    create?: XOR<TenantCreateWithoutSantriInput, TenantUncheckedCreateWithoutSantriInput>
    connectOrCreate?: TenantCreateOrConnectWithoutSantriInput
    connect?: TenantWhereUniqueInput
  }

  export type SantriWaliCreateNestedManyWithoutSantriInput = {
    create?: XOR<SantriWaliCreateWithoutSantriInput, SantriWaliUncheckedCreateWithoutSantriInput> | SantriWaliCreateWithoutSantriInput[] | SantriWaliUncheckedCreateWithoutSantriInput[]
    connectOrCreate?: SantriWaliCreateOrConnectWithoutSantriInput | SantriWaliCreateOrConnectWithoutSantriInput[]
    createMany?: SantriWaliCreateManySantriInputEnvelope
    connect?: SantriWaliWhereUniqueInput | SantriWaliWhereUniqueInput[]
  }

  export type IzinCreateNestedManyWithoutSantriInput = {
    create?: XOR<IzinCreateWithoutSantriInput, IzinUncheckedCreateWithoutSantriInput> | IzinCreateWithoutSantriInput[] | IzinUncheckedCreateWithoutSantriInput[]
    connectOrCreate?: IzinCreateOrConnectWithoutSantriInput | IzinCreateOrConnectWithoutSantriInput[]
    createMany?: IzinCreateManySantriInputEnvelope
    connect?: IzinWhereUniqueInput | IzinWhereUniqueInput[]
  }

  export type CatatanHarianCreateNestedManyWithoutSantriInput = {
    create?: XOR<CatatanHarianCreateWithoutSantriInput, CatatanHarianUncheckedCreateWithoutSantriInput> | CatatanHarianCreateWithoutSantriInput[] | CatatanHarianUncheckedCreateWithoutSantriInput[]
    connectOrCreate?: CatatanHarianCreateOrConnectWithoutSantriInput | CatatanHarianCreateOrConnectWithoutSantriInput[]
    createMany?: CatatanHarianCreateManySantriInputEnvelope
    connect?: CatatanHarianWhereUniqueInput | CatatanHarianWhereUniqueInput[]
  }

  export type InvoiceCreateNestedManyWithoutSantriInput = {
    create?: XOR<InvoiceCreateWithoutSantriInput, InvoiceUncheckedCreateWithoutSantriInput> | InvoiceCreateWithoutSantriInput[] | InvoiceUncheckedCreateWithoutSantriInput[]
    connectOrCreate?: InvoiceCreateOrConnectWithoutSantriInput | InvoiceCreateOrConnectWithoutSantriInput[]
    createMany?: InvoiceCreateManySantriInputEnvelope
    connect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
  }

  export type PelanggaranCreateNestedManyWithoutSantriInput = {
    create?: XOR<PelanggaranCreateWithoutSantriInput, PelanggaranUncheckedCreateWithoutSantriInput> | PelanggaranCreateWithoutSantriInput[] | PelanggaranUncheckedCreateWithoutSantriInput[]
    connectOrCreate?: PelanggaranCreateOrConnectWithoutSantriInput | PelanggaranCreateOrConnectWithoutSantriInput[]
    createMany?: PelanggaranCreateManySantriInputEnvelope
    connect?: PelanggaranWhereUniqueInput | PelanggaranWhereUniqueInput[]
  }

  export type PembinaanCreateNestedManyWithoutSantriInput = {
    create?: XOR<PembinaanCreateWithoutSantriInput, PembinaanUncheckedCreateWithoutSantriInput> | PembinaanCreateWithoutSantriInput[] | PembinaanUncheckedCreateWithoutSantriInput[]
    connectOrCreate?: PembinaanCreateOrConnectWithoutSantriInput | PembinaanCreateOrConnectWithoutSantriInput[]
    createMany?: PembinaanCreateManySantriInputEnvelope
    connect?: PembinaanWhereUniqueInput | PembinaanWhereUniqueInput[]
  }

  export type KunjunganCreateNestedManyWithoutSantriInput = {
    create?: XOR<KunjunganCreateWithoutSantriInput, KunjunganUncheckedCreateWithoutSantriInput> | KunjunganCreateWithoutSantriInput[] | KunjunganUncheckedCreateWithoutSantriInput[]
    connectOrCreate?: KunjunganCreateOrConnectWithoutSantriInput | KunjunganCreateOrConnectWithoutSantriInput[]
    createMany?: KunjunganCreateManySantriInputEnvelope
    connect?: KunjunganWhereUniqueInput | KunjunganWhereUniqueInput[]
  }

  export type HealthRecordCreateNestedManyWithoutSantriInput = {
    create?: XOR<HealthRecordCreateWithoutSantriInput, HealthRecordUncheckedCreateWithoutSantriInput> | HealthRecordCreateWithoutSantriInput[] | HealthRecordUncheckedCreateWithoutSantriInput[]
    connectOrCreate?: HealthRecordCreateOrConnectWithoutSantriInput | HealthRecordCreateOrConnectWithoutSantriInput[]
    createMany?: HealthRecordCreateManySantriInputEnvelope
    connect?: HealthRecordWhereUniqueInput | HealthRecordWhereUniqueInput[]
  }

  export type MedicationCreateNestedManyWithoutSantriInput = {
    create?: XOR<MedicationCreateWithoutSantriInput, MedicationUncheckedCreateWithoutSantriInput> | MedicationCreateWithoutSantriInput[] | MedicationUncheckedCreateWithoutSantriInput[]
    connectOrCreate?: MedicationCreateOrConnectWithoutSantriInput | MedicationCreateOrConnectWithoutSantriInput[]
    createMany?: MedicationCreateManySantriInputEnvelope
    connect?: MedicationWhereUniqueInput | MedicationWhereUniqueInput[]
  }

  export type SantriWaliUncheckedCreateNestedManyWithoutSantriInput = {
    create?: XOR<SantriWaliCreateWithoutSantriInput, SantriWaliUncheckedCreateWithoutSantriInput> | SantriWaliCreateWithoutSantriInput[] | SantriWaliUncheckedCreateWithoutSantriInput[]
    connectOrCreate?: SantriWaliCreateOrConnectWithoutSantriInput | SantriWaliCreateOrConnectWithoutSantriInput[]
    createMany?: SantriWaliCreateManySantriInputEnvelope
    connect?: SantriWaliWhereUniqueInput | SantriWaliWhereUniqueInput[]
  }

  export type IzinUncheckedCreateNestedManyWithoutSantriInput = {
    create?: XOR<IzinCreateWithoutSantriInput, IzinUncheckedCreateWithoutSantriInput> | IzinCreateWithoutSantriInput[] | IzinUncheckedCreateWithoutSantriInput[]
    connectOrCreate?: IzinCreateOrConnectWithoutSantriInput | IzinCreateOrConnectWithoutSantriInput[]
    createMany?: IzinCreateManySantriInputEnvelope
    connect?: IzinWhereUniqueInput | IzinWhereUniqueInput[]
  }

  export type CatatanHarianUncheckedCreateNestedManyWithoutSantriInput = {
    create?: XOR<CatatanHarianCreateWithoutSantriInput, CatatanHarianUncheckedCreateWithoutSantriInput> | CatatanHarianCreateWithoutSantriInput[] | CatatanHarianUncheckedCreateWithoutSantriInput[]
    connectOrCreate?: CatatanHarianCreateOrConnectWithoutSantriInput | CatatanHarianCreateOrConnectWithoutSantriInput[]
    createMany?: CatatanHarianCreateManySantriInputEnvelope
    connect?: CatatanHarianWhereUniqueInput | CatatanHarianWhereUniqueInput[]
  }

  export type InvoiceUncheckedCreateNestedManyWithoutSantriInput = {
    create?: XOR<InvoiceCreateWithoutSantriInput, InvoiceUncheckedCreateWithoutSantriInput> | InvoiceCreateWithoutSantriInput[] | InvoiceUncheckedCreateWithoutSantriInput[]
    connectOrCreate?: InvoiceCreateOrConnectWithoutSantriInput | InvoiceCreateOrConnectWithoutSantriInput[]
    createMany?: InvoiceCreateManySantriInputEnvelope
    connect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
  }

  export type PelanggaranUncheckedCreateNestedManyWithoutSantriInput = {
    create?: XOR<PelanggaranCreateWithoutSantriInput, PelanggaranUncheckedCreateWithoutSantriInput> | PelanggaranCreateWithoutSantriInput[] | PelanggaranUncheckedCreateWithoutSantriInput[]
    connectOrCreate?: PelanggaranCreateOrConnectWithoutSantriInput | PelanggaranCreateOrConnectWithoutSantriInput[]
    createMany?: PelanggaranCreateManySantriInputEnvelope
    connect?: PelanggaranWhereUniqueInput | PelanggaranWhereUniqueInput[]
  }

  export type PembinaanUncheckedCreateNestedManyWithoutSantriInput = {
    create?: XOR<PembinaanCreateWithoutSantriInput, PembinaanUncheckedCreateWithoutSantriInput> | PembinaanCreateWithoutSantriInput[] | PembinaanUncheckedCreateWithoutSantriInput[]
    connectOrCreate?: PembinaanCreateOrConnectWithoutSantriInput | PembinaanCreateOrConnectWithoutSantriInput[]
    createMany?: PembinaanCreateManySantriInputEnvelope
    connect?: PembinaanWhereUniqueInput | PembinaanWhereUniqueInput[]
  }

  export type KunjunganUncheckedCreateNestedManyWithoutSantriInput = {
    create?: XOR<KunjunganCreateWithoutSantriInput, KunjunganUncheckedCreateWithoutSantriInput> | KunjunganCreateWithoutSantriInput[] | KunjunganUncheckedCreateWithoutSantriInput[]
    connectOrCreate?: KunjunganCreateOrConnectWithoutSantriInput | KunjunganCreateOrConnectWithoutSantriInput[]
    createMany?: KunjunganCreateManySantriInputEnvelope
    connect?: KunjunganWhereUniqueInput | KunjunganWhereUniqueInput[]
  }

  export type HealthRecordUncheckedCreateNestedManyWithoutSantriInput = {
    create?: XOR<HealthRecordCreateWithoutSantriInput, HealthRecordUncheckedCreateWithoutSantriInput> | HealthRecordCreateWithoutSantriInput[] | HealthRecordUncheckedCreateWithoutSantriInput[]
    connectOrCreate?: HealthRecordCreateOrConnectWithoutSantriInput | HealthRecordCreateOrConnectWithoutSantriInput[]
    createMany?: HealthRecordCreateManySantriInputEnvelope
    connect?: HealthRecordWhereUniqueInput | HealthRecordWhereUniqueInput[]
  }

  export type MedicationUncheckedCreateNestedManyWithoutSantriInput = {
    create?: XOR<MedicationCreateWithoutSantriInput, MedicationUncheckedCreateWithoutSantriInput> | MedicationCreateWithoutSantriInput[] | MedicationUncheckedCreateWithoutSantriInput[]
    connectOrCreate?: MedicationCreateOrConnectWithoutSantriInput | MedicationCreateOrConnectWithoutSantriInput[]
    createMany?: MedicationCreateManySantriInputEnvelope
    connect?: MedicationWhereUniqueInput | MedicationWhereUniqueInput[]
  }

  export type TenantUpdateOneRequiredWithoutSantriNestedInput = {
    create?: XOR<TenantCreateWithoutSantriInput, TenantUncheckedCreateWithoutSantriInput>
    connectOrCreate?: TenantCreateOrConnectWithoutSantriInput
    upsert?: TenantUpsertWithoutSantriInput
    connect?: TenantWhereUniqueInput
    update?: XOR<XOR<TenantUpdateToOneWithWhereWithoutSantriInput, TenantUpdateWithoutSantriInput>, TenantUncheckedUpdateWithoutSantriInput>
  }

  export type SantriWaliUpdateManyWithoutSantriNestedInput = {
    create?: XOR<SantriWaliCreateWithoutSantriInput, SantriWaliUncheckedCreateWithoutSantriInput> | SantriWaliCreateWithoutSantriInput[] | SantriWaliUncheckedCreateWithoutSantriInput[]
    connectOrCreate?: SantriWaliCreateOrConnectWithoutSantriInput | SantriWaliCreateOrConnectWithoutSantriInput[]
    upsert?: SantriWaliUpsertWithWhereUniqueWithoutSantriInput | SantriWaliUpsertWithWhereUniqueWithoutSantriInput[]
    createMany?: SantriWaliCreateManySantriInputEnvelope
    set?: SantriWaliWhereUniqueInput | SantriWaliWhereUniqueInput[]
    disconnect?: SantriWaliWhereUniqueInput | SantriWaliWhereUniqueInput[]
    delete?: SantriWaliWhereUniqueInput | SantriWaliWhereUniqueInput[]
    connect?: SantriWaliWhereUniqueInput | SantriWaliWhereUniqueInput[]
    update?: SantriWaliUpdateWithWhereUniqueWithoutSantriInput | SantriWaliUpdateWithWhereUniqueWithoutSantriInput[]
    updateMany?: SantriWaliUpdateManyWithWhereWithoutSantriInput | SantriWaliUpdateManyWithWhereWithoutSantriInput[]
    deleteMany?: SantriWaliScalarWhereInput | SantriWaliScalarWhereInput[]
  }

  export type IzinUpdateManyWithoutSantriNestedInput = {
    create?: XOR<IzinCreateWithoutSantriInput, IzinUncheckedCreateWithoutSantriInput> | IzinCreateWithoutSantriInput[] | IzinUncheckedCreateWithoutSantriInput[]
    connectOrCreate?: IzinCreateOrConnectWithoutSantriInput | IzinCreateOrConnectWithoutSantriInput[]
    upsert?: IzinUpsertWithWhereUniqueWithoutSantriInput | IzinUpsertWithWhereUniqueWithoutSantriInput[]
    createMany?: IzinCreateManySantriInputEnvelope
    set?: IzinWhereUniqueInput | IzinWhereUniqueInput[]
    disconnect?: IzinWhereUniqueInput | IzinWhereUniqueInput[]
    delete?: IzinWhereUniqueInput | IzinWhereUniqueInput[]
    connect?: IzinWhereUniqueInput | IzinWhereUniqueInput[]
    update?: IzinUpdateWithWhereUniqueWithoutSantriInput | IzinUpdateWithWhereUniqueWithoutSantriInput[]
    updateMany?: IzinUpdateManyWithWhereWithoutSantriInput | IzinUpdateManyWithWhereWithoutSantriInput[]
    deleteMany?: IzinScalarWhereInput | IzinScalarWhereInput[]
  }

  export type CatatanHarianUpdateManyWithoutSantriNestedInput = {
    create?: XOR<CatatanHarianCreateWithoutSantriInput, CatatanHarianUncheckedCreateWithoutSantriInput> | CatatanHarianCreateWithoutSantriInput[] | CatatanHarianUncheckedCreateWithoutSantriInput[]
    connectOrCreate?: CatatanHarianCreateOrConnectWithoutSantriInput | CatatanHarianCreateOrConnectWithoutSantriInput[]
    upsert?: CatatanHarianUpsertWithWhereUniqueWithoutSantriInput | CatatanHarianUpsertWithWhereUniqueWithoutSantriInput[]
    createMany?: CatatanHarianCreateManySantriInputEnvelope
    set?: CatatanHarianWhereUniqueInput | CatatanHarianWhereUniqueInput[]
    disconnect?: CatatanHarianWhereUniqueInput | CatatanHarianWhereUniqueInput[]
    delete?: CatatanHarianWhereUniqueInput | CatatanHarianWhereUniqueInput[]
    connect?: CatatanHarianWhereUniqueInput | CatatanHarianWhereUniqueInput[]
    update?: CatatanHarianUpdateWithWhereUniqueWithoutSantriInput | CatatanHarianUpdateWithWhereUniqueWithoutSantriInput[]
    updateMany?: CatatanHarianUpdateManyWithWhereWithoutSantriInput | CatatanHarianUpdateManyWithWhereWithoutSantriInput[]
    deleteMany?: CatatanHarianScalarWhereInput | CatatanHarianScalarWhereInput[]
  }

  export type InvoiceUpdateManyWithoutSantriNestedInput = {
    create?: XOR<InvoiceCreateWithoutSantriInput, InvoiceUncheckedCreateWithoutSantriInput> | InvoiceCreateWithoutSantriInput[] | InvoiceUncheckedCreateWithoutSantriInput[]
    connectOrCreate?: InvoiceCreateOrConnectWithoutSantriInput | InvoiceCreateOrConnectWithoutSantriInput[]
    upsert?: InvoiceUpsertWithWhereUniqueWithoutSantriInput | InvoiceUpsertWithWhereUniqueWithoutSantriInput[]
    createMany?: InvoiceCreateManySantriInputEnvelope
    set?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    disconnect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    delete?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    connect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    update?: InvoiceUpdateWithWhereUniqueWithoutSantriInput | InvoiceUpdateWithWhereUniqueWithoutSantriInput[]
    updateMany?: InvoiceUpdateManyWithWhereWithoutSantriInput | InvoiceUpdateManyWithWhereWithoutSantriInput[]
    deleteMany?: InvoiceScalarWhereInput | InvoiceScalarWhereInput[]
  }

  export type PelanggaranUpdateManyWithoutSantriNestedInput = {
    create?: XOR<PelanggaranCreateWithoutSantriInput, PelanggaranUncheckedCreateWithoutSantriInput> | PelanggaranCreateWithoutSantriInput[] | PelanggaranUncheckedCreateWithoutSantriInput[]
    connectOrCreate?: PelanggaranCreateOrConnectWithoutSantriInput | PelanggaranCreateOrConnectWithoutSantriInput[]
    upsert?: PelanggaranUpsertWithWhereUniqueWithoutSantriInput | PelanggaranUpsertWithWhereUniqueWithoutSantriInput[]
    createMany?: PelanggaranCreateManySantriInputEnvelope
    set?: PelanggaranWhereUniqueInput | PelanggaranWhereUniqueInput[]
    disconnect?: PelanggaranWhereUniqueInput | PelanggaranWhereUniqueInput[]
    delete?: PelanggaranWhereUniqueInput | PelanggaranWhereUniqueInput[]
    connect?: PelanggaranWhereUniqueInput | PelanggaranWhereUniqueInput[]
    update?: PelanggaranUpdateWithWhereUniqueWithoutSantriInput | PelanggaranUpdateWithWhereUniqueWithoutSantriInput[]
    updateMany?: PelanggaranUpdateManyWithWhereWithoutSantriInput | PelanggaranUpdateManyWithWhereWithoutSantriInput[]
    deleteMany?: PelanggaranScalarWhereInput | PelanggaranScalarWhereInput[]
  }

  export type PembinaanUpdateManyWithoutSantriNestedInput = {
    create?: XOR<PembinaanCreateWithoutSantriInput, PembinaanUncheckedCreateWithoutSantriInput> | PembinaanCreateWithoutSantriInput[] | PembinaanUncheckedCreateWithoutSantriInput[]
    connectOrCreate?: PembinaanCreateOrConnectWithoutSantriInput | PembinaanCreateOrConnectWithoutSantriInput[]
    upsert?: PembinaanUpsertWithWhereUniqueWithoutSantriInput | PembinaanUpsertWithWhereUniqueWithoutSantriInput[]
    createMany?: PembinaanCreateManySantriInputEnvelope
    set?: PembinaanWhereUniqueInput | PembinaanWhereUniqueInput[]
    disconnect?: PembinaanWhereUniqueInput | PembinaanWhereUniqueInput[]
    delete?: PembinaanWhereUniqueInput | PembinaanWhereUniqueInput[]
    connect?: PembinaanWhereUniqueInput | PembinaanWhereUniqueInput[]
    update?: PembinaanUpdateWithWhereUniqueWithoutSantriInput | PembinaanUpdateWithWhereUniqueWithoutSantriInput[]
    updateMany?: PembinaanUpdateManyWithWhereWithoutSantriInput | PembinaanUpdateManyWithWhereWithoutSantriInput[]
    deleteMany?: PembinaanScalarWhereInput | PembinaanScalarWhereInput[]
  }

  export type KunjunganUpdateManyWithoutSantriNestedInput = {
    create?: XOR<KunjunganCreateWithoutSantriInput, KunjunganUncheckedCreateWithoutSantriInput> | KunjunganCreateWithoutSantriInput[] | KunjunganUncheckedCreateWithoutSantriInput[]
    connectOrCreate?: KunjunganCreateOrConnectWithoutSantriInput | KunjunganCreateOrConnectWithoutSantriInput[]
    upsert?: KunjunganUpsertWithWhereUniqueWithoutSantriInput | KunjunganUpsertWithWhereUniqueWithoutSantriInput[]
    createMany?: KunjunganCreateManySantriInputEnvelope
    set?: KunjunganWhereUniqueInput | KunjunganWhereUniqueInput[]
    disconnect?: KunjunganWhereUniqueInput | KunjunganWhereUniqueInput[]
    delete?: KunjunganWhereUniqueInput | KunjunganWhereUniqueInput[]
    connect?: KunjunganWhereUniqueInput | KunjunganWhereUniqueInput[]
    update?: KunjunganUpdateWithWhereUniqueWithoutSantriInput | KunjunganUpdateWithWhereUniqueWithoutSantriInput[]
    updateMany?: KunjunganUpdateManyWithWhereWithoutSantriInput | KunjunganUpdateManyWithWhereWithoutSantriInput[]
    deleteMany?: KunjunganScalarWhereInput | KunjunganScalarWhereInput[]
  }

  export type HealthRecordUpdateManyWithoutSantriNestedInput = {
    create?: XOR<HealthRecordCreateWithoutSantriInput, HealthRecordUncheckedCreateWithoutSantriInput> | HealthRecordCreateWithoutSantriInput[] | HealthRecordUncheckedCreateWithoutSantriInput[]
    connectOrCreate?: HealthRecordCreateOrConnectWithoutSantriInput | HealthRecordCreateOrConnectWithoutSantriInput[]
    upsert?: HealthRecordUpsertWithWhereUniqueWithoutSantriInput | HealthRecordUpsertWithWhereUniqueWithoutSantriInput[]
    createMany?: HealthRecordCreateManySantriInputEnvelope
    set?: HealthRecordWhereUniqueInput | HealthRecordWhereUniqueInput[]
    disconnect?: HealthRecordWhereUniqueInput | HealthRecordWhereUniqueInput[]
    delete?: HealthRecordWhereUniqueInput | HealthRecordWhereUniqueInput[]
    connect?: HealthRecordWhereUniqueInput | HealthRecordWhereUniqueInput[]
    update?: HealthRecordUpdateWithWhereUniqueWithoutSantriInput | HealthRecordUpdateWithWhereUniqueWithoutSantriInput[]
    updateMany?: HealthRecordUpdateManyWithWhereWithoutSantriInput | HealthRecordUpdateManyWithWhereWithoutSantriInput[]
    deleteMany?: HealthRecordScalarWhereInput | HealthRecordScalarWhereInput[]
  }

  export type MedicationUpdateManyWithoutSantriNestedInput = {
    create?: XOR<MedicationCreateWithoutSantriInput, MedicationUncheckedCreateWithoutSantriInput> | MedicationCreateWithoutSantriInput[] | MedicationUncheckedCreateWithoutSantriInput[]
    connectOrCreate?: MedicationCreateOrConnectWithoutSantriInput | MedicationCreateOrConnectWithoutSantriInput[]
    upsert?: MedicationUpsertWithWhereUniqueWithoutSantriInput | MedicationUpsertWithWhereUniqueWithoutSantriInput[]
    createMany?: MedicationCreateManySantriInputEnvelope
    set?: MedicationWhereUniqueInput | MedicationWhereUniqueInput[]
    disconnect?: MedicationWhereUniqueInput | MedicationWhereUniqueInput[]
    delete?: MedicationWhereUniqueInput | MedicationWhereUniqueInput[]
    connect?: MedicationWhereUniqueInput | MedicationWhereUniqueInput[]
    update?: MedicationUpdateWithWhereUniqueWithoutSantriInput | MedicationUpdateWithWhereUniqueWithoutSantriInput[]
    updateMany?: MedicationUpdateManyWithWhereWithoutSantriInput | MedicationUpdateManyWithWhereWithoutSantriInput[]
    deleteMany?: MedicationScalarWhereInput | MedicationScalarWhereInput[]
  }

  export type SantriWaliUncheckedUpdateManyWithoutSantriNestedInput = {
    create?: XOR<SantriWaliCreateWithoutSantriInput, SantriWaliUncheckedCreateWithoutSantriInput> | SantriWaliCreateWithoutSantriInput[] | SantriWaliUncheckedCreateWithoutSantriInput[]
    connectOrCreate?: SantriWaliCreateOrConnectWithoutSantriInput | SantriWaliCreateOrConnectWithoutSantriInput[]
    upsert?: SantriWaliUpsertWithWhereUniqueWithoutSantriInput | SantriWaliUpsertWithWhereUniqueWithoutSantriInput[]
    createMany?: SantriWaliCreateManySantriInputEnvelope
    set?: SantriWaliWhereUniqueInput | SantriWaliWhereUniqueInput[]
    disconnect?: SantriWaliWhereUniqueInput | SantriWaliWhereUniqueInput[]
    delete?: SantriWaliWhereUniqueInput | SantriWaliWhereUniqueInput[]
    connect?: SantriWaliWhereUniqueInput | SantriWaliWhereUniqueInput[]
    update?: SantriWaliUpdateWithWhereUniqueWithoutSantriInput | SantriWaliUpdateWithWhereUniqueWithoutSantriInput[]
    updateMany?: SantriWaliUpdateManyWithWhereWithoutSantriInput | SantriWaliUpdateManyWithWhereWithoutSantriInput[]
    deleteMany?: SantriWaliScalarWhereInput | SantriWaliScalarWhereInput[]
  }

  export type IzinUncheckedUpdateManyWithoutSantriNestedInput = {
    create?: XOR<IzinCreateWithoutSantriInput, IzinUncheckedCreateWithoutSantriInput> | IzinCreateWithoutSantriInput[] | IzinUncheckedCreateWithoutSantriInput[]
    connectOrCreate?: IzinCreateOrConnectWithoutSantriInput | IzinCreateOrConnectWithoutSantriInput[]
    upsert?: IzinUpsertWithWhereUniqueWithoutSantriInput | IzinUpsertWithWhereUniqueWithoutSantriInput[]
    createMany?: IzinCreateManySantriInputEnvelope
    set?: IzinWhereUniqueInput | IzinWhereUniqueInput[]
    disconnect?: IzinWhereUniqueInput | IzinWhereUniqueInput[]
    delete?: IzinWhereUniqueInput | IzinWhereUniqueInput[]
    connect?: IzinWhereUniqueInput | IzinWhereUniqueInput[]
    update?: IzinUpdateWithWhereUniqueWithoutSantriInput | IzinUpdateWithWhereUniqueWithoutSantriInput[]
    updateMany?: IzinUpdateManyWithWhereWithoutSantriInput | IzinUpdateManyWithWhereWithoutSantriInput[]
    deleteMany?: IzinScalarWhereInput | IzinScalarWhereInput[]
  }

  export type CatatanHarianUncheckedUpdateManyWithoutSantriNestedInput = {
    create?: XOR<CatatanHarianCreateWithoutSantriInput, CatatanHarianUncheckedCreateWithoutSantriInput> | CatatanHarianCreateWithoutSantriInput[] | CatatanHarianUncheckedCreateWithoutSantriInput[]
    connectOrCreate?: CatatanHarianCreateOrConnectWithoutSantriInput | CatatanHarianCreateOrConnectWithoutSantriInput[]
    upsert?: CatatanHarianUpsertWithWhereUniqueWithoutSantriInput | CatatanHarianUpsertWithWhereUniqueWithoutSantriInput[]
    createMany?: CatatanHarianCreateManySantriInputEnvelope
    set?: CatatanHarianWhereUniqueInput | CatatanHarianWhereUniqueInput[]
    disconnect?: CatatanHarianWhereUniqueInput | CatatanHarianWhereUniqueInput[]
    delete?: CatatanHarianWhereUniqueInput | CatatanHarianWhereUniqueInput[]
    connect?: CatatanHarianWhereUniqueInput | CatatanHarianWhereUniqueInput[]
    update?: CatatanHarianUpdateWithWhereUniqueWithoutSantriInput | CatatanHarianUpdateWithWhereUniqueWithoutSantriInput[]
    updateMany?: CatatanHarianUpdateManyWithWhereWithoutSantriInput | CatatanHarianUpdateManyWithWhereWithoutSantriInput[]
    deleteMany?: CatatanHarianScalarWhereInput | CatatanHarianScalarWhereInput[]
  }

  export type InvoiceUncheckedUpdateManyWithoutSantriNestedInput = {
    create?: XOR<InvoiceCreateWithoutSantriInput, InvoiceUncheckedCreateWithoutSantriInput> | InvoiceCreateWithoutSantriInput[] | InvoiceUncheckedCreateWithoutSantriInput[]
    connectOrCreate?: InvoiceCreateOrConnectWithoutSantriInput | InvoiceCreateOrConnectWithoutSantriInput[]
    upsert?: InvoiceUpsertWithWhereUniqueWithoutSantriInput | InvoiceUpsertWithWhereUniqueWithoutSantriInput[]
    createMany?: InvoiceCreateManySantriInputEnvelope
    set?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    disconnect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    delete?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    connect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    update?: InvoiceUpdateWithWhereUniqueWithoutSantriInput | InvoiceUpdateWithWhereUniqueWithoutSantriInput[]
    updateMany?: InvoiceUpdateManyWithWhereWithoutSantriInput | InvoiceUpdateManyWithWhereWithoutSantriInput[]
    deleteMany?: InvoiceScalarWhereInput | InvoiceScalarWhereInput[]
  }

  export type PelanggaranUncheckedUpdateManyWithoutSantriNestedInput = {
    create?: XOR<PelanggaranCreateWithoutSantriInput, PelanggaranUncheckedCreateWithoutSantriInput> | PelanggaranCreateWithoutSantriInput[] | PelanggaranUncheckedCreateWithoutSantriInput[]
    connectOrCreate?: PelanggaranCreateOrConnectWithoutSantriInput | PelanggaranCreateOrConnectWithoutSantriInput[]
    upsert?: PelanggaranUpsertWithWhereUniqueWithoutSantriInput | PelanggaranUpsertWithWhereUniqueWithoutSantriInput[]
    createMany?: PelanggaranCreateManySantriInputEnvelope
    set?: PelanggaranWhereUniqueInput | PelanggaranWhereUniqueInput[]
    disconnect?: PelanggaranWhereUniqueInput | PelanggaranWhereUniqueInput[]
    delete?: PelanggaranWhereUniqueInput | PelanggaranWhereUniqueInput[]
    connect?: PelanggaranWhereUniqueInput | PelanggaranWhereUniqueInput[]
    update?: PelanggaranUpdateWithWhereUniqueWithoutSantriInput | PelanggaranUpdateWithWhereUniqueWithoutSantriInput[]
    updateMany?: PelanggaranUpdateManyWithWhereWithoutSantriInput | PelanggaranUpdateManyWithWhereWithoutSantriInput[]
    deleteMany?: PelanggaranScalarWhereInput | PelanggaranScalarWhereInput[]
  }

  export type PembinaanUncheckedUpdateManyWithoutSantriNestedInput = {
    create?: XOR<PembinaanCreateWithoutSantriInput, PembinaanUncheckedCreateWithoutSantriInput> | PembinaanCreateWithoutSantriInput[] | PembinaanUncheckedCreateWithoutSantriInput[]
    connectOrCreate?: PembinaanCreateOrConnectWithoutSantriInput | PembinaanCreateOrConnectWithoutSantriInput[]
    upsert?: PembinaanUpsertWithWhereUniqueWithoutSantriInput | PembinaanUpsertWithWhereUniqueWithoutSantriInput[]
    createMany?: PembinaanCreateManySantriInputEnvelope
    set?: PembinaanWhereUniqueInput | PembinaanWhereUniqueInput[]
    disconnect?: PembinaanWhereUniqueInput | PembinaanWhereUniqueInput[]
    delete?: PembinaanWhereUniqueInput | PembinaanWhereUniqueInput[]
    connect?: PembinaanWhereUniqueInput | PembinaanWhereUniqueInput[]
    update?: PembinaanUpdateWithWhereUniqueWithoutSantriInput | PembinaanUpdateWithWhereUniqueWithoutSantriInput[]
    updateMany?: PembinaanUpdateManyWithWhereWithoutSantriInput | PembinaanUpdateManyWithWhereWithoutSantriInput[]
    deleteMany?: PembinaanScalarWhereInput | PembinaanScalarWhereInput[]
  }

  export type KunjunganUncheckedUpdateManyWithoutSantriNestedInput = {
    create?: XOR<KunjunganCreateWithoutSantriInput, KunjunganUncheckedCreateWithoutSantriInput> | KunjunganCreateWithoutSantriInput[] | KunjunganUncheckedCreateWithoutSantriInput[]
    connectOrCreate?: KunjunganCreateOrConnectWithoutSantriInput | KunjunganCreateOrConnectWithoutSantriInput[]
    upsert?: KunjunganUpsertWithWhereUniqueWithoutSantriInput | KunjunganUpsertWithWhereUniqueWithoutSantriInput[]
    createMany?: KunjunganCreateManySantriInputEnvelope
    set?: KunjunganWhereUniqueInput | KunjunganWhereUniqueInput[]
    disconnect?: KunjunganWhereUniqueInput | KunjunganWhereUniqueInput[]
    delete?: KunjunganWhereUniqueInput | KunjunganWhereUniqueInput[]
    connect?: KunjunganWhereUniqueInput | KunjunganWhereUniqueInput[]
    update?: KunjunganUpdateWithWhereUniqueWithoutSantriInput | KunjunganUpdateWithWhereUniqueWithoutSantriInput[]
    updateMany?: KunjunganUpdateManyWithWhereWithoutSantriInput | KunjunganUpdateManyWithWhereWithoutSantriInput[]
    deleteMany?: KunjunganScalarWhereInput | KunjunganScalarWhereInput[]
  }

  export type HealthRecordUncheckedUpdateManyWithoutSantriNestedInput = {
    create?: XOR<HealthRecordCreateWithoutSantriInput, HealthRecordUncheckedCreateWithoutSantriInput> | HealthRecordCreateWithoutSantriInput[] | HealthRecordUncheckedCreateWithoutSantriInput[]
    connectOrCreate?: HealthRecordCreateOrConnectWithoutSantriInput | HealthRecordCreateOrConnectWithoutSantriInput[]
    upsert?: HealthRecordUpsertWithWhereUniqueWithoutSantriInput | HealthRecordUpsertWithWhereUniqueWithoutSantriInput[]
    createMany?: HealthRecordCreateManySantriInputEnvelope
    set?: HealthRecordWhereUniqueInput | HealthRecordWhereUniqueInput[]
    disconnect?: HealthRecordWhereUniqueInput | HealthRecordWhereUniqueInput[]
    delete?: HealthRecordWhereUniqueInput | HealthRecordWhereUniqueInput[]
    connect?: HealthRecordWhereUniqueInput | HealthRecordWhereUniqueInput[]
    update?: HealthRecordUpdateWithWhereUniqueWithoutSantriInput | HealthRecordUpdateWithWhereUniqueWithoutSantriInput[]
    updateMany?: HealthRecordUpdateManyWithWhereWithoutSantriInput | HealthRecordUpdateManyWithWhereWithoutSantriInput[]
    deleteMany?: HealthRecordScalarWhereInput | HealthRecordScalarWhereInput[]
  }

  export type MedicationUncheckedUpdateManyWithoutSantriNestedInput = {
    create?: XOR<MedicationCreateWithoutSantriInput, MedicationUncheckedCreateWithoutSantriInput> | MedicationCreateWithoutSantriInput[] | MedicationUncheckedCreateWithoutSantriInput[]
    connectOrCreate?: MedicationCreateOrConnectWithoutSantriInput | MedicationCreateOrConnectWithoutSantriInput[]
    upsert?: MedicationUpsertWithWhereUniqueWithoutSantriInput | MedicationUpsertWithWhereUniqueWithoutSantriInput[]
    createMany?: MedicationCreateManySantriInputEnvelope
    set?: MedicationWhereUniqueInput | MedicationWhereUniqueInput[]
    disconnect?: MedicationWhereUniqueInput | MedicationWhereUniqueInput[]
    delete?: MedicationWhereUniqueInput | MedicationWhereUniqueInput[]
    connect?: MedicationWhereUniqueInput | MedicationWhereUniqueInput[]
    update?: MedicationUpdateWithWhereUniqueWithoutSantriInput | MedicationUpdateWithWhereUniqueWithoutSantriInput[]
    updateMany?: MedicationUpdateManyWithWhereWithoutSantriInput | MedicationUpdateManyWithWhereWithoutSantriInput[]
    deleteMany?: MedicationScalarWhereInput | MedicationScalarWhereInput[]
  }

  export type TenantCreateNestedOneWithoutWaliInput = {
    create?: XOR<TenantCreateWithoutWaliInput, TenantUncheckedCreateWithoutWaliInput>
    connectOrCreate?: TenantCreateOrConnectWithoutWaliInput
    connect?: TenantWhereUniqueInput
  }

  export type SantriWaliCreateNestedManyWithoutWaliInput = {
    create?: XOR<SantriWaliCreateWithoutWaliInput, SantriWaliUncheckedCreateWithoutWaliInput> | SantriWaliCreateWithoutWaliInput[] | SantriWaliUncheckedCreateWithoutWaliInput[]
    connectOrCreate?: SantriWaliCreateOrConnectWithoutWaliInput | SantriWaliCreateOrConnectWithoutWaliInput[]
    createMany?: SantriWaliCreateManyWaliInputEnvelope
    connect?: SantriWaliWhereUniqueInput | SantriWaliWhereUniqueInput[]
  }

  export type SantriWaliUncheckedCreateNestedManyWithoutWaliInput = {
    create?: XOR<SantriWaliCreateWithoutWaliInput, SantriWaliUncheckedCreateWithoutWaliInput> | SantriWaliCreateWithoutWaliInput[] | SantriWaliUncheckedCreateWithoutWaliInput[]
    connectOrCreate?: SantriWaliCreateOrConnectWithoutWaliInput | SantriWaliCreateOrConnectWithoutWaliInput[]
    createMany?: SantriWaliCreateManyWaliInputEnvelope
    connect?: SantriWaliWhereUniqueInput | SantriWaliWhereUniqueInput[]
  }

  export type TenantUpdateOneRequiredWithoutWaliNestedInput = {
    create?: XOR<TenantCreateWithoutWaliInput, TenantUncheckedCreateWithoutWaliInput>
    connectOrCreate?: TenantCreateOrConnectWithoutWaliInput
    upsert?: TenantUpsertWithoutWaliInput
    connect?: TenantWhereUniqueInput
    update?: XOR<XOR<TenantUpdateToOneWithWhereWithoutWaliInput, TenantUpdateWithoutWaliInput>, TenantUncheckedUpdateWithoutWaliInput>
  }

  export type SantriWaliUpdateManyWithoutWaliNestedInput = {
    create?: XOR<SantriWaliCreateWithoutWaliInput, SantriWaliUncheckedCreateWithoutWaliInput> | SantriWaliCreateWithoutWaliInput[] | SantriWaliUncheckedCreateWithoutWaliInput[]
    connectOrCreate?: SantriWaliCreateOrConnectWithoutWaliInput | SantriWaliCreateOrConnectWithoutWaliInput[]
    upsert?: SantriWaliUpsertWithWhereUniqueWithoutWaliInput | SantriWaliUpsertWithWhereUniqueWithoutWaliInput[]
    createMany?: SantriWaliCreateManyWaliInputEnvelope
    set?: SantriWaliWhereUniqueInput | SantriWaliWhereUniqueInput[]
    disconnect?: SantriWaliWhereUniqueInput | SantriWaliWhereUniqueInput[]
    delete?: SantriWaliWhereUniqueInput | SantriWaliWhereUniqueInput[]
    connect?: SantriWaliWhereUniqueInput | SantriWaliWhereUniqueInput[]
    update?: SantriWaliUpdateWithWhereUniqueWithoutWaliInput | SantriWaliUpdateWithWhereUniqueWithoutWaliInput[]
    updateMany?: SantriWaliUpdateManyWithWhereWithoutWaliInput | SantriWaliUpdateManyWithWhereWithoutWaliInput[]
    deleteMany?: SantriWaliScalarWhereInput | SantriWaliScalarWhereInput[]
  }

  export type SantriWaliUncheckedUpdateManyWithoutWaliNestedInput = {
    create?: XOR<SantriWaliCreateWithoutWaliInput, SantriWaliUncheckedCreateWithoutWaliInput> | SantriWaliCreateWithoutWaliInput[] | SantriWaliUncheckedCreateWithoutWaliInput[]
    connectOrCreate?: SantriWaliCreateOrConnectWithoutWaliInput | SantriWaliCreateOrConnectWithoutWaliInput[]
    upsert?: SantriWaliUpsertWithWhereUniqueWithoutWaliInput | SantriWaliUpsertWithWhereUniqueWithoutWaliInput[]
    createMany?: SantriWaliCreateManyWaliInputEnvelope
    set?: SantriWaliWhereUniqueInput | SantriWaliWhereUniqueInput[]
    disconnect?: SantriWaliWhereUniqueInput | SantriWaliWhereUniqueInput[]
    delete?: SantriWaliWhereUniqueInput | SantriWaliWhereUniqueInput[]
    connect?: SantriWaliWhereUniqueInput | SantriWaliWhereUniqueInput[]
    update?: SantriWaliUpdateWithWhereUniqueWithoutWaliInput | SantriWaliUpdateWithWhereUniqueWithoutWaliInput[]
    updateMany?: SantriWaliUpdateManyWithWhereWithoutWaliInput | SantriWaliUpdateManyWithWhereWithoutWaliInput[]
    deleteMany?: SantriWaliScalarWhereInput | SantriWaliScalarWhereInput[]
  }

  export type SantriCreateNestedOneWithoutWalisInput = {
    create?: XOR<SantriCreateWithoutWalisInput, SantriUncheckedCreateWithoutWalisInput>
    connectOrCreate?: SantriCreateOrConnectWithoutWalisInput
    connect?: SantriWhereUniqueInput
  }

  export type WaliCreateNestedOneWithoutSantrisInput = {
    create?: XOR<WaliCreateWithoutSantrisInput, WaliUncheckedCreateWithoutSantrisInput>
    connectOrCreate?: WaliCreateOrConnectWithoutSantrisInput
    connect?: WaliWhereUniqueInput
  }

  export type SantriUpdateOneRequiredWithoutWalisNestedInput = {
    create?: XOR<SantriCreateWithoutWalisInput, SantriUncheckedCreateWithoutWalisInput>
    connectOrCreate?: SantriCreateOrConnectWithoutWalisInput
    upsert?: SantriUpsertWithoutWalisInput
    connect?: SantriWhereUniqueInput
    update?: XOR<XOR<SantriUpdateToOneWithWhereWithoutWalisInput, SantriUpdateWithoutWalisInput>, SantriUncheckedUpdateWithoutWalisInput>
  }

  export type WaliUpdateOneRequiredWithoutSantrisNestedInput = {
    create?: XOR<WaliCreateWithoutSantrisInput, WaliUncheckedCreateWithoutSantrisInput>
    connectOrCreate?: WaliCreateOrConnectWithoutSantrisInput
    upsert?: WaliUpsertWithoutSantrisInput
    connect?: WaliWhereUniqueInput
    update?: XOR<XOR<WaliUpdateToOneWithWhereWithoutSantrisInput, WaliUpdateWithoutSantrisInput>, WaliUncheckedUpdateWithoutSantrisInput>
  }

  export type TenantCreateNestedOneWithoutIzinInput = {
    create?: XOR<TenantCreateWithoutIzinInput, TenantUncheckedCreateWithoutIzinInput>
    connectOrCreate?: TenantCreateOrConnectWithoutIzinInput
    connect?: TenantWhereUniqueInput
  }

  export type SantriCreateNestedOneWithoutIzinInput = {
    create?: XOR<SantriCreateWithoutIzinInput, SantriUncheckedCreateWithoutIzinInput>
    connectOrCreate?: SantriCreateOrConnectWithoutIzinInput
    connect?: SantriWhereUniqueInput
  }

  export type TenantUpdateOneRequiredWithoutIzinNestedInput = {
    create?: XOR<TenantCreateWithoutIzinInput, TenantUncheckedCreateWithoutIzinInput>
    connectOrCreate?: TenantCreateOrConnectWithoutIzinInput
    upsert?: TenantUpsertWithoutIzinInput
    connect?: TenantWhereUniqueInput
    update?: XOR<XOR<TenantUpdateToOneWithWhereWithoutIzinInput, TenantUpdateWithoutIzinInput>, TenantUncheckedUpdateWithoutIzinInput>
  }

  export type SantriUpdateOneRequiredWithoutIzinNestedInput = {
    create?: XOR<SantriCreateWithoutIzinInput, SantriUncheckedCreateWithoutIzinInput>
    connectOrCreate?: SantriCreateOrConnectWithoutIzinInput
    upsert?: SantriUpsertWithoutIzinInput
    connect?: SantriWhereUniqueInput
    update?: XOR<XOR<SantriUpdateToOneWithWhereWithoutIzinInput, SantriUpdateWithoutIzinInput>, SantriUncheckedUpdateWithoutIzinInput>
  }

  export type TenantCreateNestedOneWithoutCatatanHarianInput = {
    create?: XOR<TenantCreateWithoutCatatanHarianInput, TenantUncheckedCreateWithoutCatatanHarianInput>
    connectOrCreate?: TenantCreateOrConnectWithoutCatatanHarianInput
    connect?: TenantWhereUniqueInput
  }

  export type SantriCreateNestedOneWithoutCatatanHarianInput = {
    create?: XOR<SantriCreateWithoutCatatanHarianInput, SantriUncheckedCreateWithoutCatatanHarianInput>
    connectOrCreate?: SantriCreateOrConnectWithoutCatatanHarianInput
    connect?: SantriWhereUniqueInput
  }

  export type TenantUpdateOneRequiredWithoutCatatanHarianNestedInput = {
    create?: XOR<TenantCreateWithoutCatatanHarianInput, TenantUncheckedCreateWithoutCatatanHarianInput>
    connectOrCreate?: TenantCreateOrConnectWithoutCatatanHarianInput
    upsert?: TenantUpsertWithoutCatatanHarianInput
    connect?: TenantWhereUniqueInput
    update?: XOR<XOR<TenantUpdateToOneWithWhereWithoutCatatanHarianInput, TenantUpdateWithoutCatatanHarianInput>, TenantUncheckedUpdateWithoutCatatanHarianInput>
  }

  export type SantriUpdateOneRequiredWithoutCatatanHarianNestedInput = {
    create?: XOR<SantriCreateWithoutCatatanHarianInput, SantriUncheckedCreateWithoutCatatanHarianInput>
    connectOrCreate?: SantriCreateOrConnectWithoutCatatanHarianInput
    upsert?: SantriUpsertWithoutCatatanHarianInput
    connect?: SantriWhereUniqueInput
    update?: XOR<XOR<SantriUpdateToOneWithWhereWithoutCatatanHarianInput, SantriUpdateWithoutCatatanHarianInput>, SantriUncheckedUpdateWithoutCatatanHarianInput>
  }

  export type TenantCreateNestedOneWithoutPengumumanInput = {
    create?: XOR<TenantCreateWithoutPengumumanInput, TenantUncheckedCreateWithoutPengumumanInput>
    connectOrCreate?: TenantCreateOrConnectWithoutPengumumanInput
    connect?: TenantWhereUniqueInput
  }

  export type TenantUpdateOneRequiredWithoutPengumumanNestedInput = {
    create?: XOR<TenantCreateWithoutPengumumanInput, TenantUncheckedCreateWithoutPengumumanInput>
    connectOrCreate?: TenantCreateOrConnectWithoutPengumumanInput
    upsert?: TenantUpsertWithoutPengumumanInput
    connect?: TenantWhereUniqueInput
    update?: XOR<XOR<TenantUpdateToOneWithWhereWithoutPengumumanInput, TenantUpdateWithoutPengumumanInput>, TenantUncheckedUpdateWithoutPengumumanInput>
  }

  export type TenantCreateNestedOneWithoutInvoicesInput = {
    create?: XOR<TenantCreateWithoutInvoicesInput, TenantUncheckedCreateWithoutInvoicesInput>
    connectOrCreate?: TenantCreateOrConnectWithoutInvoicesInput
    connect?: TenantWhereUniqueInput
  }

  export type SantriCreateNestedOneWithoutInvoicesInput = {
    create?: XOR<SantriCreateWithoutInvoicesInput, SantriUncheckedCreateWithoutInvoicesInput>
    connectOrCreate?: SantriCreateOrConnectWithoutInvoicesInput
    connect?: SantriWhereUniqueInput
  }

  export type InvoiceLineCreateNestedManyWithoutInvoiceInput = {
    create?: XOR<InvoiceLineCreateWithoutInvoiceInput, InvoiceLineUncheckedCreateWithoutInvoiceInput> | InvoiceLineCreateWithoutInvoiceInput[] | InvoiceLineUncheckedCreateWithoutInvoiceInput[]
    connectOrCreate?: InvoiceLineCreateOrConnectWithoutInvoiceInput | InvoiceLineCreateOrConnectWithoutInvoiceInput[]
    createMany?: InvoiceLineCreateManyInvoiceInputEnvelope
    connect?: InvoiceLineWhereUniqueInput | InvoiceLineWhereUniqueInput[]
  }

  export type PaymentCreateNestedManyWithoutInvoiceInput = {
    create?: XOR<PaymentCreateWithoutInvoiceInput, PaymentUncheckedCreateWithoutInvoiceInput> | PaymentCreateWithoutInvoiceInput[] | PaymentUncheckedCreateWithoutInvoiceInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutInvoiceInput | PaymentCreateOrConnectWithoutInvoiceInput[]
    createMany?: PaymentCreateManyInvoiceInputEnvelope
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
  }

  export type InvoiceLineUncheckedCreateNestedManyWithoutInvoiceInput = {
    create?: XOR<InvoiceLineCreateWithoutInvoiceInput, InvoiceLineUncheckedCreateWithoutInvoiceInput> | InvoiceLineCreateWithoutInvoiceInput[] | InvoiceLineUncheckedCreateWithoutInvoiceInput[]
    connectOrCreate?: InvoiceLineCreateOrConnectWithoutInvoiceInput | InvoiceLineCreateOrConnectWithoutInvoiceInput[]
    createMany?: InvoiceLineCreateManyInvoiceInputEnvelope
    connect?: InvoiceLineWhereUniqueInput | InvoiceLineWhereUniqueInput[]
  }

  export type PaymentUncheckedCreateNestedManyWithoutInvoiceInput = {
    create?: XOR<PaymentCreateWithoutInvoiceInput, PaymentUncheckedCreateWithoutInvoiceInput> | PaymentCreateWithoutInvoiceInput[] | PaymentUncheckedCreateWithoutInvoiceInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutInvoiceInput | PaymentCreateOrConnectWithoutInvoiceInput[]
    createMany?: PaymentCreateManyInvoiceInputEnvelope
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type TenantUpdateOneRequiredWithoutInvoicesNestedInput = {
    create?: XOR<TenantCreateWithoutInvoicesInput, TenantUncheckedCreateWithoutInvoicesInput>
    connectOrCreate?: TenantCreateOrConnectWithoutInvoicesInput
    upsert?: TenantUpsertWithoutInvoicesInput
    connect?: TenantWhereUniqueInput
    update?: XOR<XOR<TenantUpdateToOneWithWhereWithoutInvoicesInput, TenantUpdateWithoutInvoicesInput>, TenantUncheckedUpdateWithoutInvoicesInput>
  }

  export type SantriUpdateOneRequiredWithoutInvoicesNestedInput = {
    create?: XOR<SantriCreateWithoutInvoicesInput, SantriUncheckedCreateWithoutInvoicesInput>
    connectOrCreate?: SantriCreateOrConnectWithoutInvoicesInput
    upsert?: SantriUpsertWithoutInvoicesInput
    connect?: SantriWhereUniqueInput
    update?: XOR<XOR<SantriUpdateToOneWithWhereWithoutInvoicesInput, SantriUpdateWithoutInvoicesInput>, SantriUncheckedUpdateWithoutInvoicesInput>
  }

  export type InvoiceLineUpdateManyWithoutInvoiceNestedInput = {
    create?: XOR<InvoiceLineCreateWithoutInvoiceInput, InvoiceLineUncheckedCreateWithoutInvoiceInput> | InvoiceLineCreateWithoutInvoiceInput[] | InvoiceLineUncheckedCreateWithoutInvoiceInput[]
    connectOrCreate?: InvoiceLineCreateOrConnectWithoutInvoiceInput | InvoiceLineCreateOrConnectWithoutInvoiceInput[]
    upsert?: InvoiceLineUpsertWithWhereUniqueWithoutInvoiceInput | InvoiceLineUpsertWithWhereUniqueWithoutInvoiceInput[]
    createMany?: InvoiceLineCreateManyInvoiceInputEnvelope
    set?: InvoiceLineWhereUniqueInput | InvoiceLineWhereUniqueInput[]
    disconnect?: InvoiceLineWhereUniqueInput | InvoiceLineWhereUniqueInput[]
    delete?: InvoiceLineWhereUniqueInput | InvoiceLineWhereUniqueInput[]
    connect?: InvoiceLineWhereUniqueInput | InvoiceLineWhereUniqueInput[]
    update?: InvoiceLineUpdateWithWhereUniqueWithoutInvoiceInput | InvoiceLineUpdateWithWhereUniqueWithoutInvoiceInput[]
    updateMany?: InvoiceLineUpdateManyWithWhereWithoutInvoiceInput | InvoiceLineUpdateManyWithWhereWithoutInvoiceInput[]
    deleteMany?: InvoiceLineScalarWhereInput | InvoiceLineScalarWhereInput[]
  }

  export type PaymentUpdateManyWithoutInvoiceNestedInput = {
    create?: XOR<PaymentCreateWithoutInvoiceInput, PaymentUncheckedCreateWithoutInvoiceInput> | PaymentCreateWithoutInvoiceInput[] | PaymentUncheckedCreateWithoutInvoiceInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutInvoiceInput | PaymentCreateOrConnectWithoutInvoiceInput[]
    upsert?: PaymentUpsertWithWhereUniqueWithoutInvoiceInput | PaymentUpsertWithWhereUniqueWithoutInvoiceInput[]
    createMany?: PaymentCreateManyInvoiceInputEnvelope
    set?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    disconnect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    delete?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    update?: PaymentUpdateWithWhereUniqueWithoutInvoiceInput | PaymentUpdateWithWhereUniqueWithoutInvoiceInput[]
    updateMany?: PaymentUpdateManyWithWhereWithoutInvoiceInput | PaymentUpdateManyWithWhereWithoutInvoiceInput[]
    deleteMany?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
  }

  export type InvoiceLineUncheckedUpdateManyWithoutInvoiceNestedInput = {
    create?: XOR<InvoiceLineCreateWithoutInvoiceInput, InvoiceLineUncheckedCreateWithoutInvoiceInput> | InvoiceLineCreateWithoutInvoiceInput[] | InvoiceLineUncheckedCreateWithoutInvoiceInput[]
    connectOrCreate?: InvoiceLineCreateOrConnectWithoutInvoiceInput | InvoiceLineCreateOrConnectWithoutInvoiceInput[]
    upsert?: InvoiceLineUpsertWithWhereUniqueWithoutInvoiceInput | InvoiceLineUpsertWithWhereUniqueWithoutInvoiceInput[]
    createMany?: InvoiceLineCreateManyInvoiceInputEnvelope
    set?: InvoiceLineWhereUniqueInput | InvoiceLineWhereUniqueInput[]
    disconnect?: InvoiceLineWhereUniqueInput | InvoiceLineWhereUniqueInput[]
    delete?: InvoiceLineWhereUniqueInput | InvoiceLineWhereUniqueInput[]
    connect?: InvoiceLineWhereUniqueInput | InvoiceLineWhereUniqueInput[]
    update?: InvoiceLineUpdateWithWhereUniqueWithoutInvoiceInput | InvoiceLineUpdateWithWhereUniqueWithoutInvoiceInput[]
    updateMany?: InvoiceLineUpdateManyWithWhereWithoutInvoiceInput | InvoiceLineUpdateManyWithWhereWithoutInvoiceInput[]
    deleteMany?: InvoiceLineScalarWhereInput | InvoiceLineScalarWhereInput[]
  }

  export type PaymentUncheckedUpdateManyWithoutInvoiceNestedInput = {
    create?: XOR<PaymentCreateWithoutInvoiceInput, PaymentUncheckedCreateWithoutInvoiceInput> | PaymentCreateWithoutInvoiceInput[] | PaymentUncheckedCreateWithoutInvoiceInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutInvoiceInput | PaymentCreateOrConnectWithoutInvoiceInput[]
    upsert?: PaymentUpsertWithWhereUniqueWithoutInvoiceInput | PaymentUpsertWithWhereUniqueWithoutInvoiceInput[]
    createMany?: PaymentCreateManyInvoiceInputEnvelope
    set?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    disconnect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    delete?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    update?: PaymentUpdateWithWhereUniqueWithoutInvoiceInput | PaymentUpdateWithWhereUniqueWithoutInvoiceInput[]
    updateMany?: PaymentUpdateManyWithWhereWithoutInvoiceInput | PaymentUpdateManyWithWhereWithoutInvoiceInput[]
    deleteMany?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
  }

  export type InvoiceCreateNestedOneWithoutLinesInput = {
    create?: XOR<InvoiceCreateWithoutLinesInput, InvoiceUncheckedCreateWithoutLinesInput>
    connectOrCreate?: InvoiceCreateOrConnectWithoutLinesInput
    connect?: InvoiceWhereUniqueInput
  }

  export type InvoiceUpdateOneRequiredWithoutLinesNestedInput = {
    create?: XOR<InvoiceCreateWithoutLinesInput, InvoiceUncheckedCreateWithoutLinesInput>
    connectOrCreate?: InvoiceCreateOrConnectWithoutLinesInput
    upsert?: InvoiceUpsertWithoutLinesInput
    connect?: InvoiceWhereUniqueInput
    update?: XOR<XOR<InvoiceUpdateToOneWithWhereWithoutLinesInput, InvoiceUpdateWithoutLinesInput>, InvoiceUncheckedUpdateWithoutLinesInput>
  }

  export type InvoiceCreateNestedOneWithoutPaymentsInput = {
    create?: XOR<InvoiceCreateWithoutPaymentsInput, InvoiceUncheckedCreateWithoutPaymentsInput>
    connectOrCreate?: InvoiceCreateOrConnectWithoutPaymentsInput
    connect?: InvoiceWhereUniqueInput
  }

  export type InvoiceUpdateOneRequiredWithoutPaymentsNestedInput = {
    create?: XOR<InvoiceCreateWithoutPaymentsInput, InvoiceUncheckedCreateWithoutPaymentsInput>
    connectOrCreate?: InvoiceCreateOrConnectWithoutPaymentsInput
    upsert?: InvoiceUpsertWithoutPaymentsInput
    connect?: InvoiceWhereUniqueInput
    update?: XOR<XOR<InvoiceUpdateToOneWithWhereWithoutPaymentsInput, InvoiceUpdateWithoutPaymentsInput>, InvoiceUncheckedUpdateWithoutPaymentsInput>
  }

  export type TenantCreateNestedOneWithoutPelanggaranInput = {
    create?: XOR<TenantCreateWithoutPelanggaranInput, TenantUncheckedCreateWithoutPelanggaranInput>
    connectOrCreate?: TenantCreateOrConnectWithoutPelanggaranInput
    connect?: TenantWhereUniqueInput
  }

  export type SantriCreateNestedOneWithoutPelanggaranInput = {
    create?: XOR<SantriCreateWithoutPelanggaranInput, SantriUncheckedCreateWithoutPelanggaranInput>
    connectOrCreate?: SantriCreateOrConnectWithoutPelanggaranInput
    connect?: SantriWhereUniqueInput
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type TenantUpdateOneRequiredWithoutPelanggaranNestedInput = {
    create?: XOR<TenantCreateWithoutPelanggaranInput, TenantUncheckedCreateWithoutPelanggaranInput>
    connectOrCreate?: TenantCreateOrConnectWithoutPelanggaranInput
    upsert?: TenantUpsertWithoutPelanggaranInput
    connect?: TenantWhereUniqueInput
    update?: XOR<XOR<TenantUpdateToOneWithWhereWithoutPelanggaranInput, TenantUpdateWithoutPelanggaranInput>, TenantUncheckedUpdateWithoutPelanggaranInput>
  }

  export type SantriUpdateOneRequiredWithoutPelanggaranNestedInput = {
    create?: XOR<SantriCreateWithoutPelanggaranInput, SantriUncheckedCreateWithoutPelanggaranInput>
    connectOrCreate?: SantriCreateOrConnectWithoutPelanggaranInput
    upsert?: SantriUpsertWithoutPelanggaranInput
    connect?: SantriWhereUniqueInput
    update?: XOR<XOR<SantriUpdateToOneWithWhereWithoutPelanggaranInput, SantriUpdateWithoutPelanggaranInput>, SantriUncheckedUpdateWithoutPelanggaranInput>
  }

  export type TenantCreateNestedOneWithoutPembinaanInput = {
    create?: XOR<TenantCreateWithoutPembinaanInput, TenantUncheckedCreateWithoutPembinaanInput>
    connectOrCreate?: TenantCreateOrConnectWithoutPembinaanInput
    connect?: TenantWhereUniqueInput
  }

  export type SantriCreateNestedOneWithoutPembinaanInput = {
    create?: XOR<SantriCreateWithoutPembinaanInput, SantriUncheckedCreateWithoutPembinaanInput>
    connectOrCreate?: SantriCreateOrConnectWithoutPembinaanInput
    connect?: SantriWhereUniqueInput
  }

  export type TenantUpdateOneRequiredWithoutPembinaanNestedInput = {
    create?: XOR<TenantCreateWithoutPembinaanInput, TenantUncheckedCreateWithoutPembinaanInput>
    connectOrCreate?: TenantCreateOrConnectWithoutPembinaanInput
    upsert?: TenantUpsertWithoutPembinaanInput
    connect?: TenantWhereUniqueInput
    update?: XOR<XOR<TenantUpdateToOneWithWhereWithoutPembinaanInput, TenantUpdateWithoutPembinaanInput>, TenantUncheckedUpdateWithoutPembinaanInput>
  }

  export type SantriUpdateOneRequiredWithoutPembinaanNestedInput = {
    create?: XOR<SantriCreateWithoutPembinaanInput, SantriUncheckedCreateWithoutPembinaanInput>
    connectOrCreate?: SantriCreateOrConnectWithoutPembinaanInput
    upsert?: SantriUpsertWithoutPembinaanInput
    connect?: SantriWhereUniqueInput
    update?: XOR<XOR<SantriUpdateToOneWithWhereWithoutPembinaanInput, SantriUpdateWithoutPembinaanInput>, SantriUncheckedUpdateWithoutPembinaanInput>
  }

  export type TenantCreateNestedOneWithoutKunjunganInput = {
    create?: XOR<TenantCreateWithoutKunjunganInput, TenantUncheckedCreateWithoutKunjunganInput>
    connectOrCreate?: TenantCreateOrConnectWithoutKunjunganInput
    connect?: TenantWhereUniqueInput
  }

  export type SantriCreateNestedOneWithoutKunjunganInput = {
    create?: XOR<SantriCreateWithoutKunjunganInput, SantriUncheckedCreateWithoutKunjunganInput>
    connectOrCreate?: SantriCreateOrConnectWithoutKunjunganInput
    connect?: SantriWhereUniqueInput
  }

  export type TamuCreateNestedManyWithoutKunjunganInput = {
    create?: XOR<TamuCreateWithoutKunjunganInput, TamuUncheckedCreateWithoutKunjunganInput> | TamuCreateWithoutKunjunganInput[] | TamuUncheckedCreateWithoutKunjunganInput[]
    connectOrCreate?: TamuCreateOrConnectWithoutKunjunganInput | TamuCreateOrConnectWithoutKunjunganInput[]
    createMany?: TamuCreateManyKunjunganInputEnvelope
    connect?: TamuWhereUniqueInput | TamuWhereUniqueInput[]
  }

  export type TamuUncheckedCreateNestedManyWithoutKunjunganInput = {
    create?: XOR<TamuCreateWithoutKunjunganInput, TamuUncheckedCreateWithoutKunjunganInput> | TamuCreateWithoutKunjunganInput[] | TamuUncheckedCreateWithoutKunjunganInput[]
    connectOrCreate?: TamuCreateOrConnectWithoutKunjunganInput | TamuCreateOrConnectWithoutKunjunganInput[]
    createMany?: TamuCreateManyKunjunganInputEnvelope
    connect?: TamuWhereUniqueInput | TamuWhereUniqueInput[]
  }

  export type TenantUpdateOneRequiredWithoutKunjunganNestedInput = {
    create?: XOR<TenantCreateWithoutKunjunganInput, TenantUncheckedCreateWithoutKunjunganInput>
    connectOrCreate?: TenantCreateOrConnectWithoutKunjunganInput
    upsert?: TenantUpsertWithoutKunjunganInput
    connect?: TenantWhereUniqueInput
    update?: XOR<XOR<TenantUpdateToOneWithWhereWithoutKunjunganInput, TenantUpdateWithoutKunjunganInput>, TenantUncheckedUpdateWithoutKunjunganInput>
  }

  export type SantriUpdateOneRequiredWithoutKunjunganNestedInput = {
    create?: XOR<SantriCreateWithoutKunjunganInput, SantriUncheckedCreateWithoutKunjunganInput>
    connectOrCreate?: SantriCreateOrConnectWithoutKunjunganInput
    upsert?: SantriUpsertWithoutKunjunganInput
    connect?: SantriWhereUniqueInput
    update?: XOR<XOR<SantriUpdateToOneWithWhereWithoutKunjunganInput, SantriUpdateWithoutKunjunganInput>, SantriUncheckedUpdateWithoutKunjunganInput>
  }

  export type TamuUpdateManyWithoutKunjunganNestedInput = {
    create?: XOR<TamuCreateWithoutKunjunganInput, TamuUncheckedCreateWithoutKunjunganInput> | TamuCreateWithoutKunjunganInput[] | TamuUncheckedCreateWithoutKunjunganInput[]
    connectOrCreate?: TamuCreateOrConnectWithoutKunjunganInput | TamuCreateOrConnectWithoutKunjunganInput[]
    upsert?: TamuUpsertWithWhereUniqueWithoutKunjunganInput | TamuUpsertWithWhereUniqueWithoutKunjunganInput[]
    createMany?: TamuCreateManyKunjunganInputEnvelope
    set?: TamuWhereUniqueInput | TamuWhereUniqueInput[]
    disconnect?: TamuWhereUniqueInput | TamuWhereUniqueInput[]
    delete?: TamuWhereUniqueInput | TamuWhereUniqueInput[]
    connect?: TamuWhereUniqueInput | TamuWhereUniqueInput[]
    update?: TamuUpdateWithWhereUniqueWithoutKunjunganInput | TamuUpdateWithWhereUniqueWithoutKunjunganInput[]
    updateMany?: TamuUpdateManyWithWhereWithoutKunjunganInput | TamuUpdateManyWithWhereWithoutKunjunganInput[]
    deleteMany?: TamuScalarWhereInput | TamuScalarWhereInput[]
  }

  export type TamuUncheckedUpdateManyWithoutKunjunganNestedInput = {
    create?: XOR<TamuCreateWithoutKunjunganInput, TamuUncheckedCreateWithoutKunjunganInput> | TamuCreateWithoutKunjunganInput[] | TamuUncheckedCreateWithoutKunjunganInput[]
    connectOrCreate?: TamuCreateOrConnectWithoutKunjunganInput | TamuCreateOrConnectWithoutKunjunganInput[]
    upsert?: TamuUpsertWithWhereUniqueWithoutKunjunganInput | TamuUpsertWithWhereUniqueWithoutKunjunganInput[]
    createMany?: TamuCreateManyKunjunganInputEnvelope
    set?: TamuWhereUniqueInput | TamuWhereUniqueInput[]
    disconnect?: TamuWhereUniqueInput | TamuWhereUniqueInput[]
    delete?: TamuWhereUniqueInput | TamuWhereUniqueInput[]
    connect?: TamuWhereUniqueInput | TamuWhereUniqueInput[]
    update?: TamuUpdateWithWhereUniqueWithoutKunjunganInput | TamuUpdateWithWhereUniqueWithoutKunjunganInput[]
    updateMany?: TamuUpdateManyWithWhereWithoutKunjunganInput | TamuUpdateManyWithWhereWithoutKunjunganInput[]
    deleteMany?: TamuScalarWhereInput | TamuScalarWhereInput[]
  }

  export type KunjunganCreateNestedOneWithoutTamuInput = {
    create?: XOR<KunjunganCreateWithoutTamuInput, KunjunganUncheckedCreateWithoutTamuInput>
    connectOrCreate?: KunjunganCreateOrConnectWithoutTamuInput
    connect?: KunjunganWhereUniqueInput
  }

  export type KunjunganUpdateOneRequiredWithoutTamuNestedInput = {
    create?: XOR<KunjunganCreateWithoutTamuInput, KunjunganUncheckedCreateWithoutTamuInput>
    connectOrCreate?: KunjunganCreateOrConnectWithoutTamuInput
    upsert?: KunjunganUpsertWithoutTamuInput
    connect?: KunjunganWhereUniqueInput
    update?: XOR<XOR<KunjunganUpdateToOneWithWhereWithoutTamuInput, KunjunganUpdateWithoutTamuInput>, KunjunganUncheckedUpdateWithoutTamuInput>
  }

  export type TenantCreateNestedOneWithoutHealthRecordsInput = {
    create?: XOR<TenantCreateWithoutHealthRecordsInput, TenantUncheckedCreateWithoutHealthRecordsInput>
    connectOrCreate?: TenantCreateOrConnectWithoutHealthRecordsInput
    connect?: TenantWhereUniqueInput
  }

  export type SantriCreateNestedOneWithoutHealthRecordsInput = {
    create?: XOR<SantriCreateWithoutHealthRecordsInput, SantriUncheckedCreateWithoutHealthRecordsInput>
    connectOrCreate?: SantriCreateOrConnectWithoutHealthRecordsInput
    connect?: SantriWhereUniqueInput
  }

  export type TenantUpdateOneRequiredWithoutHealthRecordsNestedInput = {
    create?: XOR<TenantCreateWithoutHealthRecordsInput, TenantUncheckedCreateWithoutHealthRecordsInput>
    connectOrCreate?: TenantCreateOrConnectWithoutHealthRecordsInput
    upsert?: TenantUpsertWithoutHealthRecordsInput
    connect?: TenantWhereUniqueInput
    update?: XOR<XOR<TenantUpdateToOneWithWhereWithoutHealthRecordsInput, TenantUpdateWithoutHealthRecordsInput>, TenantUncheckedUpdateWithoutHealthRecordsInput>
  }

  export type SantriUpdateOneRequiredWithoutHealthRecordsNestedInput = {
    create?: XOR<SantriCreateWithoutHealthRecordsInput, SantriUncheckedCreateWithoutHealthRecordsInput>
    connectOrCreate?: SantriCreateOrConnectWithoutHealthRecordsInput
    upsert?: SantriUpsertWithoutHealthRecordsInput
    connect?: SantriWhereUniqueInput
    update?: XOR<XOR<SantriUpdateToOneWithWhereWithoutHealthRecordsInput, SantriUpdateWithoutHealthRecordsInput>, SantriUncheckedUpdateWithoutHealthRecordsInput>
  }

  export type SantriCreateNestedOneWithoutMedicationsInput = {
    create?: XOR<SantriCreateWithoutMedicationsInput, SantriUncheckedCreateWithoutMedicationsInput>
    connectOrCreate?: SantriCreateOrConnectWithoutMedicationsInput
    connect?: SantriWhereUniqueInput
  }

  export type SantriUpdateOneRequiredWithoutMedicationsNestedInput = {
    create?: XOR<SantriCreateWithoutMedicationsInput, SantriUncheckedCreateWithoutMedicationsInput>
    connectOrCreate?: SantriCreateOrConnectWithoutMedicationsInput
    upsert?: SantriUpsertWithoutMedicationsInput
    connect?: SantriWhereUniqueInput
    update?: XOR<XOR<SantriUpdateToOneWithWhereWithoutMedicationsInput, SantriUpdateWithoutMedicationsInput>, SantriUncheckedUpdateWithoutMedicationsInput>
  }

  export type TenantCreateNestedOneWithoutAuditLogsInput = {
    create?: XOR<TenantCreateWithoutAuditLogsInput, TenantUncheckedCreateWithoutAuditLogsInput>
    connectOrCreate?: TenantCreateOrConnectWithoutAuditLogsInput
    connect?: TenantWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutAuditLogsInput = {
    create?: XOR<UserCreateWithoutAuditLogsInput, UserUncheckedCreateWithoutAuditLogsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAuditLogsInput
    connect?: UserWhereUniqueInput
  }

  export type TenantUpdateOneWithoutAuditLogsNestedInput = {
    create?: XOR<TenantCreateWithoutAuditLogsInput, TenantUncheckedCreateWithoutAuditLogsInput>
    connectOrCreate?: TenantCreateOrConnectWithoutAuditLogsInput
    upsert?: TenantUpsertWithoutAuditLogsInput
    disconnect?: TenantWhereInput | boolean
    delete?: TenantWhereInput | boolean
    connect?: TenantWhereUniqueInput
    update?: XOR<XOR<TenantUpdateToOneWithWhereWithoutAuditLogsInput, TenantUpdateWithoutAuditLogsInput>, TenantUncheckedUpdateWithoutAuditLogsInput>
  }

  export type UserUpdateOneWithoutAuditLogsNestedInput = {
    create?: XOR<UserCreateWithoutAuditLogsInput, UserUncheckedCreateWithoutAuditLogsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAuditLogsInput
    upsert?: UserUpsertWithoutAuditLogsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAuditLogsInput, UserUpdateWithoutAuditLogsInput>, UserUncheckedUpdateWithoutAuditLogsInput>
  }

  export type TenantCreateNestedOneWithoutNotificationsInput = {
    create?: XOR<TenantCreateWithoutNotificationsInput, TenantUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: TenantCreateOrConnectWithoutNotificationsInput
    connect?: TenantWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutNotificationsInput = {
    create?: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutNotificationsInput
    connect?: UserWhereUniqueInput
  }

  export type TenantUpdateOneRequiredWithoutNotificationsNestedInput = {
    create?: XOR<TenantCreateWithoutNotificationsInput, TenantUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: TenantCreateOrConnectWithoutNotificationsInput
    upsert?: TenantUpsertWithoutNotificationsInput
    connect?: TenantWhereUniqueInput
    update?: XOR<XOR<TenantUpdateToOneWithWhereWithoutNotificationsInput, TenantUpdateWithoutNotificationsInput>, TenantUncheckedUpdateWithoutNotificationsInput>
  }

  export type UserUpdateOneRequiredWithoutNotificationsNestedInput = {
    create?: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutNotificationsInput
    upsert?: UserUpsertWithoutNotificationsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutNotificationsInput, UserUpdateWithoutNotificationsInput>, UserUncheckedUpdateWithoutNotificationsInput>
  }

  export type TenantCreateNestedOneWithoutWebhookEventsInput = {
    create?: XOR<TenantCreateWithoutWebhookEventsInput, TenantUncheckedCreateWithoutWebhookEventsInput>
    connectOrCreate?: TenantCreateOrConnectWithoutWebhookEventsInput
    connect?: TenantWhereUniqueInput
  }

  export type TenantUpdateOneWithoutWebhookEventsNestedInput = {
    create?: XOR<TenantCreateWithoutWebhookEventsInput, TenantUncheckedCreateWithoutWebhookEventsInput>
    connectOrCreate?: TenantCreateOrConnectWithoutWebhookEventsInput
    upsert?: TenantUpsertWithoutWebhookEventsInput
    disconnect?: TenantWhereInput | boolean
    delete?: TenantWhereInput | boolean
    connect?: TenantWhereUniqueInput
    update?: XOR<XOR<TenantUpdateToOneWithWhereWithoutWebhookEventsInput, TenantUpdateWithoutWebhookEventsInput>, TenantUncheckedUpdateWithoutWebhookEventsInput>
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type UserCreateWithoutTenantInput = {
    id?: string
    email: string
    passwordHash: string
    role?: string
    name: string
    phone?: string | null
    isActive?: boolean
    lastLogin?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    refreshTokens?: RefreshTokenCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutTenantInput = {
    id?: string
    email: string
    passwordHash: string
    role?: string
    name: string
    phone?: string | null
    isActive?: boolean
    lastLogin?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    refreshTokens?: RefreshTokenUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutTenantInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutTenantInput, UserUncheckedCreateWithoutTenantInput>
  }

  export type UserCreateManyTenantInputEnvelope = {
    data: UserCreateManyTenantInput | UserCreateManyTenantInput[]
  }

  export type SantriCreateWithoutTenantInput = {
    id?: string
    nisn?: string | null
    name: string
    gender: string
    dob?: Date | string | null
    kelas?: string | null
    room?: string | null
    contact?: string | null
    address?: string | null
    photo?: string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    walis?: SantriWaliCreateNestedManyWithoutSantriInput
    izin?: IzinCreateNestedManyWithoutSantriInput
    catatanHarian?: CatatanHarianCreateNestedManyWithoutSantriInput
    invoices?: InvoiceCreateNestedManyWithoutSantriInput
    pelanggaran?: PelanggaranCreateNestedManyWithoutSantriInput
    pembinaan?: PembinaanCreateNestedManyWithoutSantriInput
    kunjungan?: KunjunganCreateNestedManyWithoutSantriInput
    healthRecords?: HealthRecordCreateNestedManyWithoutSantriInput
    medications?: MedicationCreateNestedManyWithoutSantriInput
  }

  export type SantriUncheckedCreateWithoutTenantInput = {
    id?: string
    nisn?: string | null
    name: string
    gender: string
    dob?: Date | string | null
    kelas?: string | null
    room?: string | null
    contact?: string | null
    address?: string | null
    photo?: string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    walis?: SantriWaliUncheckedCreateNestedManyWithoutSantriInput
    izin?: IzinUncheckedCreateNestedManyWithoutSantriInput
    catatanHarian?: CatatanHarianUncheckedCreateNestedManyWithoutSantriInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutSantriInput
    pelanggaran?: PelanggaranUncheckedCreateNestedManyWithoutSantriInput
    pembinaan?: PembinaanUncheckedCreateNestedManyWithoutSantriInput
    kunjungan?: KunjunganUncheckedCreateNestedManyWithoutSantriInput
    healthRecords?: HealthRecordUncheckedCreateNestedManyWithoutSantriInput
    medications?: MedicationUncheckedCreateNestedManyWithoutSantriInput
  }

  export type SantriCreateOrConnectWithoutTenantInput = {
    where: SantriWhereUniqueInput
    create: XOR<SantriCreateWithoutTenantInput, SantriUncheckedCreateWithoutTenantInput>
  }

  export type SantriCreateManyTenantInputEnvelope = {
    data: SantriCreateManyTenantInput | SantriCreateManyTenantInput[]
  }

  export type WaliCreateWithoutTenantInput = {
    id?: string
    name: string
    relation: string
    phone: string
    email?: string | null
    address?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    santris?: SantriWaliCreateNestedManyWithoutWaliInput
  }

  export type WaliUncheckedCreateWithoutTenantInput = {
    id?: string
    name: string
    relation: string
    phone: string
    email?: string | null
    address?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    santris?: SantriWaliUncheckedCreateNestedManyWithoutWaliInput
  }

  export type WaliCreateOrConnectWithoutTenantInput = {
    where: WaliWhereUniqueInput
    create: XOR<WaliCreateWithoutTenantInput, WaliUncheckedCreateWithoutTenantInput>
  }

  export type WaliCreateManyTenantInputEnvelope = {
    data: WaliCreateManyTenantInput | WaliCreateManyTenantInput[]
  }

  export type IzinCreateWithoutTenantInput = {
    id?: string
    type: string
    reason: string
    startAt: Date | string
    endAt: Date | string
    status?: string
    requestedBy: string
    approvedBy?: string | null
    approvedAt?: Date | string | null
    qrCodeData?: string | null
    checkoutAt?: Date | string | null
    checkoutBy?: string | null
    checkinAt?: Date | string | null
    checkinBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    santri: SantriCreateNestedOneWithoutIzinInput
  }

  export type IzinUncheckedCreateWithoutTenantInput = {
    id?: string
    santriId: string
    type: string
    reason: string
    startAt: Date | string
    endAt: Date | string
    status?: string
    requestedBy: string
    approvedBy?: string | null
    approvedAt?: Date | string | null
    qrCodeData?: string | null
    checkoutAt?: Date | string | null
    checkoutBy?: string | null
    checkinAt?: Date | string | null
    checkinBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type IzinCreateOrConnectWithoutTenantInput = {
    where: IzinWhereUniqueInput
    create: XOR<IzinCreateWithoutTenantInput, IzinUncheckedCreateWithoutTenantInput>
  }

  export type IzinCreateManyTenantInputEnvelope = {
    data: IzinCreateManyTenantInput | IzinCreateManyTenantInput[]
  }

  export type CatatanHarianCreateWithoutTenantInput = {
    id?: string
    authorId: string
    date?: Date | string
    content: string
    category: string
    attachments?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    santri: SantriCreateNestedOneWithoutCatatanHarianInput
  }

  export type CatatanHarianUncheckedCreateWithoutTenantInput = {
    id?: string
    santriId: string
    authorId: string
    date?: Date | string
    content: string
    category: string
    attachments?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CatatanHarianCreateOrConnectWithoutTenantInput = {
    where: CatatanHarianWhereUniqueInput
    create: XOR<CatatanHarianCreateWithoutTenantInput, CatatanHarianUncheckedCreateWithoutTenantInput>
  }

  export type CatatanHarianCreateManyTenantInputEnvelope = {
    data: CatatanHarianCreateManyTenantInput | CatatanHarianCreateManyTenantInput[]
  }

  export type PengumumanCreateWithoutTenantInput = {
    id?: string
    title: string
    content: string
    audience: string
    pinnedUntil?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PengumumanUncheckedCreateWithoutTenantInput = {
    id?: string
    title: string
    content: string
    audience: string
    pinnedUntil?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PengumumanCreateOrConnectWithoutTenantInput = {
    where: PengumumanWhereUniqueInput
    create: XOR<PengumumanCreateWithoutTenantInput, PengumumanUncheckedCreateWithoutTenantInput>
  }

  export type PengumumanCreateManyTenantInputEnvelope = {
    data: PengumumanCreateManyTenantInput | PengumumanCreateManyTenantInput[]
  }

  export type InvoiceCreateWithoutTenantInput = {
    id?: string
    amountDue: number
    dueDate: Date | string
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    santri: SantriCreateNestedOneWithoutInvoicesInput
    lines?: InvoiceLineCreateNestedManyWithoutInvoiceInput
    payments?: PaymentCreateNestedManyWithoutInvoiceInput
  }

  export type InvoiceUncheckedCreateWithoutTenantInput = {
    id?: string
    santriId: string
    amountDue: number
    dueDate: Date | string
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    lines?: InvoiceLineUncheckedCreateNestedManyWithoutInvoiceInput
    payments?: PaymentUncheckedCreateNestedManyWithoutInvoiceInput
  }

  export type InvoiceCreateOrConnectWithoutTenantInput = {
    where: InvoiceWhereUniqueInput
    create: XOR<InvoiceCreateWithoutTenantInput, InvoiceUncheckedCreateWithoutTenantInput>
  }

  export type InvoiceCreateManyTenantInputEnvelope = {
    data: InvoiceCreateManyTenantInput | InvoiceCreateManyTenantInput[]
  }

  export type PelanggaranCreateWithoutTenantInput = {
    id?: string
    recordedBy: string
    category: string
    severity: number
    points?: number
    description: string
    date?: Date | string
    resolved?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    santri: SantriCreateNestedOneWithoutPelanggaranInput
  }

  export type PelanggaranUncheckedCreateWithoutTenantInput = {
    id?: string
    santriId: string
    recordedBy: string
    category: string
    severity: number
    points?: number
    description: string
    date?: Date | string
    resolved?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PelanggaranCreateOrConnectWithoutTenantInput = {
    where: PelanggaranWhereUniqueInput
    create: XOR<PelanggaranCreateWithoutTenantInput, PelanggaranUncheckedCreateWithoutTenantInput>
  }

  export type PelanggaranCreateManyTenantInputEnvelope = {
    data: PelanggaranCreateManyTenantInput | PelanggaranCreateManyTenantInput[]
  }

  export type PembinaanCreateWithoutTenantInput = {
    id?: string
    plan: string
    targetDate: Date | string
    status?: string
    assignedTo: string
    createdAt?: Date | string
    updatedAt?: Date | string
    santri: SantriCreateNestedOneWithoutPembinaanInput
  }

  export type PembinaanUncheckedCreateWithoutTenantInput = {
    id?: string
    santriId: string
    plan: string
    targetDate: Date | string
    status?: string
    assignedTo: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PembinaanCreateOrConnectWithoutTenantInput = {
    where: PembinaanWhereUniqueInput
    create: XOR<PembinaanCreateWithoutTenantInput, PembinaanUncheckedCreateWithoutTenantInput>
  }

  export type PembinaanCreateManyTenantInputEnvelope = {
    data: PembinaanCreateManyTenantInput | PembinaanCreateManyTenantInput[]
  }

  export type KunjunganCreateWithoutTenantInput = {
    id?: string
    scheduledAt: Date | string
    slot: string
    visitorLimit?: number
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    santri: SantriCreateNestedOneWithoutKunjunganInput
    tamu?: TamuCreateNestedManyWithoutKunjunganInput
  }

  export type KunjunganUncheckedCreateWithoutTenantInput = {
    id?: string
    santriId: string
    scheduledAt: Date | string
    slot: string
    visitorLimit?: number
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    tamu?: TamuUncheckedCreateNestedManyWithoutKunjunganInput
  }

  export type KunjunganCreateOrConnectWithoutTenantInput = {
    where: KunjunganWhereUniqueInput
    create: XOR<KunjunganCreateWithoutTenantInput, KunjunganUncheckedCreateWithoutTenantInput>
  }

  export type KunjunganCreateManyTenantInputEnvelope = {
    data: KunjunganCreateManyTenantInput | KunjunganCreateManyTenantInput[]
  }

  export type HealthRecordCreateWithoutTenantInput = {
    id?: string
    recordedBy: string
    symptoms: string
    diagnosis?: string | null
    actionTaken?: string | null
    referred?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    santri: SantriCreateNestedOneWithoutHealthRecordsInput
  }

  export type HealthRecordUncheckedCreateWithoutTenantInput = {
    id?: string
    santriId: string
    recordedBy: string
    symptoms: string
    diagnosis?: string | null
    actionTaken?: string | null
    referred?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type HealthRecordCreateOrConnectWithoutTenantInput = {
    where: HealthRecordWhereUniqueInput
    create: XOR<HealthRecordCreateWithoutTenantInput, HealthRecordUncheckedCreateWithoutTenantInput>
  }

  export type HealthRecordCreateManyTenantInputEnvelope = {
    data: HealthRecordCreateManyTenantInput | HealthRecordCreateManyTenantInput[]
  }

  export type AuditLogCreateWithoutTenantInput = {
    id?: string
    action: string
    entity: string
    entityId: string
    oldValue?: string | null
    newValue?: string | null
    ip?: string | null
    createdAt?: Date | string
    user?: UserCreateNestedOneWithoutAuditLogsInput
  }

  export type AuditLogUncheckedCreateWithoutTenantInput = {
    id?: string
    userId?: string | null
    action: string
    entity: string
    entityId: string
    oldValue?: string | null
    newValue?: string | null
    ip?: string | null
    createdAt?: Date | string
  }

  export type AuditLogCreateOrConnectWithoutTenantInput = {
    where: AuditLogWhereUniqueInput
    create: XOR<AuditLogCreateWithoutTenantInput, AuditLogUncheckedCreateWithoutTenantInput>
  }

  export type AuditLogCreateManyTenantInputEnvelope = {
    data: AuditLogCreateManyTenantInput | AuditLogCreateManyTenantInput[]
  }

  export type NotificationCreateWithoutTenantInput = {
    id?: string
    type: string
    title: string
    body: string
    read?: boolean
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutNotificationsInput
  }

  export type NotificationUncheckedCreateWithoutTenantInput = {
    id?: string
    userId: string
    type: string
    title: string
    body: string
    read?: boolean
    createdAt?: Date | string
  }

  export type NotificationCreateOrConnectWithoutTenantInput = {
    where: NotificationWhereUniqueInput
    create: XOR<NotificationCreateWithoutTenantInput, NotificationUncheckedCreateWithoutTenantInput>
  }

  export type NotificationCreateManyTenantInputEnvelope = {
    data: NotificationCreateManyTenantInput | NotificationCreateManyTenantInput[]
  }

  export type WebhookEventCreateWithoutTenantInput = {
    id?: string
    eventType: string
    payload: string
    status?: string
    error?: string | null
    createdAt?: Date | string
    processedAt?: Date | string | null
  }

  export type WebhookEventUncheckedCreateWithoutTenantInput = {
    id?: string
    eventType: string
    payload: string
    status?: string
    error?: string | null
    createdAt?: Date | string
    processedAt?: Date | string | null
  }

  export type WebhookEventCreateOrConnectWithoutTenantInput = {
    where: WebhookEventWhereUniqueInput
    create: XOR<WebhookEventCreateWithoutTenantInput, WebhookEventUncheckedCreateWithoutTenantInput>
  }

  export type WebhookEventCreateManyTenantInputEnvelope = {
    data: WebhookEventCreateManyTenantInput | WebhookEventCreateManyTenantInput[]
  }

  export type UserUpsertWithWhereUniqueWithoutTenantInput = {
    where: UserWhereUniqueInput
    update: XOR<UserUpdateWithoutTenantInput, UserUncheckedUpdateWithoutTenantInput>
    create: XOR<UserCreateWithoutTenantInput, UserUncheckedCreateWithoutTenantInput>
  }

  export type UserUpdateWithWhereUniqueWithoutTenantInput = {
    where: UserWhereUniqueInput
    data: XOR<UserUpdateWithoutTenantInput, UserUncheckedUpdateWithoutTenantInput>
  }

  export type UserUpdateManyWithWhereWithoutTenantInput = {
    where: UserScalarWhereInput
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyWithoutTenantInput>
  }

  export type UserScalarWhereInput = {
    AND?: UserScalarWhereInput | UserScalarWhereInput[]
    OR?: UserScalarWhereInput[]
    NOT?: UserScalarWhereInput | UserScalarWhereInput[]
    id?: StringFilter<"User"> | string
    tenantId?: StringNullableFilter<"User"> | string | null
    email?: StringFilter<"User"> | string
    passwordHash?: StringFilter<"User"> | string
    role?: StringFilter<"User"> | string
    name?: StringFilter<"User"> | string
    phone?: StringNullableFilter<"User"> | string | null
    isActive?: BoolFilter<"User"> | boolean
    lastLogin?: DateTimeNullableFilter<"User"> | Date | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
  }

  export type SantriUpsertWithWhereUniqueWithoutTenantInput = {
    where: SantriWhereUniqueInput
    update: XOR<SantriUpdateWithoutTenantInput, SantriUncheckedUpdateWithoutTenantInput>
    create: XOR<SantriCreateWithoutTenantInput, SantriUncheckedCreateWithoutTenantInput>
  }

  export type SantriUpdateWithWhereUniqueWithoutTenantInput = {
    where: SantriWhereUniqueInput
    data: XOR<SantriUpdateWithoutTenantInput, SantriUncheckedUpdateWithoutTenantInput>
  }

  export type SantriUpdateManyWithWhereWithoutTenantInput = {
    where: SantriScalarWhereInput
    data: XOR<SantriUpdateManyMutationInput, SantriUncheckedUpdateManyWithoutTenantInput>
  }

  export type SantriScalarWhereInput = {
    AND?: SantriScalarWhereInput | SantriScalarWhereInput[]
    OR?: SantriScalarWhereInput[]
    NOT?: SantriScalarWhereInput | SantriScalarWhereInput[]
    id?: StringFilter<"Santri"> | string
    tenantId?: StringFilter<"Santri"> | string
    nisn?: StringNullableFilter<"Santri"> | string | null
    name?: StringFilter<"Santri"> | string
    gender?: StringFilter<"Santri"> | string
    dob?: DateTimeNullableFilter<"Santri"> | Date | string | null
    kelas?: StringNullableFilter<"Santri"> | string | null
    room?: StringNullableFilter<"Santri"> | string | null
    contact?: StringNullableFilter<"Santri"> | string | null
    address?: StringNullableFilter<"Santri"> | string | null
    photo?: StringNullableFilter<"Santri"> | string | null
    status?: StringFilter<"Santri"> | string
    createdAt?: DateTimeFilter<"Santri"> | Date | string
    updatedAt?: DateTimeFilter<"Santri"> | Date | string
  }

  export type WaliUpsertWithWhereUniqueWithoutTenantInput = {
    where: WaliWhereUniqueInput
    update: XOR<WaliUpdateWithoutTenantInput, WaliUncheckedUpdateWithoutTenantInput>
    create: XOR<WaliCreateWithoutTenantInput, WaliUncheckedCreateWithoutTenantInput>
  }

  export type WaliUpdateWithWhereUniqueWithoutTenantInput = {
    where: WaliWhereUniqueInput
    data: XOR<WaliUpdateWithoutTenantInput, WaliUncheckedUpdateWithoutTenantInput>
  }

  export type WaliUpdateManyWithWhereWithoutTenantInput = {
    where: WaliScalarWhereInput
    data: XOR<WaliUpdateManyMutationInput, WaliUncheckedUpdateManyWithoutTenantInput>
  }

  export type WaliScalarWhereInput = {
    AND?: WaliScalarWhereInput | WaliScalarWhereInput[]
    OR?: WaliScalarWhereInput[]
    NOT?: WaliScalarWhereInput | WaliScalarWhereInput[]
    id?: StringFilter<"Wali"> | string
    tenantId?: StringFilter<"Wali"> | string
    name?: StringFilter<"Wali"> | string
    relation?: StringFilter<"Wali"> | string
    phone?: StringFilter<"Wali"> | string
    email?: StringNullableFilter<"Wali"> | string | null
    address?: StringNullableFilter<"Wali"> | string | null
    createdAt?: DateTimeFilter<"Wali"> | Date | string
    updatedAt?: DateTimeFilter<"Wali"> | Date | string
  }

  export type IzinUpsertWithWhereUniqueWithoutTenantInput = {
    where: IzinWhereUniqueInput
    update: XOR<IzinUpdateWithoutTenantInput, IzinUncheckedUpdateWithoutTenantInput>
    create: XOR<IzinCreateWithoutTenantInput, IzinUncheckedCreateWithoutTenantInput>
  }

  export type IzinUpdateWithWhereUniqueWithoutTenantInput = {
    where: IzinWhereUniqueInput
    data: XOR<IzinUpdateWithoutTenantInput, IzinUncheckedUpdateWithoutTenantInput>
  }

  export type IzinUpdateManyWithWhereWithoutTenantInput = {
    where: IzinScalarWhereInput
    data: XOR<IzinUpdateManyMutationInput, IzinUncheckedUpdateManyWithoutTenantInput>
  }

  export type IzinScalarWhereInput = {
    AND?: IzinScalarWhereInput | IzinScalarWhereInput[]
    OR?: IzinScalarWhereInput[]
    NOT?: IzinScalarWhereInput | IzinScalarWhereInput[]
    id?: StringFilter<"Izin"> | string
    tenantId?: StringFilter<"Izin"> | string
    santriId?: StringFilter<"Izin"> | string
    type?: StringFilter<"Izin"> | string
    reason?: StringFilter<"Izin"> | string
    startAt?: DateTimeFilter<"Izin"> | Date | string
    endAt?: DateTimeFilter<"Izin"> | Date | string
    status?: StringFilter<"Izin"> | string
    requestedBy?: StringFilter<"Izin"> | string
    approvedBy?: StringNullableFilter<"Izin"> | string | null
    approvedAt?: DateTimeNullableFilter<"Izin"> | Date | string | null
    qrCodeData?: StringNullableFilter<"Izin"> | string | null
    checkoutAt?: DateTimeNullableFilter<"Izin"> | Date | string | null
    checkoutBy?: StringNullableFilter<"Izin"> | string | null
    checkinAt?: DateTimeNullableFilter<"Izin"> | Date | string | null
    checkinBy?: StringNullableFilter<"Izin"> | string | null
    createdAt?: DateTimeFilter<"Izin"> | Date | string
    updatedAt?: DateTimeFilter<"Izin"> | Date | string
  }

  export type CatatanHarianUpsertWithWhereUniqueWithoutTenantInput = {
    where: CatatanHarianWhereUniqueInput
    update: XOR<CatatanHarianUpdateWithoutTenantInput, CatatanHarianUncheckedUpdateWithoutTenantInput>
    create: XOR<CatatanHarianCreateWithoutTenantInput, CatatanHarianUncheckedCreateWithoutTenantInput>
  }

  export type CatatanHarianUpdateWithWhereUniqueWithoutTenantInput = {
    where: CatatanHarianWhereUniqueInput
    data: XOR<CatatanHarianUpdateWithoutTenantInput, CatatanHarianUncheckedUpdateWithoutTenantInput>
  }

  export type CatatanHarianUpdateManyWithWhereWithoutTenantInput = {
    where: CatatanHarianScalarWhereInput
    data: XOR<CatatanHarianUpdateManyMutationInput, CatatanHarianUncheckedUpdateManyWithoutTenantInput>
  }

  export type CatatanHarianScalarWhereInput = {
    AND?: CatatanHarianScalarWhereInput | CatatanHarianScalarWhereInput[]
    OR?: CatatanHarianScalarWhereInput[]
    NOT?: CatatanHarianScalarWhereInput | CatatanHarianScalarWhereInput[]
    id?: StringFilter<"CatatanHarian"> | string
    tenantId?: StringFilter<"CatatanHarian"> | string
    santriId?: StringFilter<"CatatanHarian"> | string
    authorId?: StringFilter<"CatatanHarian"> | string
    date?: DateTimeFilter<"CatatanHarian"> | Date | string
    content?: StringFilter<"CatatanHarian"> | string
    category?: StringFilter<"CatatanHarian"> | string
    attachments?: StringNullableFilter<"CatatanHarian"> | string | null
    createdAt?: DateTimeFilter<"CatatanHarian"> | Date | string
    updatedAt?: DateTimeFilter<"CatatanHarian"> | Date | string
  }

  export type PengumumanUpsertWithWhereUniqueWithoutTenantInput = {
    where: PengumumanWhereUniqueInput
    update: XOR<PengumumanUpdateWithoutTenantInput, PengumumanUncheckedUpdateWithoutTenantInput>
    create: XOR<PengumumanCreateWithoutTenantInput, PengumumanUncheckedCreateWithoutTenantInput>
  }

  export type PengumumanUpdateWithWhereUniqueWithoutTenantInput = {
    where: PengumumanWhereUniqueInput
    data: XOR<PengumumanUpdateWithoutTenantInput, PengumumanUncheckedUpdateWithoutTenantInput>
  }

  export type PengumumanUpdateManyWithWhereWithoutTenantInput = {
    where: PengumumanScalarWhereInput
    data: XOR<PengumumanUpdateManyMutationInput, PengumumanUncheckedUpdateManyWithoutTenantInput>
  }

  export type PengumumanScalarWhereInput = {
    AND?: PengumumanScalarWhereInput | PengumumanScalarWhereInput[]
    OR?: PengumumanScalarWhereInput[]
    NOT?: PengumumanScalarWhereInput | PengumumanScalarWhereInput[]
    id?: StringFilter<"Pengumuman"> | string
    tenantId?: StringFilter<"Pengumuman"> | string
    title?: StringFilter<"Pengumuman"> | string
    content?: StringFilter<"Pengumuman"> | string
    audience?: StringFilter<"Pengumuman"> | string
    pinnedUntil?: DateTimeNullableFilter<"Pengumuman"> | Date | string | null
    createdAt?: DateTimeFilter<"Pengumuman"> | Date | string
    updatedAt?: DateTimeFilter<"Pengumuman"> | Date | string
  }

  export type InvoiceUpsertWithWhereUniqueWithoutTenantInput = {
    where: InvoiceWhereUniqueInput
    update: XOR<InvoiceUpdateWithoutTenantInput, InvoiceUncheckedUpdateWithoutTenantInput>
    create: XOR<InvoiceCreateWithoutTenantInput, InvoiceUncheckedCreateWithoutTenantInput>
  }

  export type InvoiceUpdateWithWhereUniqueWithoutTenantInput = {
    where: InvoiceWhereUniqueInput
    data: XOR<InvoiceUpdateWithoutTenantInput, InvoiceUncheckedUpdateWithoutTenantInput>
  }

  export type InvoiceUpdateManyWithWhereWithoutTenantInput = {
    where: InvoiceScalarWhereInput
    data: XOR<InvoiceUpdateManyMutationInput, InvoiceUncheckedUpdateManyWithoutTenantInput>
  }

  export type InvoiceScalarWhereInput = {
    AND?: InvoiceScalarWhereInput | InvoiceScalarWhereInput[]
    OR?: InvoiceScalarWhereInput[]
    NOT?: InvoiceScalarWhereInput | InvoiceScalarWhereInput[]
    id?: StringFilter<"Invoice"> | string
    tenantId?: StringFilter<"Invoice"> | string
    santriId?: StringFilter<"Invoice"> | string
    amountDue?: FloatFilter<"Invoice"> | number
    dueDate?: DateTimeFilter<"Invoice"> | Date | string
    status?: StringFilter<"Invoice"> | string
    createdAt?: DateTimeFilter<"Invoice"> | Date | string
    updatedAt?: DateTimeFilter<"Invoice"> | Date | string
  }

  export type PelanggaranUpsertWithWhereUniqueWithoutTenantInput = {
    where: PelanggaranWhereUniqueInput
    update: XOR<PelanggaranUpdateWithoutTenantInput, PelanggaranUncheckedUpdateWithoutTenantInput>
    create: XOR<PelanggaranCreateWithoutTenantInput, PelanggaranUncheckedCreateWithoutTenantInput>
  }

  export type PelanggaranUpdateWithWhereUniqueWithoutTenantInput = {
    where: PelanggaranWhereUniqueInput
    data: XOR<PelanggaranUpdateWithoutTenantInput, PelanggaranUncheckedUpdateWithoutTenantInput>
  }

  export type PelanggaranUpdateManyWithWhereWithoutTenantInput = {
    where: PelanggaranScalarWhereInput
    data: XOR<PelanggaranUpdateManyMutationInput, PelanggaranUncheckedUpdateManyWithoutTenantInput>
  }

  export type PelanggaranScalarWhereInput = {
    AND?: PelanggaranScalarWhereInput | PelanggaranScalarWhereInput[]
    OR?: PelanggaranScalarWhereInput[]
    NOT?: PelanggaranScalarWhereInput | PelanggaranScalarWhereInput[]
    id?: StringFilter<"Pelanggaran"> | string
    tenantId?: StringFilter<"Pelanggaran"> | string
    santriId?: StringFilter<"Pelanggaran"> | string
    recordedBy?: StringFilter<"Pelanggaran"> | string
    category?: StringFilter<"Pelanggaran"> | string
    severity?: IntFilter<"Pelanggaran"> | number
    points?: IntFilter<"Pelanggaran"> | number
    description?: StringFilter<"Pelanggaran"> | string
    date?: DateTimeFilter<"Pelanggaran"> | Date | string
    resolved?: BoolFilter<"Pelanggaran"> | boolean
    createdAt?: DateTimeFilter<"Pelanggaran"> | Date | string
    updatedAt?: DateTimeFilter<"Pelanggaran"> | Date | string
  }

  export type PembinaanUpsertWithWhereUniqueWithoutTenantInput = {
    where: PembinaanWhereUniqueInput
    update: XOR<PembinaanUpdateWithoutTenantInput, PembinaanUncheckedUpdateWithoutTenantInput>
    create: XOR<PembinaanCreateWithoutTenantInput, PembinaanUncheckedCreateWithoutTenantInput>
  }

  export type PembinaanUpdateWithWhereUniqueWithoutTenantInput = {
    where: PembinaanWhereUniqueInput
    data: XOR<PembinaanUpdateWithoutTenantInput, PembinaanUncheckedUpdateWithoutTenantInput>
  }

  export type PembinaanUpdateManyWithWhereWithoutTenantInput = {
    where: PembinaanScalarWhereInput
    data: XOR<PembinaanUpdateManyMutationInput, PembinaanUncheckedUpdateManyWithoutTenantInput>
  }

  export type PembinaanScalarWhereInput = {
    AND?: PembinaanScalarWhereInput | PembinaanScalarWhereInput[]
    OR?: PembinaanScalarWhereInput[]
    NOT?: PembinaanScalarWhereInput | PembinaanScalarWhereInput[]
    id?: StringFilter<"Pembinaan"> | string
    tenantId?: StringFilter<"Pembinaan"> | string
    santriId?: StringFilter<"Pembinaan"> | string
    plan?: StringFilter<"Pembinaan"> | string
    targetDate?: DateTimeFilter<"Pembinaan"> | Date | string
    status?: StringFilter<"Pembinaan"> | string
    assignedTo?: StringFilter<"Pembinaan"> | string
    createdAt?: DateTimeFilter<"Pembinaan"> | Date | string
    updatedAt?: DateTimeFilter<"Pembinaan"> | Date | string
  }

  export type KunjunganUpsertWithWhereUniqueWithoutTenantInput = {
    where: KunjunganWhereUniqueInput
    update: XOR<KunjunganUpdateWithoutTenantInput, KunjunganUncheckedUpdateWithoutTenantInput>
    create: XOR<KunjunganCreateWithoutTenantInput, KunjunganUncheckedCreateWithoutTenantInput>
  }

  export type KunjunganUpdateWithWhereUniqueWithoutTenantInput = {
    where: KunjunganWhereUniqueInput
    data: XOR<KunjunganUpdateWithoutTenantInput, KunjunganUncheckedUpdateWithoutTenantInput>
  }

  export type KunjunganUpdateManyWithWhereWithoutTenantInput = {
    where: KunjunganScalarWhereInput
    data: XOR<KunjunganUpdateManyMutationInput, KunjunganUncheckedUpdateManyWithoutTenantInput>
  }

  export type KunjunganScalarWhereInput = {
    AND?: KunjunganScalarWhereInput | KunjunganScalarWhereInput[]
    OR?: KunjunganScalarWhereInput[]
    NOT?: KunjunganScalarWhereInput | KunjunganScalarWhereInput[]
    id?: StringFilter<"Kunjungan"> | string
    tenantId?: StringFilter<"Kunjungan"> | string
    santriId?: StringFilter<"Kunjungan"> | string
    scheduledAt?: DateTimeFilter<"Kunjungan"> | Date | string
    slot?: StringFilter<"Kunjungan"> | string
    visitorLimit?: IntFilter<"Kunjungan"> | number
    status?: StringFilter<"Kunjungan"> | string
    createdAt?: DateTimeFilter<"Kunjungan"> | Date | string
    updatedAt?: DateTimeFilter<"Kunjungan"> | Date | string
  }

  export type HealthRecordUpsertWithWhereUniqueWithoutTenantInput = {
    where: HealthRecordWhereUniqueInput
    update: XOR<HealthRecordUpdateWithoutTenantInput, HealthRecordUncheckedUpdateWithoutTenantInput>
    create: XOR<HealthRecordCreateWithoutTenantInput, HealthRecordUncheckedCreateWithoutTenantInput>
  }

  export type HealthRecordUpdateWithWhereUniqueWithoutTenantInput = {
    where: HealthRecordWhereUniqueInput
    data: XOR<HealthRecordUpdateWithoutTenantInput, HealthRecordUncheckedUpdateWithoutTenantInput>
  }

  export type HealthRecordUpdateManyWithWhereWithoutTenantInput = {
    where: HealthRecordScalarWhereInput
    data: XOR<HealthRecordUpdateManyMutationInput, HealthRecordUncheckedUpdateManyWithoutTenantInput>
  }

  export type HealthRecordScalarWhereInput = {
    AND?: HealthRecordScalarWhereInput | HealthRecordScalarWhereInput[]
    OR?: HealthRecordScalarWhereInput[]
    NOT?: HealthRecordScalarWhereInput | HealthRecordScalarWhereInput[]
    id?: StringFilter<"HealthRecord"> | string
    tenantId?: StringFilter<"HealthRecord"> | string
    santriId?: StringFilter<"HealthRecord"> | string
    recordedBy?: StringFilter<"HealthRecord"> | string
    symptoms?: StringFilter<"HealthRecord"> | string
    diagnosis?: StringNullableFilter<"HealthRecord"> | string | null
    actionTaken?: StringNullableFilter<"HealthRecord"> | string | null
    referred?: BoolFilter<"HealthRecord"> | boolean
    createdAt?: DateTimeFilter<"HealthRecord"> | Date | string
    updatedAt?: DateTimeFilter<"HealthRecord"> | Date | string
  }

  export type AuditLogUpsertWithWhereUniqueWithoutTenantInput = {
    where: AuditLogWhereUniqueInput
    update: XOR<AuditLogUpdateWithoutTenantInput, AuditLogUncheckedUpdateWithoutTenantInput>
    create: XOR<AuditLogCreateWithoutTenantInput, AuditLogUncheckedCreateWithoutTenantInput>
  }

  export type AuditLogUpdateWithWhereUniqueWithoutTenantInput = {
    where: AuditLogWhereUniqueInput
    data: XOR<AuditLogUpdateWithoutTenantInput, AuditLogUncheckedUpdateWithoutTenantInput>
  }

  export type AuditLogUpdateManyWithWhereWithoutTenantInput = {
    where: AuditLogScalarWhereInput
    data: XOR<AuditLogUpdateManyMutationInput, AuditLogUncheckedUpdateManyWithoutTenantInput>
  }

  export type AuditLogScalarWhereInput = {
    AND?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
    OR?: AuditLogScalarWhereInput[]
    NOT?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
    id?: StringFilter<"AuditLog"> | string
    tenantId?: StringNullableFilter<"AuditLog"> | string | null
    userId?: StringNullableFilter<"AuditLog"> | string | null
    action?: StringFilter<"AuditLog"> | string
    entity?: StringFilter<"AuditLog"> | string
    entityId?: StringFilter<"AuditLog"> | string
    oldValue?: StringNullableFilter<"AuditLog"> | string | null
    newValue?: StringNullableFilter<"AuditLog"> | string | null
    ip?: StringNullableFilter<"AuditLog"> | string | null
    createdAt?: DateTimeFilter<"AuditLog"> | Date | string
  }

  export type NotificationUpsertWithWhereUniqueWithoutTenantInput = {
    where: NotificationWhereUniqueInput
    update: XOR<NotificationUpdateWithoutTenantInput, NotificationUncheckedUpdateWithoutTenantInput>
    create: XOR<NotificationCreateWithoutTenantInput, NotificationUncheckedCreateWithoutTenantInput>
  }

  export type NotificationUpdateWithWhereUniqueWithoutTenantInput = {
    where: NotificationWhereUniqueInput
    data: XOR<NotificationUpdateWithoutTenantInput, NotificationUncheckedUpdateWithoutTenantInput>
  }

  export type NotificationUpdateManyWithWhereWithoutTenantInput = {
    where: NotificationScalarWhereInput
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyWithoutTenantInput>
  }

  export type NotificationScalarWhereInput = {
    AND?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
    OR?: NotificationScalarWhereInput[]
    NOT?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
    id?: StringFilter<"Notification"> | string
    tenantId?: StringFilter<"Notification"> | string
    userId?: StringFilter<"Notification"> | string
    type?: StringFilter<"Notification"> | string
    title?: StringFilter<"Notification"> | string
    body?: StringFilter<"Notification"> | string
    read?: BoolFilter<"Notification"> | boolean
    createdAt?: DateTimeFilter<"Notification"> | Date | string
  }

  export type WebhookEventUpsertWithWhereUniqueWithoutTenantInput = {
    where: WebhookEventWhereUniqueInput
    update: XOR<WebhookEventUpdateWithoutTenantInput, WebhookEventUncheckedUpdateWithoutTenantInput>
    create: XOR<WebhookEventCreateWithoutTenantInput, WebhookEventUncheckedCreateWithoutTenantInput>
  }

  export type WebhookEventUpdateWithWhereUniqueWithoutTenantInput = {
    where: WebhookEventWhereUniqueInput
    data: XOR<WebhookEventUpdateWithoutTenantInput, WebhookEventUncheckedUpdateWithoutTenantInput>
  }

  export type WebhookEventUpdateManyWithWhereWithoutTenantInput = {
    where: WebhookEventScalarWhereInput
    data: XOR<WebhookEventUpdateManyMutationInput, WebhookEventUncheckedUpdateManyWithoutTenantInput>
  }

  export type WebhookEventScalarWhereInput = {
    AND?: WebhookEventScalarWhereInput | WebhookEventScalarWhereInput[]
    OR?: WebhookEventScalarWhereInput[]
    NOT?: WebhookEventScalarWhereInput | WebhookEventScalarWhereInput[]
    id?: StringFilter<"WebhookEvent"> | string
    tenantId?: StringNullableFilter<"WebhookEvent"> | string | null
    eventType?: StringFilter<"WebhookEvent"> | string
    payload?: StringFilter<"WebhookEvent"> | string
    status?: StringFilter<"WebhookEvent"> | string
    error?: StringNullableFilter<"WebhookEvent"> | string | null
    createdAt?: DateTimeFilter<"WebhookEvent"> | Date | string
    processedAt?: DateTimeNullableFilter<"WebhookEvent"> | Date | string | null
  }

  export type TenantCreateWithoutUsersInput = {
    id?: string
    name: string
    address?: string | null
    phone?: string | null
    adminUserId?: string | null
    timezone?: string
    plan?: string
    billingContact?: string | null
    status?: string
    settings?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    santri?: SantriCreateNestedManyWithoutTenantInput
    wali?: WaliCreateNestedManyWithoutTenantInput
    izin?: IzinCreateNestedManyWithoutTenantInput
    catatanHarian?: CatatanHarianCreateNestedManyWithoutTenantInput
    pengumuman?: PengumumanCreateNestedManyWithoutTenantInput
    invoices?: InvoiceCreateNestedManyWithoutTenantInput
    pelanggaran?: PelanggaranCreateNestedManyWithoutTenantInput
    pembinaan?: PembinaanCreateNestedManyWithoutTenantInput
    kunjungan?: KunjunganCreateNestedManyWithoutTenantInput
    healthRecords?: HealthRecordCreateNestedManyWithoutTenantInput
    auditLogs?: AuditLogCreateNestedManyWithoutTenantInput
    notifications?: NotificationCreateNestedManyWithoutTenantInput
    webhookEvents?: WebhookEventCreateNestedManyWithoutTenantInput
  }

  export type TenantUncheckedCreateWithoutUsersInput = {
    id?: string
    name: string
    address?: string | null
    phone?: string | null
    adminUserId?: string | null
    timezone?: string
    plan?: string
    billingContact?: string | null
    status?: string
    settings?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    santri?: SantriUncheckedCreateNestedManyWithoutTenantInput
    wali?: WaliUncheckedCreateNestedManyWithoutTenantInput
    izin?: IzinUncheckedCreateNestedManyWithoutTenantInput
    catatanHarian?: CatatanHarianUncheckedCreateNestedManyWithoutTenantInput
    pengumuman?: PengumumanUncheckedCreateNestedManyWithoutTenantInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutTenantInput
    pelanggaran?: PelanggaranUncheckedCreateNestedManyWithoutTenantInput
    pembinaan?: PembinaanUncheckedCreateNestedManyWithoutTenantInput
    kunjungan?: KunjunganUncheckedCreateNestedManyWithoutTenantInput
    healthRecords?: HealthRecordUncheckedCreateNestedManyWithoutTenantInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutTenantInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutTenantInput
    webhookEvents?: WebhookEventUncheckedCreateNestedManyWithoutTenantInput
  }

  export type TenantCreateOrConnectWithoutUsersInput = {
    where: TenantWhereUniqueInput
    create: XOR<TenantCreateWithoutUsersInput, TenantUncheckedCreateWithoutUsersInput>
  }

  export type RefreshTokenCreateWithoutUserInput = {
    id?: string
    token: string
    expiresAt: Date | string
    revoked?: boolean
    createdAt?: Date | string
  }

  export type RefreshTokenUncheckedCreateWithoutUserInput = {
    id?: string
    token: string
    expiresAt: Date | string
    revoked?: boolean
    createdAt?: Date | string
  }

  export type RefreshTokenCreateOrConnectWithoutUserInput = {
    where: RefreshTokenWhereUniqueInput
    create: XOR<RefreshTokenCreateWithoutUserInput, RefreshTokenUncheckedCreateWithoutUserInput>
  }

  export type RefreshTokenCreateManyUserInputEnvelope = {
    data: RefreshTokenCreateManyUserInput | RefreshTokenCreateManyUserInput[]
  }

  export type AuditLogCreateWithoutUserInput = {
    id?: string
    action: string
    entity: string
    entityId: string
    oldValue?: string | null
    newValue?: string | null
    ip?: string | null
    createdAt?: Date | string
    tenant?: TenantCreateNestedOneWithoutAuditLogsInput
  }

  export type AuditLogUncheckedCreateWithoutUserInput = {
    id?: string
    tenantId?: string | null
    action: string
    entity: string
    entityId: string
    oldValue?: string | null
    newValue?: string | null
    ip?: string | null
    createdAt?: Date | string
  }

  export type AuditLogCreateOrConnectWithoutUserInput = {
    where: AuditLogWhereUniqueInput
    create: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput>
  }

  export type AuditLogCreateManyUserInputEnvelope = {
    data: AuditLogCreateManyUserInput | AuditLogCreateManyUserInput[]
  }

  export type NotificationCreateWithoutUserInput = {
    id?: string
    type: string
    title: string
    body: string
    read?: boolean
    createdAt?: Date | string
    tenant: TenantCreateNestedOneWithoutNotificationsInput
  }

  export type NotificationUncheckedCreateWithoutUserInput = {
    id?: string
    tenantId: string
    type: string
    title: string
    body: string
    read?: boolean
    createdAt?: Date | string
  }

  export type NotificationCreateOrConnectWithoutUserInput = {
    where: NotificationWhereUniqueInput
    create: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput>
  }

  export type NotificationCreateManyUserInputEnvelope = {
    data: NotificationCreateManyUserInput | NotificationCreateManyUserInput[]
  }

  export type TenantUpsertWithoutUsersInput = {
    update: XOR<TenantUpdateWithoutUsersInput, TenantUncheckedUpdateWithoutUsersInput>
    create: XOR<TenantCreateWithoutUsersInput, TenantUncheckedCreateWithoutUsersInput>
    where?: TenantWhereInput
  }

  export type TenantUpdateToOneWithWhereWithoutUsersInput = {
    where?: TenantWhereInput
    data: XOR<TenantUpdateWithoutUsersInput, TenantUncheckedUpdateWithoutUsersInput>
  }

  export type TenantUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    adminUserId?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    plan?: StringFieldUpdateOperationsInput | string
    billingContact?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    settings?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    santri?: SantriUpdateManyWithoutTenantNestedInput
    wali?: WaliUpdateManyWithoutTenantNestedInput
    izin?: IzinUpdateManyWithoutTenantNestedInput
    catatanHarian?: CatatanHarianUpdateManyWithoutTenantNestedInput
    pengumuman?: PengumumanUpdateManyWithoutTenantNestedInput
    invoices?: InvoiceUpdateManyWithoutTenantNestedInput
    pelanggaran?: PelanggaranUpdateManyWithoutTenantNestedInput
    pembinaan?: PembinaanUpdateManyWithoutTenantNestedInput
    kunjungan?: KunjunganUpdateManyWithoutTenantNestedInput
    healthRecords?: HealthRecordUpdateManyWithoutTenantNestedInput
    auditLogs?: AuditLogUpdateManyWithoutTenantNestedInput
    notifications?: NotificationUpdateManyWithoutTenantNestedInput
    webhookEvents?: WebhookEventUpdateManyWithoutTenantNestedInput
  }

  export type TenantUncheckedUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    adminUserId?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    plan?: StringFieldUpdateOperationsInput | string
    billingContact?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    settings?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    santri?: SantriUncheckedUpdateManyWithoutTenantNestedInput
    wali?: WaliUncheckedUpdateManyWithoutTenantNestedInput
    izin?: IzinUncheckedUpdateManyWithoutTenantNestedInput
    catatanHarian?: CatatanHarianUncheckedUpdateManyWithoutTenantNestedInput
    pengumuman?: PengumumanUncheckedUpdateManyWithoutTenantNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutTenantNestedInput
    pelanggaran?: PelanggaranUncheckedUpdateManyWithoutTenantNestedInput
    pembinaan?: PembinaanUncheckedUpdateManyWithoutTenantNestedInput
    kunjungan?: KunjunganUncheckedUpdateManyWithoutTenantNestedInput
    healthRecords?: HealthRecordUncheckedUpdateManyWithoutTenantNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutTenantNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutTenantNestedInput
    webhookEvents?: WebhookEventUncheckedUpdateManyWithoutTenantNestedInput
  }

  export type RefreshTokenUpsertWithWhereUniqueWithoutUserInput = {
    where: RefreshTokenWhereUniqueInput
    update: XOR<RefreshTokenUpdateWithoutUserInput, RefreshTokenUncheckedUpdateWithoutUserInput>
    create: XOR<RefreshTokenCreateWithoutUserInput, RefreshTokenUncheckedCreateWithoutUserInput>
  }

  export type RefreshTokenUpdateWithWhereUniqueWithoutUserInput = {
    where: RefreshTokenWhereUniqueInput
    data: XOR<RefreshTokenUpdateWithoutUserInput, RefreshTokenUncheckedUpdateWithoutUserInput>
  }

  export type RefreshTokenUpdateManyWithWhereWithoutUserInput = {
    where: RefreshTokenScalarWhereInput
    data: XOR<RefreshTokenUpdateManyMutationInput, RefreshTokenUncheckedUpdateManyWithoutUserInput>
  }

  export type RefreshTokenScalarWhereInput = {
    AND?: RefreshTokenScalarWhereInput | RefreshTokenScalarWhereInput[]
    OR?: RefreshTokenScalarWhereInput[]
    NOT?: RefreshTokenScalarWhereInput | RefreshTokenScalarWhereInput[]
    id?: StringFilter<"RefreshToken"> | string
    userId?: StringFilter<"RefreshToken"> | string
    token?: StringFilter<"RefreshToken"> | string
    expiresAt?: DateTimeFilter<"RefreshToken"> | Date | string
    revoked?: BoolFilter<"RefreshToken"> | boolean
    createdAt?: DateTimeFilter<"RefreshToken"> | Date | string
  }

  export type AuditLogUpsertWithWhereUniqueWithoutUserInput = {
    where: AuditLogWhereUniqueInput
    update: XOR<AuditLogUpdateWithoutUserInput, AuditLogUncheckedUpdateWithoutUserInput>
    create: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput>
  }

  export type AuditLogUpdateWithWhereUniqueWithoutUserInput = {
    where: AuditLogWhereUniqueInput
    data: XOR<AuditLogUpdateWithoutUserInput, AuditLogUncheckedUpdateWithoutUserInput>
  }

  export type AuditLogUpdateManyWithWhereWithoutUserInput = {
    where: AuditLogScalarWhereInput
    data: XOR<AuditLogUpdateManyMutationInput, AuditLogUncheckedUpdateManyWithoutUserInput>
  }

  export type NotificationUpsertWithWhereUniqueWithoutUserInput = {
    where: NotificationWhereUniqueInput
    update: XOR<NotificationUpdateWithoutUserInput, NotificationUncheckedUpdateWithoutUserInput>
    create: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput>
  }

  export type NotificationUpdateWithWhereUniqueWithoutUserInput = {
    where: NotificationWhereUniqueInput
    data: XOR<NotificationUpdateWithoutUserInput, NotificationUncheckedUpdateWithoutUserInput>
  }

  export type NotificationUpdateManyWithWhereWithoutUserInput = {
    where: NotificationScalarWhereInput
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyWithoutUserInput>
  }

  export type UserCreateWithoutRefreshTokensInput = {
    id?: string
    email: string
    passwordHash: string
    role?: string
    name: string
    phone?: string | null
    isActive?: boolean
    lastLogin?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant?: TenantCreateNestedOneWithoutUsersInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutRefreshTokensInput = {
    id?: string
    tenantId?: string | null
    email: string
    passwordHash: string
    role?: string
    name: string
    phone?: string | null
    isActive?: boolean
    lastLogin?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutRefreshTokensInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutRefreshTokensInput, UserUncheckedCreateWithoutRefreshTokensInput>
  }

  export type UserUpsertWithoutRefreshTokensInput = {
    update: XOR<UserUpdateWithoutRefreshTokensInput, UserUncheckedUpdateWithoutRefreshTokensInput>
    create: XOR<UserCreateWithoutRefreshTokensInput, UserUncheckedCreateWithoutRefreshTokensInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutRefreshTokensInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutRefreshTokensInput, UserUncheckedUpdateWithoutRefreshTokensInput>
  }

  export type UserUpdateWithoutRefreshTokensInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneWithoutUsersNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutRefreshTokensInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
  }

  export type TenantCreateWithoutSantriInput = {
    id?: string
    name: string
    address?: string | null
    phone?: string | null
    adminUserId?: string | null
    timezone?: string
    plan?: string
    billingContact?: string | null
    status?: string
    settings?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutTenantInput
    wali?: WaliCreateNestedManyWithoutTenantInput
    izin?: IzinCreateNestedManyWithoutTenantInput
    catatanHarian?: CatatanHarianCreateNestedManyWithoutTenantInput
    pengumuman?: PengumumanCreateNestedManyWithoutTenantInput
    invoices?: InvoiceCreateNestedManyWithoutTenantInput
    pelanggaran?: PelanggaranCreateNestedManyWithoutTenantInput
    pembinaan?: PembinaanCreateNestedManyWithoutTenantInput
    kunjungan?: KunjunganCreateNestedManyWithoutTenantInput
    healthRecords?: HealthRecordCreateNestedManyWithoutTenantInput
    auditLogs?: AuditLogCreateNestedManyWithoutTenantInput
    notifications?: NotificationCreateNestedManyWithoutTenantInput
    webhookEvents?: WebhookEventCreateNestedManyWithoutTenantInput
  }

  export type TenantUncheckedCreateWithoutSantriInput = {
    id?: string
    name: string
    address?: string | null
    phone?: string | null
    adminUserId?: string | null
    timezone?: string
    plan?: string
    billingContact?: string | null
    status?: string
    settings?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutTenantInput
    wali?: WaliUncheckedCreateNestedManyWithoutTenantInput
    izin?: IzinUncheckedCreateNestedManyWithoutTenantInput
    catatanHarian?: CatatanHarianUncheckedCreateNestedManyWithoutTenantInput
    pengumuman?: PengumumanUncheckedCreateNestedManyWithoutTenantInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutTenantInput
    pelanggaran?: PelanggaranUncheckedCreateNestedManyWithoutTenantInput
    pembinaan?: PembinaanUncheckedCreateNestedManyWithoutTenantInput
    kunjungan?: KunjunganUncheckedCreateNestedManyWithoutTenantInput
    healthRecords?: HealthRecordUncheckedCreateNestedManyWithoutTenantInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutTenantInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutTenantInput
    webhookEvents?: WebhookEventUncheckedCreateNestedManyWithoutTenantInput
  }

  export type TenantCreateOrConnectWithoutSantriInput = {
    where: TenantWhereUniqueInput
    create: XOR<TenantCreateWithoutSantriInput, TenantUncheckedCreateWithoutSantriInput>
  }

  export type SantriWaliCreateWithoutSantriInput = {
    isPrimary?: boolean
    wali: WaliCreateNestedOneWithoutSantrisInput
  }

  export type SantriWaliUncheckedCreateWithoutSantriInput = {
    waliId: string
    isPrimary?: boolean
  }

  export type SantriWaliCreateOrConnectWithoutSantriInput = {
    where: SantriWaliWhereUniqueInput
    create: XOR<SantriWaliCreateWithoutSantriInput, SantriWaliUncheckedCreateWithoutSantriInput>
  }

  export type SantriWaliCreateManySantriInputEnvelope = {
    data: SantriWaliCreateManySantriInput | SantriWaliCreateManySantriInput[]
  }

  export type IzinCreateWithoutSantriInput = {
    id?: string
    type: string
    reason: string
    startAt: Date | string
    endAt: Date | string
    status?: string
    requestedBy: string
    approvedBy?: string | null
    approvedAt?: Date | string | null
    qrCodeData?: string | null
    checkoutAt?: Date | string | null
    checkoutBy?: string | null
    checkinAt?: Date | string | null
    checkinBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutIzinInput
  }

  export type IzinUncheckedCreateWithoutSantriInput = {
    id?: string
    tenantId: string
    type: string
    reason: string
    startAt: Date | string
    endAt: Date | string
    status?: string
    requestedBy: string
    approvedBy?: string | null
    approvedAt?: Date | string | null
    qrCodeData?: string | null
    checkoutAt?: Date | string | null
    checkoutBy?: string | null
    checkinAt?: Date | string | null
    checkinBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type IzinCreateOrConnectWithoutSantriInput = {
    where: IzinWhereUniqueInput
    create: XOR<IzinCreateWithoutSantriInput, IzinUncheckedCreateWithoutSantriInput>
  }

  export type IzinCreateManySantriInputEnvelope = {
    data: IzinCreateManySantriInput | IzinCreateManySantriInput[]
  }

  export type CatatanHarianCreateWithoutSantriInput = {
    id?: string
    authorId: string
    date?: Date | string
    content: string
    category: string
    attachments?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutCatatanHarianInput
  }

  export type CatatanHarianUncheckedCreateWithoutSantriInput = {
    id?: string
    tenantId: string
    authorId: string
    date?: Date | string
    content: string
    category: string
    attachments?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CatatanHarianCreateOrConnectWithoutSantriInput = {
    where: CatatanHarianWhereUniqueInput
    create: XOR<CatatanHarianCreateWithoutSantriInput, CatatanHarianUncheckedCreateWithoutSantriInput>
  }

  export type CatatanHarianCreateManySantriInputEnvelope = {
    data: CatatanHarianCreateManySantriInput | CatatanHarianCreateManySantriInput[]
  }

  export type InvoiceCreateWithoutSantriInput = {
    id?: string
    amountDue: number
    dueDate: Date | string
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutInvoicesInput
    lines?: InvoiceLineCreateNestedManyWithoutInvoiceInput
    payments?: PaymentCreateNestedManyWithoutInvoiceInput
  }

  export type InvoiceUncheckedCreateWithoutSantriInput = {
    id?: string
    tenantId: string
    amountDue: number
    dueDate: Date | string
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    lines?: InvoiceLineUncheckedCreateNestedManyWithoutInvoiceInput
    payments?: PaymentUncheckedCreateNestedManyWithoutInvoiceInput
  }

  export type InvoiceCreateOrConnectWithoutSantriInput = {
    where: InvoiceWhereUniqueInput
    create: XOR<InvoiceCreateWithoutSantriInput, InvoiceUncheckedCreateWithoutSantriInput>
  }

  export type InvoiceCreateManySantriInputEnvelope = {
    data: InvoiceCreateManySantriInput | InvoiceCreateManySantriInput[]
  }

  export type PelanggaranCreateWithoutSantriInput = {
    id?: string
    recordedBy: string
    category: string
    severity: number
    points?: number
    description: string
    date?: Date | string
    resolved?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutPelanggaranInput
  }

  export type PelanggaranUncheckedCreateWithoutSantriInput = {
    id?: string
    tenantId: string
    recordedBy: string
    category: string
    severity: number
    points?: number
    description: string
    date?: Date | string
    resolved?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PelanggaranCreateOrConnectWithoutSantriInput = {
    where: PelanggaranWhereUniqueInput
    create: XOR<PelanggaranCreateWithoutSantriInput, PelanggaranUncheckedCreateWithoutSantriInput>
  }

  export type PelanggaranCreateManySantriInputEnvelope = {
    data: PelanggaranCreateManySantriInput | PelanggaranCreateManySantriInput[]
  }

  export type PembinaanCreateWithoutSantriInput = {
    id?: string
    plan: string
    targetDate: Date | string
    status?: string
    assignedTo: string
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutPembinaanInput
  }

  export type PembinaanUncheckedCreateWithoutSantriInput = {
    id?: string
    tenantId: string
    plan: string
    targetDate: Date | string
    status?: string
    assignedTo: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PembinaanCreateOrConnectWithoutSantriInput = {
    where: PembinaanWhereUniqueInput
    create: XOR<PembinaanCreateWithoutSantriInput, PembinaanUncheckedCreateWithoutSantriInput>
  }

  export type PembinaanCreateManySantriInputEnvelope = {
    data: PembinaanCreateManySantriInput | PembinaanCreateManySantriInput[]
  }

  export type KunjunganCreateWithoutSantriInput = {
    id?: string
    scheduledAt: Date | string
    slot: string
    visitorLimit?: number
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutKunjunganInput
    tamu?: TamuCreateNestedManyWithoutKunjunganInput
  }

  export type KunjunganUncheckedCreateWithoutSantriInput = {
    id?: string
    tenantId: string
    scheduledAt: Date | string
    slot: string
    visitorLimit?: number
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    tamu?: TamuUncheckedCreateNestedManyWithoutKunjunganInput
  }

  export type KunjunganCreateOrConnectWithoutSantriInput = {
    where: KunjunganWhereUniqueInput
    create: XOR<KunjunganCreateWithoutSantriInput, KunjunganUncheckedCreateWithoutSantriInput>
  }

  export type KunjunganCreateManySantriInputEnvelope = {
    data: KunjunganCreateManySantriInput | KunjunganCreateManySantriInput[]
  }

  export type HealthRecordCreateWithoutSantriInput = {
    id?: string
    recordedBy: string
    symptoms: string
    diagnosis?: string | null
    actionTaken?: string | null
    referred?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutHealthRecordsInput
  }

  export type HealthRecordUncheckedCreateWithoutSantriInput = {
    id?: string
    tenantId: string
    recordedBy: string
    symptoms: string
    diagnosis?: string | null
    actionTaken?: string | null
    referred?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type HealthRecordCreateOrConnectWithoutSantriInput = {
    where: HealthRecordWhereUniqueInput
    create: XOR<HealthRecordCreateWithoutSantriInput, HealthRecordUncheckedCreateWithoutSantriInput>
  }

  export type HealthRecordCreateManySantriInputEnvelope = {
    data: HealthRecordCreateManySantriInput | HealthRecordCreateManySantriInput[]
  }

  export type MedicationCreateWithoutSantriInput = {
    id?: string
    medicineName: string
    dose: string
    schedule: string
    givenBy?: string | null
    givenAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MedicationUncheckedCreateWithoutSantriInput = {
    id?: string
    medicineName: string
    dose: string
    schedule: string
    givenBy?: string | null
    givenAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MedicationCreateOrConnectWithoutSantriInput = {
    where: MedicationWhereUniqueInput
    create: XOR<MedicationCreateWithoutSantriInput, MedicationUncheckedCreateWithoutSantriInput>
  }

  export type MedicationCreateManySantriInputEnvelope = {
    data: MedicationCreateManySantriInput | MedicationCreateManySantriInput[]
  }

  export type TenantUpsertWithoutSantriInput = {
    update: XOR<TenantUpdateWithoutSantriInput, TenantUncheckedUpdateWithoutSantriInput>
    create: XOR<TenantCreateWithoutSantriInput, TenantUncheckedCreateWithoutSantriInput>
    where?: TenantWhereInput
  }

  export type TenantUpdateToOneWithWhereWithoutSantriInput = {
    where?: TenantWhereInput
    data: XOR<TenantUpdateWithoutSantriInput, TenantUncheckedUpdateWithoutSantriInput>
  }

  export type TenantUpdateWithoutSantriInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    adminUserId?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    plan?: StringFieldUpdateOperationsInput | string
    billingContact?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    settings?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutTenantNestedInput
    wali?: WaliUpdateManyWithoutTenantNestedInput
    izin?: IzinUpdateManyWithoutTenantNestedInput
    catatanHarian?: CatatanHarianUpdateManyWithoutTenantNestedInput
    pengumuman?: PengumumanUpdateManyWithoutTenantNestedInput
    invoices?: InvoiceUpdateManyWithoutTenantNestedInput
    pelanggaran?: PelanggaranUpdateManyWithoutTenantNestedInput
    pembinaan?: PembinaanUpdateManyWithoutTenantNestedInput
    kunjungan?: KunjunganUpdateManyWithoutTenantNestedInput
    healthRecords?: HealthRecordUpdateManyWithoutTenantNestedInput
    auditLogs?: AuditLogUpdateManyWithoutTenantNestedInput
    notifications?: NotificationUpdateManyWithoutTenantNestedInput
    webhookEvents?: WebhookEventUpdateManyWithoutTenantNestedInput
  }

  export type TenantUncheckedUpdateWithoutSantriInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    adminUserId?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    plan?: StringFieldUpdateOperationsInput | string
    billingContact?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    settings?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutTenantNestedInput
    wali?: WaliUncheckedUpdateManyWithoutTenantNestedInput
    izin?: IzinUncheckedUpdateManyWithoutTenantNestedInput
    catatanHarian?: CatatanHarianUncheckedUpdateManyWithoutTenantNestedInput
    pengumuman?: PengumumanUncheckedUpdateManyWithoutTenantNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutTenantNestedInput
    pelanggaran?: PelanggaranUncheckedUpdateManyWithoutTenantNestedInput
    pembinaan?: PembinaanUncheckedUpdateManyWithoutTenantNestedInput
    kunjungan?: KunjunganUncheckedUpdateManyWithoutTenantNestedInput
    healthRecords?: HealthRecordUncheckedUpdateManyWithoutTenantNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutTenantNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutTenantNestedInput
    webhookEvents?: WebhookEventUncheckedUpdateManyWithoutTenantNestedInput
  }

  export type SantriWaliUpsertWithWhereUniqueWithoutSantriInput = {
    where: SantriWaliWhereUniqueInput
    update: XOR<SantriWaliUpdateWithoutSantriInput, SantriWaliUncheckedUpdateWithoutSantriInput>
    create: XOR<SantriWaliCreateWithoutSantriInput, SantriWaliUncheckedCreateWithoutSantriInput>
  }

  export type SantriWaliUpdateWithWhereUniqueWithoutSantriInput = {
    where: SantriWaliWhereUniqueInput
    data: XOR<SantriWaliUpdateWithoutSantriInput, SantriWaliUncheckedUpdateWithoutSantriInput>
  }

  export type SantriWaliUpdateManyWithWhereWithoutSantriInput = {
    where: SantriWaliScalarWhereInput
    data: XOR<SantriWaliUpdateManyMutationInput, SantriWaliUncheckedUpdateManyWithoutSantriInput>
  }

  export type SantriWaliScalarWhereInput = {
    AND?: SantriWaliScalarWhereInput | SantriWaliScalarWhereInput[]
    OR?: SantriWaliScalarWhereInput[]
    NOT?: SantriWaliScalarWhereInput | SantriWaliScalarWhereInput[]
    santriId?: StringFilter<"SantriWali"> | string
    waliId?: StringFilter<"SantriWali"> | string
    isPrimary?: BoolFilter<"SantriWali"> | boolean
  }

  export type IzinUpsertWithWhereUniqueWithoutSantriInput = {
    where: IzinWhereUniqueInput
    update: XOR<IzinUpdateWithoutSantriInput, IzinUncheckedUpdateWithoutSantriInput>
    create: XOR<IzinCreateWithoutSantriInput, IzinUncheckedCreateWithoutSantriInput>
  }

  export type IzinUpdateWithWhereUniqueWithoutSantriInput = {
    where: IzinWhereUniqueInput
    data: XOR<IzinUpdateWithoutSantriInput, IzinUncheckedUpdateWithoutSantriInput>
  }

  export type IzinUpdateManyWithWhereWithoutSantriInput = {
    where: IzinScalarWhereInput
    data: XOR<IzinUpdateManyMutationInput, IzinUncheckedUpdateManyWithoutSantriInput>
  }

  export type CatatanHarianUpsertWithWhereUniqueWithoutSantriInput = {
    where: CatatanHarianWhereUniqueInput
    update: XOR<CatatanHarianUpdateWithoutSantriInput, CatatanHarianUncheckedUpdateWithoutSantriInput>
    create: XOR<CatatanHarianCreateWithoutSantriInput, CatatanHarianUncheckedCreateWithoutSantriInput>
  }

  export type CatatanHarianUpdateWithWhereUniqueWithoutSantriInput = {
    where: CatatanHarianWhereUniqueInput
    data: XOR<CatatanHarianUpdateWithoutSantriInput, CatatanHarianUncheckedUpdateWithoutSantriInput>
  }

  export type CatatanHarianUpdateManyWithWhereWithoutSantriInput = {
    where: CatatanHarianScalarWhereInput
    data: XOR<CatatanHarianUpdateManyMutationInput, CatatanHarianUncheckedUpdateManyWithoutSantriInput>
  }

  export type InvoiceUpsertWithWhereUniqueWithoutSantriInput = {
    where: InvoiceWhereUniqueInput
    update: XOR<InvoiceUpdateWithoutSantriInput, InvoiceUncheckedUpdateWithoutSantriInput>
    create: XOR<InvoiceCreateWithoutSantriInput, InvoiceUncheckedCreateWithoutSantriInput>
  }

  export type InvoiceUpdateWithWhereUniqueWithoutSantriInput = {
    where: InvoiceWhereUniqueInput
    data: XOR<InvoiceUpdateWithoutSantriInput, InvoiceUncheckedUpdateWithoutSantriInput>
  }

  export type InvoiceUpdateManyWithWhereWithoutSantriInput = {
    where: InvoiceScalarWhereInput
    data: XOR<InvoiceUpdateManyMutationInput, InvoiceUncheckedUpdateManyWithoutSantriInput>
  }

  export type PelanggaranUpsertWithWhereUniqueWithoutSantriInput = {
    where: PelanggaranWhereUniqueInput
    update: XOR<PelanggaranUpdateWithoutSantriInput, PelanggaranUncheckedUpdateWithoutSantriInput>
    create: XOR<PelanggaranCreateWithoutSantriInput, PelanggaranUncheckedCreateWithoutSantriInput>
  }

  export type PelanggaranUpdateWithWhereUniqueWithoutSantriInput = {
    where: PelanggaranWhereUniqueInput
    data: XOR<PelanggaranUpdateWithoutSantriInput, PelanggaranUncheckedUpdateWithoutSantriInput>
  }

  export type PelanggaranUpdateManyWithWhereWithoutSantriInput = {
    where: PelanggaranScalarWhereInput
    data: XOR<PelanggaranUpdateManyMutationInput, PelanggaranUncheckedUpdateManyWithoutSantriInput>
  }

  export type PembinaanUpsertWithWhereUniqueWithoutSantriInput = {
    where: PembinaanWhereUniqueInput
    update: XOR<PembinaanUpdateWithoutSantriInput, PembinaanUncheckedUpdateWithoutSantriInput>
    create: XOR<PembinaanCreateWithoutSantriInput, PembinaanUncheckedCreateWithoutSantriInput>
  }

  export type PembinaanUpdateWithWhereUniqueWithoutSantriInput = {
    where: PembinaanWhereUniqueInput
    data: XOR<PembinaanUpdateWithoutSantriInput, PembinaanUncheckedUpdateWithoutSantriInput>
  }

  export type PembinaanUpdateManyWithWhereWithoutSantriInput = {
    where: PembinaanScalarWhereInput
    data: XOR<PembinaanUpdateManyMutationInput, PembinaanUncheckedUpdateManyWithoutSantriInput>
  }

  export type KunjunganUpsertWithWhereUniqueWithoutSantriInput = {
    where: KunjunganWhereUniqueInput
    update: XOR<KunjunganUpdateWithoutSantriInput, KunjunganUncheckedUpdateWithoutSantriInput>
    create: XOR<KunjunganCreateWithoutSantriInput, KunjunganUncheckedCreateWithoutSantriInput>
  }

  export type KunjunganUpdateWithWhereUniqueWithoutSantriInput = {
    where: KunjunganWhereUniqueInput
    data: XOR<KunjunganUpdateWithoutSantriInput, KunjunganUncheckedUpdateWithoutSantriInput>
  }

  export type KunjunganUpdateManyWithWhereWithoutSantriInput = {
    where: KunjunganScalarWhereInput
    data: XOR<KunjunganUpdateManyMutationInput, KunjunganUncheckedUpdateManyWithoutSantriInput>
  }

  export type HealthRecordUpsertWithWhereUniqueWithoutSantriInput = {
    where: HealthRecordWhereUniqueInput
    update: XOR<HealthRecordUpdateWithoutSantriInput, HealthRecordUncheckedUpdateWithoutSantriInput>
    create: XOR<HealthRecordCreateWithoutSantriInput, HealthRecordUncheckedCreateWithoutSantriInput>
  }

  export type HealthRecordUpdateWithWhereUniqueWithoutSantriInput = {
    where: HealthRecordWhereUniqueInput
    data: XOR<HealthRecordUpdateWithoutSantriInput, HealthRecordUncheckedUpdateWithoutSantriInput>
  }

  export type HealthRecordUpdateManyWithWhereWithoutSantriInput = {
    where: HealthRecordScalarWhereInput
    data: XOR<HealthRecordUpdateManyMutationInput, HealthRecordUncheckedUpdateManyWithoutSantriInput>
  }

  export type MedicationUpsertWithWhereUniqueWithoutSantriInput = {
    where: MedicationWhereUniqueInput
    update: XOR<MedicationUpdateWithoutSantriInput, MedicationUncheckedUpdateWithoutSantriInput>
    create: XOR<MedicationCreateWithoutSantriInput, MedicationUncheckedCreateWithoutSantriInput>
  }

  export type MedicationUpdateWithWhereUniqueWithoutSantriInput = {
    where: MedicationWhereUniqueInput
    data: XOR<MedicationUpdateWithoutSantriInput, MedicationUncheckedUpdateWithoutSantriInput>
  }

  export type MedicationUpdateManyWithWhereWithoutSantriInput = {
    where: MedicationScalarWhereInput
    data: XOR<MedicationUpdateManyMutationInput, MedicationUncheckedUpdateManyWithoutSantriInput>
  }

  export type MedicationScalarWhereInput = {
    AND?: MedicationScalarWhereInput | MedicationScalarWhereInput[]
    OR?: MedicationScalarWhereInput[]
    NOT?: MedicationScalarWhereInput | MedicationScalarWhereInput[]
    id?: StringFilter<"Medication"> | string
    santriId?: StringFilter<"Medication"> | string
    medicineName?: StringFilter<"Medication"> | string
    dose?: StringFilter<"Medication"> | string
    schedule?: StringFilter<"Medication"> | string
    givenBy?: StringNullableFilter<"Medication"> | string | null
    givenAt?: DateTimeNullableFilter<"Medication"> | Date | string | null
    createdAt?: DateTimeFilter<"Medication"> | Date | string
    updatedAt?: DateTimeFilter<"Medication"> | Date | string
  }

  export type TenantCreateWithoutWaliInput = {
    id?: string
    name: string
    address?: string | null
    phone?: string | null
    adminUserId?: string | null
    timezone?: string
    plan?: string
    billingContact?: string | null
    status?: string
    settings?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutTenantInput
    santri?: SantriCreateNestedManyWithoutTenantInput
    izin?: IzinCreateNestedManyWithoutTenantInput
    catatanHarian?: CatatanHarianCreateNestedManyWithoutTenantInput
    pengumuman?: PengumumanCreateNestedManyWithoutTenantInput
    invoices?: InvoiceCreateNestedManyWithoutTenantInput
    pelanggaran?: PelanggaranCreateNestedManyWithoutTenantInput
    pembinaan?: PembinaanCreateNestedManyWithoutTenantInput
    kunjungan?: KunjunganCreateNestedManyWithoutTenantInput
    healthRecords?: HealthRecordCreateNestedManyWithoutTenantInput
    auditLogs?: AuditLogCreateNestedManyWithoutTenantInput
    notifications?: NotificationCreateNestedManyWithoutTenantInput
    webhookEvents?: WebhookEventCreateNestedManyWithoutTenantInput
  }

  export type TenantUncheckedCreateWithoutWaliInput = {
    id?: string
    name: string
    address?: string | null
    phone?: string | null
    adminUserId?: string | null
    timezone?: string
    plan?: string
    billingContact?: string | null
    status?: string
    settings?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutTenantInput
    santri?: SantriUncheckedCreateNestedManyWithoutTenantInput
    izin?: IzinUncheckedCreateNestedManyWithoutTenantInput
    catatanHarian?: CatatanHarianUncheckedCreateNestedManyWithoutTenantInput
    pengumuman?: PengumumanUncheckedCreateNestedManyWithoutTenantInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutTenantInput
    pelanggaran?: PelanggaranUncheckedCreateNestedManyWithoutTenantInput
    pembinaan?: PembinaanUncheckedCreateNestedManyWithoutTenantInput
    kunjungan?: KunjunganUncheckedCreateNestedManyWithoutTenantInput
    healthRecords?: HealthRecordUncheckedCreateNestedManyWithoutTenantInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutTenantInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutTenantInput
    webhookEvents?: WebhookEventUncheckedCreateNestedManyWithoutTenantInput
  }

  export type TenantCreateOrConnectWithoutWaliInput = {
    where: TenantWhereUniqueInput
    create: XOR<TenantCreateWithoutWaliInput, TenantUncheckedCreateWithoutWaliInput>
  }

  export type SantriWaliCreateWithoutWaliInput = {
    isPrimary?: boolean
    santri: SantriCreateNestedOneWithoutWalisInput
  }

  export type SantriWaliUncheckedCreateWithoutWaliInput = {
    santriId: string
    isPrimary?: boolean
  }

  export type SantriWaliCreateOrConnectWithoutWaliInput = {
    where: SantriWaliWhereUniqueInput
    create: XOR<SantriWaliCreateWithoutWaliInput, SantriWaliUncheckedCreateWithoutWaliInput>
  }

  export type SantriWaliCreateManyWaliInputEnvelope = {
    data: SantriWaliCreateManyWaliInput | SantriWaliCreateManyWaliInput[]
  }

  export type TenantUpsertWithoutWaliInput = {
    update: XOR<TenantUpdateWithoutWaliInput, TenantUncheckedUpdateWithoutWaliInput>
    create: XOR<TenantCreateWithoutWaliInput, TenantUncheckedCreateWithoutWaliInput>
    where?: TenantWhereInput
  }

  export type TenantUpdateToOneWithWhereWithoutWaliInput = {
    where?: TenantWhereInput
    data: XOR<TenantUpdateWithoutWaliInput, TenantUncheckedUpdateWithoutWaliInput>
  }

  export type TenantUpdateWithoutWaliInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    adminUserId?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    plan?: StringFieldUpdateOperationsInput | string
    billingContact?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    settings?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutTenantNestedInput
    santri?: SantriUpdateManyWithoutTenantNestedInput
    izin?: IzinUpdateManyWithoutTenantNestedInput
    catatanHarian?: CatatanHarianUpdateManyWithoutTenantNestedInput
    pengumuman?: PengumumanUpdateManyWithoutTenantNestedInput
    invoices?: InvoiceUpdateManyWithoutTenantNestedInput
    pelanggaran?: PelanggaranUpdateManyWithoutTenantNestedInput
    pembinaan?: PembinaanUpdateManyWithoutTenantNestedInput
    kunjungan?: KunjunganUpdateManyWithoutTenantNestedInput
    healthRecords?: HealthRecordUpdateManyWithoutTenantNestedInput
    auditLogs?: AuditLogUpdateManyWithoutTenantNestedInput
    notifications?: NotificationUpdateManyWithoutTenantNestedInput
    webhookEvents?: WebhookEventUpdateManyWithoutTenantNestedInput
  }

  export type TenantUncheckedUpdateWithoutWaliInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    adminUserId?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    plan?: StringFieldUpdateOperationsInput | string
    billingContact?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    settings?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutTenantNestedInput
    santri?: SantriUncheckedUpdateManyWithoutTenantNestedInput
    izin?: IzinUncheckedUpdateManyWithoutTenantNestedInput
    catatanHarian?: CatatanHarianUncheckedUpdateManyWithoutTenantNestedInput
    pengumuman?: PengumumanUncheckedUpdateManyWithoutTenantNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutTenantNestedInput
    pelanggaran?: PelanggaranUncheckedUpdateManyWithoutTenantNestedInput
    pembinaan?: PembinaanUncheckedUpdateManyWithoutTenantNestedInput
    kunjungan?: KunjunganUncheckedUpdateManyWithoutTenantNestedInput
    healthRecords?: HealthRecordUncheckedUpdateManyWithoutTenantNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutTenantNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutTenantNestedInput
    webhookEvents?: WebhookEventUncheckedUpdateManyWithoutTenantNestedInput
  }

  export type SantriWaliUpsertWithWhereUniqueWithoutWaliInput = {
    where: SantriWaliWhereUniqueInput
    update: XOR<SantriWaliUpdateWithoutWaliInput, SantriWaliUncheckedUpdateWithoutWaliInput>
    create: XOR<SantriWaliCreateWithoutWaliInput, SantriWaliUncheckedCreateWithoutWaliInput>
  }

  export type SantriWaliUpdateWithWhereUniqueWithoutWaliInput = {
    where: SantriWaliWhereUniqueInput
    data: XOR<SantriWaliUpdateWithoutWaliInput, SantriWaliUncheckedUpdateWithoutWaliInput>
  }

  export type SantriWaliUpdateManyWithWhereWithoutWaliInput = {
    where: SantriWaliScalarWhereInput
    data: XOR<SantriWaliUpdateManyMutationInput, SantriWaliUncheckedUpdateManyWithoutWaliInput>
  }

  export type SantriCreateWithoutWalisInput = {
    id?: string
    nisn?: string | null
    name: string
    gender: string
    dob?: Date | string | null
    kelas?: string | null
    room?: string | null
    contact?: string | null
    address?: string | null
    photo?: string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutSantriInput
    izin?: IzinCreateNestedManyWithoutSantriInput
    catatanHarian?: CatatanHarianCreateNestedManyWithoutSantriInput
    invoices?: InvoiceCreateNestedManyWithoutSantriInput
    pelanggaran?: PelanggaranCreateNestedManyWithoutSantriInput
    pembinaan?: PembinaanCreateNestedManyWithoutSantriInput
    kunjungan?: KunjunganCreateNestedManyWithoutSantriInput
    healthRecords?: HealthRecordCreateNestedManyWithoutSantriInput
    medications?: MedicationCreateNestedManyWithoutSantriInput
  }

  export type SantriUncheckedCreateWithoutWalisInput = {
    id?: string
    tenantId: string
    nisn?: string | null
    name: string
    gender: string
    dob?: Date | string | null
    kelas?: string | null
    room?: string | null
    contact?: string | null
    address?: string | null
    photo?: string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    izin?: IzinUncheckedCreateNestedManyWithoutSantriInput
    catatanHarian?: CatatanHarianUncheckedCreateNestedManyWithoutSantriInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutSantriInput
    pelanggaran?: PelanggaranUncheckedCreateNestedManyWithoutSantriInput
    pembinaan?: PembinaanUncheckedCreateNestedManyWithoutSantriInput
    kunjungan?: KunjunganUncheckedCreateNestedManyWithoutSantriInput
    healthRecords?: HealthRecordUncheckedCreateNestedManyWithoutSantriInput
    medications?: MedicationUncheckedCreateNestedManyWithoutSantriInput
  }

  export type SantriCreateOrConnectWithoutWalisInput = {
    where: SantriWhereUniqueInput
    create: XOR<SantriCreateWithoutWalisInput, SantriUncheckedCreateWithoutWalisInput>
  }

  export type WaliCreateWithoutSantrisInput = {
    id?: string
    name: string
    relation: string
    phone: string
    email?: string | null
    address?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutWaliInput
  }

  export type WaliUncheckedCreateWithoutSantrisInput = {
    id?: string
    tenantId: string
    name: string
    relation: string
    phone: string
    email?: string | null
    address?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WaliCreateOrConnectWithoutSantrisInput = {
    where: WaliWhereUniqueInput
    create: XOR<WaliCreateWithoutSantrisInput, WaliUncheckedCreateWithoutSantrisInput>
  }

  export type SantriUpsertWithoutWalisInput = {
    update: XOR<SantriUpdateWithoutWalisInput, SantriUncheckedUpdateWithoutWalisInput>
    create: XOR<SantriCreateWithoutWalisInput, SantriUncheckedCreateWithoutWalisInput>
    where?: SantriWhereInput
  }

  export type SantriUpdateToOneWithWhereWithoutWalisInput = {
    where?: SantriWhereInput
    data: XOR<SantriUpdateWithoutWalisInput, SantriUncheckedUpdateWithoutWalisInput>
  }

  export type SantriUpdateWithoutWalisInput = {
    id?: StringFieldUpdateOperationsInput | string
    nisn?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    gender?: StringFieldUpdateOperationsInput | string
    dob?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    kelas?: NullableStringFieldUpdateOperationsInput | string | null
    room?: NullableStringFieldUpdateOperationsInput | string | null
    contact?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutSantriNestedInput
    izin?: IzinUpdateManyWithoutSantriNestedInput
    catatanHarian?: CatatanHarianUpdateManyWithoutSantriNestedInput
    invoices?: InvoiceUpdateManyWithoutSantriNestedInput
    pelanggaran?: PelanggaranUpdateManyWithoutSantriNestedInput
    pembinaan?: PembinaanUpdateManyWithoutSantriNestedInput
    kunjungan?: KunjunganUpdateManyWithoutSantriNestedInput
    healthRecords?: HealthRecordUpdateManyWithoutSantriNestedInput
    medications?: MedicationUpdateManyWithoutSantriNestedInput
  }

  export type SantriUncheckedUpdateWithoutWalisInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    nisn?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    gender?: StringFieldUpdateOperationsInput | string
    dob?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    kelas?: NullableStringFieldUpdateOperationsInput | string | null
    room?: NullableStringFieldUpdateOperationsInput | string | null
    contact?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    izin?: IzinUncheckedUpdateManyWithoutSantriNestedInput
    catatanHarian?: CatatanHarianUncheckedUpdateManyWithoutSantriNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutSantriNestedInput
    pelanggaran?: PelanggaranUncheckedUpdateManyWithoutSantriNestedInput
    pembinaan?: PembinaanUncheckedUpdateManyWithoutSantriNestedInput
    kunjungan?: KunjunganUncheckedUpdateManyWithoutSantriNestedInput
    healthRecords?: HealthRecordUncheckedUpdateManyWithoutSantriNestedInput
    medications?: MedicationUncheckedUpdateManyWithoutSantriNestedInput
  }

  export type WaliUpsertWithoutSantrisInput = {
    update: XOR<WaliUpdateWithoutSantrisInput, WaliUncheckedUpdateWithoutSantrisInput>
    create: XOR<WaliCreateWithoutSantrisInput, WaliUncheckedCreateWithoutSantrisInput>
    where?: WaliWhereInput
  }

  export type WaliUpdateToOneWithWhereWithoutSantrisInput = {
    where?: WaliWhereInput
    data: XOR<WaliUpdateWithoutSantrisInput, WaliUncheckedUpdateWithoutSantrisInput>
  }

  export type WaliUpdateWithoutSantrisInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    relation?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutWaliNestedInput
  }

  export type WaliUncheckedUpdateWithoutSantrisInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    relation?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TenantCreateWithoutIzinInput = {
    id?: string
    name: string
    address?: string | null
    phone?: string | null
    adminUserId?: string | null
    timezone?: string
    plan?: string
    billingContact?: string | null
    status?: string
    settings?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutTenantInput
    santri?: SantriCreateNestedManyWithoutTenantInput
    wali?: WaliCreateNestedManyWithoutTenantInput
    catatanHarian?: CatatanHarianCreateNestedManyWithoutTenantInput
    pengumuman?: PengumumanCreateNestedManyWithoutTenantInput
    invoices?: InvoiceCreateNestedManyWithoutTenantInput
    pelanggaran?: PelanggaranCreateNestedManyWithoutTenantInput
    pembinaan?: PembinaanCreateNestedManyWithoutTenantInput
    kunjungan?: KunjunganCreateNestedManyWithoutTenantInput
    healthRecords?: HealthRecordCreateNestedManyWithoutTenantInput
    auditLogs?: AuditLogCreateNestedManyWithoutTenantInput
    notifications?: NotificationCreateNestedManyWithoutTenantInput
    webhookEvents?: WebhookEventCreateNestedManyWithoutTenantInput
  }

  export type TenantUncheckedCreateWithoutIzinInput = {
    id?: string
    name: string
    address?: string | null
    phone?: string | null
    adminUserId?: string | null
    timezone?: string
    plan?: string
    billingContact?: string | null
    status?: string
    settings?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutTenantInput
    santri?: SantriUncheckedCreateNestedManyWithoutTenantInput
    wali?: WaliUncheckedCreateNestedManyWithoutTenantInput
    catatanHarian?: CatatanHarianUncheckedCreateNestedManyWithoutTenantInput
    pengumuman?: PengumumanUncheckedCreateNestedManyWithoutTenantInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutTenantInput
    pelanggaran?: PelanggaranUncheckedCreateNestedManyWithoutTenantInput
    pembinaan?: PembinaanUncheckedCreateNestedManyWithoutTenantInput
    kunjungan?: KunjunganUncheckedCreateNestedManyWithoutTenantInput
    healthRecords?: HealthRecordUncheckedCreateNestedManyWithoutTenantInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutTenantInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutTenantInput
    webhookEvents?: WebhookEventUncheckedCreateNestedManyWithoutTenantInput
  }

  export type TenantCreateOrConnectWithoutIzinInput = {
    where: TenantWhereUniqueInput
    create: XOR<TenantCreateWithoutIzinInput, TenantUncheckedCreateWithoutIzinInput>
  }

  export type SantriCreateWithoutIzinInput = {
    id?: string
    nisn?: string | null
    name: string
    gender: string
    dob?: Date | string | null
    kelas?: string | null
    room?: string | null
    contact?: string | null
    address?: string | null
    photo?: string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutSantriInput
    walis?: SantriWaliCreateNestedManyWithoutSantriInput
    catatanHarian?: CatatanHarianCreateNestedManyWithoutSantriInput
    invoices?: InvoiceCreateNestedManyWithoutSantriInput
    pelanggaran?: PelanggaranCreateNestedManyWithoutSantriInput
    pembinaan?: PembinaanCreateNestedManyWithoutSantriInput
    kunjungan?: KunjunganCreateNestedManyWithoutSantriInput
    healthRecords?: HealthRecordCreateNestedManyWithoutSantriInput
    medications?: MedicationCreateNestedManyWithoutSantriInput
  }

  export type SantriUncheckedCreateWithoutIzinInput = {
    id?: string
    tenantId: string
    nisn?: string | null
    name: string
    gender: string
    dob?: Date | string | null
    kelas?: string | null
    room?: string | null
    contact?: string | null
    address?: string | null
    photo?: string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    walis?: SantriWaliUncheckedCreateNestedManyWithoutSantriInput
    catatanHarian?: CatatanHarianUncheckedCreateNestedManyWithoutSantriInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutSantriInput
    pelanggaran?: PelanggaranUncheckedCreateNestedManyWithoutSantriInput
    pembinaan?: PembinaanUncheckedCreateNestedManyWithoutSantriInput
    kunjungan?: KunjunganUncheckedCreateNestedManyWithoutSantriInput
    healthRecords?: HealthRecordUncheckedCreateNestedManyWithoutSantriInput
    medications?: MedicationUncheckedCreateNestedManyWithoutSantriInput
  }

  export type SantriCreateOrConnectWithoutIzinInput = {
    where: SantriWhereUniqueInput
    create: XOR<SantriCreateWithoutIzinInput, SantriUncheckedCreateWithoutIzinInput>
  }

  export type TenantUpsertWithoutIzinInput = {
    update: XOR<TenantUpdateWithoutIzinInput, TenantUncheckedUpdateWithoutIzinInput>
    create: XOR<TenantCreateWithoutIzinInput, TenantUncheckedCreateWithoutIzinInput>
    where?: TenantWhereInput
  }

  export type TenantUpdateToOneWithWhereWithoutIzinInput = {
    where?: TenantWhereInput
    data: XOR<TenantUpdateWithoutIzinInput, TenantUncheckedUpdateWithoutIzinInput>
  }

  export type TenantUpdateWithoutIzinInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    adminUserId?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    plan?: StringFieldUpdateOperationsInput | string
    billingContact?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    settings?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutTenantNestedInput
    santri?: SantriUpdateManyWithoutTenantNestedInput
    wali?: WaliUpdateManyWithoutTenantNestedInput
    catatanHarian?: CatatanHarianUpdateManyWithoutTenantNestedInput
    pengumuman?: PengumumanUpdateManyWithoutTenantNestedInput
    invoices?: InvoiceUpdateManyWithoutTenantNestedInput
    pelanggaran?: PelanggaranUpdateManyWithoutTenantNestedInput
    pembinaan?: PembinaanUpdateManyWithoutTenantNestedInput
    kunjungan?: KunjunganUpdateManyWithoutTenantNestedInput
    healthRecords?: HealthRecordUpdateManyWithoutTenantNestedInput
    auditLogs?: AuditLogUpdateManyWithoutTenantNestedInput
    notifications?: NotificationUpdateManyWithoutTenantNestedInput
    webhookEvents?: WebhookEventUpdateManyWithoutTenantNestedInput
  }

  export type TenantUncheckedUpdateWithoutIzinInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    adminUserId?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    plan?: StringFieldUpdateOperationsInput | string
    billingContact?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    settings?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutTenantNestedInput
    santri?: SantriUncheckedUpdateManyWithoutTenantNestedInput
    wali?: WaliUncheckedUpdateManyWithoutTenantNestedInput
    catatanHarian?: CatatanHarianUncheckedUpdateManyWithoutTenantNestedInput
    pengumuman?: PengumumanUncheckedUpdateManyWithoutTenantNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutTenantNestedInput
    pelanggaran?: PelanggaranUncheckedUpdateManyWithoutTenantNestedInput
    pembinaan?: PembinaanUncheckedUpdateManyWithoutTenantNestedInput
    kunjungan?: KunjunganUncheckedUpdateManyWithoutTenantNestedInput
    healthRecords?: HealthRecordUncheckedUpdateManyWithoutTenantNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutTenantNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutTenantNestedInput
    webhookEvents?: WebhookEventUncheckedUpdateManyWithoutTenantNestedInput
  }

  export type SantriUpsertWithoutIzinInput = {
    update: XOR<SantriUpdateWithoutIzinInput, SantriUncheckedUpdateWithoutIzinInput>
    create: XOR<SantriCreateWithoutIzinInput, SantriUncheckedCreateWithoutIzinInput>
    where?: SantriWhereInput
  }

  export type SantriUpdateToOneWithWhereWithoutIzinInput = {
    where?: SantriWhereInput
    data: XOR<SantriUpdateWithoutIzinInput, SantriUncheckedUpdateWithoutIzinInput>
  }

  export type SantriUpdateWithoutIzinInput = {
    id?: StringFieldUpdateOperationsInput | string
    nisn?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    gender?: StringFieldUpdateOperationsInput | string
    dob?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    kelas?: NullableStringFieldUpdateOperationsInput | string | null
    room?: NullableStringFieldUpdateOperationsInput | string | null
    contact?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutSantriNestedInput
    walis?: SantriWaliUpdateManyWithoutSantriNestedInput
    catatanHarian?: CatatanHarianUpdateManyWithoutSantriNestedInput
    invoices?: InvoiceUpdateManyWithoutSantriNestedInput
    pelanggaran?: PelanggaranUpdateManyWithoutSantriNestedInput
    pembinaan?: PembinaanUpdateManyWithoutSantriNestedInput
    kunjungan?: KunjunganUpdateManyWithoutSantriNestedInput
    healthRecords?: HealthRecordUpdateManyWithoutSantriNestedInput
    medications?: MedicationUpdateManyWithoutSantriNestedInput
  }

  export type SantriUncheckedUpdateWithoutIzinInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    nisn?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    gender?: StringFieldUpdateOperationsInput | string
    dob?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    kelas?: NullableStringFieldUpdateOperationsInput | string | null
    room?: NullableStringFieldUpdateOperationsInput | string | null
    contact?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    walis?: SantriWaliUncheckedUpdateManyWithoutSantriNestedInput
    catatanHarian?: CatatanHarianUncheckedUpdateManyWithoutSantriNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutSantriNestedInput
    pelanggaran?: PelanggaranUncheckedUpdateManyWithoutSantriNestedInput
    pembinaan?: PembinaanUncheckedUpdateManyWithoutSantriNestedInput
    kunjungan?: KunjunganUncheckedUpdateManyWithoutSantriNestedInput
    healthRecords?: HealthRecordUncheckedUpdateManyWithoutSantriNestedInput
    medications?: MedicationUncheckedUpdateManyWithoutSantriNestedInput
  }

  export type TenantCreateWithoutCatatanHarianInput = {
    id?: string
    name: string
    address?: string | null
    phone?: string | null
    adminUserId?: string | null
    timezone?: string
    plan?: string
    billingContact?: string | null
    status?: string
    settings?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutTenantInput
    santri?: SantriCreateNestedManyWithoutTenantInput
    wali?: WaliCreateNestedManyWithoutTenantInput
    izin?: IzinCreateNestedManyWithoutTenantInput
    pengumuman?: PengumumanCreateNestedManyWithoutTenantInput
    invoices?: InvoiceCreateNestedManyWithoutTenantInput
    pelanggaran?: PelanggaranCreateNestedManyWithoutTenantInput
    pembinaan?: PembinaanCreateNestedManyWithoutTenantInput
    kunjungan?: KunjunganCreateNestedManyWithoutTenantInput
    healthRecords?: HealthRecordCreateNestedManyWithoutTenantInput
    auditLogs?: AuditLogCreateNestedManyWithoutTenantInput
    notifications?: NotificationCreateNestedManyWithoutTenantInput
    webhookEvents?: WebhookEventCreateNestedManyWithoutTenantInput
  }

  export type TenantUncheckedCreateWithoutCatatanHarianInput = {
    id?: string
    name: string
    address?: string | null
    phone?: string | null
    adminUserId?: string | null
    timezone?: string
    plan?: string
    billingContact?: string | null
    status?: string
    settings?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutTenantInput
    santri?: SantriUncheckedCreateNestedManyWithoutTenantInput
    wali?: WaliUncheckedCreateNestedManyWithoutTenantInput
    izin?: IzinUncheckedCreateNestedManyWithoutTenantInput
    pengumuman?: PengumumanUncheckedCreateNestedManyWithoutTenantInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutTenantInput
    pelanggaran?: PelanggaranUncheckedCreateNestedManyWithoutTenantInput
    pembinaan?: PembinaanUncheckedCreateNestedManyWithoutTenantInput
    kunjungan?: KunjunganUncheckedCreateNestedManyWithoutTenantInput
    healthRecords?: HealthRecordUncheckedCreateNestedManyWithoutTenantInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutTenantInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutTenantInput
    webhookEvents?: WebhookEventUncheckedCreateNestedManyWithoutTenantInput
  }

  export type TenantCreateOrConnectWithoutCatatanHarianInput = {
    where: TenantWhereUniqueInput
    create: XOR<TenantCreateWithoutCatatanHarianInput, TenantUncheckedCreateWithoutCatatanHarianInput>
  }

  export type SantriCreateWithoutCatatanHarianInput = {
    id?: string
    nisn?: string | null
    name: string
    gender: string
    dob?: Date | string | null
    kelas?: string | null
    room?: string | null
    contact?: string | null
    address?: string | null
    photo?: string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutSantriInput
    walis?: SantriWaliCreateNestedManyWithoutSantriInput
    izin?: IzinCreateNestedManyWithoutSantriInput
    invoices?: InvoiceCreateNestedManyWithoutSantriInput
    pelanggaran?: PelanggaranCreateNestedManyWithoutSantriInput
    pembinaan?: PembinaanCreateNestedManyWithoutSantriInput
    kunjungan?: KunjunganCreateNestedManyWithoutSantriInput
    healthRecords?: HealthRecordCreateNestedManyWithoutSantriInput
    medications?: MedicationCreateNestedManyWithoutSantriInput
  }

  export type SantriUncheckedCreateWithoutCatatanHarianInput = {
    id?: string
    tenantId: string
    nisn?: string | null
    name: string
    gender: string
    dob?: Date | string | null
    kelas?: string | null
    room?: string | null
    contact?: string | null
    address?: string | null
    photo?: string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    walis?: SantriWaliUncheckedCreateNestedManyWithoutSantriInput
    izin?: IzinUncheckedCreateNestedManyWithoutSantriInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutSantriInput
    pelanggaran?: PelanggaranUncheckedCreateNestedManyWithoutSantriInput
    pembinaan?: PembinaanUncheckedCreateNestedManyWithoutSantriInput
    kunjungan?: KunjunganUncheckedCreateNestedManyWithoutSantriInput
    healthRecords?: HealthRecordUncheckedCreateNestedManyWithoutSantriInput
    medications?: MedicationUncheckedCreateNestedManyWithoutSantriInput
  }

  export type SantriCreateOrConnectWithoutCatatanHarianInput = {
    where: SantriWhereUniqueInput
    create: XOR<SantriCreateWithoutCatatanHarianInput, SantriUncheckedCreateWithoutCatatanHarianInput>
  }

  export type TenantUpsertWithoutCatatanHarianInput = {
    update: XOR<TenantUpdateWithoutCatatanHarianInput, TenantUncheckedUpdateWithoutCatatanHarianInput>
    create: XOR<TenantCreateWithoutCatatanHarianInput, TenantUncheckedCreateWithoutCatatanHarianInput>
    where?: TenantWhereInput
  }

  export type TenantUpdateToOneWithWhereWithoutCatatanHarianInput = {
    where?: TenantWhereInput
    data: XOR<TenantUpdateWithoutCatatanHarianInput, TenantUncheckedUpdateWithoutCatatanHarianInput>
  }

  export type TenantUpdateWithoutCatatanHarianInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    adminUserId?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    plan?: StringFieldUpdateOperationsInput | string
    billingContact?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    settings?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutTenantNestedInput
    santri?: SantriUpdateManyWithoutTenantNestedInput
    wali?: WaliUpdateManyWithoutTenantNestedInput
    izin?: IzinUpdateManyWithoutTenantNestedInput
    pengumuman?: PengumumanUpdateManyWithoutTenantNestedInput
    invoices?: InvoiceUpdateManyWithoutTenantNestedInput
    pelanggaran?: PelanggaranUpdateManyWithoutTenantNestedInput
    pembinaan?: PembinaanUpdateManyWithoutTenantNestedInput
    kunjungan?: KunjunganUpdateManyWithoutTenantNestedInput
    healthRecords?: HealthRecordUpdateManyWithoutTenantNestedInput
    auditLogs?: AuditLogUpdateManyWithoutTenantNestedInput
    notifications?: NotificationUpdateManyWithoutTenantNestedInput
    webhookEvents?: WebhookEventUpdateManyWithoutTenantNestedInput
  }

  export type TenantUncheckedUpdateWithoutCatatanHarianInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    adminUserId?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    plan?: StringFieldUpdateOperationsInput | string
    billingContact?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    settings?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutTenantNestedInput
    santri?: SantriUncheckedUpdateManyWithoutTenantNestedInput
    wali?: WaliUncheckedUpdateManyWithoutTenantNestedInput
    izin?: IzinUncheckedUpdateManyWithoutTenantNestedInput
    pengumuman?: PengumumanUncheckedUpdateManyWithoutTenantNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutTenantNestedInput
    pelanggaran?: PelanggaranUncheckedUpdateManyWithoutTenantNestedInput
    pembinaan?: PembinaanUncheckedUpdateManyWithoutTenantNestedInput
    kunjungan?: KunjunganUncheckedUpdateManyWithoutTenantNestedInput
    healthRecords?: HealthRecordUncheckedUpdateManyWithoutTenantNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutTenantNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutTenantNestedInput
    webhookEvents?: WebhookEventUncheckedUpdateManyWithoutTenantNestedInput
  }

  export type SantriUpsertWithoutCatatanHarianInput = {
    update: XOR<SantriUpdateWithoutCatatanHarianInput, SantriUncheckedUpdateWithoutCatatanHarianInput>
    create: XOR<SantriCreateWithoutCatatanHarianInput, SantriUncheckedCreateWithoutCatatanHarianInput>
    where?: SantriWhereInput
  }

  export type SantriUpdateToOneWithWhereWithoutCatatanHarianInput = {
    where?: SantriWhereInput
    data: XOR<SantriUpdateWithoutCatatanHarianInput, SantriUncheckedUpdateWithoutCatatanHarianInput>
  }

  export type SantriUpdateWithoutCatatanHarianInput = {
    id?: StringFieldUpdateOperationsInput | string
    nisn?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    gender?: StringFieldUpdateOperationsInput | string
    dob?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    kelas?: NullableStringFieldUpdateOperationsInput | string | null
    room?: NullableStringFieldUpdateOperationsInput | string | null
    contact?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutSantriNestedInput
    walis?: SantriWaliUpdateManyWithoutSantriNestedInput
    izin?: IzinUpdateManyWithoutSantriNestedInput
    invoices?: InvoiceUpdateManyWithoutSantriNestedInput
    pelanggaran?: PelanggaranUpdateManyWithoutSantriNestedInput
    pembinaan?: PembinaanUpdateManyWithoutSantriNestedInput
    kunjungan?: KunjunganUpdateManyWithoutSantriNestedInput
    healthRecords?: HealthRecordUpdateManyWithoutSantriNestedInput
    medications?: MedicationUpdateManyWithoutSantriNestedInput
  }

  export type SantriUncheckedUpdateWithoutCatatanHarianInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    nisn?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    gender?: StringFieldUpdateOperationsInput | string
    dob?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    kelas?: NullableStringFieldUpdateOperationsInput | string | null
    room?: NullableStringFieldUpdateOperationsInput | string | null
    contact?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    walis?: SantriWaliUncheckedUpdateManyWithoutSantriNestedInput
    izin?: IzinUncheckedUpdateManyWithoutSantriNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutSantriNestedInput
    pelanggaran?: PelanggaranUncheckedUpdateManyWithoutSantriNestedInput
    pembinaan?: PembinaanUncheckedUpdateManyWithoutSantriNestedInput
    kunjungan?: KunjunganUncheckedUpdateManyWithoutSantriNestedInput
    healthRecords?: HealthRecordUncheckedUpdateManyWithoutSantriNestedInput
    medications?: MedicationUncheckedUpdateManyWithoutSantriNestedInput
  }

  export type TenantCreateWithoutPengumumanInput = {
    id?: string
    name: string
    address?: string | null
    phone?: string | null
    adminUserId?: string | null
    timezone?: string
    plan?: string
    billingContact?: string | null
    status?: string
    settings?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutTenantInput
    santri?: SantriCreateNestedManyWithoutTenantInput
    wali?: WaliCreateNestedManyWithoutTenantInput
    izin?: IzinCreateNestedManyWithoutTenantInput
    catatanHarian?: CatatanHarianCreateNestedManyWithoutTenantInput
    invoices?: InvoiceCreateNestedManyWithoutTenantInput
    pelanggaran?: PelanggaranCreateNestedManyWithoutTenantInput
    pembinaan?: PembinaanCreateNestedManyWithoutTenantInput
    kunjungan?: KunjunganCreateNestedManyWithoutTenantInput
    healthRecords?: HealthRecordCreateNestedManyWithoutTenantInput
    auditLogs?: AuditLogCreateNestedManyWithoutTenantInput
    notifications?: NotificationCreateNestedManyWithoutTenantInput
    webhookEvents?: WebhookEventCreateNestedManyWithoutTenantInput
  }

  export type TenantUncheckedCreateWithoutPengumumanInput = {
    id?: string
    name: string
    address?: string | null
    phone?: string | null
    adminUserId?: string | null
    timezone?: string
    plan?: string
    billingContact?: string | null
    status?: string
    settings?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutTenantInput
    santri?: SantriUncheckedCreateNestedManyWithoutTenantInput
    wali?: WaliUncheckedCreateNestedManyWithoutTenantInput
    izin?: IzinUncheckedCreateNestedManyWithoutTenantInput
    catatanHarian?: CatatanHarianUncheckedCreateNestedManyWithoutTenantInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutTenantInput
    pelanggaran?: PelanggaranUncheckedCreateNestedManyWithoutTenantInput
    pembinaan?: PembinaanUncheckedCreateNestedManyWithoutTenantInput
    kunjungan?: KunjunganUncheckedCreateNestedManyWithoutTenantInput
    healthRecords?: HealthRecordUncheckedCreateNestedManyWithoutTenantInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutTenantInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutTenantInput
    webhookEvents?: WebhookEventUncheckedCreateNestedManyWithoutTenantInput
  }

  export type TenantCreateOrConnectWithoutPengumumanInput = {
    where: TenantWhereUniqueInput
    create: XOR<TenantCreateWithoutPengumumanInput, TenantUncheckedCreateWithoutPengumumanInput>
  }

  export type TenantUpsertWithoutPengumumanInput = {
    update: XOR<TenantUpdateWithoutPengumumanInput, TenantUncheckedUpdateWithoutPengumumanInput>
    create: XOR<TenantCreateWithoutPengumumanInput, TenantUncheckedCreateWithoutPengumumanInput>
    where?: TenantWhereInput
  }

  export type TenantUpdateToOneWithWhereWithoutPengumumanInput = {
    where?: TenantWhereInput
    data: XOR<TenantUpdateWithoutPengumumanInput, TenantUncheckedUpdateWithoutPengumumanInput>
  }

  export type TenantUpdateWithoutPengumumanInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    adminUserId?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    plan?: StringFieldUpdateOperationsInput | string
    billingContact?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    settings?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutTenantNestedInput
    santri?: SantriUpdateManyWithoutTenantNestedInput
    wali?: WaliUpdateManyWithoutTenantNestedInput
    izin?: IzinUpdateManyWithoutTenantNestedInput
    catatanHarian?: CatatanHarianUpdateManyWithoutTenantNestedInput
    invoices?: InvoiceUpdateManyWithoutTenantNestedInput
    pelanggaran?: PelanggaranUpdateManyWithoutTenantNestedInput
    pembinaan?: PembinaanUpdateManyWithoutTenantNestedInput
    kunjungan?: KunjunganUpdateManyWithoutTenantNestedInput
    healthRecords?: HealthRecordUpdateManyWithoutTenantNestedInput
    auditLogs?: AuditLogUpdateManyWithoutTenantNestedInput
    notifications?: NotificationUpdateManyWithoutTenantNestedInput
    webhookEvents?: WebhookEventUpdateManyWithoutTenantNestedInput
  }

  export type TenantUncheckedUpdateWithoutPengumumanInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    adminUserId?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    plan?: StringFieldUpdateOperationsInput | string
    billingContact?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    settings?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutTenantNestedInput
    santri?: SantriUncheckedUpdateManyWithoutTenantNestedInput
    wali?: WaliUncheckedUpdateManyWithoutTenantNestedInput
    izin?: IzinUncheckedUpdateManyWithoutTenantNestedInput
    catatanHarian?: CatatanHarianUncheckedUpdateManyWithoutTenantNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutTenantNestedInput
    pelanggaran?: PelanggaranUncheckedUpdateManyWithoutTenantNestedInput
    pembinaan?: PembinaanUncheckedUpdateManyWithoutTenantNestedInput
    kunjungan?: KunjunganUncheckedUpdateManyWithoutTenantNestedInput
    healthRecords?: HealthRecordUncheckedUpdateManyWithoutTenantNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutTenantNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutTenantNestedInput
    webhookEvents?: WebhookEventUncheckedUpdateManyWithoutTenantNestedInput
  }

  export type TenantCreateWithoutInvoicesInput = {
    id?: string
    name: string
    address?: string | null
    phone?: string | null
    adminUserId?: string | null
    timezone?: string
    plan?: string
    billingContact?: string | null
    status?: string
    settings?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutTenantInput
    santri?: SantriCreateNestedManyWithoutTenantInput
    wali?: WaliCreateNestedManyWithoutTenantInput
    izin?: IzinCreateNestedManyWithoutTenantInput
    catatanHarian?: CatatanHarianCreateNestedManyWithoutTenantInput
    pengumuman?: PengumumanCreateNestedManyWithoutTenantInput
    pelanggaran?: PelanggaranCreateNestedManyWithoutTenantInput
    pembinaan?: PembinaanCreateNestedManyWithoutTenantInput
    kunjungan?: KunjunganCreateNestedManyWithoutTenantInput
    healthRecords?: HealthRecordCreateNestedManyWithoutTenantInput
    auditLogs?: AuditLogCreateNestedManyWithoutTenantInput
    notifications?: NotificationCreateNestedManyWithoutTenantInput
    webhookEvents?: WebhookEventCreateNestedManyWithoutTenantInput
  }

  export type TenantUncheckedCreateWithoutInvoicesInput = {
    id?: string
    name: string
    address?: string | null
    phone?: string | null
    adminUserId?: string | null
    timezone?: string
    plan?: string
    billingContact?: string | null
    status?: string
    settings?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutTenantInput
    santri?: SantriUncheckedCreateNestedManyWithoutTenantInput
    wali?: WaliUncheckedCreateNestedManyWithoutTenantInput
    izin?: IzinUncheckedCreateNestedManyWithoutTenantInput
    catatanHarian?: CatatanHarianUncheckedCreateNestedManyWithoutTenantInput
    pengumuman?: PengumumanUncheckedCreateNestedManyWithoutTenantInput
    pelanggaran?: PelanggaranUncheckedCreateNestedManyWithoutTenantInput
    pembinaan?: PembinaanUncheckedCreateNestedManyWithoutTenantInput
    kunjungan?: KunjunganUncheckedCreateNestedManyWithoutTenantInput
    healthRecords?: HealthRecordUncheckedCreateNestedManyWithoutTenantInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutTenantInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutTenantInput
    webhookEvents?: WebhookEventUncheckedCreateNestedManyWithoutTenantInput
  }

  export type TenantCreateOrConnectWithoutInvoicesInput = {
    where: TenantWhereUniqueInput
    create: XOR<TenantCreateWithoutInvoicesInput, TenantUncheckedCreateWithoutInvoicesInput>
  }

  export type SantriCreateWithoutInvoicesInput = {
    id?: string
    nisn?: string | null
    name: string
    gender: string
    dob?: Date | string | null
    kelas?: string | null
    room?: string | null
    contact?: string | null
    address?: string | null
    photo?: string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutSantriInput
    walis?: SantriWaliCreateNestedManyWithoutSantriInput
    izin?: IzinCreateNestedManyWithoutSantriInput
    catatanHarian?: CatatanHarianCreateNestedManyWithoutSantriInput
    pelanggaran?: PelanggaranCreateNestedManyWithoutSantriInput
    pembinaan?: PembinaanCreateNestedManyWithoutSantriInput
    kunjungan?: KunjunganCreateNestedManyWithoutSantriInput
    healthRecords?: HealthRecordCreateNestedManyWithoutSantriInput
    medications?: MedicationCreateNestedManyWithoutSantriInput
  }

  export type SantriUncheckedCreateWithoutInvoicesInput = {
    id?: string
    tenantId: string
    nisn?: string | null
    name: string
    gender: string
    dob?: Date | string | null
    kelas?: string | null
    room?: string | null
    contact?: string | null
    address?: string | null
    photo?: string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    walis?: SantriWaliUncheckedCreateNestedManyWithoutSantriInput
    izin?: IzinUncheckedCreateNestedManyWithoutSantriInput
    catatanHarian?: CatatanHarianUncheckedCreateNestedManyWithoutSantriInput
    pelanggaran?: PelanggaranUncheckedCreateNestedManyWithoutSantriInput
    pembinaan?: PembinaanUncheckedCreateNestedManyWithoutSantriInput
    kunjungan?: KunjunganUncheckedCreateNestedManyWithoutSantriInput
    healthRecords?: HealthRecordUncheckedCreateNestedManyWithoutSantriInput
    medications?: MedicationUncheckedCreateNestedManyWithoutSantriInput
  }

  export type SantriCreateOrConnectWithoutInvoicesInput = {
    where: SantriWhereUniqueInput
    create: XOR<SantriCreateWithoutInvoicesInput, SantriUncheckedCreateWithoutInvoicesInput>
  }

  export type InvoiceLineCreateWithoutInvoiceInput = {
    id?: string
    description: string
    amount: number
    type: string
  }

  export type InvoiceLineUncheckedCreateWithoutInvoiceInput = {
    id?: string
    description: string
    amount: number
    type: string
  }

  export type InvoiceLineCreateOrConnectWithoutInvoiceInput = {
    where: InvoiceLineWhereUniqueInput
    create: XOR<InvoiceLineCreateWithoutInvoiceInput, InvoiceLineUncheckedCreateWithoutInvoiceInput>
  }

  export type InvoiceLineCreateManyInvoiceInputEnvelope = {
    data: InvoiceLineCreateManyInvoiceInput | InvoiceLineCreateManyInvoiceInput[]
  }

  export type PaymentCreateWithoutInvoiceInput = {
    id?: string
    method: string
    amount: number
    status?: string
    transactionRef?: string | null
    paidAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PaymentUncheckedCreateWithoutInvoiceInput = {
    id?: string
    method: string
    amount: number
    status?: string
    transactionRef?: string | null
    paidAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PaymentCreateOrConnectWithoutInvoiceInput = {
    where: PaymentWhereUniqueInput
    create: XOR<PaymentCreateWithoutInvoiceInput, PaymentUncheckedCreateWithoutInvoiceInput>
  }

  export type PaymentCreateManyInvoiceInputEnvelope = {
    data: PaymentCreateManyInvoiceInput | PaymentCreateManyInvoiceInput[]
  }

  export type TenantUpsertWithoutInvoicesInput = {
    update: XOR<TenantUpdateWithoutInvoicesInput, TenantUncheckedUpdateWithoutInvoicesInput>
    create: XOR<TenantCreateWithoutInvoicesInput, TenantUncheckedCreateWithoutInvoicesInput>
    where?: TenantWhereInput
  }

  export type TenantUpdateToOneWithWhereWithoutInvoicesInput = {
    where?: TenantWhereInput
    data: XOR<TenantUpdateWithoutInvoicesInput, TenantUncheckedUpdateWithoutInvoicesInput>
  }

  export type TenantUpdateWithoutInvoicesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    adminUserId?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    plan?: StringFieldUpdateOperationsInput | string
    billingContact?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    settings?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutTenantNestedInput
    santri?: SantriUpdateManyWithoutTenantNestedInput
    wali?: WaliUpdateManyWithoutTenantNestedInput
    izin?: IzinUpdateManyWithoutTenantNestedInput
    catatanHarian?: CatatanHarianUpdateManyWithoutTenantNestedInput
    pengumuman?: PengumumanUpdateManyWithoutTenantNestedInput
    pelanggaran?: PelanggaranUpdateManyWithoutTenantNestedInput
    pembinaan?: PembinaanUpdateManyWithoutTenantNestedInput
    kunjungan?: KunjunganUpdateManyWithoutTenantNestedInput
    healthRecords?: HealthRecordUpdateManyWithoutTenantNestedInput
    auditLogs?: AuditLogUpdateManyWithoutTenantNestedInput
    notifications?: NotificationUpdateManyWithoutTenantNestedInput
    webhookEvents?: WebhookEventUpdateManyWithoutTenantNestedInput
  }

  export type TenantUncheckedUpdateWithoutInvoicesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    adminUserId?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    plan?: StringFieldUpdateOperationsInput | string
    billingContact?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    settings?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutTenantNestedInput
    santri?: SantriUncheckedUpdateManyWithoutTenantNestedInput
    wali?: WaliUncheckedUpdateManyWithoutTenantNestedInput
    izin?: IzinUncheckedUpdateManyWithoutTenantNestedInput
    catatanHarian?: CatatanHarianUncheckedUpdateManyWithoutTenantNestedInput
    pengumuman?: PengumumanUncheckedUpdateManyWithoutTenantNestedInput
    pelanggaran?: PelanggaranUncheckedUpdateManyWithoutTenantNestedInput
    pembinaan?: PembinaanUncheckedUpdateManyWithoutTenantNestedInput
    kunjungan?: KunjunganUncheckedUpdateManyWithoutTenantNestedInput
    healthRecords?: HealthRecordUncheckedUpdateManyWithoutTenantNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutTenantNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutTenantNestedInput
    webhookEvents?: WebhookEventUncheckedUpdateManyWithoutTenantNestedInput
  }

  export type SantriUpsertWithoutInvoicesInput = {
    update: XOR<SantriUpdateWithoutInvoicesInput, SantriUncheckedUpdateWithoutInvoicesInput>
    create: XOR<SantriCreateWithoutInvoicesInput, SantriUncheckedCreateWithoutInvoicesInput>
    where?: SantriWhereInput
  }

  export type SantriUpdateToOneWithWhereWithoutInvoicesInput = {
    where?: SantriWhereInput
    data: XOR<SantriUpdateWithoutInvoicesInput, SantriUncheckedUpdateWithoutInvoicesInput>
  }

  export type SantriUpdateWithoutInvoicesInput = {
    id?: StringFieldUpdateOperationsInput | string
    nisn?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    gender?: StringFieldUpdateOperationsInput | string
    dob?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    kelas?: NullableStringFieldUpdateOperationsInput | string | null
    room?: NullableStringFieldUpdateOperationsInput | string | null
    contact?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutSantriNestedInput
    walis?: SantriWaliUpdateManyWithoutSantriNestedInput
    izin?: IzinUpdateManyWithoutSantriNestedInput
    catatanHarian?: CatatanHarianUpdateManyWithoutSantriNestedInput
    pelanggaran?: PelanggaranUpdateManyWithoutSantriNestedInput
    pembinaan?: PembinaanUpdateManyWithoutSantriNestedInput
    kunjungan?: KunjunganUpdateManyWithoutSantriNestedInput
    healthRecords?: HealthRecordUpdateManyWithoutSantriNestedInput
    medications?: MedicationUpdateManyWithoutSantriNestedInput
  }

  export type SantriUncheckedUpdateWithoutInvoicesInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    nisn?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    gender?: StringFieldUpdateOperationsInput | string
    dob?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    kelas?: NullableStringFieldUpdateOperationsInput | string | null
    room?: NullableStringFieldUpdateOperationsInput | string | null
    contact?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    walis?: SantriWaliUncheckedUpdateManyWithoutSantriNestedInput
    izin?: IzinUncheckedUpdateManyWithoutSantriNestedInput
    catatanHarian?: CatatanHarianUncheckedUpdateManyWithoutSantriNestedInput
    pelanggaran?: PelanggaranUncheckedUpdateManyWithoutSantriNestedInput
    pembinaan?: PembinaanUncheckedUpdateManyWithoutSantriNestedInput
    kunjungan?: KunjunganUncheckedUpdateManyWithoutSantriNestedInput
    healthRecords?: HealthRecordUncheckedUpdateManyWithoutSantriNestedInput
    medications?: MedicationUncheckedUpdateManyWithoutSantriNestedInput
  }

  export type InvoiceLineUpsertWithWhereUniqueWithoutInvoiceInput = {
    where: InvoiceLineWhereUniqueInput
    update: XOR<InvoiceLineUpdateWithoutInvoiceInput, InvoiceLineUncheckedUpdateWithoutInvoiceInput>
    create: XOR<InvoiceLineCreateWithoutInvoiceInput, InvoiceLineUncheckedCreateWithoutInvoiceInput>
  }

  export type InvoiceLineUpdateWithWhereUniqueWithoutInvoiceInput = {
    where: InvoiceLineWhereUniqueInput
    data: XOR<InvoiceLineUpdateWithoutInvoiceInput, InvoiceLineUncheckedUpdateWithoutInvoiceInput>
  }

  export type InvoiceLineUpdateManyWithWhereWithoutInvoiceInput = {
    where: InvoiceLineScalarWhereInput
    data: XOR<InvoiceLineUpdateManyMutationInput, InvoiceLineUncheckedUpdateManyWithoutInvoiceInput>
  }

  export type InvoiceLineScalarWhereInput = {
    AND?: InvoiceLineScalarWhereInput | InvoiceLineScalarWhereInput[]
    OR?: InvoiceLineScalarWhereInput[]
    NOT?: InvoiceLineScalarWhereInput | InvoiceLineScalarWhereInput[]
    id?: StringFilter<"InvoiceLine"> | string
    invoiceId?: StringFilter<"InvoiceLine"> | string
    description?: StringFilter<"InvoiceLine"> | string
    amount?: FloatFilter<"InvoiceLine"> | number
    type?: StringFilter<"InvoiceLine"> | string
  }

  export type PaymentUpsertWithWhereUniqueWithoutInvoiceInput = {
    where: PaymentWhereUniqueInput
    update: XOR<PaymentUpdateWithoutInvoiceInput, PaymentUncheckedUpdateWithoutInvoiceInput>
    create: XOR<PaymentCreateWithoutInvoiceInput, PaymentUncheckedCreateWithoutInvoiceInput>
  }

  export type PaymentUpdateWithWhereUniqueWithoutInvoiceInput = {
    where: PaymentWhereUniqueInput
    data: XOR<PaymentUpdateWithoutInvoiceInput, PaymentUncheckedUpdateWithoutInvoiceInput>
  }

  export type PaymentUpdateManyWithWhereWithoutInvoiceInput = {
    where: PaymentScalarWhereInput
    data: XOR<PaymentUpdateManyMutationInput, PaymentUncheckedUpdateManyWithoutInvoiceInput>
  }

  export type PaymentScalarWhereInput = {
    AND?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
    OR?: PaymentScalarWhereInput[]
    NOT?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
    id?: StringFilter<"Payment"> | string
    invoiceId?: StringFilter<"Payment"> | string
    method?: StringFilter<"Payment"> | string
    amount?: FloatFilter<"Payment"> | number
    status?: StringFilter<"Payment"> | string
    transactionRef?: StringNullableFilter<"Payment"> | string | null
    paidAt?: DateTimeNullableFilter<"Payment"> | Date | string | null
    createdAt?: DateTimeFilter<"Payment"> | Date | string
    updatedAt?: DateTimeFilter<"Payment"> | Date | string
  }

  export type InvoiceCreateWithoutLinesInput = {
    id?: string
    amountDue: number
    dueDate: Date | string
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutInvoicesInput
    santri: SantriCreateNestedOneWithoutInvoicesInput
    payments?: PaymentCreateNestedManyWithoutInvoiceInput
  }

  export type InvoiceUncheckedCreateWithoutLinesInput = {
    id?: string
    tenantId: string
    santriId: string
    amountDue: number
    dueDate: Date | string
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    payments?: PaymentUncheckedCreateNestedManyWithoutInvoiceInput
  }

  export type InvoiceCreateOrConnectWithoutLinesInput = {
    where: InvoiceWhereUniqueInput
    create: XOR<InvoiceCreateWithoutLinesInput, InvoiceUncheckedCreateWithoutLinesInput>
  }

  export type InvoiceUpsertWithoutLinesInput = {
    update: XOR<InvoiceUpdateWithoutLinesInput, InvoiceUncheckedUpdateWithoutLinesInput>
    create: XOR<InvoiceCreateWithoutLinesInput, InvoiceUncheckedCreateWithoutLinesInput>
    where?: InvoiceWhereInput
  }

  export type InvoiceUpdateToOneWithWhereWithoutLinesInput = {
    where?: InvoiceWhereInput
    data: XOR<InvoiceUpdateWithoutLinesInput, InvoiceUncheckedUpdateWithoutLinesInput>
  }

  export type InvoiceUpdateWithoutLinesInput = {
    id?: StringFieldUpdateOperationsInput | string
    amountDue?: FloatFieldUpdateOperationsInput | number
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutInvoicesNestedInput
    santri?: SantriUpdateOneRequiredWithoutInvoicesNestedInput
    payments?: PaymentUpdateManyWithoutInvoiceNestedInput
  }

  export type InvoiceUncheckedUpdateWithoutLinesInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    santriId?: StringFieldUpdateOperationsInput | string
    amountDue?: FloatFieldUpdateOperationsInput | number
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    payments?: PaymentUncheckedUpdateManyWithoutInvoiceNestedInput
  }

  export type InvoiceCreateWithoutPaymentsInput = {
    id?: string
    amountDue: number
    dueDate: Date | string
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutInvoicesInput
    santri: SantriCreateNestedOneWithoutInvoicesInput
    lines?: InvoiceLineCreateNestedManyWithoutInvoiceInput
  }

  export type InvoiceUncheckedCreateWithoutPaymentsInput = {
    id?: string
    tenantId: string
    santriId: string
    amountDue: number
    dueDate: Date | string
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    lines?: InvoiceLineUncheckedCreateNestedManyWithoutInvoiceInput
  }

  export type InvoiceCreateOrConnectWithoutPaymentsInput = {
    where: InvoiceWhereUniqueInput
    create: XOR<InvoiceCreateWithoutPaymentsInput, InvoiceUncheckedCreateWithoutPaymentsInput>
  }

  export type InvoiceUpsertWithoutPaymentsInput = {
    update: XOR<InvoiceUpdateWithoutPaymentsInput, InvoiceUncheckedUpdateWithoutPaymentsInput>
    create: XOR<InvoiceCreateWithoutPaymentsInput, InvoiceUncheckedCreateWithoutPaymentsInput>
    where?: InvoiceWhereInput
  }

  export type InvoiceUpdateToOneWithWhereWithoutPaymentsInput = {
    where?: InvoiceWhereInput
    data: XOR<InvoiceUpdateWithoutPaymentsInput, InvoiceUncheckedUpdateWithoutPaymentsInput>
  }

  export type InvoiceUpdateWithoutPaymentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    amountDue?: FloatFieldUpdateOperationsInput | number
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutInvoicesNestedInput
    santri?: SantriUpdateOneRequiredWithoutInvoicesNestedInput
    lines?: InvoiceLineUpdateManyWithoutInvoiceNestedInput
  }

  export type InvoiceUncheckedUpdateWithoutPaymentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    santriId?: StringFieldUpdateOperationsInput | string
    amountDue?: FloatFieldUpdateOperationsInput | number
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lines?: InvoiceLineUncheckedUpdateManyWithoutInvoiceNestedInput
  }

  export type TenantCreateWithoutPelanggaranInput = {
    id?: string
    name: string
    address?: string | null
    phone?: string | null
    adminUserId?: string | null
    timezone?: string
    plan?: string
    billingContact?: string | null
    status?: string
    settings?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutTenantInput
    santri?: SantriCreateNestedManyWithoutTenantInput
    wali?: WaliCreateNestedManyWithoutTenantInput
    izin?: IzinCreateNestedManyWithoutTenantInput
    catatanHarian?: CatatanHarianCreateNestedManyWithoutTenantInput
    pengumuman?: PengumumanCreateNestedManyWithoutTenantInput
    invoices?: InvoiceCreateNestedManyWithoutTenantInput
    pembinaan?: PembinaanCreateNestedManyWithoutTenantInput
    kunjungan?: KunjunganCreateNestedManyWithoutTenantInput
    healthRecords?: HealthRecordCreateNestedManyWithoutTenantInput
    auditLogs?: AuditLogCreateNestedManyWithoutTenantInput
    notifications?: NotificationCreateNestedManyWithoutTenantInput
    webhookEvents?: WebhookEventCreateNestedManyWithoutTenantInput
  }

  export type TenantUncheckedCreateWithoutPelanggaranInput = {
    id?: string
    name: string
    address?: string | null
    phone?: string | null
    adminUserId?: string | null
    timezone?: string
    plan?: string
    billingContact?: string | null
    status?: string
    settings?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutTenantInput
    santri?: SantriUncheckedCreateNestedManyWithoutTenantInput
    wali?: WaliUncheckedCreateNestedManyWithoutTenantInput
    izin?: IzinUncheckedCreateNestedManyWithoutTenantInput
    catatanHarian?: CatatanHarianUncheckedCreateNestedManyWithoutTenantInput
    pengumuman?: PengumumanUncheckedCreateNestedManyWithoutTenantInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutTenantInput
    pembinaan?: PembinaanUncheckedCreateNestedManyWithoutTenantInput
    kunjungan?: KunjunganUncheckedCreateNestedManyWithoutTenantInput
    healthRecords?: HealthRecordUncheckedCreateNestedManyWithoutTenantInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutTenantInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutTenantInput
    webhookEvents?: WebhookEventUncheckedCreateNestedManyWithoutTenantInput
  }

  export type TenantCreateOrConnectWithoutPelanggaranInput = {
    where: TenantWhereUniqueInput
    create: XOR<TenantCreateWithoutPelanggaranInput, TenantUncheckedCreateWithoutPelanggaranInput>
  }

  export type SantriCreateWithoutPelanggaranInput = {
    id?: string
    nisn?: string | null
    name: string
    gender: string
    dob?: Date | string | null
    kelas?: string | null
    room?: string | null
    contact?: string | null
    address?: string | null
    photo?: string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutSantriInput
    walis?: SantriWaliCreateNestedManyWithoutSantriInput
    izin?: IzinCreateNestedManyWithoutSantriInput
    catatanHarian?: CatatanHarianCreateNestedManyWithoutSantriInput
    invoices?: InvoiceCreateNestedManyWithoutSantriInput
    pembinaan?: PembinaanCreateNestedManyWithoutSantriInput
    kunjungan?: KunjunganCreateNestedManyWithoutSantriInput
    healthRecords?: HealthRecordCreateNestedManyWithoutSantriInput
    medications?: MedicationCreateNestedManyWithoutSantriInput
  }

  export type SantriUncheckedCreateWithoutPelanggaranInput = {
    id?: string
    tenantId: string
    nisn?: string | null
    name: string
    gender: string
    dob?: Date | string | null
    kelas?: string | null
    room?: string | null
    contact?: string | null
    address?: string | null
    photo?: string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    walis?: SantriWaliUncheckedCreateNestedManyWithoutSantriInput
    izin?: IzinUncheckedCreateNestedManyWithoutSantriInput
    catatanHarian?: CatatanHarianUncheckedCreateNestedManyWithoutSantriInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutSantriInput
    pembinaan?: PembinaanUncheckedCreateNestedManyWithoutSantriInput
    kunjungan?: KunjunganUncheckedCreateNestedManyWithoutSantriInput
    healthRecords?: HealthRecordUncheckedCreateNestedManyWithoutSantriInput
    medications?: MedicationUncheckedCreateNestedManyWithoutSantriInput
  }

  export type SantriCreateOrConnectWithoutPelanggaranInput = {
    where: SantriWhereUniqueInput
    create: XOR<SantriCreateWithoutPelanggaranInput, SantriUncheckedCreateWithoutPelanggaranInput>
  }

  export type TenantUpsertWithoutPelanggaranInput = {
    update: XOR<TenantUpdateWithoutPelanggaranInput, TenantUncheckedUpdateWithoutPelanggaranInput>
    create: XOR<TenantCreateWithoutPelanggaranInput, TenantUncheckedCreateWithoutPelanggaranInput>
    where?: TenantWhereInput
  }

  export type TenantUpdateToOneWithWhereWithoutPelanggaranInput = {
    where?: TenantWhereInput
    data: XOR<TenantUpdateWithoutPelanggaranInput, TenantUncheckedUpdateWithoutPelanggaranInput>
  }

  export type TenantUpdateWithoutPelanggaranInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    adminUserId?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    plan?: StringFieldUpdateOperationsInput | string
    billingContact?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    settings?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutTenantNestedInput
    santri?: SantriUpdateManyWithoutTenantNestedInput
    wali?: WaliUpdateManyWithoutTenantNestedInput
    izin?: IzinUpdateManyWithoutTenantNestedInput
    catatanHarian?: CatatanHarianUpdateManyWithoutTenantNestedInput
    pengumuman?: PengumumanUpdateManyWithoutTenantNestedInput
    invoices?: InvoiceUpdateManyWithoutTenantNestedInput
    pembinaan?: PembinaanUpdateManyWithoutTenantNestedInput
    kunjungan?: KunjunganUpdateManyWithoutTenantNestedInput
    healthRecords?: HealthRecordUpdateManyWithoutTenantNestedInput
    auditLogs?: AuditLogUpdateManyWithoutTenantNestedInput
    notifications?: NotificationUpdateManyWithoutTenantNestedInput
    webhookEvents?: WebhookEventUpdateManyWithoutTenantNestedInput
  }

  export type TenantUncheckedUpdateWithoutPelanggaranInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    adminUserId?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    plan?: StringFieldUpdateOperationsInput | string
    billingContact?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    settings?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutTenantNestedInput
    santri?: SantriUncheckedUpdateManyWithoutTenantNestedInput
    wali?: WaliUncheckedUpdateManyWithoutTenantNestedInput
    izin?: IzinUncheckedUpdateManyWithoutTenantNestedInput
    catatanHarian?: CatatanHarianUncheckedUpdateManyWithoutTenantNestedInput
    pengumuman?: PengumumanUncheckedUpdateManyWithoutTenantNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutTenantNestedInput
    pembinaan?: PembinaanUncheckedUpdateManyWithoutTenantNestedInput
    kunjungan?: KunjunganUncheckedUpdateManyWithoutTenantNestedInput
    healthRecords?: HealthRecordUncheckedUpdateManyWithoutTenantNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutTenantNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutTenantNestedInput
    webhookEvents?: WebhookEventUncheckedUpdateManyWithoutTenantNestedInput
  }

  export type SantriUpsertWithoutPelanggaranInput = {
    update: XOR<SantriUpdateWithoutPelanggaranInput, SantriUncheckedUpdateWithoutPelanggaranInput>
    create: XOR<SantriCreateWithoutPelanggaranInput, SantriUncheckedCreateWithoutPelanggaranInput>
    where?: SantriWhereInput
  }

  export type SantriUpdateToOneWithWhereWithoutPelanggaranInput = {
    where?: SantriWhereInput
    data: XOR<SantriUpdateWithoutPelanggaranInput, SantriUncheckedUpdateWithoutPelanggaranInput>
  }

  export type SantriUpdateWithoutPelanggaranInput = {
    id?: StringFieldUpdateOperationsInput | string
    nisn?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    gender?: StringFieldUpdateOperationsInput | string
    dob?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    kelas?: NullableStringFieldUpdateOperationsInput | string | null
    room?: NullableStringFieldUpdateOperationsInput | string | null
    contact?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutSantriNestedInput
    walis?: SantriWaliUpdateManyWithoutSantriNestedInput
    izin?: IzinUpdateManyWithoutSantriNestedInput
    catatanHarian?: CatatanHarianUpdateManyWithoutSantriNestedInput
    invoices?: InvoiceUpdateManyWithoutSantriNestedInput
    pembinaan?: PembinaanUpdateManyWithoutSantriNestedInput
    kunjungan?: KunjunganUpdateManyWithoutSantriNestedInput
    healthRecords?: HealthRecordUpdateManyWithoutSantriNestedInput
    medications?: MedicationUpdateManyWithoutSantriNestedInput
  }

  export type SantriUncheckedUpdateWithoutPelanggaranInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    nisn?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    gender?: StringFieldUpdateOperationsInput | string
    dob?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    kelas?: NullableStringFieldUpdateOperationsInput | string | null
    room?: NullableStringFieldUpdateOperationsInput | string | null
    contact?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    walis?: SantriWaliUncheckedUpdateManyWithoutSantriNestedInput
    izin?: IzinUncheckedUpdateManyWithoutSantriNestedInput
    catatanHarian?: CatatanHarianUncheckedUpdateManyWithoutSantriNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutSantriNestedInput
    pembinaan?: PembinaanUncheckedUpdateManyWithoutSantriNestedInput
    kunjungan?: KunjunganUncheckedUpdateManyWithoutSantriNestedInput
    healthRecords?: HealthRecordUncheckedUpdateManyWithoutSantriNestedInput
    medications?: MedicationUncheckedUpdateManyWithoutSantriNestedInput
  }

  export type TenantCreateWithoutPembinaanInput = {
    id?: string
    name: string
    address?: string | null
    phone?: string | null
    adminUserId?: string | null
    timezone?: string
    plan?: string
    billingContact?: string | null
    status?: string
    settings?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutTenantInput
    santri?: SantriCreateNestedManyWithoutTenantInput
    wali?: WaliCreateNestedManyWithoutTenantInput
    izin?: IzinCreateNestedManyWithoutTenantInput
    catatanHarian?: CatatanHarianCreateNestedManyWithoutTenantInput
    pengumuman?: PengumumanCreateNestedManyWithoutTenantInput
    invoices?: InvoiceCreateNestedManyWithoutTenantInput
    pelanggaran?: PelanggaranCreateNestedManyWithoutTenantInput
    kunjungan?: KunjunganCreateNestedManyWithoutTenantInput
    healthRecords?: HealthRecordCreateNestedManyWithoutTenantInput
    auditLogs?: AuditLogCreateNestedManyWithoutTenantInput
    notifications?: NotificationCreateNestedManyWithoutTenantInput
    webhookEvents?: WebhookEventCreateNestedManyWithoutTenantInput
  }

  export type TenantUncheckedCreateWithoutPembinaanInput = {
    id?: string
    name: string
    address?: string | null
    phone?: string | null
    adminUserId?: string | null
    timezone?: string
    plan?: string
    billingContact?: string | null
    status?: string
    settings?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutTenantInput
    santri?: SantriUncheckedCreateNestedManyWithoutTenantInput
    wali?: WaliUncheckedCreateNestedManyWithoutTenantInput
    izin?: IzinUncheckedCreateNestedManyWithoutTenantInput
    catatanHarian?: CatatanHarianUncheckedCreateNestedManyWithoutTenantInput
    pengumuman?: PengumumanUncheckedCreateNestedManyWithoutTenantInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutTenantInput
    pelanggaran?: PelanggaranUncheckedCreateNestedManyWithoutTenantInput
    kunjungan?: KunjunganUncheckedCreateNestedManyWithoutTenantInput
    healthRecords?: HealthRecordUncheckedCreateNestedManyWithoutTenantInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutTenantInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutTenantInput
    webhookEvents?: WebhookEventUncheckedCreateNestedManyWithoutTenantInput
  }

  export type TenantCreateOrConnectWithoutPembinaanInput = {
    where: TenantWhereUniqueInput
    create: XOR<TenantCreateWithoutPembinaanInput, TenantUncheckedCreateWithoutPembinaanInput>
  }

  export type SantriCreateWithoutPembinaanInput = {
    id?: string
    nisn?: string | null
    name: string
    gender: string
    dob?: Date | string | null
    kelas?: string | null
    room?: string | null
    contact?: string | null
    address?: string | null
    photo?: string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutSantriInput
    walis?: SantriWaliCreateNestedManyWithoutSantriInput
    izin?: IzinCreateNestedManyWithoutSantriInput
    catatanHarian?: CatatanHarianCreateNestedManyWithoutSantriInput
    invoices?: InvoiceCreateNestedManyWithoutSantriInput
    pelanggaran?: PelanggaranCreateNestedManyWithoutSantriInput
    kunjungan?: KunjunganCreateNestedManyWithoutSantriInput
    healthRecords?: HealthRecordCreateNestedManyWithoutSantriInput
    medications?: MedicationCreateNestedManyWithoutSantriInput
  }

  export type SantriUncheckedCreateWithoutPembinaanInput = {
    id?: string
    tenantId: string
    nisn?: string | null
    name: string
    gender: string
    dob?: Date | string | null
    kelas?: string | null
    room?: string | null
    contact?: string | null
    address?: string | null
    photo?: string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    walis?: SantriWaliUncheckedCreateNestedManyWithoutSantriInput
    izin?: IzinUncheckedCreateNestedManyWithoutSantriInput
    catatanHarian?: CatatanHarianUncheckedCreateNestedManyWithoutSantriInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutSantriInput
    pelanggaran?: PelanggaranUncheckedCreateNestedManyWithoutSantriInput
    kunjungan?: KunjunganUncheckedCreateNestedManyWithoutSantriInput
    healthRecords?: HealthRecordUncheckedCreateNestedManyWithoutSantriInput
    medications?: MedicationUncheckedCreateNestedManyWithoutSantriInput
  }

  export type SantriCreateOrConnectWithoutPembinaanInput = {
    where: SantriWhereUniqueInput
    create: XOR<SantriCreateWithoutPembinaanInput, SantriUncheckedCreateWithoutPembinaanInput>
  }

  export type TenantUpsertWithoutPembinaanInput = {
    update: XOR<TenantUpdateWithoutPembinaanInput, TenantUncheckedUpdateWithoutPembinaanInput>
    create: XOR<TenantCreateWithoutPembinaanInput, TenantUncheckedCreateWithoutPembinaanInput>
    where?: TenantWhereInput
  }

  export type TenantUpdateToOneWithWhereWithoutPembinaanInput = {
    where?: TenantWhereInput
    data: XOR<TenantUpdateWithoutPembinaanInput, TenantUncheckedUpdateWithoutPembinaanInput>
  }

  export type TenantUpdateWithoutPembinaanInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    adminUserId?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    plan?: StringFieldUpdateOperationsInput | string
    billingContact?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    settings?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutTenantNestedInput
    santri?: SantriUpdateManyWithoutTenantNestedInput
    wali?: WaliUpdateManyWithoutTenantNestedInput
    izin?: IzinUpdateManyWithoutTenantNestedInput
    catatanHarian?: CatatanHarianUpdateManyWithoutTenantNestedInput
    pengumuman?: PengumumanUpdateManyWithoutTenantNestedInput
    invoices?: InvoiceUpdateManyWithoutTenantNestedInput
    pelanggaran?: PelanggaranUpdateManyWithoutTenantNestedInput
    kunjungan?: KunjunganUpdateManyWithoutTenantNestedInput
    healthRecords?: HealthRecordUpdateManyWithoutTenantNestedInput
    auditLogs?: AuditLogUpdateManyWithoutTenantNestedInput
    notifications?: NotificationUpdateManyWithoutTenantNestedInput
    webhookEvents?: WebhookEventUpdateManyWithoutTenantNestedInput
  }

  export type TenantUncheckedUpdateWithoutPembinaanInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    adminUserId?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    plan?: StringFieldUpdateOperationsInput | string
    billingContact?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    settings?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutTenantNestedInput
    santri?: SantriUncheckedUpdateManyWithoutTenantNestedInput
    wali?: WaliUncheckedUpdateManyWithoutTenantNestedInput
    izin?: IzinUncheckedUpdateManyWithoutTenantNestedInput
    catatanHarian?: CatatanHarianUncheckedUpdateManyWithoutTenantNestedInput
    pengumuman?: PengumumanUncheckedUpdateManyWithoutTenantNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutTenantNestedInput
    pelanggaran?: PelanggaranUncheckedUpdateManyWithoutTenantNestedInput
    kunjungan?: KunjunganUncheckedUpdateManyWithoutTenantNestedInput
    healthRecords?: HealthRecordUncheckedUpdateManyWithoutTenantNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutTenantNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutTenantNestedInput
    webhookEvents?: WebhookEventUncheckedUpdateManyWithoutTenantNestedInput
  }

  export type SantriUpsertWithoutPembinaanInput = {
    update: XOR<SantriUpdateWithoutPembinaanInput, SantriUncheckedUpdateWithoutPembinaanInput>
    create: XOR<SantriCreateWithoutPembinaanInput, SantriUncheckedCreateWithoutPembinaanInput>
    where?: SantriWhereInput
  }

  export type SantriUpdateToOneWithWhereWithoutPembinaanInput = {
    where?: SantriWhereInput
    data: XOR<SantriUpdateWithoutPembinaanInput, SantriUncheckedUpdateWithoutPembinaanInput>
  }

  export type SantriUpdateWithoutPembinaanInput = {
    id?: StringFieldUpdateOperationsInput | string
    nisn?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    gender?: StringFieldUpdateOperationsInput | string
    dob?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    kelas?: NullableStringFieldUpdateOperationsInput | string | null
    room?: NullableStringFieldUpdateOperationsInput | string | null
    contact?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutSantriNestedInput
    walis?: SantriWaliUpdateManyWithoutSantriNestedInput
    izin?: IzinUpdateManyWithoutSantriNestedInput
    catatanHarian?: CatatanHarianUpdateManyWithoutSantriNestedInput
    invoices?: InvoiceUpdateManyWithoutSantriNestedInput
    pelanggaran?: PelanggaranUpdateManyWithoutSantriNestedInput
    kunjungan?: KunjunganUpdateManyWithoutSantriNestedInput
    healthRecords?: HealthRecordUpdateManyWithoutSantriNestedInput
    medications?: MedicationUpdateManyWithoutSantriNestedInput
  }

  export type SantriUncheckedUpdateWithoutPembinaanInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    nisn?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    gender?: StringFieldUpdateOperationsInput | string
    dob?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    kelas?: NullableStringFieldUpdateOperationsInput | string | null
    room?: NullableStringFieldUpdateOperationsInput | string | null
    contact?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    walis?: SantriWaliUncheckedUpdateManyWithoutSantriNestedInput
    izin?: IzinUncheckedUpdateManyWithoutSantriNestedInput
    catatanHarian?: CatatanHarianUncheckedUpdateManyWithoutSantriNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutSantriNestedInput
    pelanggaran?: PelanggaranUncheckedUpdateManyWithoutSantriNestedInput
    kunjungan?: KunjunganUncheckedUpdateManyWithoutSantriNestedInput
    healthRecords?: HealthRecordUncheckedUpdateManyWithoutSantriNestedInput
    medications?: MedicationUncheckedUpdateManyWithoutSantriNestedInput
  }

  export type TenantCreateWithoutKunjunganInput = {
    id?: string
    name: string
    address?: string | null
    phone?: string | null
    adminUserId?: string | null
    timezone?: string
    plan?: string
    billingContact?: string | null
    status?: string
    settings?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutTenantInput
    santri?: SantriCreateNestedManyWithoutTenantInput
    wali?: WaliCreateNestedManyWithoutTenantInput
    izin?: IzinCreateNestedManyWithoutTenantInput
    catatanHarian?: CatatanHarianCreateNestedManyWithoutTenantInput
    pengumuman?: PengumumanCreateNestedManyWithoutTenantInput
    invoices?: InvoiceCreateNestedManyWithoutTenantInput
    pelanggaran?: PelanggaranCreateNestedManyWithoutTenantInput
    pembinaan?: PembinaanCreateNestedManyWithoutTenantInput
    healthRecords?: HealthRecordCreateNestedManyWithoutTenantInput
    auditLogs?: AuditLogCreateNestedManyWithoutTenantInput
    notifications?: NotificationCreateNestedManyWithoutTenantInput
    webhookEvents?: WebhookEventCreateNestedManyWithoutTenantInput
  }

  export type TenantUncheckedCreateWithoutKunjunganInput = {
    id?: string
    name: string
    address?: string | null
    phone?: string | null
    adminUserId?: string | null
    timezone?: string
    plan?: string
    billingContact?: string | null
    status?: string
    settings?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutTenantInput
    santri?: SantriUncheckedCreateNestedManyWithoutTenantInput
    wali?: WaliUncheckedCreateNestedManyWithoutTenantInput
    izin?: IzinUncheckedCreateNestedManyWithoutTenantInput
    catatanHarian?: CatatanHarianUncheckedCreateNestedManyWithoutTenantInput
    pengumuman?: PengumumanUncheckedCreateNestedManyWithoutTenantInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutTenantInput
    pelanggaran?: PelanggaranUncheckedCreateNestedManyWithoutTenantInput
    pembinaan?: PembinaanUncheckedCreateNestedManyWithoutTenantInput
    healthRecords?: HealthRecordUncheckedCreateNestedManyWithoutTenantInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutTenantInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutTenantInput
    webhookEvents?: WebhookEventUncheckedCreateNestedManyWithoutTenantInput
  }

  export type TenantCreateOrConnectWithoutKunjunganInput = {
    where: TenantWhereUniqueInput
    create: XOR<TenantCreateWithoutKunjunganInput, TenantUncheckedCreateWithoutKunjunganInput>
  }

  export type SantriCreateWithoutKunjunganInput = {
    id?: string
    nisn?: string | null
    name: string
    gender: string
    dob?: Date | string | null
    kelas?: string | null
    room?: string | null
    contact?: string | null
    address?: string | null
    photo?: string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutSantriInput
    walis?: SantriWaliCreateNestedManyWithoutSantriInput
    izin?: IzinCreateNestedManyWithoutSantriInput
    catatanHarian?: CatatanHarianCreateNestedManyWithoutSantriInput
    invoices?: InvoiceCreateNestedManyWithoutSantriInput
    pelanggaran?: PelanggaranCreateNestedManyWithoutSantriInput
    pembinaan?: PembinaanCreateNestedManyWithoutSantriInput
    healthRecords?: HealthRecordCreateNestedManyWithoutSantriInput
    medications?: MedicationCreateNestedManyWithoutSantriInput
  }

  export type SantriUncheckedCreateWithoutKunjunganInput = {
    id?: string
    tenantId: string
    nisn?: string | null
    name: string
    gender: string
    dob?: Date | string | null
    kelas?: string | null
    room?: string | null
    contact?: string | null
    address?: string | null
    photo?: string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    walis?: SantriWaliUncheckedCreateNestedManyWithoutSantriInput
    izin?: IzinUncheckedCreateNestedManyWithoutSantriInput
    catatanHarian?: CatatanHarianUncheckedCreateNestedManyWithoutSantriInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutSantriInput
    pelanggaran?: PelanggaranUncheckedCreateNestedManyWithoutSantriInput
    pembinaan?: PembinaanUncheckedCreateNestedManyWithoutSantriInput
    healthRecords?: HealthRecordUncheckedCreateNestedManyWithoutSantriInput
    medications?: MedicationUncheckedCreateNestedManyWithoutSantriInput
  }

  export type SantriCreateOrConnectWithoutKunjunganInput = {
    where: SantriWhereUniqueInput
    create: XOR<SantriCreateWithoutKunjunganInput, SantriUncheckedCreateWithoutKunjunganInput>
  }

  export type TamuCreateWithoutKunjunganInput = {
    id?: string
    name: string
    phone?: string | null
    idNumber?: string | null
    checkinAt?: Date | string | null
    createdAt?: Date | string
  }

  export type TamuUncheckedCreateWithoutKunjunganInput = {
    id?: string
    name: string
    phone?: string | null
    idNumber?: string | null
    checkinAt?: Date | string | null
    createdAt?: Date | string
  }

  export type TamuCreateOrConnectWithoutKunjunganInput = {
    where: TamuWhereUniqueInput
    create: XOR<TamuCreateWithoutKunjunganInput, TamuUncheckedCreateWithoutKunjunganInput>
  }

  export type TamuCreateManyKunjunganInputEnvelope = {
    data: TamuCreateManyKunjunganInput | TamuCreateManyKunjunganInput[]
  }

  export type TenantUpsertWithoutKunjunganInput = {
    update: XOR<TenantUpdateWithoutKunjunganInput, TenantUncheckedUpdateWithoutKunjunganInput>
    create: XOR<TenantCreateWithoutKunjunganInput, TenantUncheckedCreateWithoutKunjunganInput>
    where?: TenantWhereInput
  }

  export type TenantUpdateToOneWithWhereWithoutKunjunganInput = {
    where?: TenantWhereInput
    data: XOR<TenantUpdateWithoutKunjunganInput, TenantUncheckedUpdateWithoutKunjunganInput>
  }

  export type TenantUpdateWithoutKunjunganInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    adminUserId?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    plan?: StringFieldUpdateOperationsInput | string
    billingContact?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    settings?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutTenantNestedInput
    santri?: SantriUpdateManyWithoutTenantNestedInput
    wali?: WaliUpdateManyWithoutTenantNestedInput
    izin?: IzinUpdateManyWithoutTenantNestedInput
    catatanHarian?: CatatanHarianUpdateManyWithoutTenantNestedInput
    pengumuman?: PengumumanUpdateManyWithoutTenantNestedInput
    invoices?: InvoiceUpdateManyWithoutTenantNestedInput
    pelanggaran?: PelanggaranUpdateManyWithoutTenantNestedInput
    pembinaan?: PembinaanUpdateManyWithoutTenantNestedInput
    healthRecords?: HealthRecordUpdateManyWithoutTenantNestedInput
    auditLogs?: AuditLogUpdateManyWithoutTenantNestedInput
    notifications?: NotificationUpdateManyWithoutTenantNestedInput
    webhookEvents?: WebhookEventUpdateManyWithoutTenantNestedInput
  }

  export type TenantUncheckedUpdateWithoutKunjunganInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    adminUserId?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    plan?: StringFieldUpdateOperationsInput | string
    billingContact?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    settings?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutTenantNestedInput
    santri?: SantriUncheckedUpdateManyWithoutTenantNestedInput
    wali?: WaliUncheckedUpdateManyWithoutTenantNestedInput
    izin?: IzinUncheckedUpdateManyWithoutTenantNestedInput
    catatanHarian?: CatatanHarianUncheckedUpdateManyWithoutTenantNestedInput
    pengumuman?: PengumumanUncheckedUpdateManyWithoutTenantNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutTenantNestedInput
    pelanggaran?: PelanggaranUncheckedUpdateManyWithoutTenantNestedInput
    pembinaan?: PembinaanUncheckedUpdateManyWithoutTenantNestedInput
    healthRecords?: HealthRecordUncheckedUpdateManyWithoutTenantNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutTenantNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutTenantNestedInput
    webhookEvents?: WebhookEventUncheckedUpdateManyWithoutTenantNestedInput
  }

  export type SantriUpsertWithoutKunjunganInput = {
    update: XOR<SantriUpdateWithoutKunjunganInput, SantriUncheckedUpdateWithoutKunjunganInput>
    create: XOR<SantriCreateWithoutKunjunganInput, SantriUncheckedCreateWithoutKunjunganInput>
    where?: SantriWhereInput
  }

  export type SantriUpdateToOneWithWhereWithoutKunjunganInput = {
    where?: SantriWhereInput
    data: XOR<SantriUpdateWithoutKunjunganInput, SantriUncheckedUpdateWithoutKunjunganInput>
  }

  export type SantriUpdateWithoutKunjunganInput = {
    id?: StringFieldUpdateOperationsInput | string
    nisn?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    gender?: StringFieldUpdateOperationsInput | string
    dob?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    kelas?: NullableStringFieldUpdateOperationsInput | string | null
    room?: NullableStringFieldUpdateOperationsInput | string | null
    contact?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutSantriNestedInput
    walis?: SantriWaliUpdateManyWithoutSantriNestedInput
    izin?: IzinUpdateManyWithoutSantriNestedInput
    catatanHarian?: CatatanHarianUpdateManyWithoutSantriNestedInput
    invoices?: InvoiceUpdateManyWithoutSantriNestedInput
    pelanggaran?: PelanggaranUpdateManyWithoutSantriNestedInput
    pembinaan?: PembinaanUpdateManyWithoutSantriNestedInput
    healthRecords?: HealthRecordUpdateManyWithoutSantriNestedInput
    medications?: MedicationUpdateManyWithoutSantriNestedInput
  }

  export type SantriUncheckedUpdateWithoutKunjunganInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    nisn?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    gender?: StringFieldUpdateOperationsInput | string
    dob?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    kelas?: NullableStringFieldUpdateOperationsInput | string | null
    room?: NullableStringFieldUpdateOperationsInput | string | null
    contact?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    walis?: SantriWaliUncheckedUpdateManyWithoutSantriNestedInput
    izin?: IzinUncheckedUpdateManyWithoutSantriNestedInput
    catatanHarian?: CatatanHarianUncheckedUpdateManyWithoutSantriNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutSantriNestedInput
    pelanggaran?: PelanggaranUncheckedUpdateManyWithoutSantriNestedInput
    pembinaan?: PembinaanUncheckedUpdateManyWithoutSantriNestedInput
    healthRecords?: HealthRecordUncheckedUpdateManyWithoutSantriNestedInput
    medications?: MedicationUncheckedUpdateManyWithoutSantriNestedInput
  }

  export type TamuUpsertWithWhereUniqueWithoutKunjunganInput = {
    where: TamuWhereUniqueInput
    update: XOR<TamuUpdateWithoutKunjunganInput, TamuUncheckedUpdateWithoutKunjunganInput>
    create: XOR<TamuCreateWithoutKunjunganInput, TamuUncheckedCreateWithoutKunjunganInput>
  }

  export type TamuUpdateWithWhereUniqueWithoutKunjunganInput = {
    where: TamuWhereUniqueInput
    data: XOR<TamuUpdateWithoutKunjunganInput, TamuUncheckedUpdateWithoutKunjunganInput>
  }

  export type TamuUpdateManyWithWhereWithoutKunjunganInput = {
    where: TamuScalarWhereInput
    data: XOR<TamuUpdateManyMutationInput, TamuUncheckedUpdateManyWithoutKunjunganInput>
  }

  export type TamuScalarWhereInput = {
    AND?: TamuScalarWhereInput | TamuScalarWhereInput[]
    OR?: TamuScalarWhereInput[]
    NOT?: TamuScalarWhereInput | TamuScalarWhereInput[]
    id?: StringFilter<"Tamu"> | string
    kunjunganId?: StringFilter<"Tamu"> | string
    name?: StringFilter<"Tamu"> | string
    phone?: StringNullableFilter<"Tamu"> | string | null
    idNumber?: StringNullableFilter<"Tamu"> | string | null
    checkinAt?: DateTimeNullableFilter<"Tamu"> | Date | string | null
    createdAt?: DateTimeFilter<"Tamu"> | Date | string
  }

  export type KunjunganCreateWithoutTamuInput = {
    id?: string
    scheduledAt: Date | string
    slot: string
    visitorLimit?: number
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutKunjunganInput
    santri: SantriCreateNestedOneWithoutKunjunganInput
  }

  export type KunjunganUncheckedCreateWithoutTamuInput = {
    id?: string
    tenantId: string
    santriId: string
    scheduledAt: Date | string
    slot: string
    visitorLimit?: number
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type KunjunganCreateOrConnectWithoutTamuInput = {
    where: KunjunganWhereUniqueInput
    create: XOR<KunjunganCreateWithoutTamuInput, KunjunganUncheckedCreateWithoutTamuInput>
  }

  export type KunjunganUpsertWithoutTamuInput = {
    update: XOR<KunjunganUpdateWithoutTamuInput, KunjunganUncheckedUpdateWithoutTamuInput>
    create: XOR<KunjunganCreateWithoutTamuInput, KunjunganUncheckedCreateWithoutTamuInput>
    where?: KunjunganWhereInput
  }

  export type KunjunganUpdateToOneWithWhereWithoutTamuInput = {
    where?: KunjunganWhereInput
    data: XOR<KunjunganUpdateWithoutTamuInput, KunjunganUncheckedUpdateWithoutTamuInput>
  }

  export type KunjunganUpdateWithoutTamuInput = {
    id?: StringFieldUpdateOperationsInput | string
    scheduledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    slot?: StringFieldUpdateOperationsInput | string
    visitorLimit?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutKunjunganNestedInput
    santri?: SantriUpdateOneRequiredWithoutKunjunganNestedInput
  }

  export type KunjunganUncheckedUpdateWithoutTamuInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    santriId?: StringFieldUpdateOperationsInput | string
    scheduledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    slot?: StringFieldUpdateOperationsInput | string
    visitorLimit?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TenantCreateWithoutHealthRecordsInput = {
    id?: string
    name: string
    address?: string | null
    phone?: string | null
    adminUserId?: string | null
    timezone?: string
    plan?: string
    billingContact?: string | null
    status?: string
    settings?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutTenantInput
    santri?: SantriCreateNestedManyWithoutTenantInput
    wali?: WaliCreateNestedManyWithoutTenantInput
    izin?: IzinCreateNestedManyWithoutTenantInput
    catatanHarian?: CatatanHarianCreateNestedManyWithoutTenantInput
    pengumuman?: PengumumanCreateNestedManyWithoutTenantInput
    invoices?: InvoiceCreateNestedManyWithoutTenantInput
    pelanggaran?: PelanggaranCreateNestedManyWithoutTenantInput
    pembinaan?: PembinaanCreateNestedManyWithoutTenantInput
    kunjungan?: KunjunganCreateNestedManyWithoutTenantInput
    auditLogs?: AuditLogCreateNestedManyWithoutTenantInput
    notifications?: NotificationCreateNestedManyWithoutTenantInput
    webhookEvents?: WebhookEventCreateNestedManyWithoutTenantInput
  }

  export type TenantUncheckedCreateWithoutHealthRecordsInput = {
    id?: string
    name: string
    address?: string | null
    phone?: string | null
    adminUserId?: string | null
    timezone?: string
    plan?: string
    billingContact?: string | null
    status?: string
    settings?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutTenantInput
    santri?: SantriUncheckedCreateNestedManyWithoutTenantInput
    wali?: WaliUncheckedCreateNestedManyWithoutTenantInput
    izin?: IzinUncheckedCreateNestedManyWithoutTenantInput
    catatanHarian?: CatatanHarianUncheckedCreateNestedManyWithoutTenantInput
    pengumuman?: PengumumanUncheckedCreateNestedManyWithoutTenantInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutTenantInput
    pelanggaran?: PelanggaranUncheckedCreateNestedManyWithoutTenantInput
    pembinaan?: PembinaanUncheckedCreateNestedManyWithoutTenantInput
    kunjungan?: KunjunganUncheckedCreateNestedManyWithoutTenantInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutTenantInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutTenantInput
    webhookEvents?: WebhookEventUncheckedCreateNestedManyWithoutTenantInput
  }

  export type TenantCreateOrConnectWithoutHealthRecordsInput = {
    where: TenantWhereUniqueInput
    create: XOR<TenantCreateWithoutHealthRecordsInput, TenantUncheckedCreateWithoutHealthRecordsInput>
  }

  export type SantriCreateWithoutHealthRecordsInput = {
    id?: string
    nisn?: string | null
    name: string
    gender: string
    dob?: Date | string | null
    kelas?: string | null
    room?: string | null
    contact?: string | null
    address?: string | null
    photo?: string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutSantriInput
    walis?: SantriWaliCreateNestedManyWithoutSantriInput
    izin?: IzinCreateNestedManyWithoutSantriInput
    catatanHarian?: CatatanHarianCreateNestedManyWithoutSantriInput
    invoices?: InvoiceCreateNestedManyWithoutSantriInput
    pelanggaran?: PelanggaranCreateNestedManyWithoutSantriInput
    pembinaan?: PembinaanCreateNestedManyWithoutSantriInput
    kunjungan?: KunjunganCreateNestedManyWithoutSantriInput
    medications?: MedicationCreateNestedManyWithoutSantriInput
  }

  export type SantriUncheckedCreateWithoutHealthRecordsInput = {
    id?: string
    tenantId: string
    nisn?: string | null
    name: string
    gender: string
    dob?: Date | string | null
    kelas?: string | null
    room?: string | null
    contact?: string | null
    address?: string | null
    photo?: string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    walis?: SantriWaliUncheckedCreateNestedManyWithoutSantriInput
    izin?: IzinUncheckedCreateNestedManyWithoutSantriInput
    catatanHarian?: CatatanHarianUncheckedCreateNestedManyWithoutSantriInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutSantriInput
    pelanggaran?: PelanggaranUncheckedCreateNestedManyWithoutSantriInput
    pembinaan?: PembinaanUncheckedCreateNestedManyWithoutSantriInput
    kunjungan?: KunjunganUncheckedCreateNestedManyWithoutSantriInput
    medications?: MedicationUncheckedCreateNestedManyWithoutSantriInput
  }

  export type SantriCreateOrConnectWithoutHealthRecordsInput = {
    where: SantriWhereUniqueInput
    create: XOR<SantriCreateWithoutHealthRecordsInput, SantriUncheckedCreateWithoutHealthRecordsInput>
  }

  export type TenantUpsertWithoutHealthRecordsInput = {
    update: XOR<TenantUpdateWithoutHealthRecordsInput, TenantUncheckedUpdateWithoutHealthRecordsInput>
    create: XOR<TenantCreateWithoutHealthRecordsInput, TenantUncheckedCreateWithoutHealthRecordsInput>
    where?: TenantWhereInput
  }

  export type TenantUpdateToOneWithWhereWithoutHealthRecordsInput = {
    where?: TenantWhereInput
    data: XOR<TenantUpdateWithoutHealthRecordsInput, TenantUncheckedUpdateWithoutHealthRecordsInput>
  }

  export type TenantUpdateWithoutHealthRecordsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    adminUserId?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    plan?: StringFieldUpdateOperationsInput | string
    billingContact?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    settings?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutTenantNestedInput
    santri?: SantriUpdateManyWithoutTenantNestedInput
    wali?: WaliUpdateManyWithoutTenantNestedInput
    izin?: IzinUpdateManyWithoutTenantNestedInput
    catatanHarian?: CatatanHarianUpdateManyWithoutTenantNestedInput
    pengumuman?: PengumumanUpdateManyWithoutTenantNestedInput
    invoices?: InvoiceUpdateManyWithoutTenantNestedInput
    pelanggaran?: PelanggaranUpdateManyWithoutTenantNestedInput
    pembinaan?: PembinaanUpdateManyWithoutTenantNestedInput
    kunjungan?: KunjunganUpdateManyWithoutTenantNestedInput
    auditLogs?: AuditLogUpdateManyWithoutTenantNestedInput
    notifications?: NotificationUpdateManyWithoutTenantNestedInput
    webhookEvents?: WebhookEventUpdateManyWithoutTenantNestedInput
  }

  export type TenantUncheckedUpdateWithoutHealthRecordsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    adminUserId?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    plan?: StringFieldUpdateOperationsInput | string
    billingContact?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    settings?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutTenantNestedInput
    santri?: SantriUncheckedUpdateManyWithoutTenantNestedInput
    wali?: WaliUncheckedUpdateManyWithoutTenantNestedInput
    izin?: IzinUncheckedUpdateManyWithoutTenantNestedInput
    catatanHarian?: CatatanHarianUncheckedUpdateManyWithoutTenantNestedInput
    pengumuman?: PengumumanUncheckedUpdateManyWithoutTenantNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutTenantNestedInput
    pelanggaran?: PelanggaranUncheckedUpdateManyWithoutTenantNestedInput
    pembinaan?: PembinaanUncheckedUpdateManyWithoutTenantNestedInput
    kunjungan?: KunjunganUncheckedUpdateManyWithoutTenantNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutTenantNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutTenantNestedInput
    webhookEvents?: WebhookEventUncheckedUpdateManyWithoutTenantNestedInput
  }

  export type SantriUpsertWithoutHealthRecordsInput = {
    update: XOR<SantriUpdateWithoutHealthRecordsInput, SantriUncheckedUpdateWithoutHealthRecordsInput>
    create: XOR<SantriCreateWithoutHealthRecordsInput, SantriUncheckedCreateWithoutHealthRecordsInput>
    where?: SantriWhereInput
  }

  export type SantriUpdateToOneWithWhereWithoutHealthRecordsInput = {
    where?: SantriWhereInput
    data: XOR<SantriUpdateWithoutHealthRecordsInput, SantriUncheckedUpdateWithoutHealthRecordsInput>
  }

  export type SantriUpdateWithoutHealthRecordsInput = {
    id?: StringFieldUpdateOperationsInput | string
    nisn?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    gender?: StringFieldUpdateOperationsInput | string
    dob?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    kelas?: NullableStringFieldUpdateOperationsInput | string | null
    room?: NullableStringFieldUpdateOperationsInput | string | null
    contact?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutSantriNestedInput
    walis?: SantriWaliUpdateManyWithoutSantriNestedInput
    izin?: IzinUpdateManyWithoutSantriNestedInput
    catatanHarian?: CatatanHarianUpdateManyWithoutSantriNestedInput
    invoices?: InvoiceUpdateManyWithoutSantriNestedInput
    pelanggaran?: PelanggaranUpdateManyWithoutSantriNestedInput
    pembinaan?: PembinaanUpdateManyWithoutSantriNestedInput
    kunjungan?: KunjunganUpdateManyWithoutSantriNestedInput
    medications?: MedicationUpdateManyWithoutSantriNestedInput
  }

  export type SantriUncheckedUpdateWithoutHealthRecordsInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    nisn?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    gender?: StringFieldUpdateOperationsInput | string
    dob?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    kelas?: NullableStringFieldUpdateOperationsInput | string | null
    room?: NullableStringFieldUpdateOperationsInput | string | null
    contact?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    walis?: SantriWaliUncheckedUpdateManyWithoutSantriNestedInput
    izin?: IzinUncheckedUpdateManyWithoutSantriNestedInput
    catatanHarian?: CatatanHarianUncheckedUpdateManyWithoutSantriNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutSantriNestedInput
    pelanggaran?: PelanggaranUncheckedUpdateManyWithoutSantriNestedInput
    pembinaan?: PembinaanUncheckedUpdateManyWithoutSantriNestedInput
    kunjungan?: KunjunganUncheckedUpdateManyWithoutSantriNestedInput
    medications?: MedicationUncheckedUpdateManyWithoutSantriNestedInput
  }

  export type SantriCreateWithoutMedicationsInput = {
    id?: string
    nisn?: string | null
    name: string
    gender: string
    dob?: Date | string | null
    kelas?: string | null
    room?: string | null
    contact?: string | null
    address?: string | null
    photo?: string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutSantriInput
    walis?: SantriWaliCreateNestedManyWithoutSantriInput
    izin?: IzinCreateNestedManyWithoutSantriInput
    catatanHarian?: CatatanHarianCreateNestedManyWithoutSantriInput
    invoices?: InvoiceCreateNestedManyWithoutSantriInput
    pelanggaran?: PelanggaranCreateNestedManyWithoutSantriInput
    pembinaan?: PembinaanCreateNestedManyWithoutSantriInput
    kunjungan?: KunjunganCreateNestedManyWithoutSantriInput
    healthRecords?: HealthRecordCreateNestedManyWithoutSantriInput
  }

  export type SantriUncheckedCreateWithoutMedicationsInput = {
    id?: string
    tenantId: string
    nisn?: string | null
    name: string
    gender: string
    dob?: Date | string | null
    kelas?: string | null
    room?: string | null
    contact?: string | null
    address?: string | null
    photo?: string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    walis?: SantriWaliUncheckedCreateNestedManyWithoutSantriInput
    izin?: IzinUncheckedCreateNestedManyWithoutSantriInput
    catatanHarian?: CatatanHarianUncheckedCreateNestedManyWithoutSantriInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutSantriInput
    pelanggaran?: PelanggaranUncheckedCreateNestedManyWithoutSantriInput
    pembinaan?: PembinaanUncheckedCreateNestedManyWithoutSantriInput
    kunjungan?: KunjunganUncheckedCreateNestedManyWithoutSantriInput
    healthRecords?: HealthRecordUncheckedCreateNestedManyWithoutSantriInput
  }

  export type SantriCreateOrConnectWithoutMedicationsInput = {
    where: SantriWhereUniqueInput
    create: XOR<SantriCreateWithoutMedicationsInput, SantriUncheckedCreateWithoutMedicationsInput>
  }

  export type SantriUpsertWithoutMedicationsInput = {
    update: XOR<SantriUpdateWithoutMedicationsInput, SantriUncheckedUpdateWithoutMedicationsInput>
    create: XOR<SantriCreateWithoutMedicationsInput, SantriUncheckedCreateWithoutMedicationsInput>
    where?: SantriWhereInput
  }

  export type SantriUpdateToOneWithWhereWithoutMedicationsInput = {
    where?: SantriWhereInput
    data: XOR<SantriUpdateWithoutMedicationsInput, SantriUncheckedUpdateWithoutMedicationsInput>
  }

  export type SantriUpdateWithoutMedicationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    nisn?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    gender?: StringFieldUpdateOperationsInput | string
    dob?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    kelas?: NullableStringFieldUpdateOperationsInput | string | null
    room?: NullableStringFieldUpdateOperationsInput | string | null
    contact?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutSantriNestedInput
    walis?: SantriWaliUpdateManyWithoutSantriNestedInput
    izin?: IzinUpdateManyWithoutSantriNestedInput
    catatanHarian?: CatatanHarianUpdateManyWithoutSantriNestedInput
    invoices?: InvoiceUpdateManyWithoutSantriNestedInput
    pelanggaran?: PelanggaranUpdateManyWithoutSantriNestedInput
    pembinaan?: PembinaanUpdateManyWithoutSantriNestedInput
    kunjungan?: KunjunganUpdateManyWithoutSantriNestedInput
    healthRecords?: HealthRecordUpdateManyWithoutSantriNestedInput
  }

  export type SantriUncheckedUpdateWithoutMedicationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    nisn?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    gender?: StringFieldUpdateOperationsInput | string
    dob?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    kelas?: NullableStringFieldUpdateOperationsInput | string | null
    room?: NullableStringFieldUpdateOperationsInput | string | null
    contact?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    walis?: SantriWaliUncheckedUpdateManyWithoutSantriNestedInput
    izin?: IzinUncheckedUpdateManyWithoutSantriNestedInput
    catatanHarian?: CatatanHarianUncheckedUpdateManyWithoutSantriNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutSantriNestedInput
    pelanggaran?: PelanggaranUncheckedUpdateManyWithoutSantriNestedInput
    pembinaan?: PembinaanUncheckedUpdateManyWithoutSantriNestedInput
    kunjungan?: KunjunganUncheckedUpdateManyWithoutSantriNestedInput
    healthRecords?: HealthRecordUncheckedUpdateManyWithoutSantriNestedInput
  }

  export type TenantCreateWithoutAuditLogsInput = {
    id?: string
    name: string
    address?: string | null
    phone?: string | null
    adminUserId?: string | null
    timezone?: string
    plan?: string
    billingContact?: string | null
    status?: string
    settings?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutTenantInput
    santri?: SantriCreateNestedManyWithoutTenantInput
    wali?: WaliCreateNestedManyWithoutTenantInput
    izin?: IzinCreateNestedManyWithoutTenantInput
    catatanHarian?: CatatanHarianCreateNestedManyWithoutTenantInput
    pengumuman?: PengumumanCreateNestedManyWithoutTenantInput
    invoices?: InvoiceCreateNestedManyWithoutTenantInput
    pelanggaran?: PelanggaranCreateNestedManyWithoutTenantInput
    pembinaan?: PembinaanCreateNestedManyWithoutTenantInput
    kunjungan?: KunjunganCreateNestedManyWithoutTenantInput
    healthRecords?: HealthRecordCreateNestedManyWithoutTenantInput
    notifications?: NotificationCreateNestedManyWithoutTenantInput
    webhookEvents?: WebhookEventCreateNestedManyWithoutTenantInput
  }

  export type TenantUncheckedCreateWithoutAuditLogsInput = {
    id?: string
    name: string
    address?: string | null
    phone?: string | null
    adminUserId?: string | null
    timezone?: string
    plan?: string
    billingContact?: string | null
    status?: string
    settings?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutTenantInput
    santri?: SantriUncheckedCreateNestedManyWithoutTenantInput
    wali?: WaliUncheckedCreateNestedManyWithoutTenantInput
    izin?: IzinUncheckedCreateNestedManyWithoutTenantInput
    catatanHarian?: CatatanHarianUncheckedCreateNestedManyWithoutTenantInput
    pengumuman?: PengumumanUncheckedCreateNestedManyWithoutTenantInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutTenantInput
    pelanggaran?: PelanggaranUncheckedCreateNestedManyWithoutTenantInput
    pembinaan?: PembinaanUncheckedCreateNestedManyWithoutTenantInput
    kunjungan?: KunjunganUncheckedCreateNestedManyWithoutTenantInput
    healthRecords?: HealthRecordUncheckedCreateNestedManyWithoutTenantInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutTenantInput
    webhookEvents?: WebhookEventUncheckedCreateNestedManyWithoutTenantInput
  }

  export type TenantCreateOrConnectWithoutAuditLogsInput = {
    where: TenantWhereUniqueInput
    create: XOR<TenantCreateWithoutAuditLogsInput, TenantUncheckedCreateWithoutAuditLogsInput>
  }

  export type UserCreateWithoutAuditLogsInput = {
    id?: string
    email: string
    passwordHash: string
    role?: string
    name: string
    phone?: string | null
    isActive?: boolean
    lastLogin?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant?: TenantCreateNestedOneWithoutUsersInput
    refreshTokens?: RefreshTokenCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutAuditLogsInput = {
    id?: string
    tenantId?: string | null
    email: string
    passwordHash: string
    role?: string
    name: string
    phone?: string | null
    isActive?: boolean
    lastLogin?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    refreshTokens?: RefreshTokenUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutAuditLogsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAuditLogsInput, UserUncheckedCreateWithoutAuditLogsInput>
  }

  export type TenantUpsertWithoutAuditLogsInput = {
    update: XOR<TenantUpdateWithoutAuditLogsInput, TenantUncheckedUpdateWithoutAuditLogsInput>
    create: XOR<TenantCreateWithoutAuditLogsInput, TenantUncheckedCreateWithoutAuditLogsInput>
    where?: TenantWhereInput
  }

  export type TenantUpdateToOneWithWhereWithoutAuditLogsInput = {
    where?: TenantWhereInput
    data: XOR<TenantUpdateWithoutAuditLogsInput, TenantUncheckedUpdateWithoutAuditLogsInput>
  }

  export type TenantUpdateWithoutAuditLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    adminUserId?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    plan?: StringFieldUpdateOperationsInput | string
    billingContact?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    settings?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutTenantNestedInput
    santri?: SantriUpdateManyWithoutTenantNestedInput
    wali?: WaliUpdateManyWithoutTenantNestedInput
    izin?: IzinUpdateManyWithoutTenantNestedInput
    catatanHarian?: CatatanHarianUpdateManyWithoutTenantNestedInput
    pengumuman?: PengumumanUpdateManyWithoutTenantNestedInput
    invoices?: InvoiceUpdateManyWithoutTenantNestedInput
    pelanggaran?: PelanggaranUpdateManyWithoutTenantNestedInput
    pembinaan?: PembinaanUpdateManyWithoutTenantNestedInput
    kunjungan?: KunjunganUpdateManyWithoutTenantNestedInput
    healthRecords?: HealthRecordUpdateManyWithoutTenantNestedInput
    notifications?: NotificationUpdateManyWithoutTenantNestedInput
    webhookEvents?: WebhookEventUpdateManyWithoutTenantNestedInput
  }

  export type TenantUncheckedUpdateWithoutAuditLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    adminUserId?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    plan?: StringFieldUpdateOperationsInput | string
    billingContact?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    settings?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutTenantNestedInput
    santri?: SantriUncheckedUpdateManyWithoutTenantNestedInput
    wali?: WaliUncheckedUpdateManyWithoutTenantNestedInput
    izin?: IzinUncheckedUpdateManyWithoutTenantNestedInput
    catatanHarian?: CatatanHarianUncheckedUpdateManyWithoutTenantNestedInput
    pengumuman?: PengumumanUncheckedUpdateManyWithoutTenantNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutTenantNestedInput
    pelanggaran?: PelanggaranUncheckedUpdateManyWithoutTenantNestedInput
    pembinaan?: PembinaanUncheckedUpdateManyWithoutTenantNestedInput
    kunjungan?: KunjunganUncheckedUpdateManyWithoutTenantNestedInput
    healthRecords?: HealthRecordUncheckedUpdateManyWithoutTenantNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutTenantNestedInput
    webhookEvents?: WebhookEventUncheckedUpdateManyWithoutTenantNestedInput
  }

  export type UserUpsertWithoutAuditLogsInput = {
    update: XOR<UserUpdateWithoutAuditLogsInput, UserUncheckedUpdateWithoutAuditLogsInput>
    create: XOR<UserCreateWithoutAuditLogsInput, UserUncheckedCreateWithoutAuditLogsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAuditLogsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAuditLogsInput, UserUncheckedUpdateWithoutAuditLogsInput>
  }

  export type UserUpdateWithoutAuditLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneWithoutUsersNestedInput
    refreshTokens?: RefreshTokenUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutAuditLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    refreshTokens?: RefreshTokenUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
  }

  export type TenantCreateWithoutNotificationsInput = {
    id?: string
    name: string
    address?: string | null
    phone?: string | null
    adminUserId?: string | null
    timezone?: string
    plan?: string
    billingContact?: string | null
    status?: string
    settings?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutTenantInput
    santri?: SantriCreateNestedManyWithoutTenantInput
    wali?: WaliCreateNestedManyWithoutTenantInput
    izin?: IzinCreateNestedManyWithoutTenantInput
    catatanHarian?: CatatanHarianCreateNestedManyWithoutTenantInput
    pengumuman?: PengumumanCreateNestedManyWithoutTenantInput
    invoices?: InvoiceCreateNestedManyWithoutTenantInput
    pelanggaran?: PelanggaranCreateNestedManyWithoutTenantInput
    pembinaan?: PembinaanCreateNestedManyWithoutTenantInput
    kunjungan?: KunjunganCreateNestedManyWithoutTenantInput
    healthRecords?: HealthRecordCreateNestedManyWithoutTenantInput
    auditLogs?: AuditLogCreateNestedManyWithoutTenantInput
    webhookEvents?: WebhookEventCreateNestedManyWithoutTenantInput
  }

  export type TenantUncheckedCreateWithoutNotificationsInput = {
    id?: string
    name: string
    address?: string | null
    phone?: string | null
    adminUserId?: string | null
    timezone?: string
    plan?: string
    billingContact?: string | null
    status?: string
    settings?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutTenantInput
    santri?: SantriUncheckedCreateNestedManyWithoutTenantInput
    wali?: WaliUncheckedCreateNestedManyWithoutTenantInput
    izin?: IzinUncheckedCreateNestedManyWithoutTenantInput
    catatanHarian?: CatatanHarianUncheckedCreateNestedManyWithoutTenantInput
    pengumuman?: PengumumanUncheckedCreateNestedManyWithoutTenantInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutTenantInput
    pelanggaran?: PelanggaranUncheckedCreateNestedManyWithoutTenantInput
    pembinaan?: PembinaanUncheckedCreateNestedManyWithoutTenantInput
    kunjungan?: KunjunganUncheckedCreateNestedManyWithoutTenantInput
    healthRecords?: HealthRecordUncheckedCreateNestedManyWithoutTenantInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutTenantInput
    webhookEvents?: WebhookEventUncheckedCreateNestedManyWithoutTenantInput
  }

  export type TenantCreateOrConnectWithoutNotificationsInput = {
    where: TenantWhereUniqueInput
    create: XOR<TenantCreateWithoutNotificationsInput, TenantUncheckedCreateWithoutNotificationsInput>
  }

  export type UserCreateWithoutNotificationsInput = {
    id?: string
    email: string
    passwordHash: string
    role?: string
    name: string
    phone?: string | null
    isActive?: boolean
    lastLogin?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant?: TenantCreateNestedOneWithoutUsersInput
    refreshTokens?: RefreshTokenCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutNotificationsInput = {
    id?: string
    tenantId?: string | null
    email: string
    passwordHash: string
    role?: string
    name: string
    phone?: string | null
    isActive?: boolean
    lastLogin?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    refreshTokens?: RefreshTokenUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutNotificationsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
  }

  export type TenantUpsertWithoutNotificationsInput = {
    update: XOR<TenantUpdateWithoutNotificationsInput, TenantUncheckedUpdateWithoutNotificationsInput>
    create: XOR<TenantCreateWithoutNotificationsInput, TenantUncheckedCreateWithoutNotificationsInput>
    where?: TenantWhereInput
  }

  export type TenantUpdateToOneWithWhereWithoutNotificationsInput = {
    where?: TenantWhereInput
    data: XOR<TenantUpdateWithoutNotificationsInput, TenantUncheckedUpdateWithoutNotificationsInput>
  }

  export type TenantUpdateWithoutNotificationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    adminUserId?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    plan?: StringFieldUpdateOperationsInput | string
    billingContact?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    settings?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutTenantNestedInput
    santri?: SantriUpdateManyWithoutTenantNestedInput
    wali?: WaliUpdateManyWithoutTenantNestedInput
    izin?: IzinUpdateManyWithoutTenantNestedInput
    catatanHarian?: CatatanHarianUpdateManyWithoutTenantNestedInput
    pengumuman?: PengumumanUpdateManyWithoutTenantNestedInput
    invoices?: InvoiceUpdateManyWithoutTenantNestedInput
    pelanggaran?: PelanggaranUpdateManyWithoutTenantNestedInput
    pembinaan?: PembinaanUpdateManyWithoutTenantNestedInput
    kunjungan?: KunjunganUpdateManyWithoutTenantNestedInput
    healthRecords?: HealthRecordUpdateManyWithoutTenantNestedInput
    auditLogs?: AuditLogUpdateManyWithoutTenantNestedInput
    webhookEvents?: WebhookEventUpdateManyWithoutTenantNestedInput
  }

  export type TenantUncheckedUpdateWithoutNotificationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    adminUserId?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    plan?: StringFieldUpdateOperationsInput | string
    billingContact?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    settings?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutTenantNestedInput
    santri?: SantriUncheckedUpdateManyWithoutTenantNestedInput
    wali?: WaliUncheckedUpdateManyWithoutTenantNestedInput
    izin?: IzinUncheckedUpdateManyWithoutTenantNestedInput
    catatanHarian?: CatatanHarianUncheckedUpdateManyWithoutTenantNestedInput
    pengumuman?: PengumumanUncheckedUpdateManyWithoutTenantNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutTenantNestedInput
    pelanggaran?: PelanggaranUncheckedUpdateManyWithoutTenantNestedInput
    pembinaan?: PembinaanUncheckedUpdateManyWithoutTenantNestedInput
    kunjungan?: KunjunganUncheckedUpdateManyWithoutTenantNestedInput
    healthRecords?: HealthRecordUncheckedUpdateManyWithoutTenantNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutTenantNestedInput
    webhookEvents?: WebhookEventUncheckedUpdateManyWithoutTenantNestedInput
  }

  export type UserUpsertWithoutNotificationsInput = {
    update: XOR<UserUpdateWithoutNotificationsInput, UserUncheckedUpdateWithoutNotificationsInput>
    create: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutNotificationsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutNotificationsInput, UserUncheckedUpdateWithoutNotificationsInput>
  }

  export type UserUpdateWithoutNotificationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneWithoutUsersNestedInput
    refreshTokens?: RefreshTokenUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutNotificationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    refreshTokens?: RefreshTokenUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
  }

  export type TenantCreateWithoutWebhookEventsInput = {
    id?: string
    name: string
    address?: string | null
    phone?: string | null
    adminUserId?: string | null
    timezone?: string
    plan?: string
    billingContact?: string | null
    status?: string
    settings?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutTenantInput
    santri?: SantriCreateNestedManyWithoutTenantInput
    wali?: WaliCreateNestedManyWithoutTenantInput
    izin?: IzinCreateNestedManyWithoutTenantInput
    catatanHarian?: CatatanHarianCreateNestedManyWithoutTenantInput
    pengumuman?: PengumumanCreateNestedManyWithoutTenantInput
    invoices?: InvoiceCreateNestedManyWithoutTenantInput
    pelanggaran?: PelanggaranCreateNestedManyWithoutTenantInput
    pembinaan?: PembinaanCreateNestedManyWithoutTenantInput
    kunjungan?: KunjunganCreateNestedManyWithoutTenantInput
    healthRecords?: HealthRecordCreateNestedManyWithoutTenantInput
    auditLogs?: AuditLogCreateNestedManyWithoutTenantInput
    notifications?: NotificationCreateNestedManyWithoutTenantInput
  }

  export type TenantUncheckedCreateWithoutWebhookEventsInput = {
    id?: string
    name: string
    address?: string | null
    phone?: string | null
    adminUserId?: string | null
    timezone?: string
    plan?: string
    billingContact?: string | null
    status?: string
    settings?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutTenantInput
    santri?: SantriUncheckedCreateNestedManyWithoutTenantInput
    wali?: WaliUncheckedCreateNestedManyWithoutTenantInput
    izin?: IzinUncheckedCreateNestedManyWithoutTenantInput
    catatanHarian?: CatatanHarianUncheckedCreateNestedManyWithoutTenantInput
    pengumuman?: PengumumanUncheckedCreateNestedManyWithoutTenantInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutTenantInput
    pelanggaran?: PelanggaranUncheckedCreateNestedManyWithoutTenantInput
    pembinaan?: PembinaanUncheckedCreateNestedManyWithoutTenantInput
    kunjungan?: KunjunganUncheckedCreateNestedManyWithoutTenantInput
    healthRecords?: HealthRecordUncheckedCreateNestedManyWithoutTenantInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutTenantInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutTenantInput
  }

  export type TenantCreateOrConnectWithoutWebhookEventsInput = {
    where: TenantWhereUniqueInput
    create: XOR<TenantCreateWithoutWebhookEventsInput, TenantUncheckedCreateWithoutWebhookEventsInput>
  }

  export type TenantUpsertWithoutWebhookEventsInput = {
    update: XOR<TenantUpdateWithoutWebhookEventsInput, TenantUncheckedUpdateWithoutWebhookEventsInput>
    create: XOR<TenantCreateWithoutWebhookEventsInput, TenantUncheckedCreateWithoutWebhookEventsInput>
    where?: TenantWhereInput
  }

  export type TenantUpdateToOneWithWhereWithoutWebhookEventsInput = {
    where?: TenantWhereInput
    data: XOR<TenantUpdateWithoutWebhookEventsInput, TenantUncheckedUpdateWithoutWebhookEventsInput>
  }

  export type TenantUpdateWithoutWebhookEventsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    adminUserId?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    plan?: StringFieldUpdateOperationsInput | string
    billingContact?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    settings?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutTenantNestedInput
    santri?: SantriUpdateManyWithoutTenantNestedInput
    wali?: WaliUpdateManyWithoutTenantNestedInput
    izin?: IzinUpdateManyWithoutTenantNestedInput
    catatanHarian?: CatatanHarianUpdateManyWithoutTenantNestedInput
    pengumuman?: PengumumanUpdateManyWithoutTenantNestedInput
    invoices?: InvoiceUpdateManyWithoutTenantNestedInput
    pelanggaran?: PelanggaranUpdateManyWithoutTenantNestedInput
    pembinaan?: PembinaanUpdateManyWithoutTenantNestedInput
    kunjungan?: KunjunganUpdateManyWithoutTenantNestedInput
    healthRecords?: HealthRecordUpdateManyWithoutTenantNestedInput
    auditLogs?: AuditLogUpdateManyWithoutTenantNestedInput
    notifications?: NotificationUpdateManyWithoutTenantNestedInput
  }

  export type TenantUncheckedUpdateWithoutWebhookEventsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    adminUserId?: NullableStringFieldUpdateOperationsInput | string | null
    timezone?: StringFieldUpdateOperationsInput | string
    plan?: StringFieldUpdateOperationsInput | string
    billingContact?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    settings?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutTenantNestedInput
    santri?: SantriUncheckedUpdateManyWithoutTenantNestedInput
    wali?: WaliUncheckedUpdateManyWithoutTenantNestedInput
    izin?: IzinUncheckedUpdateManyWithoutTenantNestedInput
    catatanHarian?: CatatanHarianUncheckedUpdateManyWithoutTenantNestedInput
    pengumuman?: PengumumanUncheckedUpdateManyWithoutTenantNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutTenantNestedInput
    pelanggaran?: PelanggaranUncheckedUpdateManyWithoutTenantNestedInput
    pembinaan?: PembinaanUncheckedUpdateManyWithoutTenantNestedInput
    kunjungan?: KunjunganUncheckedUpdateManyWithoutTenantNestedInput
    healthRecords?: HealthRecordUncheckedUpdateManyWithoutTenantNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutTenantNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutTenantNestedInput
  }

  export type UserCreateManyTenantInput = {
    id?: string
    email: string
    passwordHash: string
    role?: string
    name: string
    phone?: string | null
    isActive?: boolean
    lastLogin?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SantriCreateManyTenantInput = {
    id?: string
    nisn?: string | null
    name: string
    gender: string
    dob?: Date | string | null
    kelas?: string | null
    room?: string | null
    contact?: string | null
    address?: string | null
    photo?: string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WaliCreateManyTenantInput = {
    id?: string
    name: string
    relation: string
    phone: string
    email?: string | null
    address?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type IzinCreateManyTenantInput = {
    id?: string
    santriId: string
    type: string
    reason: string
    startAt: Date | string
    endAt: Date | string
    status?: string
    requestedBy: string
    approvedBy?: string | null
    approvedAt?: Date | string | null
    qrCodeData?: string | null
    checkoutAt?: Date | string | null
    checkoutBy?: string | null
    checkinAt?: Date | string | null
    checkinBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CatatanHarianCreateManyTenantInput = {
    id?: string
    santriId: string
    authorId: string
    date?: Date | string
    content: string
    category: string
    attachments?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PengumumanCreateManyTenantInput = {
    id?: string
    title: string
    content: string
    audience: string
    pinnedUntil?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InvoiceCreateManyTenantInput = {
    id?: string
    santriId: string
    amountDue: number
    dueDate: Date | string
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PelanggaranCreateManyTenantInput = {
    id?: string
    santriId: string
    recordedBy: string
    category: string
    severity: number
    points?: number
    description: string
    date?: Date | string
    resolved?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PembinaanCreateManyTenantInput = {
    id?: string
    santriId: string
    plan: string
    targetDate: Date | string
    status?: string
    assignedTo: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type KunjunganCreateManyTenantInput = {
    id?: string
    santriId: string
    scheduledAt: Date | string
    slot: string
    visitorLimit?: number
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type HealthRecordCreateManyTenantInput = {
    id?: string
    santriId: string
    recordedBy: string
    symptoms: string
    diagnosis?: string | null
    actionTaken?: string | null
    referred?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AuditLogCreateManyTenantInput = {
    id?: string
    userId?: string | null
    action: string
    entity: string
    entityId: string
    oldValue?: string | null
    newValue?: string | null
    ip?: string | null
    createdAt?: Date | string
  }

  export type NotificationCreateManyTenantInput = {
    id?: string
    userId: string
    type: string
    title: string
    body: string
    read?: boolean
    createdAt?: Date | string
  }

  export type WebhookEventCreateManyTenantInput = {
    id?: string
    eventType: string
    payload: string
    status?: string
    error?: string | null
    createdAt?: Date | string
    processedAt?: Date | string | null
  }

  export type UserUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    refreshTokens?: RefreshTokenUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    refreshTokens?: RefreshTokenUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateManyWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SantriUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    nisn?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    gender?: StringFieldUpdateOperationsInput | string
    dob?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    kelas?: NullableStringFieldUpdateOperationsInput | string | null
    room?: NullableStringFieldUpdateOperationsInput | string | null
    contact?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    walis?: SantriWaliUpdateManyWithoutSantriNestedInput
    izin?: IzinUpdateManyWithoutSantriNestedInput
    catatanHarian?: CatatanHarianUpdateManyWithoutSantriNestedInput
    invoices?: InvoiceUpdateManyWithoutSantriNestedInput
    pelanggaran?: PelanggaranUpdateManyWithoutSantriNestedInput
    pembinaan?: PembinaanUpdateManyWithoutSantriNestedInput
    kunjungan?: KunjunganUpdateManyWithoutSantriNestedInput
    healthRecords?: HealthRecordUpdateManyWithoutSantriNestedInput
    medications?: MedicationUpdateManyWithoutSantriNestedInput
  }

  export type SantriUncheckedUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    nisn?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    gender?: StringFieldUpdateOperationsInput | string
    dob?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    kelas?: NullableStringFieldUpdateOperationsInput | string | null
    room?: NullableStringFieldUpdateOperationsInput | string | null
    contact?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    walis?: SantriWaliUncheckedUpdateManyWithoutSantriNestedInput
    izin?: IzinUncheckedUpdateManyWithoutSantriNestedInput
    catatanHarian?: CatatanHarianUncheckedUpdateManyWithoutSantriNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutSantriNestedInput
    pelanggaran?: PelanggaranUncheckedUpdateManyWithoutSantriNestedInput
    pembinaan?: PembinaanUncheckedUpdateManyWithoutSantriNestedInput
    kunjungan?: KunjunganUncheckedUpdateManyWithoutSantriNestedInput
    healthRecords?: HealthRecordUncheckedUpdateManyWithoutSantriNestedInput
    medications?: MedicationUncheckedUpdateManyWithoutSantriNestedInput
  }

  export type SantriUncheckedUpdateManyWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    nisn?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    gender?: StringFieldUpdateOperationsInput | string
    dob?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    kelas?: NullableStringFieldUpdateOperationsInput | string | null
    room?: NullableStringFieldUpdateOperationsInput | string | null
    contact?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WaliUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    relation?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    santris?: SantriWaliUpdateManyWithoutWaliNestedInput
  }

  export type WaliUncheckedUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    relation?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    santris?: SantriWaliUncheckedUpdateManyWithoutWaliNestedInput
  }

  export type WaliUncheckedUpdateManyWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    relation?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IzinUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    reason?: StringFieldUpdateOperationsInput | string
    startAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    requestedBy?: StringFieldUpdateOperationsInput | string
    approvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    qrCodeData?: NullableStringFieldUpdateOperationsInput | string | null
    checkoutAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    checkoutBy?: NullableStringFieldUpdateOperationsInput | string | null
    checkinAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    checkinBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    santri?: SantriUpdateOneRequiredWithoutIzinNestedInput
  }

  export type IzinUncheckedUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    santriId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    reason?: StringFieldUpdateOperationsInput | string
    startAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    requestedBy?: StringFieldUpdateOperationsInput | string
    approvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    qrCodeData?: NullableStringFieldUpdateOperationsInput | string | null
    checkoutAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    checkoutBy?: NullableStringFieldUpdateOperationsInput | string | null
    checkinAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    checkinBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IzinUncheckedUpdateManyWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    santriId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    reason?: StringFieldUpdateOperationsInput | string
    startAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    requestedBy?: StringFieldUpdateOperationsInput | string
    approvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    qrCodeData?: NullableStringFieldUpdateOperationsInput | string | null
    checkoutAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    checkoutBy?: NullableStringFieldUpdateOperationsInput | string | null
    checkinAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    checkinBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CatatanHarianUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    content?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    attachments?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    santri?: SantriUpdateOneRequiredWithoutCatatanHarianNestedInput
  }

  export type CatatanHarianUncheckedUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    santriId?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    content?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    attachments?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CatatanHarianUncheckedUpdateManyWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    santriId?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    content?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    attachments?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PengumumanUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    audience?: StringFieldUpdateOperationsInput | string
    pinnedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PengumumanUncheckedUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    audience?: StringFieldUpdateOperationsInput | string
    pinnedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PengumumanUncheckedUpdateManyWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    audience?: StringFieldUpdateOperationsInput | string
    pinnedUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvoiceUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    amountDue?: FloatFieldUpdateOperationsInput | number
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    santri?: SantriUpdateOneRequiredWithoutInvoicesNestedInput
    lines?: InvoiceLineUpdateManyWithoutInvoiceNestedInput
    payments?: PaymentUpdateManyWithoutInvoiceNestedInput
  }

  export type InvoiceUncheckedUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    santriId?: StringFieldUpdateOperationsInput | string
    amountDue?: FloatFieldUpdateOperationsInput | number
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lines?: InvoiceLineUncheckedUpdateManyWithoutInvoiceNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutInvoiceNestedInput
  }

  export type InvoiceUncheckedUpdateManyWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    santriId?: StringFieldUpdateOperationsInput | string
    amountDue?: FloatFieldUpdateOperationsInput | number
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PelanggaranUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    recordedBy?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    severity?: IntFieldUpdateOperationsInput | number
    points?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    resolved?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    santri?: SantriUpdateOneRequiredWithoutPelanggaranNestedInput
  }

  export type PelanggaranUncheckedUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    santriId?: StringFieldUpdateOperationsInput | string
    recordedBy?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    severity?: IntFieldUpdateOperationsInput | number
    points?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    resolved?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PelanggaranUncheckedUpdateManyWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    santriId?: StringFieldUpdateOperationsInput | string
    recordedBy?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    severity?: IntFieldUpdateOperationsInput | number
    points?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    resolved?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PembinaanUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    plan?: StringFieldUpdateOperationsInput | string
    targetDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    assignedTo?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    santri?: SantriUpdateOneRequiredWithoutPembinaanNestedInput
  }

  export type PembinaanUncheckedUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    santriId?: StringFieldUpdateOperationsInput | string
    plan?: StringFieldUpdateOperationsInput | string
    targetDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    assignedTo?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PembinaanUncheckedUpdateManyWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    santriId?: StringFieldUpdateOperationsInput | string
    plan?: StringFieldUpdateOperationsInput | string
    targetDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    assignedTo?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type KunjunganUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    scheduledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    slot?: StringFieldUpdateOperationsInput | string
    visitorLimit?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    santri?: SantriUpdateOneRequiredWithoutKunjunganNestedInput
    tamu?: TamuUpdateManyWithoutKunjunganNestedInput
  }

  export type KunjunganUncheckedUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    santriId?: StringFieldUpdateOperationsInput | string
    scheduledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    slot?: StringFieldUpdateOperationsInput | string
    visitorLimit?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tamu?: TamuUncheckedUpdateManyWithoutKunjunganNestedInput
  }

  export type KunjunganUncheckedUpdateManyWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    santriId?: StringFieldUpdateOperationsInput | string
    scheduledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    slot?: StringFieldUpdateOperationsInput | string
    visitorLimit?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HealthRecordUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    recordedBy?: StringFieldUpdateOperationsInput | string
    symptoms?: StringFieldUpdateOperationsInput | string
    diagnosis?: NullableStringFieldUpdateOperationsInput | string | null
    actionTaken?: NullableStringFieldUpdateOperationsInput | string | null
    referred?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    santri?: SantriUpdateOneRequiredWithoutHealthRecordsNestedInput
  }

  export type HealthRecordUncheckedUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    santriId?: StringFieldUpdateOperationsInput | string
    recordedBy?: StringFieldUpdateOperationsInput | string
    symptoms?: StringFieldUpdateOperationsInput | string
    diagnosis?: NullableStringFieldUpdateOperationsInput | string | null
    actionTaken?: NullableStringFieldUpdateOperationsInput | string | null
    referred?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HealthRecordUncheckedUpdateManyWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    santriId?: StringFieldUpdateOperationsInput | string
    recordedBy?: StringFieldUpdateOperationsInput | string
    symptoms?: StringFieldUpdateOperationsInput | string
    diagnosis?: NullableStringFieldUpdateOperationsInput | string | null
    actionTaken?: NullableStringFieldUpdateOperationsInput | string | null
    referred?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    entity?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    oldValue?: NullableStringFieldUpdateOperationsInput | string | null
    newValue?: NullableStringFieldUpdateOperationsInput | string | null
    ip?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutAuditLogsNestedInput
  }

  export type AuditLogUncheckedUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    action?: StringFieldUpdateOperationsInput | string
    entity?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    oldValue?: NullableStringFieldUpdateOperationsInput | string | null
    newValue?: NullableStringFieldUpdateOperationsInput | string | null
    ip?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogUncheckedUpdateManyWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    action?: StringFieldUpdateOperationsInput | string
    entity?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    oldValue?: NullableStringFieldUpdateOperationsInput | string | null
    newValue?: NullableStringFieldUpdateOperationsInput | string | null
    ip?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    read?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutNotificationsNestedInput
  }

  export type NotificationUncheckedUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    read?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUncheckedUpdateManyWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    read?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WebhookEventUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    eventType?: StringFieldUpdateOperationsInput | string
    payload?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    error?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type WebhookEventUncheckedUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    eventType?: StringFieldUpdateOperationsInput | string
    payload?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    error?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type WebhookEventUncheckedUpdateManyWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    eventType?: StringFieldUpdateOperationsInput | string
    payload?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    error?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type RefreshTokenCreateManyUserInput = {
    id?: string
    token: string
    expiresAt: Date | string
    revoked?: boolean
    createdAt?: Date | string
  }

  export type AuditLogCreateManyUserInput = {
    id?: string
    tenantId?: string | null
    action: string
    entity: string
    entityId: string
    oldValue?: string | null
    newValue?: string | null
    ip?: string | null
    createdAt?: Date | string
  }

  export type NotificationCreateManyUserInput = {
    id?: string
    tenantId: string
    type: string
    title: string
    body: string
    read?: boolean
    createdAt?: Date | string
  }

  export type RefreshTokenUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    revoked?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RefreshTokenUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    revoked?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RefreshTokenUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    revoked?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    entity?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    oldValue?: NullableStringFieldUpdateOperationsInput | string | null
    newValue?: NullableStringFieldUpdateOperationsInput | string | null
    ip?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneWithoutAuditLogsNestedInput
  }

  export type AuditLogUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: NullableStringFieldUpdateOperationsInput | string | null
    action?: StringFieldUpdateOperationsInput | string
    entity?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    oldValue?: NullableStringFieldUpdateOperationsInput | string | null
    newValue?: NullableStringFieldUpdateOperationsInput | string | null
    ip?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: NullableStringFieldUpdateOperationsInput | string | null
    action?: StringFieldUpdateOperationsInput | string
    entity?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    oldValue?: NullableStringFieldUpdateOperationsInput | string | null
    newValue?: NullableStringFieldUpdateOperationsInput | string | null
    ip?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    read?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutNotificationsNestedInput
  }

  export type NotificationUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    read?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    read?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SantriWaliCreateManySantriInput = {
    waliId: string
    isPrimary?: boolean
  }

  export type IzinCreateManySantriInput = {
    id?: string
    tenantId: string
    type: string
    reason: string
    startAt: Date | string
    endAt: Date | string
    status?: string
    requestedBy: string
    approvedBy?: string | null
    approvedAt?: Date | string | null
    qrCodeData?: string | null
    checkoutAt?: Date | string | null
    checkoutBy?: string | null
    checkinAt?: Date | string | null
    checkinBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CatatanHarianCreateManySantriInput = {
    id?: string
    tenantId: string
    authorId: string
    date?: Date | string
    content: string
    category: string
    attachments?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InvoiceCreateManySantriInput = {
    id?: string
    tenantId: string
    amountDue: number
    dueDate: Date | string
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PelanggaranCreateManySantriInput = {
    id?: string
    tenantId: string
    recordedBy: string
    category: string
    severity: number
    points?: number
    description: string
    date?: Date | string
    resolved?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PembinaanCreateManySantriInput = {
    id?: string
    tenantId: string
    plan: string
    targetDate: Date | string
    status?: string
    assignedTo: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type KunjunganCreateManySantriInput = {
    id?: string
    tenantId: string
    scheduledAt: Date | string
    slot: string
    visitorLimit?: number
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type HealthRecordCreateManySantriInput = {
    id?: string
    tenantId: string
    recordedBy: string
    symptoms: string
    diagnosis?: string | null
    actionTaken?: string | null
    referred?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MedicationCreateManySantriInput = {
    id?: string
    medicineName: string
    dose: string
    schedule: string
    givenBy?: string | null
    givenAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SantriWaliUpdateWithoutSantriInput = {
    isPrimary?: BoolFieldUpdateOperationsInput | boolean
    wali?: WaliUpdateOneRequiredWithoutSantrisNestedInput
  }

  export type SantriWaliUncheckedUpdateWithoutSantriInput = {
    waliId?: StringFieldUpdateOperationsInput | string
    isPrimary?: BoolFieldUpdateOperationsInput | boolean
  }

  export type SantriWaliUncheckedUpdateManyWithoutSantriInput = {
    waliId?: StringFieldUpdateOperationsInput | string
    isPrimary?: BoolFieldUpdateOperationsInput | boolean
  }

  export type IzinUpdateWithoutSantriInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    reason?: StringFieldUpdateOperationsInput | string
    startAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    requestedBy?: StringFieldUpdateOperationsInput | string
    approvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    qrCodeData?: NullableStringFieldUpdateOperationsInput | string | null
    checkoutAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    checkoutBy?: NullableStringFieldUpdateOperationsInput | string | null
    checkinAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    checkinBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutIzinNestedInput
  }

  export type IzinUncheckedUpdateWithoutSantriInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    reason?: StringFieldUpdateOperationsInput | string
    startAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    requestedBy?: StringFieldUpdateOperationsInput | string
    approvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    qrCodeData?: NullableStringFieldUpdateOperationsInput | string | null
    checkoutAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    checkoutBy?: NullableStringFieldUpdateOperationsInput | string | null
    checkinAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    checkinBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IzinUncheckedUpdateManyWithoutSantriInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    reason?: StringFieldUpdateOperationsInput | string
    startAt?: DateTimeFieldUpdateOperationsInput | Date | string
    endAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    requestedBy?: StringFieldUpdateOperationsInput | string
    approvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    qrCodeData?: NullableStringFieldUpdateOperationsInput | string | null
    checkoutAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    checkoutBy?: NullableStringFieldUpdateOperationsInput | string | null
    checkinAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    checkinBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CatatanHarianUpdateWithoutSantriInput = {
    id?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    content?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    attachments?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutCatatanHarianNestedInput
  }

  export type CatatanHarianUncheckedUpdateWithoutSantriInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    content?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    attachments?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CatatanHarianUncheckedUpdateManyWithoutSantriInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    content?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    attachments?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvoiceUpdateWithoutSantriInput = {
    id?: StringFieldUpdateOperationsInput | string
    amountDue?: FloatFieldUpdateOperationsInput | number
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutInvoicesNestedInput
    lines?: InvoiceLineUpdateManyWithoutInvoiceNestedInput
    payments?: PaymentUpdateManyWithoutInvoiceNestedInput
  }

  export type InvoiceUncheckedUpdateWithoutSantriInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    amountDue?: FloatFieldUpdateOperationsInput | number
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lines?: InvoiceLineUncheckedUpdateManyWithoutInvoiceNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutInvoiceNestedInput
  }

  export type InvoiceUncheckedUpdateManyWithoutSantriInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    amountDue?: FloatFieldUpdateOperationsInput | number
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PelanggaranUpdateWithoutSantriInput = {
    id?: StringFieldUpdateOperationsInput | string
    recordedBy?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    severity?: IntFieldUpdateOperationsInput | number
    points?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    resolved?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutPelanggaranNestedInput
  }

  export type PelanggaranUncheckedUpdateWithoutSantriInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    recordedBy?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    severity?: IntFieldUpdateOperationsInput | number
    points?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    resolved?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PelanggaranUncheckedUpdateManyWithoutSantriInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    recordedBy?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    severity?: IntFieldUpdateOperationsInput | number
    points?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    resolved?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PembinaanUpdateWithoutSantriInput = {
    id?: StringFieldUpdateOperationsInput | string
    plan?: StringFieldUpdateOperationsInput | string
    targetDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    assignedTo?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutPembinaanNestedInput
  }

  export type PembinaanUncheckedUpdateWithoutSantriInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    plan?: StringFieldUpdateOperationsInput | string
    targetDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    assignedTo?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PembinaanUncheckedUpdateManyWithoutSantriInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    plan?: StringFieldUpdateOperationsInput | string
    targetDate?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    assignedTo?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type KunjunganUpdateWithoutSantriInput = {
    id?: StringFieldUpdateOperationsInput | string
    scheduledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    slot?: StringFieldUpdateOperationsInput | string
    visitorLimit?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutKunjunganNestedInput
    tamu?: TamuUpdateManyWithoutKunjunganNestedInput
  }

  export type KunjunganUncheckedUpdateWithoutSantriInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    scheduledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    slot?: StringFieldUpdateOperationsInput | string
    visitorLimit?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tamu?: TamuUncheckedUpdateManyWithoutKunjunganNestedInput
  }

  export type KunjunganUncheckedUpdateManyWithoutSantriInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    scheduledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    slot?: StringFieldUpdateOperationsInput | string
    visitorLimit?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HealthRecordUpdateWithoutSantriInput = {
    id?: StringFieldUpdateOperationsInput | string
    recordedBy?: StringFieldUpdateOperationsInput | string
    symptoms?: StringFieldUpdateOperationsInput | string
    diagnosis?: NullableStringFieldUpdateOperationsInput | string | null
    actionTaken?: NullableStringFieldUpdateOperationsInput | string | null
    referred?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutHealthRecordsNestedInput
  }

  export type HealthRecordUncheckedUpdateWithoutSantriInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    recordedBy?: StringFieldUpdateOperationsInput | string
    symptoms?: StringFieldUpdateOperationsInput | string
    diagnosis?: NullableStringFieldUpdateOperationsInput | string | null
    actionTaken?: NullableStringFieldUpdateOperationsInput | string | null
    referred?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HealthRecordUncheckedUpdateManyWithoutSantriInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    recordedBy?: StringFieldUpdateOperationsInput | string
    symptoms?: StringFieldUpdateOperationsInput | string
    diagnosis?: NullableStringFieldUpdateOperationsInput | string | null
    actionTaken?: NullableStringFieldUpdateOperationsInput | string | null
    referred?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MedicationUpdateWithoutSantriInput = {
    id?: StringFieldUpdateOperationsInput | string
    medicineName?: StringFieldUpdateOperationsInput | string
    dose?: StringFieldUpdateOperationsInput | string
    schedule?: StringFieldUpdateOperationsInput | string
    givenBy?: NullableStringFieldUpdateOperationsInput | string | null
    givenAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MedicationUncheckedUpdateWithoutSantriInput = {
    id?: StringFieldUpdateOperationsInput | string
    medicineName?: StringFieldUpdateOperationsInput | string
    dose?: StringFieldUpdateOperationsInput | string
    schedule?: StringFieldUpdateOperationsInput | string
    givenBy?: NullableStringFieldUpdateOperationsInput | string | null
    givenAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MedicationUncheckedUpdateManyWithoutSantriInput = {
    id?: StringFieldUpdateOperationsInput | string
    medicineName?: StringFieldUpdateOperationsInput | string
    dose?: StringFieldUpdateOperationsInput | string
    schedule?: StringFieldUpdateOperationsInput | string
    givenBy?: NullableStringFieldUpdateOperationsInput | string | null
    givenAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SantriWaliCreateManyWaliInput = {
    santriId: string
    isPrimary?: boolean
  }

  export type SantriWaliUpdateWithoutWaliInput = {
    isPrimary?: BoolFieldUpdateOperationsInput | boolean
    santri?: SantriUpdateOneRequiredWithoutWalisNestedInput
  }

  export type SantriWaliUncheckedUpdateWithoutWaliInput = {
    santriId?: StringFieldUpdateOperationsInput | string
    isPrimary?: BoolFieldUpdateOperationsInput | boolean
  }

  export type SantriWaliUncheckedUpdateManyWithoutWaliInput = {
    santriId?: StringFieldUpdateOperationsInput | string
    isPrimary?: BoolFieldUpdateOperationsInput | boolean
  }

  export type InvoiceLineCreateManyInvoiceInput = {
    id?: string
    description: string
    amount: number
    type: string
  }

  export type PaymentCreateManyInvoiceInput = {
    id?: string
    method: string
    amount: number
    status?: string
    transactionRef?: string | null
    paidAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InvoiceLineUpdateWithoutInvoiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
  }

  export type InvoiceLineUncheckedUpdateWithoutInvoiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
  }

  export type InvoiceLineUncheckedUpdateManyWithoutInvoiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
  }

  export type PaymentUpdateWithoutInvoiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    method?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    transactionRef?: NullableStringFieldUpdateOperationsInput | string | null
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentUncheckedUpdateWithoutInvoiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    method?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    transactionRef?: NullableStringFieldUpdateOperationsInput | string | null
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentUncheckedUpdateManyWithoutInvoiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    method?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    transactionRef?: NullableStringFieldUpdateOperationsInput | string | null
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TamuCreateManyKunjunganInput = {
    id?: string
    name: string
    phone?: string | null
    idNumber?: string | null
    checkinAt?: Date | string | null
    createdAt?: Date | string
  }

  export type TamuUpdateWithoutKunjunganInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    idNumber?: NullableStringFieldUpdateOperationsInput | string | null
    checkinAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TamuUncheckedUpdateWithoutKunjunganInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    idNumber?: NullableStringFieldUpdateOperationsInput | string | null
    checkinAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TamuUncheckedUpdateManyWithoutKunjunganInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    idNumber?: NullableStringFieldUpdateOperationsInput | string | null
    checkinAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Aliases for legacy arg types
   */
    /**
     * @deprecated Use TenantCountOutputTypeDefaultArgs instead
     */
    export type TenantCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TenantCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UserCountOutputTypeDefaultArgs instead
     */
    export type UserCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SantriCountOutputTypeDefaultArgs instead
     */
    export type SantriCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SantriCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use WaliCountOutputTypeDefaultArgs instead
     */
    export type WaliCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = WaliCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use InvoiceCountOutputTypeDefaultArgs instead
     */
    export type InvoiceCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = InvoiceCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use KunjunganCountOutputTypeDefaultArgs instead
     */
    export type KunjunganCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = KunjunganCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TenantDefaultArgs instead
     */
    export type TenantArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TenantDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UserDefaultArgs instead
     */
    export type UserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserDefaultArgs<ExtArgs>
    /**
     * @deprecated Use RefreshTokenDefaultArgs instead
     */
    export type RefreshTokenArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = RefreshTokenDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SantriDefaultArgs instead
     */
    export type SantriArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SantriDefaultArgs<ExtArgs>
    /**
     * @deprecated Use WaliDefaultArgs instead
     */
    export type WaliArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = WaliDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SantriWaliDefaultArgs instead
     */
    export type SantriWaliArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SantriWaliDefaultArgs<ExtArgs>
    /**
     * @deprecated Use IzinDefaultArgs instead
     */
    export type IzinArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = IzinDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CatatanHarianDefaultArgs instead
     */
    export type CatatanHarianArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CatatanHarianDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PengumumanDefaultArgs instead
     */
    export type PengumumanArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PengumumanDefaultArgs<ExtArgs>
    /**
     * @deprecated Use InvoiceDefaultArgs instead
     */
    export type InvoiceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = InvoiceDefaultArgs<ExtArgs>
    /**
     * @deprecated Use InvoiceLineDefaultArgs instead
     */
    export type InvoiceLineArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = InvoiceLineDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PaymentDefaultArgs instead
     */
    export type PaymentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PaymentDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PelanggaranDefaultArgs instead
     */
    export type PelanggaranArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PelanggaranDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PembinaanDefaultArgs instead
     */
    export type PembinaanArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PembinaanDefaultArgs<ExtArgs>
    /**
     * @deprecated Use KunjunganDefaultArgs instead
     */
    export type KunjunganArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = KunjunganDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TamuDefaultArgs instead
     */
    export type TamuArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TamuDefaultArgs<ExtArgs>
    /**
     * @deprecated Use HealthRecordDefaultArgs instead
     */
    export type HealthRecordArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = HealthRecordDefaultArgs<ExtArgs>
    /**
     * @deprecated Use MedicationDefaultArgs instead
     */
    export type MedicationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = MedicationDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AuditLogDefaultArgs instead
     */
    export type AuditLogArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AuditLogDefaultArgs<ExtArgs>
    /**
     * @deprecated Use NotificationDefaultArgs instead
     */
    export type NotificationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = NotificationDefaultArgs<ExtArgs>
    /**
     * @deprecated Use WebhookEventDefaultArgs instead
     */
    export type WebhookEventArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = WebhookEventDefaultArgs<ExtArgs>

  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}